#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_PuzzleSelectionComponent

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "FPuzzleSlot_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "EPuzzleMovementStates_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_PuzzleSelectionComponent.BP_PuzzleSelectionComponent_C
// 0x0150 (0x0208 - 0x00B8)
class UBP_PuzzleSelectionComponent_C final : public UActorComponent
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x00B8(0x0008)(ZeroConstructor, Transient, DuplicateTransient)
	int32                                         AmountOfItems;                                     // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         CurrentItemIndex;                                  // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMap<int32, struct FFPuzzleSlot>              ItemSlotMap;                                       // 0x00C8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	int32                                         HeldItemIndex;                                     // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bIsHoldingItem;                                    // 0x011C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSwapItem;                                        // 0x0120(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnItemHeld;                                        // 0x0130(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	FMulticastInlineDelegateProperty_             OnItemReleased;                                    // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	int32                                         RowSize;                                           // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EPuzzleMovementStates                         State;                                             // 0x0154(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EPuzzleMovementStates                         PreviousState;                                     // 0x0155(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bDebugState;                                       // 0x0156(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          bHasQuit;                                          // 0x0157(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	FMulticastInlineDelegateProperty_             OnPuzzleStopped;                                   // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	float                                         SelectionCooldown;                                 // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnNavigated;                                       // 0x0170(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	TArray<class UPrimitiveComponent*>            PuzzleItems;                                       // 0x0180(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, ContainsInstancedReference)
	TArray<int32>                                 DisabledIndices;                                   // 0x0190(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance)
	FMulticastInlineDelegateProperty_             OnSlotToggled;                                     // 0x01A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          bHoldItemRemovesHighlight;                         // 0x01B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           InputTimer;                                        // 0x01B8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	FMulticastInlineDelegateProperty_             OnPuzzleStarted;                                   // 0x01C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          bHasSaves;                                         // 0x01D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            SavedPuzzleItems;                                  // 0x01D8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame, ContainsInstancedReference)
	TArray<bool>                                  SavedEnabledPieces;                                // 0x01E8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)
	TArray<struct FTransform>                     SavedSlotTransforms;                               // 0x01F8(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, SaveGame)

public:
	void OnSwapItem__DelegateSignature(int32 PreviousItemIndex, int32 SelectedItemIndex);
	void OnItemHeld__DelegateSignature(int32 HeldItemIndex_0);
	void OnItemReleased__DelegateSignature(int32 HeldItemIndex_0);
	void OnPuzzleStopped__DelegateSignature();
	void OnNavigated__DelegateSignature(bool IsHoldingItem, int32 CurrentSelectedIndex, int32 PreviousSelectedIndex, bool NavigationSuccessful);
	void OnSlotToggled__DelegateSignature(bool Enabled, class UPrimitiveComponent* Item);
	void OnPuzzleStarted__DelegateSignature();
	void ExecuteUbergraph_BP_PuzzleSelectionComponent(int32 EntryPoint);
	void LockInput();
	void ReceiveBeginPlay();
	void ReceiveTick(float DeltaSeconds);
	void UnlockInput();
	void SetState(EPuzzleMovementStates State_0);
	void StopPuzzle();
	void StartPuzzle();
	void HorizontalSelectionInput(float RightAxis);
	void VerticalSelectionInput(const float ForwardAxis);
	void SetupPuzzleItems(TArray<class UPrimitiveComponent*>& PuzzleItems_0);
	void MapItemsToSlots();
	class UPrimitiveComponent* GetSelectedItem();
	void SwapItemsBetweenSlots(int32 FromIndex, int32 ToIndex, bool* SwapSuccessful);
	class UPrimitiveComponent* GetItemInIndex(int32 Index_0);
	struct FTransform GetSlotTransformInIndex(int32 Index_0);
	int32 GetHeldItemIndex();
	int32 GetSelectedItemIndex();
	void SetupSelectionMaterial();
	void ToggleHighlightOnItemInSlot(bool IsHighlit, int32 SlotIndex);
	void StartHighlight();
	void StopHighlight();
	class UPrimitiveComponent* GetHeldItem();
	void SwapItems();
	void NavigateUp();
	void NavigateRight();
	void NavigateLeft();
	void NavigateDown();
	void HoldItem();
	void DebugStates();
	void StopHoldingItem();
	void ResetLocationOfItems();
	void PuzzleStopped();
	void PuzzleStarted();
	void HoldSelectedItem();
	void ToggleSlotOfItem(class UPrimitiveComponent* PuzzleItem, bool Enabled);
	void EnableSlotOfItem(class UPrimitiveComponent* PuzzleItem);
	void DisableSlotOfItem(class UPrimitiveComponent* PuzzleItem);
	void GetSlotIndexOfItem(class UPrimitiveComponent* PuzzleItem, int32* SlotIndex);
	bool IsSlotIndexDisabled(int32 Index_0);
	void GetDisabledSlotIndices(TArray<int32>* DisabledIndices_0);
	void IncrementHorizontalIndex(int32* CurrentIndex, int32* PreviousSelectedIndex, bool* NavigationSuccessful);
	void DecrementHorizontalIndex(int32* CurrentIndex, int32* PreviousSelectedIndex, bool* NavigationSuccessful);
	void IncrementVerticalIndex(int32* CurrentIndex, int32* PreviousSelectedIndex, bool* NavigationSuccessful);
	void DecrementVerticalIndex(int32* CurrentIndex, int32* PreviousSelectedIndex, bool* NavigationSuccessful);
	void ResetInput();
	void GetIsHoldingItem(bool* IsHoldingItem);
	void FindFirstEnabledSlot(int32* EnabledIndex, bool* Success);
	void FindAndSetFirstEnabledSlot();
	void SetSelectedItemIndex(int32 CurrentItemIndex_0);
	void SetSelectedItemIndexOfItem(class UPrimitiveComponent* PuzzleItem);
	void FindFirstDisabledSlot(int32* Index_0, bool* Success);
	void DiscreetSwap(int32 FromIndex, int32 ToIndex);
	void SwapTransformsOfTwoIndices(int32 FromIndex, int32 ToIndex);
	void GetState(EPuzzleMovementStates* State_0);
	void GetSlotTransformOfItem(class UPrimitiveComponent* PuzzleItem, struct FTransform* SlotTransform);
	bool IsAnySlotsEnabled();
	void HandleHighlightOnFailedNavigation(bool NavigationSucessful, int32 SlotIndex);
	void SavePuzzle();
	void LoadPuzzle();
	void StopHighlightOfAllPuzzleItems();
	void IsSavedItemsTheSameAsSetup(bool* IsItemsTheSame);
	bool IsSavedArrayTheSameLengthAsSetup();

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_PuzzleSelectionComponent_C">();
	}
	static class UBP_PuzzleSelectionComponent_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_PuzzleSelectionComponent_C>();
	}
};
static_assert(alignof(UBP_PuzzleSelectionComponent_C) == 0x000008, "Wrong alignment on UBP_PuzzleSelectionComponent_C");
static_assert(sizeof(UBP_PuzzleSelectionComponent_C) == 0x000208, "Wrong size on UBP_PuzzleSelectionComponent_C");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, UberGraphFrame) == 0x0000B8, "Member 'UBP_PuzzleSelectionComponent_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, AmountOfItems) == 0x0000C0, "Member 'UBP_PuzzleSelectionComponent_C::AmountOfItems' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, CurrentItemIndex) == 0x0000C4, "Member 'UBP_PuzzleSelectionComponent_C::CurrentItemIndex' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, ItemSlotMap) == 0x0000C8, "Member 'UBP_PuzzleSelectionComponent_C::ItemSlotMap' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, HeldItemIndex) == 0x000118, "Member 'UBP_PuzzleSelectionComponent_C::HeldItemIndex' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, bIsHoldingItem) == 0x00011C, "Member 'UBP_PuzzleSelectionComponent_C::bIsHoldingItem' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, OnSwapItem) == 0x000120, "Member 'UBP_PuzzleSelectionComponent_C::OnSwapItem' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, OnItemHeld) == 0x000130, "Member 'UBP_PuzzleSelectionComponent_C::OnItemHeld' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, OnItemReleased) == 0x000140, "Member 'UBP_PuzzleSelectionComponent_C::OnItemReleased' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, RowSize) == 0x000150, "Member 'UBP_PuzzleSelectionComponent_C::RowSize' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, State) == 0x000154, "Member 'UBP_PuzzleSelectionComponent_C::State' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, PreviousState) == 0x000155, "Member 'UBP_PuzzleSelectionComponent_C::PreviousState' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, bDebugState) == 0x000156, "Member 'UBP_PuzzleSelectionComponent_C::bDebugState' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, bHasQuit) == 0x000157, "Member 'UBP_PuzzleSelectionComponent_C::bHasQuit' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, OnPuzzleStopped) == 0x000158, "Member 'UBP_PuzzleSelectionComponent_C::OnPuzzleStopped' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, SelectionCooldown) == 0x000168, "Member 'UBP_PuzzleSelectionComponent_C::SelectionCooldown' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, OnNavigated) == 0x000170, "Member 'UBP_PuzzleSelectionComponent_C::OnNavigated' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, PuzzleItems) == 0x000180, "Member 'UBP_PuzzleSelectionComponent_C::PuzzleItems' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, DisabledIndices) == 0x000190, "Member 'UBP_PuzzleSelectionComponent_C::DisabledIndices' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, OnSlotToggled) == 0x0001A0, "Member 'UBP_PuzzleSelectionComponent_C::OnSlotToggled' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, bHoldItemRemovesHighlight) == 0x0001B0, "Member 'UBP_PuzzleSelectionComponent_C::bHoldItemRemovesHighlight' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, InputTimer) == 0x0001B8, "Member 'UBP_PuzzleSelectionComponent_C::InputTimer' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, OnPuzzleStarted) == 0x0001C0, "Member 'UBP_PuzzleSelectionComponent_C::OnPuzzleStarted' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, bHasSaves) == 0x0001D0, "Member 'UBP_PuzzleSelectionComponent_C::bHasSaves' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, SavedPuzzleItems) == 0x0001D8, "Member 'UBP_PuzzleSelectionComponent_C::SavedPuzzleItems' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, SavedEnabledPieces) == 0x0001E8, "Member 'UBP_PuzzleSelectionComponent_C::SavedEnabledPieces' has a wrong offset!");
static_assert(offsetof(UBP_PuzzleSelectionComponent_C, SavedSlotTransforms) == 0x0001F8, "Member 'UBP_PuzzleSelectionComponent_C::SavedSlotTransforms' has a wrong offset!");

}

