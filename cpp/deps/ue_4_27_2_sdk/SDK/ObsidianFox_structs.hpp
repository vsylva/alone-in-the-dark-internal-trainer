#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ObsidianFox

#include "Basic.hpp"

#include "PiecesAnimNodes_structs.hpp"
#include "PhysicsCore_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "SlateCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "CinematicCamera_structs.hpp"
#include "ControlRig_structs.hpp"
#include "ObsidianFoxSettings_structs.hpp"


namespace SDK
{

// Enum ObsidianFox.EGameMainState
// NumValues: 0x000A
enum class EGameMainState : uint8
{
	ThirdPerson                              = 0,
	Cinematic                                = 1,
	Sequence                                 = 2,
	InGameMenu                               = 3,
	PauseMenu                                = 4,
	Puzzle                                   = 5,
	LoadingScreen                            = 6,
	MainMenu                                 = 7,
	PhotoMode                                = 8,
	EGameMainState_MAX                       = 9,
};

// Enum ObsidianFox.EPlayerCharacterType
// NumValues: 0x0006
enum class EPlayerCharacterType : uint8
{
	Edward                                   = 0,
	Emily                                    = 1,
	Grace                                    = 2,
	Count                                    = 3,
	None                                     = 255,
	EPlayerCharacterType_MAX                 = 256,
};

// Enum ObsidianFox.EPlayerHealthState
// NumValues: 0x0006
enum class EPlayerHealthState : uint8
{
	Fine                                     = 0,
	Bruised                                  = 1,
	Injured                                  = 2,
	Critical                                 = 3,
	Dead                                     = 4,
	EPlayerHealthState_MAX                   = 5,
};

// Enum ObsidianFox.ECardinalDirection
// NumValues: 0x0005
enum class ECardinalDirection : uint8
{
	H_North                                  = 0,
	H_South                                  = 1,
	H_West                                   = 2,
	H_East                                   = 3,
	H_MAX                                    = 4,
};

// Enum ObsidianFox.EFocusPointCategory
// NumValues: 0x0006
enum class EFocusPointCategory : uint8
{
	FPC_Default                              = 0,
	FPC_Player                               = 1,
	FPC_Enemy                                = 2,
	FPC_PlayerInteraction                    = 3,
	FPC_PlayerPointOfInterest                = 4,
	FPC_MAX                                  = 5,
};

// Enum ObsidianFox.EFocusPointType
// NumValues: 0x0003
enum class EFocusPointType : uint8
{
	FPT_Sight                                = 0,
	FPT_Touch                                = 1,
	FPT_MAX                                  = 2,
};

// Enum ObsidianFox.EInteractionType
// NumValues: 0x0005
enum class EInteractionType : uint8
{
	Standard                                 = 0,
	Combat                                   = 1,
	Examination                              = 2,
	Num                                      = 3,
	EInteractionType_MAX                     = 4,
};

// Enum ObsidianFox.EInteractionSelectionShape
// NumValues: 0x0003
enum class EInteractionSelectionShape : uint8
{
	Sphere                                   = 0,
	Cone                                     = 1,
	EInteractionSelectionShape_MAX           = 2,
};

// Enum ObsidianFox.EInteractTransformMethod
// NumValues: 0x0006
enum class EInteractTransformMethod : uint8
{
	LookAtRotation                           = 0,
	SceneComponentTransform                  = 1,
	SceneComponentTransform2D                = 2,
	PlayerMoveToThenRotate                   = 3,
	PlayerMoveToThenTurnInPlace              = 4,
	EInteractTransformMethod_MAX             = 5,
};

// Enum ObsidianFox.EInteractAnimType
// NumValues: 0x0003
enum class EInteractAnimType : uint8
{
	IAT_Montage                              = 0,
	IAT_GenericIK                            = 1,
	IAT_MAX                                  = 2,
};

// Enum ObsidianFox.EIKState
// NumValues: 0x0006
enum class EIKState : uint8
{
	IKS_Inactive                             = 0,
	IKS_TransToLocation                      = 1,
	IKS_TransFromLocation                    = 2,
	IKS_OutOfReach                           = 3,
	IKS_Locked                               = 4,
	IKS_MAX                                  = 5,
};

// Enum ObsidianFox.ERagdollState
// NumValues: 0x0006
enum class ERagdollState : uint8
{
	RS_Disabled                              = 0,
	RS_Inactive                              = 1,
	RS_Partial                               = 2,
	RS_FullBody                              = 3,
	RS_Recovering                            = 4,
	RS_MAX                                   = 5,
};

// Enum ObsidianFox.EFootType
// NumValues: 0x0004
enum class EFootType : uint8
{
	BoneName                                 = 0,
	Left                                     = 1,
	Right                                    = 2,
	EFootType_MAX                            = 3,
};

// Enum ObsidianFox.EBodyFocusMode
// NumValues: 0x0009
enum class EBodyFocusMode : uint8
{
	Disabled                                 = 0,
	Inactive                                 = 1,
	LookingAround                            = 2,
	FocusPoint                               = 3,
	Startled                                 = 4,
	Aiming                                   = 5,
	Turning                                  = 6,
	Walking                                  = 7,
	EBodyFocusMode_MAX                       = 8,
};

// Enum ObsidianFox.EIKHandRotationMode
// NumValues: 0x0003
enum class EIKHandRotationMode : uint8
{
	HOM_AnimationOnly                        = 0,
	HOM_CustomRotation                       = 1,
	HOM_MAX                                  = 2,
};

// Enum ObsidianFox.EConsumableType
// NumValues: 0x0007
enum class EConsumableType : uint8
{
	None                                     = 0,
	Health                                   = 1,
	HandgunAmmo                              = 2,
	ShotgunAmmo                              = 3,
	TommygunAmmo                             = 4,
	FlareGunAmmo                             = 5,
	EConsumableType_MAX                      = 6,
};

// Enum ObsidianFox.EInputIgnoreBranch
// NumValues: 0x0003
enum class EInputIgnoreBranch : uint8
{
	NotIgnored                               = 0,
	Ignored                                  = 1,
	EInputIgnoreBranch_MAX                   = 2,
};

// Enum ObsidianFox.ESaveMethod
// NumValues: 0x0003
enum class ESaveMethod : uint32
{
	NoSave                                   = 0,
	Save                                     = 1,
	ESaveMethod_MAX                          = 2,
};

// Enum ObsidianFox.ESpawnMethod
// NumValues: 0x0003
enum class ESpawnMethod : uint32
{
	Manual                                   = 0,
	BeginPlay                                = 1,
	ESpawnMethod_MAX                         = 2,
};

// Enum ObsidianFox.EEquipmentSocket
// NumValues: 0x0003
enum class EEquipmentSocket : uint8
{
	Held                                     = 0,
	Holstered                                = 1,
	EEquipmentSocket_MAX                     = 2,
};

// Enum ObsidianFox.EEquipmentType
// NumValues: 0x0003
enum class EEquipmentType : uint8
{
	MeleeWeapon                              = 0,
	RangeWeapon                              = 1,
	EEquipmentType_MAX                       = 2,
};

// Enum ObsidianFox.EHitReactionType
// NumValues: 0x0006
enum class EHitReactionType : uint8
{
	Invalid                                  = 0,
	Heavy                                    = 1,
	Medium                                   = 2,
	Light                                    = 3,
	Special                                  = 4,
	EHitReactionType_MAX                     = 5,
};

// Enum ObsidianFox.EDoorLockState
// NumValues: 0x0005
enum class EDoorLockState : uint8
{
	Unlocked                                 = 0,
	Key                                      = 1,
	Bolted                                   = 2,
	Permanent                                = 3,
	EDoorLockState_MAX                       = 4,
};

// Enum ObsidianFox.ETransformCalculationMethod
// NumValues: 0x0003
enum class ETransformCalculationMethod : uint8
{
	Align                                    = 0,
	LookAt                                   = 1,
	ETransformCalculationMethod_MAX          = 2,
};

// Enum ObsidianFox.EReorientMethod
// NumValues: 0x0004
enum class EReorientMethod : uint8
{
	None                                     = 0,
	TurnInPlace                              = 1,
	LerpTo                                   = 2,
	EReorientMethod_MAX                      = 3,
};

// Enum ObsidianFox.ERepositionMethod
// NumValues: 0x0005
enum class ERepositionMethod : uint8
{
	None                                     = 0,
	MoveTo                                   = 1,
	LerpTo                                   = 2,
	VelocityBasedLerpTo                      = 3,
	ERepositionMethod_MAX                    = 4,
};

// Enum ObsidianFox.EOFTransformSpace
// NumValues: 0x0003
enum class EOFTransformSpace : uint8
{
	WorldSpace                               = 0,
	ComponentSpace                           = 1,
	EOFTransformSpace_MAX                    = 2,
};

// Enum ObsidianFox.EObjectiveParts
// NumValues: 0x0016
enum class EObjectiveParts : uint8
{
	PartOne                                  = 0,
	PartTwo                                  = 1,
	PartThree                                = 2,
	PartFour                                 = 3,
	PartFive                                 = 4,
	PartSix                                  = 5,
	PartSeven                                = 6,
	PartEight                                = 7,
	PartNine                                 = 8,
	PartTen                                  = 9,
	PartEleven                               = 10,
	PartTwelve                               = 11,
	PartThirteen                             = 12,
	PartFourteen                             = 13,
	PartFifteen                              = 14,
	PartSixteen                              = 15,
	PartSeventeen                            = 16,
	PartEighteen                             = 17,
	PartNineteen                             = 18,
	PartTwenty                               = 19,
	None                                     = 20,
	EObjectiveParts_MAX                      = 21,
};

// Enum ObsidianFox.EAbilityInput
// NumValues: 0x0017
enum class EAbilityInput : uint8
{
	None                                     = 0,
	RangedAttack                             = 1,
	Interact                                 = 2,
	Examine                                  = 3,
	MeleeAttack                              = 4,
	Dodge                                    = 5,
	Reload                                   = 6,
	Confirm                                  = 7,
	Cancel                                   = 8,
	SwitchWeapon                             = 9,
	Aim                                      = 10,
	Sprint                                   = 11,
	SprintHold                               = 12,
	CameraShift                              = 13,
	Stealth                                  = 14,
	UseConsumable                            = 15,
	QuickTimeInteractionN                    = 16,
	QuickTimeInteractionE                    = 17,
	QuickTimeInteractionW                    = 18,
	QuickTimeInteractionS                    = 19,
	Opportunity                              = 20,
	UseTalisman                              = 21,
	EAbilityInput_MAX                        = 22,
};

// Enum ObsidianFox.EAchievementGrade
// NumValues: 0x0005
enum class EAchievementGrade : uint32
{
	Platinum                                 = 0,
	Gold                                     = 1,
	Silver                                   = 2,
	Bronze                                   = 3,
	EAchievementGrade_MAX                    = 4,
};

// Enum ObsidianFox.EStatValueType
// NumValues: 0x0003
enum class EStatValueType : uint32
{
	Int                                      = 0,
	Float                                    = 1,
	EStatValueType_MAX                       = 2,
};

// Enum ObsidianFox.EStatModificationType
// NumValues: 0x0006
enum class EStatModificationType : uint32
{
	Unknown                                  = 0,
	Sum                                      = 1,
	Set                                      = 2,
	Largest                                  = 3,
	Smallest                                 = 4,
	EStatModificationType_MAX                = 5,
};

// Enum ObsidianFox.EAchievementProgressionType
// NumValues: 0x0003
enum class EAchievementProgressionType : uint32
{
	NonProgressive                           = 0,
	Progressive                              = 1,
	EAchievementProgressionType_MAX          = 2,
};

// Enum ObsidianFox.EAnimationLookupTableLookupMethod
// NumValues: 0x0003
enum class EAnimationLookupTableLookupMethod : uint8
{
	Exact                                    = 0,
	IncludeChildren                          = 1,
	EAnimationLookupTableLookupMethod_MAX    = 2,
};

// Enum ObsidianFox.EAnimAlertState
// NumValues: 0x0005
enum class EAnimAlertState : uint8
{
	Inactive                                 = 0,
	Starting                                 = 1,
	Active                                   = 2,
	Ending                                   = 3,
	EAnimAlertState_MAX                      = 4,
};

// Enum ObsidianFox.EPlayerMoveToLocationAsyncMode
// NumValues: 0x0003
enum class EPlayerMoveToLocationAsyncMode : uint8
{
	Progress                                 = 0,
	Completed                                = 1,
	EPlayerMoveToLocationAsyncMode_MAX       = 2,
};

// Enum ObsidianFox.ECollectibleCompletionStatus
// NumValues: 0x0005
enum class ECollectibleCompletionStatus : uint8
{
	INVALID                                  = 0,
	NOT_COMPLETE                             = 1,
	COMPLETE                                 = 2,
	COLLECTIBLE_DATA_NOT_LOADED              = 3,
	ECollectibleCompletionStatus_MAX         = 4,
};

// Enum ObsidianFox.ECollectibleSetStatus
// NumValues: 0x0004
enum class ECollectibleSetStatus : uint8
{
	INVALID                                  = 0,
	ADDED                                    = 1,
	ADDED_COMPLETE                           = 2,
	ECollectibleSetStatus_MAX                = 3,
};

// Enum ObsidianFox.EDoorTimelineActions
// NumValues: 0x0013
enum class EDoorTimelineActions : uint8
{
	FirsTimeOpen                             = 0,
	FirstTimeOpenCounterClockwise            = 1,
	Open                                     = 2,
	OpenCounterClockwise                     = 3,
	Locked                                   = 4,
	LockedCounterClockwise                   = 5,
	LockedCombat                             = 6,
	LockedCombatCounterClockwise             = 7,
	Close                                    = 8,
	Running                                  = 9,
	UnBolt                                   = 10,
	HandleOpen                               = 11,
	HandleOpenCounterClockwise               = 12,
	HandleLocked                             = 13,
	HandleLockedCounterClockwise             = 14,
	HandleLockedCombat                       = 15,
	HandleLockedCombatCounterClockwise       = 16,
	NumOfTimelines                           = 17,
	EDoorTimelineActions_MAX                 = 18,
};

// Enum ObsidianFox.EDoorOpenType
// NumValues: 0x0003
enum class EDoorOpenType : uint8
{
	Normal                                   = 0,
	Sprinting                                = 1,
	EDoorOpenType_MAX                        = 2,
};

// Enum ObsidianFox.EDoorOpenState
// NumValues: 0x0004
enum class EDoorOpenState : uint8
{
	Closed                                   = 0,
	OpenClockwise                            = 1,
	OpenCounterClockwise                     = 2,
	EDoorOpenState_MAX                       = 3,
};

// Enum ObsidianFox.ETerrainMaterialType
// NumValues: 0x0005
enum class ETerrainMaterialType : uint8
{
	TS_None                                  = 0,
	TS_Snow                                  = 1,
	TS_Mud                                   = 2,
	TS_Sand                                  = 3,
	TS_MAX                                   = 4,
};

// Enum ObsidianFox.EEnvironmentInteractionType
// NumValues: 0x0003
enum class EEnvironmentInteractionType : uint8
{
	EIT_Fluid                                = 0,
	EIT_Terrain                              = 1,
	EIT_MAX                                  = 2,
};

// Enum ObsidianFox.EEnvTestOFPathfinding
// NumValues: 0x0004
enum class EEnvTestOFPathfinding : uint8
{
	PathExist                                = 0,
	PathCost                                 = 1,
	PathLength                               = 2,
	EEnvTestOFPathfinding_MAX                = 3,
};

// Enum ObsidianFox.EProjectionDirection
// NumValues: 0x0004
enum class EProjectionDirection : uint8
{
	PD_X                                     = 0,
	PD_Y                                     = 1,
	PD_Z                                     = 2,
	PD_MAX                                   = 3,
};

// Enum ObsidianFox.EForceDirectionType
// NumValues: 0x0005
enum class EForceDirectionType : uint8
{
	FDM_NormalAndTrace                       = 0,
	FDM_TraceDirection                       = 1,
	FDM_SurfaceNormal                        = 2,
	FDM_WeaponForward                        = 3,
	FDM_MAX                                  = 4,
};

// Enum ObsidianFox.EOFObsessionStage
// NumValues: 0x0006
enum class EOFObsessionStage : uint8
{
	Stage0                                   = 0,
	Stage1                                   = 1,
	Stage2                                   = 2,
	Stage3                                   = 3,
	Stage4                                   = 4,
	EOFObsessionStage_MAX                    = 5,
};

// Enum ObsidianFox.EHelptText
// NumValues: 0x0008
enum class EHelptText : uint8
{
	STARTGAME                                = 0,
	RURHTSPAINTING                           = 1,
	SKETCHBOOK                               = 2,
	OPPORTUNITIES                            = 3,
	BAYO                                     = 4,
	POC                                      = 5,
	DERCETO                                  = 6,
	EHelptText_MAX                           = 7,
};

// Enum ObsidianFox.EObjectives
// NumValues: 0x0009
enum class EObjectives : uint8
{
	FIRSTOBJECTIVE                           = 0,
	SECONDOBJECTIVE                          = 1,
	THIRDOBJECTIVE                           = 2,
	FOURTHOBJECTIVE                          = 3,
	FIFTHOBJECTIVE                           = 4,
	SIXTHOBJECTIVE                           = 5,
	SEVENOBJECTIVE                           = 6,
	EIGHTOBJECTIVE                           = 7,
	EObjectives_MAX                          = 8,
};

// Enum ObsidianFox.EHealthState
// NumValues: 0x0005
enum class EHealthState : uint8
{
	HS_Fine                                  = 0,
	HS_Injured                               = 1,
	HS_Critical                              = 2,
	HS_Dead                                  = 3,
	HS_MAX                                   = 4,
};

// Enum ObsidianFox.FButtonType
// NumValues: 0x000B
enum class EFButtonType : uint8
{
	Interact                                 = 0,
	Cancel                                   = 1,
	Inspect                                  = 2,
	Change                                   = 3,
	TurnRate                                 = 4,
	MoveFoward                               = 5,
	CategoryNext                             = 6,
	CategoryPrevious                         = 7,
	Aim                                      = 8,
	RangedAttack                             = 9,
	FButtonType_MAX                          = 10,
};

// Enum ObsidianFox.EHiddenOptions
// NumValues: 0x000B
enum class EHiddenOptions : uint8
{
	Gamma                                    = 0,
	SFX                                      = 1,
	Music                                    = 2,
	Master                                   = 3,
	Resolution                               = 4,
	WindowType                               = 5,
	VSync                                    = 6,
	Restart                                  = 7,
	Quit                                     = 8,
	NumOfOptions                             = 9,
	EHiddenOptions_MAX                       = 10,
};

// Enum ObsidianFox.FInventoryPopUp
// NumValues: 0x0005
enum class EFInventoryPopUp : uint8
{
	Default                                  = 0,
	HidePopup                                = 1,
	HideAll                                  = 2,
	ForcePopup                               = 3,
	FInventoryPopUp_MAX                      = 4,
};

// Enum ObsidianFox.EExaminationViewState
// NumValues: 0x0006
enum class EExaminationViewState : uint8
{
	Idle                                     = 0,
	ReadingMode                              = 1,
	ReadingToInspection                      = 2,
	InspectionMode                           = 3,
	InspectionToReading                      = 4,
	EExaminationViewState_MAX                = 5,
};

// Enum ObsidianFox.EItemChapter
// NumValues: 0x0006
enum class EItemChapter : uint8
{
	CHAPTER_ONE                              = 0,
	CHAPTER_TWO                              = 1,
	CHAPTER_THREE                            = 2,
	CHAPTER_FOUR                             = 3,
	CHAPTER_FIVE                             = 4,
	CHAPTER_MAX                              = 5,
};

// Enum ObsidianFox.EItemDisplayInfoType
// NumValues: 0x0004
enum class EItemDisplayInfoType : uint8
{
	SINGLE_ITEM                              = 0,
	SET_OF_ITEMS                             = 1,
	PART_OF_ITEMS                            = 2,
	EItemDisplayInfoType_MAX                 = 3,
};

// Enum ObsidianFox.EItemType
// NumValues: 0x0007
enum class EItemType : uint8
{
	Clue                                     = 0,
	Collectible                              = 1,
	RangedWeapon                             = 2,
	MeleeWeapon                              = 3,
	Supplies                                 = 4,
	KeyItem                                  = 5,
	EItemType_MAX                            = 6,
};

// Enum ObsidianFox.EItemPickupAnimationType
// NumValues: 0x0003
enum class EItemPickupAnimationType : uint8
{
	Montage                                  = 0,
	Sequence                                 = 1,
	EItemPickupAnimationType_MAX             = 2,
};

// Enum ObsidianFox.EEquipmentSlot
// NumValues: 0x0003
enum class EEquipmentSlot : uint8
{
	NoSlot                                   = 0,
	Pistol                                   = 1,
	EEquipmentSlot_MAX                       = 2,
};

// Enum ObsidianFox.EDoorIconState
// NumValues: 0x0007
enum class EDoorIconState : uint32
{
	None                                     = 0,
	PermanentlyLocked                        = 1,
	Unlocked                                 = 2,
	Bolted                                   = 3,
	LockedKey                                = 4,
	Unlockable                               = 5,
	EDoorIconState_MAX                       = 6,
};

// Enum ObsidianFox.EEmotion
// NumValues: 0x0003
enum class EEmotion : uint8
{
	Fear                                     = 0,
	Carefulness                              = 1,
	EEmotion_MAX                             = 2,
};

// Enum ObsidianFox.EAnimationLocomotionState
// NumValues: 0x0005
enum class EAnimationLocomotionState : uint8
{
	Default                                  = 0,
	Combat                                   = 1,
	Sneak                                    = 2,
	Resistance                               = 3,
	EAnimationLocomotionState_MAX            = 4,
};

// Enum ObsidianFox.EOFCustomMovementMode
// NumValues: 0x0002
enum class EOFCustomMovementMode : uint8
{
	Crawling                                 = 0,
	EOFCustomMovementMode_MAX                = 1,
};

// Enum ObsidianFox.ERenderType
// NumValues: 0x0007
enum class ERenderType : uint8
{
	LOW                                      = 0,
	MEDIUM                                   = 1,
	HIGH                                     = 2,
	EPIC                                     = 3,
	CINEMATIC                                = 4,
	CUSTOM                                   = 5,
	ERenderType_MAX                          = 6,
};

// Enum ObsidianFox.ESyncStreamingVolumesMode
// NumValues: 0x0004
enum class ESyncStreamingVolumesMode : uint8
{
	StreamingVolumeDecides                   = 0,
	StreamingLevelDecides                    = 1,
	MergeBothLists                           = 2,
	ESyncStreamingVolumesMode_MAX            = 3,
};

// Enum ObsidianFox.ESaveGameWidgetState
// NumValues: 0x0006
enum class ESaveGameWidgetState : uint8
{
	Idle                                     = 0,
	FadingIn                                 = 1,
	WaitForSaveActionFinish                  = 2,
	SaveActionFinished                       = 3,
	FadingOut                                = 4,
	ESaveGameWidgetState_MAX                 = 5,
};

// Enum ObsidianFox.EControlsOptions
// NumValues: 0x0003
enum class EControlsOptions : uint8
{
	Controllersensitivity                    = 0,
	Inverted                                 = 1,
	EControlsOptions_MAX                     = 2,
};

// Enum ObsidianFox.EActivationType
// NumValues: 0x0004
enum class EActivationType : uint8
{
	AT_TriggerOnce                           = 0,
	AT_TriggerMultiple                       = 1,
	AT_ContinuousRandom                      = 2,
	AT_MAX                                   = 3,
};

// Enum ObsidianFox.EPauseMenuPT
// NumValues: 0x0007
enum class EPauseMenuPT : uint8
{
	ControllerSensitivity                    = 0,
	Inverted                                 = 1,
	QuickLoad                                = 2,
	SaveGame                                 = 3,
	Quit                                     = 4,
	NumOfOptions                             = 5,
	EPauseMenuPT_MAX                         = 6,
};

// Enum ObsidianFox.EInputActionType
// NumValues: 0x0005
enum class EInputActionType : uint8
{
	Hold                                     = 0,
	Press                                    = 1,
	Tap                                      = 2,
	None                                     = 3,
	EInputActionType_MAX                     = 4,
};

// Enum ObsidianFox.EProgressLevel
// NumValues: 0x000E
enum class EProgressLevel : uint8
{
	None                                     = 0,
	Derceto                                  = 1,
	FrenchQuarters                           = 2,
	OilRig                                   = 3,
	Cemetery                                 = 4,
	Taroella                                 = 5,
	Gallatin                                 = 6,
	DesertStandingStones                     = 7,
	Steamboat                                = 8,
	PearlRiverBridge                         = 9,
	Warphoto                                 = 10,
	Arctic                                   = 11,
	FinalArena                               = 12,
	EProgressLevel_MAX                       = 13,
};

// Enum ObsidianFox.EPuzzleHelperHints
// NumValues: 0x0006
enum class EPuzzleHelperHints : uint8
{
	MASKPUZZLE                               = 0,
	GAVEPUZZLEORIGNAL                        = 1,
	DESKPUZLE                                = 2,
	PAINTINGRUTHS                            = 3,
	PAINTINGSEANCE                           = 4,
	EPuzzleHelperHints_MAX                   = 5,
};

// Enum ObsidianFox.EPuzzleHelperSections
// NumValues: 0x0006
enum class EPuzzleHelperSections : uint8
{
	MASKPUZZLE                               = 0,
	GAVEPUZZLEORIGNAL                        = 1,
	DESKPUZLE                                = 2,
	ACTIVATEPAINTING                         = 3,
	GAVEPUZZLEBONE                           = 4,
	EPuzzleHelperSections_MAX                = 5,
};

// Enum ObsidianFox.EMakeRotationTwoVectorOrder
// NumValues: 0x0007
enum class EMakeRotationTwoVectorOrder : uint8
{
	XY                                       = 0,
	XZ                                       = 1,
	YX                                       = 2,
	YZ                                       = 3,
	ZY                                       = 4,
	ZX                                       = 5,
	EMakeRotationTwoVectorOrder_MAX          = 6,
};

// Enum ObsidianFox.EMakeRotationVectorOrder
// NumValues: 0x0004
enum class EMakeRotationVectorOrder : uint8
{
	X                                        = 0,
	Y                                        = 1,
	Z                                        = 2,
	EMakeRotationVectorOrder_MAX             = 3,
};

// Enum ObsidianFox.ESaveBFLDoOnceExec
// NumValues: 0x0003
enum class ESaveBFLDoOnceExec : uint8
{
	Completed                                = 0,
	Rejected                                 = 1,
	ESaveBFLDoOnceExec_MAX                   = 2,
};

// Enum ObsidianFox.ESolventGauntlet
// NumValues: 0x0004
enum class ESolventGauntlet : uint8
{
	GauntletNochange                         = 0,
	GuantletActivated                        = 1,
	GauntletDeactivated                      = 2,
	ESolventGauntlet_MAX                     = 3,
};

// Enum ObsidianFox.ESplineMovementDirection
// NumValues: 0x0004
enum class ESplineMovementDirection : uint8
{
	Forward                                  = 0,
	Backward                                 = 1,
	Stop                                     = 2,
	ESplineMovementDirection_MAX             = 3,
};

// Enum ObsidianFox.ETimerPauseSource
// NumValues: 0x0007
enum class ETimerPauseSource : uint8
{
	None                                     = 0,
	Location                                 = 1,
	Menu                                     = 2,
	Puzzle                                   = 3,
	Cinematic                                = 4,
	Custom                                   = 5,
	ETimerPauseSource_MAX                    = 6,
};

// ScriptStruct ObsidianFox.RigUnit_SmoothStep
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_SmoothStep final : public FRigUnit
{
public:
	float                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         T;                                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Output;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SmoothStep) == 0x000008, "Wrong alignment on FRigUnit_SmoothStep");
static_assert(sizeof(FRigUnit_SmoothStep) == 0x000018, "Wrong size on FRigUnit_SmoothStep");
static_assert(offsetof(FRigUnit_SmoothStep, A) == 0x000008, "Member 'FRigUnit_SmoothStep::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_SmoothStep, B) == 0x00000C, "Member 'FRigUnit_SmoothStep::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_SmoothStep, T) == 0x000010, "Member 'FRigUnit_SmoothStep::T' has a wrong offset!");
static_assert(offsetof(FRigUnit_SmoothStep, Output) == 0x000014, "Member 'FRigUnit_SmoothStep::Output' has a wrong offset!");

// ScriptStruct ObsidianFox.HitDecal
// 0x0010 (0x0018 - 0x0008)
struct FHitDecal final : public FTableRowBase
{
public:
	class UMaterialInterface*                     HitDecalMaterial;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalScale;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomDecalScaleIncrease;                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitDecal) == 0x000008, "Wrong alignment on FHitDecal");
static_assert(sizeof(FHitDecal) == 0x000018, "Wrong size on FHitDecal");
static_assert(offsetof(FHitDecal, HitDecalMaterial) == 0x000008, "Member 'FHitDecal::HitDecalMaterial' has a wrong offset!");
static_assert(offsetof(FHitDecal, DecalScale) == 0x000010, "Member 'FHitDecal::DecalScale' has a wrong offset!");
static_assert(offsetof(FHitDecal, RandomDecalScaleIncrease) == 0x000014, "Member 'FHitDecal::RandomDecalScaleIncrease' has a wrong offset!");

// ScriptStruct ObsidianFox.SurfaceHitFX
// 0x0070 (0x0078 - 0x0008)
struct FSurfaceHitFX final : public FTableRowBase
{
public:
	class FString                                 Description;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EPhysicalSurface>                      HitPhysSurface;                                    // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bSpawnMeshDecal;                                   // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          HitParticleEffect;                                 // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandomParticleEffectScaleIncrease;                 // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitDecal>                      HitDecals;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UFMODEvent*                             HitSound;                                          // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSurfaceHitFX) == 0x000008, "Wrong alignment on FSurfaceHitFX");
static_assert(sizeof(FSurfaceHitFX) == 0x000078, "Wrong size on FSurfaceHitFX");
static_assert(offsetof(FSurfaceHitFX, Description) == 0x000008, "Member 'FSurfaceHitFX::Description' has a wrong offset!");
static_assert(offsetof(FSurfaceHitFX, HitPhysSurface) == 0x000018, "Member 'FSurfaceHitFX::HitPhysSurface' has a wrong offset!");
static_assert(offsetof(FSurfaceHitFX, bSpawnMeshDecal) == 0x000028, "Member 'FSurfaceHitFX::bSpawnMeshDecal' has a wrong offset!");
static_assert(offsetof(FSurfaceHitFX, HitParticleEffect) == 0x000030, "Member 'FSurfaceHitFX::HitParticleEffect' has a wrong offset!");
static_assert(offsetof(FSurfaceHitFX, RandomParticleEffectScaleIncrease) == 0x000058, "Member 'FSurfaceHitFX::RandomParticleEffectScaleIncrease' has a wrong offset!");
static_assert(offsetof(FSurfaceHitFX, HitDecals) == 0x000060, "Member 'FSurfaceHitFX::HitDecals' has a wrong offset!");
static_assert(offsetof(FSurfaceHitFX, HitSound) == 0x000070, "Member 'FSurfaceHitFX::HitSound' has a wrong offset!");

// ScriptStruct ObsidianFox.RigunitFootLockingOutput
// 0x0018 (0x0018 - 0x0000)
struct FRigunitFootLockingOutput
{
public:
	struct FRigElementKey                         EffectorControl;                                   // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         LockedControl;                                     // 0x000C(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigunitFootLockingOutput) == 0x000004, "Wrong alignment on FRigunitFootLockingOutput");
static_assert(sizeof(FRigunitFootLockingOutput) == 0x000018, "Wrong size on FRigunitFootLockingOutput");
static_assert(offsetof(FRigunitFootLockingOutput, EffectorControl) == 0x000000, "Member 'FRigunitFootLockingOutput::EffectorControl' has a wrong offset!");
static_assert(offsetof(FRigunitFootLockingOutput, LockedControl) == 0x00000C, "Member 'FRigunitFootLockingOutput::LockedControl' has a wrong offset!");

// ScriptStruct ObsidianFox.OFAnimInstanceProxy
// 0x0000 (0x0770 - 0x0770)
struct FOFAnimInstanceProxy final : public FAnimInstanceProxy
{
};
static_assert(alignof(FOFAnimInstanceProxy) == 0x000010, "Wrong alignment on FOFAnimInstanceProxy");
static_assert(sizeof(FOFAnimInstanceProxy) == 0x000770, "Wrong size on FOFAnimInstanceProxy");

// ScriptStruct ObsidianFox.AnimNode_ModifyBoneMasked
// 0x0010 (0x0118 - 0x0108)
struct FAnimNode_ModifyBoneMasked final : public FAnimNode_ModifyBone
{
public:
	struct FRotator                               RotationMask;                                      // 0x0108(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_ModifyBoneMasked) == 0x000008, "Wrong alignment on FAnimNode_ModifyBoneMasked");
static_assert(sizeof(FAnimNode_ModifyBoneMasked) == 0x000118, "Wrong size on FAnimNode_ModifyBoneMasked");
static_assert(offsetof(FAnimNode_ModifyBoneMasked, RotationMask) == 0x000108, "Member 'FAnimNode_ModifyBoneMasked::RotationMask' has a wrong offset!");

// ScriptStruct ObsidianFox.FeetPlantData
// 0x002C (0x002C - 0x0000)
struct FFeetPlantData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FeetLockWeight;                                    // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LockedLocation;                                    // 0x0014(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               LockedRotation;                                    // 0x0020(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFeetPlantData) == 0x000004, "Wrong alignment on FFeetPlantData");
static_assert(sizeof(FFeetPlantData) == 0x00002C, "Wrong size on FFeetPlantData");
static_assert(offsetof(FFeetPlantData, FeetLockWeight) == 0x000010, "Member 'FFeetPlantData::FeetLockWeight' has a wrong offset!");
static_assert(offsetof(FFeetPlantData, LockedLocation) == 0x000014, "Member 'FFeetPlantData::LockedLocation' has a wrong offset!");
static_assert(offsetof(FFeetPlantData, LockedRotation) == 0x000020, "Member 'FFeetPlantData::LockedRotation' has a wrong offset!");

// ScriptStruct ObsidianFox.BoneEffectorData
// 0x008C (0x008C - 0x0000)
struct FBoneEffectorData final
{
public:
	uint8                                         bGroundHit : 1;                                    // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFootLockedToGround : 1;                           // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EffectorLocation;                                  // 0x0004(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               EffectorRotation;                                  // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                PoleVectorLocation;                                // 0x001C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFeetPlantData                         FeetPlantData;                                     // 0x0028(0x002C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	EPhysicalSurface                              SurfaceType;                                       // 0x0054(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x37];                                      // 0x0055(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoneEffectorData) == 0x000004, "Wrong alignment on FBoneEffectorData");
static_assert(sizeof(FBoneEffectorData) == 0x00008C, "Wrong size on FBoneEffectorData");
static_assert(offsetof(FBoneEffectorData, EffectorLocation) == 0x000004, "Member 'FBoneEffectorData::EffectorLocation' has a wrong offset!");
static_assert(offsetof(FBoneEffectorData, EffectorRotation) == 0x000010, "Member 'FBoneEffectorData::EffectorRotation' has a wrong offset!");
static_assert(offsetof(FBoneEffectorData, PoleVectorLocation) == 0x00001C, "Member 'FBoneEffectorData::PoleVectorLocation' has a wrong offset!");
static_assert(offsetof(FBoneEffectorData, FeetPlantData) == 0x000028, "Member 'FBoneEffectorData::FeetPlantData' has a wrong offset!");
static_assert(offsetof(FBoneEffectorData, SurfaceType) == 0x000054, "Member 'FBoneEffectorData::SurfaceType' has a wrong offset!");

// ScriptStruct ObsidianFox.CharacterTransformData
// 0x0080 (0x0080 - 0x0000)
struct alignas(0x10) FCharacterTransformData final
{
public:
	uint8                                         Pad_0[0x80];                                       // 0x0000(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterTransformData) == 0x000010, "Wrong alignment on FCharacterTransformData");
static_assert(sizeof(FCharacterTransformData) == 0x000080, "Wrong size on FCharacterTransformData");

// ScriptStruct ObsidianFox.ActWorldInfo
// 0x0030 (0x0030 - 0x0000)
struct FActWorldInfo final
{
public:
	class FName                                   ActWorldName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPoolManagerDataAsset>   PoolManagerDataAsset;                              // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActWorldInfo) == 0x000008, "Wrong alignment on FActWorldInfo");
static_assert(sizeof(FActWorldInfo) == 0x000030, "Wrong size on FActWorldInfo");
static_assert(offsetof(FActWorldInfo, ActWorldName) == 0x000000, "Member 'FActWorldInfo::ActWorldName' has a wrong offset!");
static_assert(offsetof(FActWorldInfo, PoolManagerDataAsset) == 0x000008, "Member 'FActWorldInfo::PoolManagerDataAsset' has a wrong offset!");

// ScriptStruct ObsidianFox.BarkPlaybackData
// 0x0010 (0x0010 - 0x0000)
struct FBarkPlaybackData final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBarkPriority                                 Priority;                                          // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBarkPlaybackData) == 0x000008, "Wrong alignment on FBarkPlaybackData");
static_assert(sizeof(FBarkPlaybackData) == 0x000010, "Wrong size on FBarkPlaybackData");
static_assert(offsetof(FBarkPlaybackData, Montage) == 0x000000, "Member 'FBarkPlaybackData::Montage' has a wrong offset!");
static_assert(offsetof(FBarkPlaybackData, Priority) == 0x000008, "Member 'FBarkPlaybackData::Priority' has a wrong offset!");

// ScriptStruct ObsidianFox.WeaponAnimationHandData
// 0x0050 (0x0050 - 0x0000)
struct FWeaponAnimationHandData final
{
public:
	TMap<class FName, TSoftObjectPtr<class UAnimSequenceBase>> HandPoses;                                         // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponAnimationHandData) == 0x000008, "Wrong alignment on FWeaponAnimationHandData");
static_assert(sizeof(FWeaponAnimationHandData) == 0x000050, "Wrong size on FWeaponAnimationHandData");
static_assert(offsetof(FWeaponAnimationHandData, HandPoses) == 0x000000, "Member 'FWeaponAnimationHandData::HandPoses' has a wrong offset!");

// ScriptStruct ObsidianFox.WeaponInfo
// 0x0010 (0x0010 - 0x0000)
struct FWeaponInfo final
{
public:
	class UItemData_Equippable*                   ItemData;                                          // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOFWeaponActor*                         WeaponActor;                                       // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponInfo) == 0x000008, "Wrong alignment on FWeaponInfo");
static_assert(sizeof(FWeaponInfo) == 0x000010, "Wrong size on FWeaponInfo");
static_assert(offsetof(FWeaponInfo, ItemData) == 0x000000, "Member 'FWeaponInfo::ItemData' has a wrong offset!");
static_assert(offsetof(FWeaponInfo, WeaponActor) == 0x000008, "Member 'FWeaponInfo::WeaponActor' has a wrong offset!");

// ScriptStruct ObsidianFox.FocusPointData
// 0x002C (0x002C - 0x0000)
struct FFocusPointData final
{
public:
	bool                                          bIsEnabled;                                        // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x1C];                                      // 0x0010(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFocusPointData) == 0x000004, "Wrong alignment on FFocusPointData");
static_assert(sizeof(FFocusPointData) == 0x00002C, "Wrong size on FFocusPointData");
static_assert(offsetof(FFocusPointData, bIsEnabled) == 0x000000, "Member 'FFocusPointData::bIsEnabled' has a wrong offset!");
static_assert(offsetof(FFocusPointData, Location) == 0x000004, "Member 'FFocusPointData::Location' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnitIKBoneData
// 0x0058 (0x0058 - 0x0000)
struct FRigUnitIKBoneData final
{
public:
	struct FRigElementKey                         Origin;                                            // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         ToeItem;                                           // 0x000C(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         ProcessedResult;                                   // 0x0018(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         RawResult;                                         // 0x0024(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationInterpolationSpeed;                        // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalInterpolationSpeed;                          // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TraceHistoryCount;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingAverageMaxDifference;                        // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MinRotationLimit;                                  // 0x0040(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               MaxRotationLimit;                                  // 0x004C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnitIKBoneData) == 0x000004, "Wrong alignment on FRigUnitIKBoneData");
static_assert(sizeof(FRigUnitIKBoneData) == 0x000058, "Wrong size on FRigUnitIKBoneData");
static_assert(offsetof(FRigUnitIKBoneData, Origin) == 0x000000, "Member 'FRigUnitIKBoneData::Origin' has a wrong offset!");
static_assert(offsetof(FRigUnitIKBoneData, ToeItem) == 0x00000C, "Member 'FRigUnitIKBoneData::ToeItem' has a wrong offset!");
static_assert(offsetof(FRigUnitIKBoneData, ProcessedResult) == 0x000018, "Member 'FRigUnitIKBoneData::ProcessedResult' has a wrong offset!");
static_assert(offsetof(FRigUnitIKBoneData, RawResult) == 0x000024, "Member 'FRigUnitIKBoneData::RawResult' has a wrong offset!");
static_assert(offsetof(FRigUnitIKBoneData, LocationInterpolationSpeed) == 0x000030, "Member 'FRigUnitIKBoneData::LocationInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(FRigUnitIKBoneData, NormalInterpolationSpeed) == 0x000034, "Member 'FRigUnitIKBoneData::NormalInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(FRigUnitIKBoneData, TraceHistoryCount) == 0x000038, "Member 'FRigUnitIKBoneData::TraceHistoryCount' has a wrong offset!");
static_assert(offsetof(FRigUnitIKBoneData, MovingAverageMaxDifference) == 0x00003C, "Member 'FRigUnitIKBoneData::MovingAverageMaxDifference' has a wrong offset!");
static_assert(offsetof(FRigUnitIKBoneData, MinRotationLimit) == 0x000040, "Member 'FRigUnitIKBoneData::MinRotationLimit' has a wrong offset!");
static_assert(offsetof(FRigUnitIKBoneData, MaxRotationLimit) == 0x00004C, "Member 'FRigUnitIKBoneData::MaxRotationLimit' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_FootIKBaseMutable
// 0x0000 (0x0068 - 0x0068)
struct FRigUnit_FootIKBaseMutable : public FRigUnitMutable
{
};
static_assert(alignof(FRigUnit_FootIKBaseMutable) == 0x000008, "Wrong alignment on FRigUnit_FootIKBaseMutable");
static_assert(sizeof(FRigUnit_FootIKBaseMutable) == 0x000068, "Wrong size on FRigUnit_FootIKBaseMutable");

// ScriptStruct ObsidianFox.RigUnit_ApplyFootIK
// 0x0090 (0x00F8 - 0x0068)
struct FRigUnit_ApplyFootIK final : public FRigUnit_FootIKBaseMutable
{
public:
	struct FRigUnitIKBoneData                     Item;                                              // 0x0068(0x0058)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          TraceHit;                                          // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ImpactPoint;                                       // 0x00C4(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactNormal;                                      // 0x00D0(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedLocation;                               // 0x00DC(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AccumulatedNormal;                                 // 0x00E8(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ApplyFootIK) == 0x000008, "Wrong alignment on FRigUnit_ApplyFootIK");
static_assert(sizeof(FRigUnit_ApplyFootIK) == 0x0000F8, "Wrong size on FRigUnit_ApplyFootIK");
static_assert(offsetof(FRigUnit_ApplyFootIK, Item) == 0x000068, "Member 'FRigUnit_ApplyFootIK::Item' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFootIK, TraceHit) == 0x0000C0, "Member 'FRigUnit_ApplyFootIK::TraceHit' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFootIK, ImpactPoint) == 0x0000C4, "Member 'FRigUnit_ApplyFootIK::ImpactPoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFootIK, ImpactNormal) == 0x0000D0, "Member 'FRigUnit_ApplyFootIK::ImpactNormal' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFootIK, AccumulatedLocation) == 0x0000DC, "Member 'FRigUnit_ApplyFootIK::AccumulatedLocation' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFootIK, AccumulatedNormal) == 0x0000E8, "Member 'FRigUnit_ApplyFootIK::AccumulatedNormal' has a wrong offset!");

// ScriptStruct ObsidianFox.FootIKModifierArrayWrapper
// 0x0010 (0x0010 - 0x0000)
struct FFootIKModifierArrayWrapper final
{
public:
	TArray<class UFootIKModifier*>                Array;                                             // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootIKModifierArrayWrapper) == 0x000008, "Wrong alignment on FFootIKModifierArrayWrapper");
static_assert(sizeof(FFootIKModifierArrayWrapper) == 0x000010, "Wrong size on FFootIKModifierArrayWrapper");
static_assert(offsetof(FFootIKModifierArrayWrapper, Array) == 0x000000, "Member 'FFootIKModifierArrayWrapper::Array' has a wrong offset!");

// ScriptStruct ObsidianFox.HitReactBoneData
// 0x0028 (0x0028 - 0x0000)
struct FHitReactBoneData final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimulationTimeCurrent;                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimulationTimeMax;                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactStrength;                                    // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceStrength;                                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ForceDirection;                                    // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitReactBoneData) == 0x000004, "Wrong alignment on FHitReactBoneData");
static_assert(sizeof(FHitReactBoneData) == 0x000028, "Wrong size on FHitReactBoneData");
static_assert(offsetof(FHitReactBoneData, BoneName) == 0x000000, "Member 'FHitReactBoneData::BoneName' has a wrong offset!");
static_assert(offsetof(FHitReactBoneData, SimulationTimeCurrent) == 0x000008, "Member 'FHitReactBoneData::SimulationTimeCurrent' has a wrong offset!");
static_assert(offsetof(FHitReactBoneData, SimulationTimeMax) == 0x00000C, "Member 'FHitReactBoneData::SimulationTimeMax' has a wrong offset!");
static_assert(offsetof(FHitReactBoneData, ImpactStrength) == 0x000010, "Member 'FHitReactBoneData::ImpactStrength' has a wrong offset!");
static_assert(offsetof(FHitReactBoneData, ForceStrength) == 0x000014, "Member 'FHitReactBoneData::ForceStrength' has a wrong offset!");
static_assert(offsetof(FHitReactBoneData, ForceDirection) == 0x000018, "Member 'FHitReactBoneData::ForceDirection' has a wrong offset!");

// ScriptStruct ObsidianFox.RagdollGroup
// 0x0028 (0x0028 - 0x0000)
struct FRagdollGroup final
{
public:
	class FName                                   GroupRootBone;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGroupSimulating;                                // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitReactBoneData>              ActiveBones;                                       // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsMarkedAsInvalid;                                // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRagdollGroup) == 0x000008, "Wrong alignment on FRagdollGroup");
static_assert(sizeof(FRagdollGroup) == 0x000028, "Wrong size on FRagdollGroup");
static_assert(offsetof(FRagdollGroup, GroupRootBone) == 0x000000, "Member 'FRagdollGroup::GroupRootBone' has a wrong offset!");
static_assert(offsetof(FRagdollGroup, bIsGroupSimulating) == 0x000008, "Member 'FRagdollGroup::bIsGroupSimulating' has a wrong offset!");
static_assert(offsetof(FRagdollGroup, ActiveBones) == 0x000010, "Member 'FRagdollGroup::ActiveBones' has a wrong offset!");
static_assert(offsetof(FRagdollGroup, bIsMarkedAsInvalid) == 0x000020, "Member 'FRagdollGroup::bIsMarkedAsInvalid' has a wrong offset!");

// ScriptStruct ObsidianFox.MovePrediction
// 0x001C (0x001C - 0x0000)
struct FMovePrediction final
{
public:
	struct FVector                                StartLocation;                                     // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMovePrediction) == 0x000004, "Wrong alignment on FMovePrediction");
static_assert(sizeof(FMovePrediction) == 0x00001C, "Wrong size on FMovePrediction");
static_assert(offsetof(FMovePrediction, StartLocation) == 0x000000, "Member 'FMovePrediction::StartLocation' has a wrong offset!");
static_assert(offsetof(FMovePrediction, EndLocation) == 0x00000C, "Member 'FMovePrediction::EndLocation' has a wrong offset!");
static_assert(offsetof(FMovePrediction, Time) == 0x000018, "Member 'FMovePrediction::Time' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_Gate
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_Gate final : public FRigUnit
{
public:
	bool                                          Input;                                             // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Reset;                                             // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InitOpen;                                          // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OpeningTime;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Output;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InternalTimer;                                     // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_Gate) == 0x000008, "Wrong alignment on FRigUnit_Gate");
static_assert(sizeof(FRigUnit_Gate) == 0x000018, "Wrong size on FRigUnit_Gate");
static_assert(offsetof(FRigUnit_Gate, Input) == 0x000008, "Member 'FRigUnit_Gate::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_Gate, Reset) == 0x000009, "Member 'FRigUnit_Gate::Reset' has a wrong offset!");
static_assert(offsetof(FRigUnit_Gate, InitOpen) == 0x00000A, "Member 'FRigUnit_Gate::InitOpen' has a wrong offset!");
static_assert(offsetof(FRigUnit_Gate, OpeningTime) == 0x00000C, "Member 'FRigUnit_Gate::OpeningTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_Gate, Output) == 0x000010, "Member 'FRigUnit_Gate::Output' has a wrong offset!");
static_assert(offsetof(FRigUnit_Gate, InternalTimer) == 0x000014, "Member 'FRigUnit_Gate::InternalTimer' has a wrong offset!");

// ScriptStruct ObsidianFox.MapData
// 0x00F8 (0x00F8 - 0x0000)
struct FMapData final
{
public:
	struct FSlateBrush                            ImageBrush;                                        // 0x0000(0x0088)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RoomTag;                                           // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SoftTexture;                                       // 0x0090(0x0028)(SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SaveID;                                            // 0x00B8(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRoomMarker;                                    // 0x00C0(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TintColor;                                         // 0x00C4(0x0010)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSolvable;                                       // 0x00D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MarkerLocation;                                    // 0x00D8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x14];                                      // 0x00E4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapData) == 0x000008, "Wrong alignment on FMapData");
static_assert(sizeof(FMapData) == 0x0000F8, "Wrong size on FMapData");
static_assert(offsetof(FMapData, ImageBrush) == 0x000000, "Member 'FMapData::ImageBrush' has a wrong offset!");
static_assert(offsetof(FMapData, RoomTag) == 0x000088, "Member 'FMapData::RoomTag' has a wrong offset!");
static_assert(offsetof(FMapData, SoftTexture) == 0x000090, "Member 'FMapData::SoftTexture' has a wrong offset!");
static_assert(offsetof(FMapData, SaveID) == 0x0000B8, "Member 'FMapData::SaveID' has a wrong offset!");
static_assert(offsetof(FMapData, bUseRoomMarker) == 0x0000C0, "Member 'FMapData::bUseRoomMarker' has a wrong offset!");
static_assert(offsetof(FMapData, TintColor) == 0x0000C4, "Member 'FMapData::TintColor' has a wrong offset!");
static_assert(offsetof(FMapData, bIsSolvable) == 0x0000D4, "Member 'FMapData::bIsSolvable' has a wrong offset!");
static_assert(offsetof(FMapData, MarkerLocation) == 0x0000D8, "Member 'FMapData::MarkerLocation' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_FootIKBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_FootIKBase final : public FRigUnit
{
};
static_assert(alignof(FRigUnit_FootIKBase) == 0x000008, "Wrong alignment on FRigUnit_FootIKBase");
static_assert(sizeof(FRigUnit_FootIKBase) == 0x000008, "Wrong size on FRigUnit_FootIKBase");

// ScriptStruct ObsidianFox.GroundTraceData
// 0x0120 (0x0120 - 0x0000)
struct alignas(0x08) FGroundTraceData final
{
public:
	uint8                                         Pad_0[0x120];                                      // 0x0000(0x0120)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGroundTraceData) == 0x000008, "Wrong alignment on FGroundTraceData");
static_assert(sizeof(FGroundTraceData) == 0x000120, "Wrong size on FGroundTraceData");

// ScriptStruct ObsidianFox.ReactionMontageData
// 0x0018 (0x0018 - 0x0000)
struct FReactionMontageData final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           Sections;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReactionMontageData) == 0x000008, "Wrong alignment on FReactionMontageData");
static_assert(sizeof(FReactionMontageData) == 0x000018, "Wrong size on FReactionMontageData");
static_assert(offsetof(FReactionMontageData, Montage) == 0x000000, "Member 'FReactionMontageData::Montage' has a wrong offset!");
static_assert(offsetof(FReactionMontageData, Sections) == 0x000008, "Member 'FReactionMontageData::Sections' has a wrong offset!");

// ScriptStruct ObsidianFox.FocusPointStartleVariables
// 0x0058 (0x0058 - 0x0000)
struct FFocusPointStartleVariables final
{
public:
	uint8                                         bCanBeStartled : 1;                                // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFocusPointData                        CurrentFocusPoint;                                 // 0x0004(0x002C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FocusOverrideInterpolationSpeed;                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FocusOverrideInterpolationSpeedCurve;              // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusTime;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialReactionTime;                               // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusTimeDeviation;                                // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSightInterestConeDegrees;                       // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFocusPointStartleVariables) == 0x000008, "Wrong alignment on FFocusPointStartleVariables");
static_assert(sizeof(FFocusPointStartleVariables) == 0x000058, "Wrong size on FFocusPointStartleVariables");
static_assert(offsetof(FFocusPointStartleVariables, CurrentFocusPoint) == 0x000004, "Member 'FFocusPointStartleVariables::CurrentFocusPoint' has a wrong offset!");
static_assert(offsetof(FFocusPointStartleVariables, FocusOverrideInterpolationSpeed) == 0x000030, "Member 'FFocusPointStartleVariables::FocusOverrideInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(FFocusPointStartleVariables, FocusOverrideInterpolationSpeedCurve) == 0x000038, "Member 'FFocusPointStartleVariables::FocusOverrideInterpolationSpeedCurve' has a wrong offset!");
static_assert(offsetof(FFocusPointStartleVariables, FocusTime) == 0x000040, "Member 'FFocusPointStartleVariables::FocusTime' has a wrong offset!");
static_assert(offsetof(FFocusPointStartleVariables, InitialReactionTime) == 0x000044, "Member 'FFocusPointStartleVariables::InitialReactionTime' has a wrong offset!");
static_assert(offsetof(FFocusPointStartleVariables, FocusTimeDeviation) == 0x000048, "Member 'FFocusPointStartleVariables::FocusTimeDeviation' has a wrong offset!");
static_assert(offsetof(FFocusPointStartleVariables, MaxSightInterestConeDegrees) == 0x00004C, "Member 'FFocusPointStartleVariables::MaxSightInterestConeDegrees' has a wrong offset!");

// ScriptStruct ObsidianFox.FocusPointsGlanceVariables
// 0x0010 (0x0010 - 0x0000)
struct FFocusPointsGlanceVariables final
{
public:
	float                                         ChanceToGlance;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlanceTime;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlanceTimeDeviation;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFocusPointsGlanceVariables) == 0x000004, "Wrong alignment on FFocusPointsGlanceVariables");
static_assert(sizeof(FFocusPointsGlanceVariables) == 0x000010, "Wrong size on FFocusPointsGlanceVariables");
static_assert(offsetof(FFocusPointsGlanceVariables, ChanceToGlance) == 0x000000, "Member 'FFocusPointsGlanceVariables::ChanceToGlance' has a wrong offset!");
static_assert(offsetof(FFocusPointsGlanceVariables, GlanceTime) == 0x000004, "Member 'FFocusPointsGlanceVariables::GlanceTime' has a wrong offset!");
static_assert(offsetof(FFocusPointsGlanceVariables, GlanceTimeDeviation) == 0x000008, "Member 'FFocusPointsGlanceVariables::GlanceTimeDeviation' has a wrong offset!");

// ScriptStruct ObsidianFox.FocusPointDebugVariables
// 0x0008 (0x0008 - 0x0000)
struct FFocusPointDebugVariables final
{
public:
	bool                                          bIsDebugging;                                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyShowSelectedFocusPoint;                        // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugShowDuration;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFocusPointDebugVariables) == 0x000004, "Wrong alignment on FFocusPointDebugVariables");
static_assert(sizeof(FFocusPointDebugVariables) == 0x000008, "Wrong size on FFocusPointDebugVariables");
static_assert(offsetof(FFocusPointDebugVariables, bIsDebugging) == 0x000000, "Member 'FFocusPointDebugVariables::bIsDebugging' has a wrong offset!");
static_assert(offsetof(FFocusPointDebugVariables, OnlyShowSelectedFocusPoint) == 0x000001, "Member 'FFocusPointDebugVariables::OnlyShowSelectedFocusPoint' has a wrong offset!");
static_assert(offsetof(FFocusPointDebugVariables, DebugShowDuration) == 0x000004, "Member 'FFocusPointDebugVariables::DebugShowDuration' has a wrong offset!");

// ScriptStruct ObsidianFox.FocusPointsVariables
// 0x0190 (0x0190 - 0x0000)
struct FFocusPointsVariables final
{
public:
	uint8                                         bFocusPointsMasterSwitch : 1;                      // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableFocus : 1;                                  // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIsCurrentFocusPointValid : 1;                     // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseTraceRadiusCurve : 1;                          // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseInterestConeCurve : 1;                         // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseInterestTimeCurve : 1;                         // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterestTime;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDecayTime;                                      // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            InterestTimeCurve;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChanceToBecomeInteresting;                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterestCooldownTime;                              // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x50];                                      // 0x0020(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFocusPointData                        CurrentFocusPoint;                                 // 0x0070(0x002C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxSightInterestConeDegrees;                       // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MaxSightInterestConeCurve;                         // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimilarityPrioMult;                                // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimilarityPriRange;                                // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OwnerPoximityPrioMult;                             // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OwnerPoximityPrioRange;                            // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForwardAlignmentPrioMult;                          // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusPointTraceRadius;                             // 0x00BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            FocusPointTraceRadiusCurve;                        // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LineOfSightOriginSocketName;                       // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<EFocusPointCategory>                     FocusInterests;                                    // 0x00D0(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FFocusPointStartleVariables            Startle;                                           // 0x0120(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FFocusPointsGlanceVariables            Glance;                                            // 0x0178(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FFocusPointDebugVariables              Debug;                                             // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFocusPointsVariables) == 0x000008, "Wrong alignment on FFocusPointsVariables");
static_assert(sizeof(FFocusPointsVariables) == 0x000190, "Wrong size on FFocusPointsVariables");
static_assert(offsetof(FFocusPointsVariables, InterestTime) == 0x000004, "Member 'FFocusPointsVariables::InterestTime' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, MaxDecayTime) == 0x000008, "Member 'FFocusPointsVariables::MaxDecayTime' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, InterestTimeCurve) == 0x000010, "Member 'FFocusPointsVariables::InterestTimeCurve' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, ChanceToBecomeInteresting) == 0x000018, "Member 'FFocusPointsVariables::ChanceToBecomeInteresting' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, InterestCooldownTime) == 0x00001C, "Member 'FFocusPointsVariables::InterestCooldownTime' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, CurrentFocusPoint) == 0x000070, "Member 'FFocusPointsVariables::CurrentFocusPoint' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, MaxSightInterestConeDegrees) == 0x00009C, "Member 'FFocusPointsVariables::MaxSightInterestConeDegrees' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, MaxSightInterestConeCurve) == 0x0000A0, "Member 'FFocusPointsVariables::MaxSightInterestConeCurve' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, SimilarityPrioMult) == 0x0000A8, "Member 'FFocusPointsVariables::SimilarityPrioMult' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, SimilarityPriRange) == 0x0000AC, "Member 'FFocusPointsVariables::SimilarityPriRange' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, OwnerPoximityPrioMult) == 0x0000B0, "Member 'FFocusPointsVariables::OwnerPoximityPrioMult' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, OwnerPoximityPrioRange) == 0x0000B4, "Member 'FFocusPointsVariables::OwnerPoximityPrioRange' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, ForwardAlignmentPrioMult) == 0x0000B8, "Member 'FFocusPointsVariables::ForwardAlignmentPrioMult' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, FocusPointTraceRadius) == 0x0000BC, "Member 'FFocusPointsVariables::FocusPointTraceRadius' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, FocusPointTraceRadiusCurve) == 0x0000C0, "Member 'FFocusPointsVariables::FocusPointTraceRadiusCurve' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, LineOfSightOriginSocketName) == 0x0000C8, "Member 'FFocusPointsVariables::LineOfSightOriginSocketName' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, FocusInterests) == 0x0000D0, "Member 'FFocusPointsVariables::FocusInterests' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, Startle) == 0x000120, "Member 'FFocusPointsVariables::Startle' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, Glance) == 0x000178, "Member 'FFocusPointsVariables::Glance' has a wrong offset!");
static_assert(offsetof(FFocusPointsVariables, Debug) == 0x000188, "Member 'FFocusPointsVariables::Debug' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_DirectionVectorAccessor
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_DirectionVectorAccessor : public FRigUnit
{
};
static_assert(alignof(FRigUnit_DirectionVectorAccessor) == 0x000008, "Wrong alignment on FRigUnit_DirectionVectorAccessor");
static_assert(sizeof(FRigUnit_DirectionVectorAccessor) == 0x000008, "Wrong size on FRigUnit_DirectionVectorAccessor");

// ScriptStruct ObsidianFox.RigUnit_GetQuaternionForward
// 0x0048 (0x0050 - 0x0008)
struct FRigUnit_GetQuaternionForward final : public FRigUnit_DirectionVectorAccessor
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Input;                                             // 0x0010(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Up;                                                // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Right;                                             // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Forward;                                           // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_GetQuaternionForward) == 0x000010, "Wrong alignment on FRigUnit_GetQuaternionForward");
static_assert(sizeof(FRigUnit_GetQuaternionForward) == 0x000050, "Wrong size on FRigUnit_GetQuaternionForward");
static_assert(offsetof(FRigUnit_GetQuaternionForward, Input) == 0x000010, "Member 'FRigUnit_GetQuaternionForward::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetQuaternionForward, Up) == 0x000020, "Member 'FRigUnit_GetQuaternionForward::Up' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetQuaternionForward, Right) == 0x00002C, "Member 'FRigUnit_GetQuaternionForward::Right' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetQuaternionForward, Forward) == 0x000038, "Member 'FRigUnit_GetQuaternionForward::Forward' has a wrong offset!");

// ScriptStruct ObsidianFox.AchievementInfo
// 0x0068 (0x0068 - 0x0000)
struct FAchievementInfo final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Progress;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LockedDesc;                                        // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   UnlockedDesc;                                      // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsHidden;                                         // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              UnlockTime;                                        // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAchievementInfo) == 0x000008, "Wrong alignment on FAchievementInfo");
static_assert(sizeof(FAchievementInfo) == 0x000068, "Wrong size on FAchievementInfo");
static_assert(offsetof(FAchievementInfo, ID) == 0x000000, "Member 'FAchievementInfo::ID' has a wrong offset!");
static_assert(offsetof(FAchievementInfo, Progress) == 0x000008, "Member 'FAchievementInfo::Progress' has a wrong offset!");
static_assert(offsetof(FAchievementInfo, Title) == 0x000010, "Member 'FAchievementInfo::Title' has a wrong offset!");
static_assert(offsetof(FAchievementInfo, LockedDesc) == 0x000028, "Member 'FAchievementInfo::LockedDesc' has a wrong offset!");
static_assert(offsetof(FAchievementInfo, UnlockedDesc) == 0x000040, "Member 'FAchievementInfo::UnlockedDesc' has a wrong offset!");
static_assert(offsetof(FAchievementInfo, bIsHidden) == 0x000058, "Member 'FAchievementInfo::bIsHidden' has a wrong offset!");
static_assert(offsetof(FAchievementInfo, UnlockTime) == 0x000060, "Member 'FAchievementInfo::UnlockTime' has a wrong offset!");

// ScriptStruct ObsidianFox.ArmIKData
// 0x0084 (0x0084 - 0x0000)
struct FArmIKData final
{
public:
	EIKState                                      IKState;                                           // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HandBoneName;                                      // 0x0004(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x10];                                       // 0x000C(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HandIKBoneName;                                    // 0x001C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EffektorLocation;                                  // 0x0024(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EffectorLocationPalmCompensated;                   // 0x0030(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetLocation;                                    // 0x003C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0xC];                                       // 0x0048(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IKWeight;                                          // 0x0054(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpToSpeed;                                     // 0x0058(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpFromSpeed;                                   // 0x005C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIKHandRotationMode                           HandRotationMode;                                  // 0x0060(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               HandTargetRotation;                                // 0x0064(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               HandRotation;                                      // 0x0070(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x8];                                       // 0x007C(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArmIKData) == 0x000004, "Wrong alignment on FArmIKData");
static_assert(sizeof(FArmIKData) == 0x000084, "Wrong size on FArmIKData");
static_assert(offsetof(FArmIKData, IKState) == 0x000000, "Member 'FArmIKData::IKState' has a wrong offset!");
static_assert(offsetof(FArmIKData, HandBoneName) == 0x000004, "Member 'FArmIKData::HandBoneName' has a wrong offset!");
static_assert(offsetof(FArmIKData, HandIKBoneName) == 0x00001C, "Member 'FArmIKData::HandIKBoneName' has a wrong offset!");
static_assert(offsetof(FArmIKData, EffektorLocation) == 0x000024, "Member 'FArmIKData::EffektorLocation' has a wrong offset!");
static_assert(offsetof(FArmIKData, EffectorLocationPalmCompensated) == 0x000030, "Member 'FArmIKData::EffectorLocationPalmCompensated' has a wrong offset!");
static_assert(offsetof(FArmIKData, TargetLocation) == 0x00003C, "Member 'FArmIKData::TargetLocation' has a wrong offset!");
static_assert(offsetof(FArmIKData, IKWeight) == 0x000054, "Member 'FArmIKData::IKWeight' has a wrong offset!");
static_assert(offsetof(FArmIKData, InterpToSpeed) == 0x000058, "Member 'FArmIKData::InterpToSpeed' has a wrong offset!");
static_assert(offsetof(FArmIKData, InterpFromSpeed) == 0x00005C, "Member 'FArmIKData::InterpFromSpeed' has a wrong offset!");
static_assert(offsetof(FArmIKData, HandRotationMode) == 0x000060, "Member 'FArmIKData::HandRotationMode' has a wrong offset!");
static_assert(offsetof(FArmIKData, HandTargetRotation) == 0x000064, "Member 'FArmIKData::HandTargetRotation' has a wrong offset!");
static_assert(offsetof(FArmIKData, HandRotation) == 0x000070, "Member 'FArmIKData::HandRotation' has a wrong offset!");

// ScriptStruct ObsidianFox.EasingBlend
// 0x0008 (0x0008 - 0x0000)
struct FEasingBlend final
{
public:
	float                                         Progress;                                          // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlRigAnimEasingType                     EasingType;                                        // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEasingBlend) == 0x000004, "Wrong alignment on FEasingBlend");
static_assert(sizeof(FEasingBlend) == 0x000008, "Wrong size on FEasingBlend");
static_assert(offsetof(FEasingBlend, Progress) == 0x000000, "Member 'FEasingBlend::Progress' has a wrong offset!");
static_assert(offsetof(FEasingBlend, EasingType) == 0x000004, "Member 'FEasingBlend::EasingType' has a wrong offset!");

// ScriptStruct ObsidianFox.AimChainRotationLimit
// 0x0018 (0x0018 - 0x0000)
struct FAimChainRotationLimit final
{
public:
	struct FRotator                               Min;                                               // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Max;                                               // 0x000C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAimChainRotationLimit) == 0x000004, "Wrong alignment on FAimChainRotationLimit");
static_assert(sizeof(FAimChainRotationLimit) == 0x000018, "Wrong size on FAimChainRotationLimit");
static_assert(offsetof(FAimChainRotationLimit, Min) == 0x000000, "Member 'FAimChainRotationLimit::Min' has a wrong offset!");
static_assert(offsetof(FAimChainRotationLimit, Max) == 0x00000C, "Member 'FAimChainRotationLimit::Max' has a wrong offset!");

// ScriptStruct ObsidianFox.AimChainRotationLimitInput
// 0x0024 (0x0024 - 0x0000)
struct FAimChainRotationLimitInput final
{
public:
	struct FRigElementKey                         Item;                                              // 0x0000(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAimChainRotationLimit                 Limit;                                             // 0x000C(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAimChainRotationLimitInput) == 0x000004, "Wrong alignment on FAimChainRotationLimitInput");
static_assert(sizeof(FAimChainRotationLimitInput) == 0x000024, "Wrong size on FAimChainRotationLimitInput");
static_assert(offsetof(FAimChainRotationLimitInput, Item) == 0x000000, "Member 'FAimChainRotationLimitInput::Item' has a wrong offset!");
static_assert(offsetof(FAimChainRotationLimitInput, Limit) == 0x00000C, "Member 'FAimChainRotationLimitInput::Limit' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_AimChain
// 0x00D8 (0x0140 - 0x0068)
struct FRigUnit_AimChain final : public FRigUnit_HighlevelBaseMutable
{
public:
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             AimTransform;                                      // 0x0070(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRigElementKeyCollection               Items;                                             // 0x00A0(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         ReferenceItem;                                     // 0x00B0(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PropagateToChildren;                               // 0x00BC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BD[0x3];                                       // 0x00BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEasingBlend>                   RotationTypes;                                     // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUseRotationLimits;                                // 0x00D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAimChainRotationLimitInput>    RotationLimits;                                    // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Iterations;                                        // 0x00EC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 Weights;                                           // 0x00F0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FEasingBlend>                   RotationTypesCache;                                // 0x0100(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<int32>                                 ItemRotationLimitMappings;                         // 0x0110(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FAimChainRotationLimitInput>    RotationLimitsCache;                               // 0x0120(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	float                                         WeightSumInverted;                                 // 0x0130(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_134[0xC];                                      // 0x0134(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_AimChain) == 0x000010, "Wrong alignment on FRigUnit_AimChain");
static_assert(sizeof(FRigUnit_AimChain) == 0x000140, "Wrong size on FRigUnit_AimChain");
static_assert(offsetof(FRigUnit_AimChain, AimTransform) == 0x000070, "Member 'FRigUnit_AimChain::AimTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimChain, Items) == 0x0000A0, "Member 'FRigUnit_AimChain::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimChain, ReferenceItem) == 0x0000B0, "Member 'FRigUnit_AimChain::ReferenceItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimChain, PropagateToChildren) == 0x0000BC, "Member 'FRigUnit_AimChain::PropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimChain, RotationTypes) == 0x0000C0, "Member 'FRigUnit_AimChain::RotationTypes' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimChain, bUseRotationLimits) == 0x0000D0, "Member 'FRigUnit_AimChain::bUseRotationLimits' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimChain, RotationLimits) == 0x0000D8, "Member 'FRigUnit_AimChain::RotationLimits' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimChain, Alpha) == 0x0000E8, "Member 'FRigUnit_AimChain::Alpha' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimChain, Iterations) == 0x0000EC, "Member 'FRigUnit_AimChain::Iterations' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimChain, Weights) == 0x0000F0, "Member 'FRigUnit_AimChain::Weights' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimChain, RotationTypesCache) == 0x000100, "Member 'FRigUnit_AimChain::RotationTypesCache' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimChain, ItemRotationLimitMappings) == 0x000110, "Member 'FRigUnit_AimChain::ItemRotationLimitMappings' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimChain, RotationLimitsCache) == 0x000120, "Member 'FRigUnit_AimChain::RotationLimitsCache' has a wrong offset!");
static_assert(offsetof(FRigUnit_AimChain, WeightSumInverted) == 0x000130, "Member 'FRigUnit_AimChain::WeightSumInverted' has a wrong offset!");

// ScriptStruct ObsidianFox.DuckLeanSettings
// 0x0018 (0x0018 - 0x0000)
struct FDuckLeanSettings final
{
public:
	uint8                                         bDuckLeanEnabled : 1;                              // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SphereTraceRadius;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceHeightSocketName;                             // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceForwardOffset;                                // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpolationSpeed;                                // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDuckLeanSettings) == 0x000004, "Wrong alignment on FDuckLeanSettings");
static_assert(sizeof(FDuckLeanSettings) == 0x000018, "Wrong size on FDuckLeanSettings");
static_assert(offsetof(FDuckLeanSettings, SphereTraceRadius) == 0x000004, "Member 'FDuckLeanSettings::SphereTraceRadius' has a wrong offset!");
static_assert(offsetof(FDuckLeanSettings, TraceHeightSocketName) == 0x000008, "Member 'FDuckLeanSettings::TraceHeightSocketName' has a wrong offset!");
static_assert(offsetof(FDuckLeanSettings, TraceForwardOffset) == 0x000010, "Member 'FDuckLeanSettings::TraceForwardOffset' has a wrong offset!");
static_assert(offsetof(FDuckLeanSettings, InterpolationSpeed) == 0x000014, "Member 'FDuckLeanSettings::InterpolationSpeed' has a wrong offset!");

// ScriptStruct ObsidianFox.TagFeatureSettings
// 0x0018 (0x0018 - 0x0000)
struct FTagFeatureSettings final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TurnRadiusCurve;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BitPad_10_0 : 1;                                   // 0x0010(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bDisableFastTurn : 1;                              // 0x0010(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTagFeatureSettings) == 0x000008, "Wrong alignment on FTagFeatureSettings");
static_assert(sizeof(FTagFeatureSettings) == 0x000018, "Wrong size on FTagFeatureSettings");
static_assert(offsetof(FTagFeatureSettings, Tag) == 0x000000, "Member 'FTagFeatureSettings::Tag' has a wrong offset!");
static_assert(offsetof(FTagFeatureSettings, TurnRadiusCurve) == 0x000008, "Member 'FTagFeatureSettings::TurnRadiusCurve' has a wrong offset!");

// ScriptStruct ObsidianFox.WallTwistSettings
// 0x0020 (0x0020 - 0x0000)
struct FWallTwistSettings final
{
public:
	uint8                                         bWallTwistEnabled : 1;                             // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SphereTraceRadius;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            InterpolationSpeedCurve;                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceOffset;                                       // 0x0010(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SqueezeThreshold;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWallTwistSettings) == 0x000008, "Wrong alignment on FWallTwistSettings");
static_assert(sizeof(FWallTwistSettings) == 0x000020, "Wrong size on FWallTwistSettings");
static_assert(offsetof(FWallTwistSettings, SphereTraceRadius) == 0x000004, "Member 'FWallTwistSettings::SphereTraceRadius' has a wrong offset!");
static_assert(offsetof(FWallTwistSettings, InterpolationSpeedCurve) == 0x000008, "Member 'FWallTwistSettings::InterpolationSpeedCurve' has a wrong offset!");
static_assert(offsetof(FWallTwistSettings, TraceOffset) == 0x000010, "Member 'FWallTwistSettings::TraceOffset' has a wrong offset!");
static_assert(offsetof(FWallTwistSettings, SqueezeThreshold) == 0x00001C, "Member 'FWallTwistSettings::SqueezeThreshold' has a wrong offset!");

// ScriptStruct ObsidianFox.FootIKStaggeredTraceCacheData
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x10) FFootIKStaggeredTraceCacheData final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFootIKStaggeredTraceCacheData) == 0x000010, "Wrong alignment on FFootIKStaggeredTraceCacheData");
static_assert(sizeof(FFootIKStaggeredTraceCacheData) == 0x000050, "Wrong size on FFootIKStaggeredTraceCacheData");

// ScriptStruct ObsidianFox.RigUnitFootIKTraceResponse
// 0x0002 (0x0002 - 0x0000)
struct FRigUnitFootIKTraceResponse final
{
public:
	ECollisionChannel                             CollisionChannel;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            Response;                                          // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnitFootIKTraceResponse) == 0x000001, "Wrong alignment on FRigUnitFootIKTraceResponse");
static_assert(sizeof(FRigUnitFootIKTraceResponse) == 0x000002, "Wrong size on FRigUnitFootIKTraceResponse");
static_assert(offsetof(FRigUnitFootIKTraceResponse, CollisionChannel) == 0x000000, "Member 'FRigUnitFootIKTraceResponse::CollisionChannel' has a wrong offset!");
static_assert(offsetof(FRigUnitFootIKTraceResponse, Response) == 0x000001, "Member 'FRigUnitFootIKTraceResponse::Response' has a wrong offset!");

// ScriptStruct ObsidianFox.FootIKTraceHitHistory
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FFootIKTraceHitHistory final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFootIKTraceHitHistory) == 0x000008, "Wrong alignment on FFootIKTraceHitHistory");
static_assert(sizeof(FFootIKTraceHitHistory) == 0x000028, "Wrong size on FFootIKTraceHitHistory");

// ScriptStruct ObsidianFox.RigUnit_FootIK
// 0x0170 (0x01D8 - 0x0068)
struct FRigUnit_FootIK final : public FRigUnit_FootIKBaseMutable
{
public:
	int32                                         Index;                                             // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Continue;                                          // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigUnitIKBoneData>             InputItems;                                        // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraceHeight;                                       // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceLength;                                       // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreItemZLocation;                              // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0091(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECollisionChannel>                     ExtraTraceChannels;                                // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TraceRadius;                                       // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepLength;                                        // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseStaggeredTracing;                               // 0x00B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigUnitFootIKTraceResponse>    ChannelResponses;                                  // 0x00B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUsePredictiveIK;                                  // 0x00C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x00C9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x2];                                       // 0x00CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnitIKBoneData                     ResultItem;                                        // 0x00CC(0x0058)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          TraceHit;                                          // 0x0124(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TraceImpactPoint;                                  // 0x0128(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceImpactNormal;                                 // 0x0134(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundAngleFromNonComplex;                         // 0x0140(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StaggeredTraceIndex;                               // 0x0144(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFootIKStaggeredTraceCacheData> StaggeredTraceCacheData;                           // 0x0148(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FTransform>                     PreviousElementTransforms;                         // 0x0158(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	TArray<struct FFootIKTraceHitHistory>         TraceHitHistory;                                   // 0x0168(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	struct FControlRigExecuteContext              Completed;                                         // 0x0178(0x0060)(Edit, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_FootIK) == 0x000008, "Wrong alignment on FRigUnit_FootIK");
static_assert(sizeof(FRigUnit_FootIK) == 0x0001D8, "Wrong size on FRigUnit_FootIK");
static_assert(offsetof(FRigUnit_FootIK, Index) == 0x000068, "Member 'FRigUnit_FootIK::Index' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, Count) == 0x00006C, "Member 'FRigUnit_FootIK::Count' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, Continue) == 0x000070, "Member 'FRigUnit_FootIK::Continue' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, InputItems) == 0x000078, "Member 'FRigUnit_FootIK::InputItems' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, TraceHeight) == 0x000088, "Member 'FRigUnit_FootIK::TraceHeight' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, TraceLength) == 0x00008C, "Member 'FRigUnit_FootIK::TraceLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, bIgnoreItemZLocation) == 0x000090, "Member 'FRigUnit_FootIK::bIgnoreItemZLocation' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, TraceChannel) == 0x000091, "Member 'FRigUnit_FootIK::TraceChannel' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, ExtraTraceChannels) == 0x000098, "Member 'FRigUnit_FootIK::ExtraTraceChannels' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, TraceRadius) == 0x0000A8, "Member 'FRigUnit_FootIK::TraceRadius' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, StepLength) == 0x0000AC, "Member 'FRigUnit_FootIK::StepLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, bTraceComplex) == 0x0000B0, "Member 'FRigUnit_FootIK::bTraceComplex' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, UseStaggeredTracing) == 0x0000B1, "Member 'FRigUnit_FootIK::UseStaggeredTracing' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, ChannelResponses) == 0x0000B8, "Member 'FRigUnit_FootIK::ChannelResponses' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, bUsePredictiveIK) == 0x0000C8, "Member 'FRigUnit_FootIK::bUsePredictiveIK' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, bDrawDebug) == 0x0000C9, "Member 'FRigUnit_FootIK::bDrawDebug' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, ResultItem) == 0x0000CC, "Member 'FRigUnit_FootIK::ResultItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, TraceHit) == 0x000124, "Member 'FRigUnit_FootIK::TraceHit' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, TraceImpactPoint) == 0x000128, "Member 'FRigUnit_FootIK::TraceImpactPoint' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, TraceImpactNormal) == 0x000134, "Member 'FRigUnit_FootIK::TraceImpactNormal' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, GroundAngleFromNonComplex) == 0x000140, "Member 'FRigUnit_FootIK::GroundAngleFromNonComplex' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, StaggeredTraceIndex) == 0x000144, "Member 'FRigUnit_FootIK::StaggeredTraceIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, StaggeredTraceCacheData) == 0x000148, "Member 'FRigUnit_FootIK::StaggeredTraceCacheData' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, PreviousElementTransforms) == 0x000158, "Member 'FRigUnit_FootIK::PreviousElementTransforms' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, TraceHitHistory) == 0x000168, "Member 'FRigUnit_FootIK::TraceHitHistory' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootIK, Completed) == 0x000178, "Member 'FRigUnit_FootIK::Completed' has a wrong offset!");

// ScriptStruct ObsidianFox.DismemberBoneLink
// 0x0010 (0x0018 - 0x0008)
struct FDismemberBoneLink final : public FTableRowBase
{
public:
	class FName                                   HitBoneName;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DismemberPointBoneName;                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDismemberBoneLink) == 0x000008, "Wrong alignment on FDismemberBoneLink");
static_assert(sizeof(FDismemberBoneLink) == 0x000018, "Wrong size on FDismemberBoneLink");
static_assert(offsetof(FDismemberBoneLink, HitBoneName) == 0x000008, "Member 'FDismemberBoneLink::HitBoneName' has a wrong offset!");
static_assert(offsetof(FDismemberBoneLink, DismemberPointBoneName) == 0x000010, "Member 'FDismemberBoneLink::DismemberPointBoneName' has a wrong offset!");

// ScriptStruct ObsidianFox.ResourceBalance
// 0x0010 (0x0010 - 0x0000)
struct FResourceBalance final
{
public:
	int32                                         Target;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetVariation;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PickupMin;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PickupMax;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResourceBalance) == 0x000004, "Wrong alignment on FResourceBalance");
static_assert(sizeof(FResourceBalance) == 0x000010, "Wrong size on FResourceBalance");
static_assert(offsetof(FResourceBalance, Target) == 0x000000, "Member 'FResourceBalance::Target' has a wrong offset!");
static_assert(offsetof(FResourceBalance, TargetVariation) == 0x000004, "Member 'FResourceBalance::TargetVariation' has a wrong offset!");
static_assert(offsetof(FResourceBalance, PickupMin) == 0x000008, "Member 'FResourceBalance::PickupMin' has a wrong offset!");
static_assert(offsetof(FResourceBalance, PickupMax) == 0x00000C, "Member 'FResourceBalance::PickupMax' has a wrong offset!");

// ScriptStruct ObsidianFox.HitScanWeaponRecoilSettings
// 0x0018 (0x0018 - 0x0000)
struct FHitScanWeaponRecoilSettings final
{
public:
	struct FRotator                               RecoilMin;                                         // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               RecoilMax;                                         // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitScanWeaponRecoilSettings) == 0x000004, "Wrong alignment on FHitScanWeaponRecoilSettings");
static_assert(sizeof(FHitScanWeaponRecoilSettings) == 0x000018, "Wrong size on FHitScanWeaponRecoilSettings");
static_assert(offsetof(FHitScanWeaponRecoilSettings, RecoilMin) == 0x000000, "Member 'FHitScanWeaponRecoilSettings::RecoilMin' has a wrong offset!");
static_assert(offsetof(FHitScanWeaponRecoilSettings, RecoilMax) == 0x00000C, "Member 'FHitScanWeaponRecoilSettings::RecoilMax' has a wrong offset!");

// ScriptStruct ObsidianFox.ResourceBalanceCollection
// 0x0060 (0x0068 - 0x0008)
struct FResourceBalanceCollection final : public FTableRowBase
{
public:
	struct FResourceBalance                       Health;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	struct FResourceBalance                       Revolver;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	struct FResourceBalance                       Remington;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	struct FResourceBalance                       Shotgun;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	struct FResourceBalance                       MachineGun;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, SaveGame, NoDestructor, NativeAccessSpecifierPublic)
	struct FResourceBalance                       FlareGun;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, SaveGame, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResourceBalanceCollection) == 0x000008, "Wrong alignment on FResourceBalanceCollection");
static_assert(sizeof(FResourceBalanceCollection) == 0x000068, "Wrong size on FResourceBalanceCollection");
static_assert(offsetof(FResourceBalanceCollection, Health) == 0x000008, "Member 'FResourceBalanceCollection::Health' has a wrong offset!");
static_assert(offsetof(FResourceBalanceCollection, Revolver) == 0x000018, "Member 'FResourceBalanceCollection::Revolver' has a wrong offset!");
static_assert(offsetof(FResourceBalanceCollection, Remington) == 0x000028, "Member 'FResourceBalanceCollection::Remington' has a wrong offset!");
static_assert(offsetof(FResourceBalanceCollection, Shotgun) == 0x000038, "Member 'FResourceBalanceCollection::Shotgun' has a wrong offset!");
static_assert(offsetof(FResourceBalanceCollection, MachineGun) == 0x000048, "Member 'FResourceBalanceCollection::MachineGun' has a wrong offset!");
static_assert(offsetof(FResourceBalanceCollection, FlareGun) == 0x000058, "Member 'FResourceBalanceCollection::FlareGun' has a wrong offset!");

// ScriptStruct ObsidianFox.NoteInfo
// 0x0020 (0x0020 - 0x0000)
struct FNoteInfo final
{
public:
	class FText                                   Note;                                              // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	bool                                          bPlayed;                                           // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNoteInfo) == 0x000008, "Wrong alignment on FNoteInfo");
static_assert(sizeof(FNoteInfo) == 0x000020, "Wrong size on FNoteInfo");
static_assert(offsetof(FNoteInfo, Note) == 0x000000, "Member 'FNoteInfo::Note' has a wrong offset!");
static_assert(offsetof(FNoteInfo, bPlayed) == 0x000018, "Member 'FNoteInfo::bPlayed' has a wrong offset!");

// ScriptStruct ObsidianFox.HitReactionData
// 0x00E0 (0x00E0 - 0x0000)
struct FHitReactionData final
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitBoneName;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitDirection;                                      // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECardinalDirection                            HitQuadrant;                                       // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitStrength;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitForce;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitResult;                                         // 0x0028(0x0088)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GameplayEventTag;                                  // 0x00B0(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InstigatorTags;                                    // 0x00B8(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UGameplayAbility*                       TriggeringAbility;                                 // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHitReactionData) == 0x000008, "Wrong alignment on FHitReactionData");
static_assert(sizeof(FHitReactionData) == 0x0000E0, "Wrong size on FHitReactionData");
static_assert(offsetof(FHitReactionData, Mesh) == 0x000000, "Member 'FHitReactionData::Mesh' has a wrong offset!");
static_assert(offsetof(FHitReactionData, HitBoneName) == 0x000008, "Member 'FHitReactionData::HitBoneName' has a wrong offset!");
static_assert(offsetof(FHitReactionData, HitDirection) == 0x000010, "Member 'FHitReactionData::HitDirection' has a wrong offset!");
static_assert(offsetof(FHitReactionData, HitQuadrant) == 0x00001C, "Member 'FHitReactionData::HitQuadrant' has a wrong offset!");
static_assert(offsetof(FHitReactionData, HitStrength) == 0x000020, "Member 'FHitReactionData::HitStrength' has a wrong offset!");
static_assert(offsetof(FHitReactionData, HitForce) == 0x000024, "Member 'FHitReactionData::HitForce' has a wrong offset!");
static_assert(offsetof(FHitReactionData, HitResult) == 0x000028, "Member 'FHitReactionData::HitResult' has a wrong offset!");
static_assert(offsetof(FHitReactionData, GameplayEventTag) == 0x0000B0, "Member 'FHitReactionData::GameplayEventTag' has a wrong offset!");
static_assert(offsetof(FHitReactionData, InstigatorTags) == 0x0000B8, "Member 'FHitReactionData::InstigatorTags' has a wrong offset!");
static_assert(offsetof(FHitReactionData, TriggeringAbility) == 0x0000D8, "Member 'FHitReactionData::TriggeringAbility' has a wrong offset!");

// ScriptStruct ObsidianFox.ChapterInfo
// 0x0020 (0x0020 - 0x0000)
struct FChapterInfo final
{
public:
	struct FGameplayTag                           ChapterTag;                                        // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ChapterName;                                       // 0x0008(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChapterInfo) == 0x000008, "Wrong alignment on FChapterInfo");
static_assert(sizeof(FChapterInfo) == 0x000020, "Wrong size on FChapterInfo");
static_assert(offsetof(FChapterInfo, ChapterTag) == 0x000000, "Member 'FChapterInfo::ChapterTag' has a wrong offset!");
static_assert(offsetof(FChapterInfo, ChapterName) == 0x000008, "Member 'FChapterInfo::ChapterName' has a wrong offset!");

// ScriptStruct ObsidianFox.ReactionMontageContainer
// 0x0048 (0x0048 - 0x0000)
struct FReactionMontageContainer final
{
public:
	struct FReactionMontageData                   HeavyReaction;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FReactionMontageData                   MediumReaction;                                    // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FReactionMontageData                   LightReaction;                                     // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReactionMontageContainer) == 0x000008, "Wrong alignment on FReactionMontageContainer");
static_assert(sizeof(FReactionMontageContainer) == 0x000048, "Wrong size on FReactionMontageContainer");
static_assert(offsetof(FReactionMontageContainer, HeavyReaction) == 0x000000, "Member 'FReactionMontageContainer::HeavyReaction' has a wrong offset!");
static_assert(offsetof(FReactionMontageContainer, MediumReaction) == 0x000018, "Member 'FReactionMontageContainer::MediumReaction' has a wrong offset!");
static_assert(offsetof(FReactionMontageContainer, LightReaction) == 0x000030, "Member 'FReactionMontageContainer::LightReaction' has a wrong offset!");

// ScriptStruct ObsidianFox.CharHitFX
// 0x0038 (0x0040 - 0x0008)
struct FCharHitFX final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UNiagaraSystem>          HitParticleEffect;                                 // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      HitDecalMaterial;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFMODEvent*                             HitSound;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharHitFX) == 0x000008, "Wrong alignment on FCharHitFX");
static_assert(sizeof(FCharHitFX) == 0x000040, "Wrong size on FCharHitFX");
static_assert(offsetof(FCharHitFX, HitParticleEffect) == 0x000008, "Member 'FCharHitFX::HitParticleEffect' has a wrong offset!");
static_assert(offsetof(FCharHitFX, HitDecalMaterial) == 0x000030, "Member 'FCharHitFX::HitDecalMaterial' has a wrong offset!");
static_assert(offsetof(FCharHitFX, HitSound) == 0x000038, "Member 'FCharHitFX::HitSound' has a wrong offset!");

// ScriptStruct ObsidianFox.RootMotionData
// 0x002C (0x002C - 0x0000)
struct alignas(0x04) FRootMotionData final
{
public:
	uint8                                         Pad_0[0x2C];                                       // 0x0000(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRootMotionData) == 0x000004, "Wrong alignment on FRootMotionData");
static_assert(sizeof(FRootMotionData) == 0x00002C, "Wrong size on FRootMotionData");

// ScriptStruct ObsidianFox.VOStructInfo
// 0x0020 (0x0020 - 0x0000)
struct FVOStructInfo final
{
public:
	class FText                                   ProgrammerSound;                                   // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Delay;                                             // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FVOStructInfo) == 0x000008, "Wrong alignment on FVOStructInfo");
static_assert(sizeof(FVOStructInfo) == 0x000020, "Wrong size on FVOStructInfo");
static_assert(offsetof(FVOStructInfo, ProgrammerSound) == 0x000000, "Member 'FVOStructInfo::ProgrammerSound' has a wrong offset!");
static_assert(offsetof(FVOStructInfo, Delay) == 0x000018, "Member 'FVOStructInfo::Delay' has a wrong offset!");

// ScriptStruct ObsidianFox.ItemDisplayInfo
// 0x00D0 (0x00D0 - 0x0000)
struct FItemDisplayInfo final
{
public:
	class FText                                   ItemName;                                          // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ItemDisplayDescription;                            // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ItemDisplaySmallDescription;                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ItemDisplaySlotTexture;                            // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ItemDisplayExaminationViewTexture;                 // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ItemPickUpTexture;                                 // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVOStructInfo>                  ClueVOs;                                           // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemDisplayInfo) == 0x000008, "Wrong alignment on FItemDisplayInfo");
static_assert(sizeof(FItemDisplayInfo) == 0x0000D0, "Wrong size on FItemDisplayInfo");
static_assert(offsetof(FItemDisplayInfo, ItemName) == 0x000000, "Member 'FItemDisplayInfo::ItemName' has a wrong offset!");
static_assert(offsetof(FItemDisplayInfo, ItemDisplayDescription) == 0x000018, "Member 'FItemDisplayInfo::ItemDisplayDescription' has a wrong offset!");
static_assert(offsetof(FItemDisplayInfo, ItemDisplaySmallDescription) == 0x000030, "Member 'FItemDisplayInfo::ItemDisplaySmallDescription' has a wrong offset!");
static_assert(offsetof(FItemDisplayInfo, ItemDisplaySlotTexture) == 0x000048, "Member 'FItemDisplayInfo::ItemDisplaySlotTexture' has a wrong offset!");
static_assert(offsetof(FItemDisplayInfo, ItemDisplayExaminationViewTexture) == 0x000070, "Member 'FItemDisplayInfo::ItemDisplayExaminationViewTexture' has a wrong offset!");
static_assert(offsetof(FItemDisplayInfo, ItemPickUpTexture) == 0x000098, "Member 'FItemDisplayInfo::ItemPickUpTexture' has a wrong offset!");
static_assert(offsetof(FItemDisplayInfo, ClueVOs) == 0x0000C0, "Member 'FItemDisplayInfo::ClueVOs' has a wrong offset!");

// ScriptStruct ObsidianFox.EnvironmentVolumeDirectionalInscatteringProperties
// 0x0018 (0x0018 - 0x0000)
struct FEnvironmentVolumeDirectionalInscatteringProperties final
{
public:
	float                                         DirectionalInscatteringExponent;                   // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectionalInscatteringStartDistance;              // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DirectionalInscatteringColor;                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnvironmentVolumeDirectionalInscatteringProperties) == 0x000004, "Wrong alignment on FEnvironmentVolumeDirectionalInscatteringProperties");
static_assert(sizeof(FEnvironmentVolumeDirectionalInscatteringProperties) == 0x000018, "Wrong size on FEnvironmentVolumeDirectionalInscatteringProperties");
static_assert(offsetof(FEnvironmentVolumeDirectionalInscatteringProperties, DirectionalInscatteringExponent) == 0x000000, "Member 'FEnvironmentVolumeDirectionalInscatteringProperties::DirectionalInscatteringExponent' has a wrong offset!");
static_assert(offsetof(FEnvironmentVolumeDirectionalInscatteringProperties, DirectionalInscatteringStartDistance) == 0x000004, "Member 'FEnvironmentVolumeDirectionalInscatteringProperties::DirectionalInscatteringStartDistance' has a wrong offset!");
static_assert(offsetof(FEnvironmentVolumeDirectionalInscatteringProperties, DirectionalInscatteringColor) == 0x000008, "Member 'FEnvironmentVolumeDirectionalInscatteringProperties::DirectionalInscatteringColor' has a wrong offset!");

// ScriptStruct ObsidianFox.IKParameters
// 0x0028 (0x0028 - 0x0000)
struct FIKParameters final
{
public:
	uint8                                         bIsRightSide : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                IKTargetLocation;                                  // 0x0004(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpToSpeed;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpFromSpeed;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOFTransformSpace                             LocationSpace;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIKHandRotationMode                           HandRotationMode;                                  // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHandGripping;                                  // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               HandRotation;                                      // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIKParameters) == 0x000004, "Wrong alignment on FIKParameters");
static_assert(sizeof(FIKParameters) == 0x000028, "Wrong size on FIKParameters");
static_assert(offsetof(FIKParameters, IKTargetLocation) == 0x000004, "Member 'FIKParameters::IKTargetLocation' has a wrong offset!");
static_assert(offsetof(FIKParameters, InterpToSpeed) == 0x000010, "Member 'FIKParameters::InterpToSpeed' has a wrong offset!");
static_assert(offsetof(FIKParameters, InterpFromSpeed) == 0x000014, "Member 'FIKParameters::InterpFromSpeed' has a wrong offset!");
static_assert(offsetof(FIKParameters, LocationSpace) == 0x000018, "Member 'FIKParameters::LocationSpace' has a wrong offset!");
static_assert(offsetof(FIKParameters, HandRotationMode) == 0x000019, "Member 'FIKParameters::HandRotationMode' has a wrong offset!");
static_assert(offsetof(FIKParameters, bUseHandGripping) == 0x00001A, "Member 'FIKParameters::bUseHandGripping' has a wrong offset!");
static_assert(offsetof(FIKParameters, HandRotation) == 0x00001C, "Member 'FIKParameters::HandRotation' has a wrong offset!");

// ScriptStruct ObsidianFox.ArmIKEffectorData
// 0x0040 (0x0040 - 0x0000)
struct FArmIKEffectorData final
{
public:
	struct FVector                                EffectorLocation;                                  // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EffectorLocationPalmCompensated;                   // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReferenceLocation;                                 // 0x0018(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasReferenceLocation : 1;                         // 0x0024(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EOFTransformSpace                             TransformSpace;                                    // 0x0025(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIKHandRotationMode                           EffectorRotationMode;                              // 0x0026(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               EffectorRotation;                                  // 0x0028(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0034(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProceduralHandWeight;                              // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FArmIKEffectorData) == 0x000004, "Wrong alignment on FArmIKEffectorData");
static_assert(sizeof(FArmIKEffectorData) == 0x000040, "Wrong size on FArmIKEffectorData");
static_assert(offsetof(FArmIKEffectorData, EffectorLocation) == 0x000000, "Member 'FArmIKEffectorData::EffectorLocation' has a wrong offset!");
static_assert(offsetof(FArmIKEffectorData, EffectorLocationPalmCompensated) == 0x00000C, "Member 'FArmIKEffectorData::EffectorLocationPalmCompensated' has a wrong offset!");
static_assert(offsetof(FArmIKEffectorData, ReferenceLocation) == 0x000018, "Member 'FArmIKEffectorData::ReferenceLocation' has a wrong offset!");
static_assert(offsetof(FArmIKEffectorData, TransformSpace) == 0x000025, "Member 'FArmIKEffectorData::TransformSpace' has a wrong offset!");
static_assert(offsetof(FArmIKEffectorData, EffectorRotationMode) == 0x000026, "Member 'FArmIKEffectorData::EffectorRotationMode' has a wrong offset!");
static_assert(offsetof(FArmIKEffectorData, EffectorRotation) == 0x000028, "Member 'FArmIKEffectorData::EffectorRotation' has a wrong offset!");
static_assert(offsetof(FArmIKEffectorData, Weight) == 0x000034, "Member 'FArmIKEffectorData::Weight' has a wrong offset!");
static_assert(offsetof(FArmIKEffectorData, ProceduralHandWeight) == 0x000038, "Member 'FArmIKEffectorData::ProceduralHandWeight' has a wrong offset!");

// ScriptStruct ObsidianFox.ObjectiveInfo
// 0x0058 (0x0058 - 0x0000)
struct FObjectiveInfo final
{
public:
	bool                                          bUnSeen;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNoteInfo>                      NoteInfos;                                         // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<EObjectiveParts>                       ActiveParts;                                       // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	EObjectiveParts                               LatestCompletedPart;                               // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectiveParts>                       CompletedParts;                                    // 0x0030(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Completed;                                         // 0x0050(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObjectiveInfo) == 0x000008, "Wrong alignment on FObjectiveInfo");
static_assert(sizeof(FObjectiveInfo) == 0x000058, "Wrong size on FObjectiveInfo");
static_assert(offsetof(FObjectiveInfo, bUnSeen) == 0x000000, "Member 'FObjectiveInfo::bUnSeen' has a wrong offset!");
static_assert(offsetof(FObjectiveInfo, NoteInfos) == 0x000008, "Member 'FObjectiveInfo::NoteInfos' has a wrong offset!");
static_assert(offsetof(FObjectiveInfo, ActiveParts) == 0x000018, "Member 'FObjectiveInfo::ActiveParts' has a wrong offset!");
static_assert(offsetof(FObjectiveInfo, LatestCompletedPart) == 0x000028, "Member 'FObjectiveInfo::LatestCompletedPart' has a wrong offset!");
static_assert(offsetof(FObjectiveInfo, CompletedParts) == 0x000030, "Member 'FObjectiveInfo::CompletedParts' has a wrong offset!");
static_assert(offsetof(FObjectiveInfo, Completed) == 0x000050, "Member 'FObjectiveInfo::Completed' has a wrong offset!");

// ScriptStruct ObsidianFox.IKFootSettings
// 0x002C (0x002C - 0x0000)
struct FIKFootSettings final
{
public:
	class FName                                   FootBoneName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToeBoneName;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IKBoneName;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PoleVectorName;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KeepFootPlantedCurve;                              // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x4];                                       // 0x0028(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIKFootSettings) == 0x000004, "Wrong alignment on FIKFootSettings");
static_assert(sizeof(FIKFootSettings) == 0x00002C, "Wrong size on FIKFootSettings");
static_assert(offsetof(FIKFootSettings, FootBoneName) == 0x000000, "Member 'FIKFootSettings::FootBoneName' has a wrong offset!");
static_assert(offsetof(FIKFootSettings, ToeBoneName) == 0x000008, "Member 'FIKFootSettings::ToeBoneName' has a wrong offset!");
static_assert(offsetof(FIKFootSettings, IKBoneName) == 0x000010, "Member 'FIKFootSettings::IKBoneName' has a wrong offset!");
static_assert(offsetof(FIKFootSettings, PoleVectorName) == 0x000018, "Member 'FIKFootSettings::PoleVectorName' has a wrong offset!");
static_assert(offsetof(FIKFootSettings, KeepFootPlantedCurve) == 0x000020, "Member 'FIKFootSettings::KeepFootPlantedCurve' has a wrong offset!");

// ScriptStruct ObsidianFox.FontSettings
// 0x0098 (0x0098 - 0x0000)
struct FFontSettings final
{
public:
	struct FSlateFontInfo                         FontInfo;                                          // 0x0000(0x0058)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            FontColor;                                         // 0x0058(0x0028)(Edit, NativeAccessSpecifierPublic)
	struct FLinearColor                           FontShadowColor;                                   // 0x0080(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FontShadowOffset;                                  // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFontSettings) == 0x000008, "Wrong alignment on FFontSettings");
static_assert(sizeof(FFontSettings) == 0x000098, "Wrong size on FFontSettings");
static_assert(offsetof(FFontSettings, FontInfo) == 0x000000, "Member 'FFontSettings::FontInfo' has a wrong offset!");
static_assert(offsetof(FFontSettings, FontColor) == 0x000058, "Member 'FFontSettings::FontColor' has a wrong offset!");
static_assert(offsetof(FFontSettings, FontShadowColor) == 0x000080, "Member 'FFontSettings::FontShadowColor' has a wrong offset!");
static_assert(offsetof(FFontSettings, FontShadowOffset) == 0x000090, "Member 'FFontSettings::FontShadowOffset' has a wrong offset!");

// ScriptStruct ObsidianFox.CompletedBanter
// 0x0030 (0x0030 - 0x0000)
struct FCompletedBanter final
{
public:
	TSoftClassPtr<class UClass>                   NPCBlueprintClass;                                 // 0x0000(0x0028)(Edit, BlueprintVisible, SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCharacterType                          CharacterType;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NPCLocation;                                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCompletedBanter) == 0x000008, "Wrong alignment on FCompletedBanter");
static_assert(sizeof(FCompletedBanter) == 0x000030, "Wrong size on FCompletedBanter");
static_assert(offsetof(FCompletedBanter, NPCBlueprintClass) == 0x000000, "Member 'FCompletedBanter::NPCBlueprintClass' has a wrong offset!");
static_assert(offsetof(FCompletedBanter, CharacterType) == 0x000028, "Member 'FCompletedBanter::CharacterType' has a wrong offset!");
static_assert(offsetof(FCompletedBanter, NPCLocation) == 0x00002C, "Member 'FCompletedBanter::NPCLocation' has a wrong offset!");

// ScriptStruct ObsidianFox.EnvironmentVolumeExponentialHeightFogProperties
// 0x0030 (0x0030 - 0x0000)
struct FEnvironmentVolumeExponentialHeightFogProperties final
{
public:
	float                                         FogDensity;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogHeightFalloff;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FExponentialHeightFogData              SecondFogData;                                     // 0x0008(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Interp, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           FogInscatteringColor;                              // 0x0014(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogMaxOpacity;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDistance;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FogCutoffDistance;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnvironmentVolumeExponentialHeightFogProperties) == 0x000004, "Wrong alignment on FEnvironmentVolumeExponentialHeightFogProperties");
static_assert(sizeof(FEnvironmentVolumeExponentialHeightFogProperties) == 0x000030, "Wrong size on FEnvironmentVolumeExponentialHeightFogProperties");
static_assert(offsetof(FEnvironmentVolumeExponentialHeightFogProperties, FogDensity) == 0x000000, "Member 'FEnvironmentVolumeExponentialHeightFogProperties::FogDensity' has a wrong offset!");
static_assert(offsetof(FEnvironmentVolumeExponentialHeightFogProperties, FogHeightFalloff) == 0x000004, "Member 'FEnvironmentVolumeExponentialHeightFogProperties::FogHeightFalloff' has a wrong offset!");
static_assert(offsetof(FEnvironmentVolumeExponentialHeightFogProperties, SecondFogData) == 0x000008, "Member 'FEnvironmentVolumeExponentialHeightFogProperties::SecondFogData' has a wrong offset!");
static_assert(offsetof(FEnvironmentVolumeExponentialHeightFogProperties, FogInscatteringColor) == 0x000014, "Member 'FEnvironmentVolumeExponentialHeightFogProperties::FogInscatteringColor' has a wrong offset!");
static_assert(offsetof(FEnvironmentVolumeExponentialHeightFogProperties, FogMaxOpacity) == 0x000024, "Member 'FEnvironmentVolumeExponentialHeightFogProperties::FogMaxOpacity' has a wrong offset!");
static_assert(offsetof(FEnvironmentVolumeExponentialHeightFogProperties, StartDistance) == 0x000028, "Member 'FEnvironmentVolumeExponentialHeightFogProperties::StartDistance' has a wrong offset!");
static_assert(offsetof(FEnvironmentVolumeExponentialHeightFogProperties, FogCutoffDistance) == 0x00002C, "Member 'FEnvironmentVolumeExponentialHeightFogProperties::FogCutoffDistance' has a wrong offset!");

// ScriptStruct ObsidianFox.EnvironmentVolumeVolumetricFogProperties
// 0x002C (0x002C - 0x0000)
struct FEnvironmentVolumeVolumetricFogProperties final
{
public:
	bool                                          bEnableVolumetricFog;                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumetricFogScatteringDistribution;               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 VolumetricFogAlbedo;                               // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           VolumetricFogEmissive;                             // 0x000C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricFogExtinctionScale;                      // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricFogDistance;                             // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumetricFogStaticLightingScatteringIntensity;    // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLightColorsWithFogInscatteringColors;     // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnvironmentVolumeVolumetricFogProperties) == 0x000004, "Wrong alignment on FEnvironmentVolumeVolumetricFogProperties");
static_assert(sizeof(FEnvironmentVolumeVolumetricFogProperties) == 0x00002C, "Wrong size on FEnvironmentVolumeVolumetricFogProperties");
static_assert(offsetof(FEnvironmentVolumeVolumetricFogProperties, bEnableVolumetricFog) == 0x000000, "Member 'FEnvironmentVolumeVolumetricFogProperties::bEnableVolumetricFog' has a wrong offset!");
static_assert(offsetof(FEnvironmentVolumeVolumetricFogProperties, VolumetricFogScatteringDistribution) == 0x000004, "Member 'FEnvironmentVolumeVolumetricFogProperties::VolumetricFogScatteringDistribution' has a wrong offset!");
static_assert(offsetof(FEnvironmentVolumeVolumetricFogProperties, VolumetricFogAlbedo) == 0x000008, "Member 'FEnvironmentVolumeVolumetricFogProperties::VolumetricFogAlbedo' has a wrong offset!");
static_assert(offsetof(FEnvironmentVolumeVolumetricFogProperties, VolumetricFogEmissive) == 0x00000C, "Member 'FEnvironmentVolumeVolumetricFogProperties::VolumetricFogEmissive' has a wrong offset!");
static_assert(offsetof(FEnvironmentVolumeVolumetricFogProperties, VolumetricFogExtinctionScale) == 0x00001C, "Member 'FEnvironmentVolumeVolumetricFogProperties::VolumetricFogExtinctionScale' has a wrong offset!");
static_assert(offsetof(FEnvironmentVolumeVolumetricFogProperties, VolumetricFogDistance) == 0x000020, "Member 'FEnvironmentVolumeVolumetricFogProperties::VolumetricFogDistance' has a wrong offset!");
static_assert(offsetof(FEnvironmentVolumeVolumetricFogProperties, VolumetricFogStaticLightingScatteringIntensity) == 0x000024, "Member 'FEnvironmentVolumeVolumetricFogProperties::VolumetricFogStaticLightingScatteringIntensity' has a wrong offset!");
static_assert(offsetof(FEnvironmentVolumeVolumetricFogProperties, bOverrideLightColorsWithFogInscatteringColors) == 0x000028, "Member 'FEnvironmentVolumeVolumetricFogProperties::bOverrideLightColorsWithFogInscatteringColors' has a wrong offset!");

// ScriptStruct ObsidianFox.EnvironmentStruct
// 0x0170 (0x0170 - 0x0000)
struct FEnvironmentStruct final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  WeatherTags;                                       // 0x0020(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Interp, NativeAccessSpecifierPublic)
	float                                         DurationEnvironment;                               // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationFog;                                       // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegreeCelsius;                                     // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WindSpeed;                                         // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Transition;                                        // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Turbulence;                                        // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurbulenceFrequency;                               // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             GustCurve;                                         // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Interp, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GustFrequency;                                     // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   LerpingTypeEnvironment;                            // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   LerpingTypeFog;                                    // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WindDirection;                                     // 0x009C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialParameterCollection> MaterialCollection;                                // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Interp, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraParameterCollection> NiagaraCollection;                                 // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Interp, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseExponentialHeightFog;                          // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepOldSettings;                                  // 0x00F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x2];                                       // 0x00FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEnvironmentVolumeExponentialHeightFogProperties ExponentialHeightFogProperties;                    // 0x00FC(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Interp, NoDestructor, NativeAccessSpecifierPublic)
	struct FEnvironmentVolumeDirectionalInscatteringProperties DirectionalInscatteringProperties;                 // 0x012C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Interp, NoDestructor, NativeAccessSpecifierPublic)
	struct FEnvironmentVolumeVolumetricFogProperties VolumetricFogProperties;                           // 0x0144(0x002C)(Edit, BlueprintVisible, BlueprintReadOnly, Interp, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnvironmentStruct) == 0x000008, "Wrong alignment on FEnvironmentStruct");
static_assert(sizeof(FEnvironmentStruct) == 0x000170, "Wrong size on FEnvironmentStruct");
static_assert(offsetof(FEnvironmentStruct, WeatherTags) == 0x000020, "Member 'FEnvironmentStruct::WeatherTags' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, DurationEnvironment) == 0x000040, "Member 'FEnvironmentStruct::DurationEnvironment' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, DurationFog) == 0x000044, "Member 'FEnvironmentStruct::DurationFog' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, DegreeCelsius) == 0x000048, "Member 'FEnvironmentStruct::DegreeCelsius' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, WindSpeed) == 0x00004C, "Member 'FEnvironmentStruct::WindSpeed' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, Transition) == 0x000050, "Member 'FEnvironmentStruct::Transition' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, Turbulence) == 0x000054, "Member 'FEnvironmentStruct::Turbulence' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, TurbulenceFrequency) == 0x000058, "Member 'FEnvironmentStruct::TurbulenceFrequency' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, GustCurve) == 0x000060, "Member 'FEnvironmentStruct::GustCurve' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, GustFrequency) == 0x000088, "Member 'FEnvironmentStruct::GustFrequency' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, GameplayEffect) == 0x000090, "Member 'FEnvironmentStruct::GameplayEffect' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, LerpingTypeEnvironment) == 0x000098, "Member 'FEnvironmentStruct::LerpingTypeEnvironment' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, LerpingTypeFog) == 0x000099, "Member 'FEnvironmentStruct::LerpingTypeFog' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, WindDirection) == 0x00009C, "Member 'FEnvironmentStruct::WindDirection' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, MaterialCollection) == 0x0000A8, "Member 'FEnvironmentStruct::MaterialCollection' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, NiagaraCollection) == 0x0000D0, "Member 'FEnvironmentStruct::NiagaraCollection' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, bUseExponentialHeightFog) == 0x0000F8, "Member 'FEnvironmentStruct::bUseExponentialHeightFog' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, bKeepOldSettings) == 0x0000F9, "Member 'FEnvironmentStruct::bKeepOldSettings' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, ExponentialHeightFogProperties) == 0x0000FC, "Member 'FEnvironmentStruct::ExponentialHeightFogProperties' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, DirectionalInscatteringProperties) == 0x00012C, "Member 'FEnvironmentStruct::DirectionalInscatteringProperties' has a wrong offset!");
static_assert(offsetof(FEnvironmentStruct, VolumetricFogProperties) == 0x000144, "Member 'FEnvironmentStruct::VolumetricFogProperties' has a wrong offset!");

// ScriptStruct ObsidianFox.StatRow
// 0x0030 (0x0038 - 0x0008)
struct FStatRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           StatTag;                                           // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StatId;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatValueType                                ValueType;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStatModificationType                         ModificationType;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMinValue;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinValue;                                          // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasMaxValue;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxValue;                                          // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValue;                                      // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatRow) == 0x000008, "Wrong alignment on FStatRow");
static_assert(sizeof(FStatRow) == 0x000038, "Wrong size on FStatRow");
static_assert(offsetof(FStatRow, StatTag) == 0x000008, "Member 'FStatRow::StatTag' has a wrong offset!");
static_assert(offsetof(FStatRow, StatId) == 0x000010, "Member 'FStatRow::StatId' has a wrong offset!");
static_assert(offsetof(FStatRow, ValueType) == 0x000018, "Member 'FStatRow::ValueType' has a wrong offset!");
static_assert(offsetof(FStatRow, ModificationType) == 0x00001C, "Member 'FStatRow::ModificationType' has a wrong offset!");
static_assert(offsetof(FStatRow, bHasMinValue) == 0x000020, "Member 'FStatRow::bHasMinValue' has a wrong offset!");
static_assert(offsetof(FStatRow, MinValue) == 0x000024, "Member 'FStatRow::MinValue' has a wrong offset!");
static_assert(offsetof(FStatRow, bHasMaxValue) == 0x000028, "Member 'FStatRow::bHasMaxValue' has a wrong offset!");
static_assert(offsetof(FStatRow, MaxValue) == 0x00002C, "Member 'FStatRow::MaxValue' has a wrong offset!");
static_assert(offsetof(FStatRow, DefaultValue) == 0x000030, "Member 'FStatRow::DefaultValue' has a wrong offset!");

// ScriptStruct ObsidianFox.AchievementRow
// 0x0048 (0x0050 - 0x0008)
struct FAchievementRow final : public FTableRowBase
{
public:
	struct FGameplayTag                           AchievementTag;                                    // 0x0008(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AchievementId;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsoleAchievementId;                              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAchievementProgressionType                   ProgressionType;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ConnectedStatTag;                                  // 0x0020(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnlockValue;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisplayName;                                       // 0x002C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Description;                                       // 0x0034(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UnlockedDescription;                               // 0x003C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHidden;                                         // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EAchievementGrade                             Grade;                                             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GamerScore;                                        // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAchievementRow) == 0x000008, "Wrong alignment on FAchievementRow");
static_assert(sizeof(FAchievementRow) == 0x000050, "Wrong size on FAchievementRow");
static_assert(offsetof(FAchievementRow, AchievementTag) == 0x000008, "Member 'FAchievementRow::AchievementTag' has a wrong offset!");
static_assert(offsetof(FAchievementRow, AchievementId) == 0x000010, "Member 'FAchievementRow::AchievementId' has a wrong offset!");
static_assert(offsetof(FAchievementRow, ConsoleAchievementId) == 0x000018, "Member 'FAchievementRow::ConsoleAchievementId' has a wrong offset!");
static_assert(offsetof(FAchievementRow, ProgressionType) == 0x00001C, "Member 'FAchievementRow::ProgressionType' has a wrong offset!");
static_assert(offsetof(FAchievementRow, ConnectedStatTag) == 0x000020, "Member 'FAchievementRow::ConnectedStatTag' has a wrong offset!");
static_assert(offsetof(FAchievementRow, UnlockValue) == 0x000028, "Member 'FAchievementRow::UnlockValue' has a wrong offset!");
static_assert(offsetof(FAchievementRow, DisplayName) == 0x00002C, "Member 'FAchievementRow::DisplayName' has a wrong offset!");
static_assert(offsetof(FAchievementRow, Description) == 0x000034, "Member 'FAchievementRow::Description' has a wrong offset!");
static_assert(offsetof(FAchievementRow, UnlockedDescription) == 0x00003C, "Member 'FAchievementRow::UnlockedDescription' has a wrong offset!");
static_assert(offsetof(FAchievementRow, bIsHidden) == 0x000044, "Member 'FAchievementRow::bIsHidden' has a wrong offset!");
static_assert(offsetof(FAchievementRow, Grade) == 0x000048, "Member 'FAchievementRow::Grade' has a wrong offset!");
static_assert(offsetof(FAchievementRow, GamerScore) == 0x00004C, "Member 'FAchievementRow::GamerScore' has a wrong offset!");

// ScriptStruct ObsidianFox.SubLevelPersistentLevelAssociations
// 0x0018 (0x0018 - 0x0000)
struct FSubLevelPersistentLevelAssociations final
{
public:
	class FName                                   SubLevelName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           PersistentLevelNames;                              // 0x0008(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubLevelPersistentLevelAssociations) == 0x000008, "Wrong alignment on FSubLevelPersistentLevelAssociations");
static_assert(sizeof(FSubLevelPersistentLevelAssociations) == 0x000018, "Wrong size on FSubLevelPersistentLevelAssociations");
static_assert(offsetof(FSubLevelPersistentLevelAssociations, SubLevelName) == 0x000000, "Member 'FSubLevelPersistentLevelAssociations::SubLevelName' has a wrong offset!");
static_assert(offsetof(FSubLevelPersistentLevelAssociations, PersistentLevelNames) == 0x000008, "Member 'FSubLevelPersistentLevelAssociations::PersistentLevelNames' has a wrong offset!");

// ScriptStruct ObsidianFox.AnimationLookupTableEntry
// 0x0038 (0x0038 - 0x0000)
struct FAnimationLookupTableEntry final
{
public:
	struct FGameplayTag                           GameplayTag;                                       // 0x0000(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SubTag;                                            // 0x0008(0x0008)(Edit, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         Asset;                                             // 0x0010(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationLookupTableEntry) == 0x000008, "Wrong alignment on FAnimationLookupTableEntry");
static_assert(sizeof(FAnimationLookupTableEntry) == 0x000038, "Wrong size on FAnimationLookupTableEntry");
static_assert(offsetof(FAnimationLookupTableEntry, GameplayTag) == 0x000000, "Member 'FAnimationLookupTableEntry::GameplayTag' has a wrong offset!");
static_assert(offsetof(FAnimationLookupTableEntry, SubTag) == 0x000008, "Member 'FAnimationLookupTableEntry::SubTag' has a wrong offset!");
static_assert(offsetof(FAnimationLookupTableEntry, Asset) == 0x000010, "Member 'FAnimationLookupTableEntry::Asset' has a wrong offset!");

// ScriptStruct ObsidianFox.RagdollWeightCurves
// 0x0010 (0x0010 - 0x0000)
struct FRagdollWeightCurves final
{
public:
	class FName                                   BlendWeightCurveName;                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PhysicalAnimationMultiplierCurveName;              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRagdollWeightCurves) == 0x000004, "Wrong alignment on FRagdollWeightCurves");
static_assert(sizeof(FRagdollWeightCurves) == 0x000010, "Wrong size on FRagdollWeightCurves");
static_assert(offsetof(FRagdollWeightCurves, BlendWeightCurveName) == 0x000000, "Member 'FRagdollWeightCurves::BlendWeightCurveName' has a wrong offset!");
static_assert(offsetof(FRagdollWeightCurves, PhysicalAnimationMultiplierCurveName) == 0x000008, "Member 'FRagdollWeightCurves::PhysicalAnimationMultiplierCurveName' has a wrong offset!");

// ScriptStruct ObsidianFox.RagdollAutoBlendOutParameters
// 0x0010 (0x0010 - 0x0000)
struct FRagdollAutoBlendOutParameters final
{
public:
	float                                         TimeBeforeBlendOutAllowed;                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityThreshold;                                 // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeBetweenVelocityTriggerAndBlendOut;             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRagdollAutoBlendOutParameters) == 0x000004, "Wrong alignment on FRagdollAutoBlendOutParameters");
static_assert(sizeof(FRagdollAutoBlendOutParameters) == 0x000010, "Wrong size on FRagdollAutoBlendOutParameters");
static_assert(offsetof(FRagdollAutoBlendOutParameters, TimeBeforeBlendOutAllowed) == 0x000000, "Member 'FRagdollAutoBlendOutParameters::TimeBeforeBlendOutAllowed' has a wrong offset!");
static_assert(offsetof(FRagdollAutoBlendOutParameters, VelocityThreshold) == 0x000004, "Member 'FRagdollAutoBlendOutParameters::VelocityThreshold' has a wrong offset!");
static_assert(offsetof(FRagdollAutoBlendOutParameters, TimeBetweenVelocityTriggerAndBlendOut) == 0x000008, "Member 'FRagdollAutoBlendOutParameters::TimeBetweenVelocityTriggerAndBlendOut' has a wrong offset!");
static_assert(offsetof(FRagdollAutoBlendOutParameters, BlendOutTime) == 0x00000C, "Member 'FRagdollAutoBlendOutParameters::BlendOutTime' has a wrong offset!");

// ScriptStruct ObsidianFox.BlendableRotator
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x10) FBlendableRotator final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Value;                                             // 0x0020(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlendableRotator) == 0x000010, "Wrong alignment on FBlendableRotator");
static_assert(sizeof(FBlendableRotator) == 0x000030, "Wrong size on FBlendableRotator");
static_assert(offsetof(FBlendableRotator, Value) == 0x000020, "Member 'FBlendableRotator::Value' has a wrong offset!");
static_assert(offsetof(FBlendableRotator, Speed) == 0x00002C, "Member 'FBlendableRotator::Speed' has a wrong offset!");

// ScriptStruct ObsidianFox.ArmIKEffectorStack
// 0x0010 (0x0010 - 0x0000)
struct FArmIKEffectorStack final
{
public:
	TArray<class UArmIKEffectorSession*>          StackArray;                                        // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FArmIKEffectorStack) == 0x000008, "Wrong alignment on FArmIKEffectorStack");
static_assert(sizeof(FArmIKEffectorStack) == 0x000010, "Wrong size on FArmIKEffectorStack");
static_assert(offsetof(FArmIKEffectorStack, StackArray) == 0x000000, "Member 'FArmIKEffectorStack::StackArray' has a wrong offset!");

// ScriptStruct ObsidianFox.DismemberPointData
// 0x00B0 (0x00B0 - 0x0000)
struct FDismemberPointData final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideCharacter;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsDismembered;                                     // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DismemberDifficulty;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOnlyOnDeath;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyEnableAsFirstDismemberment;                    // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           GoreActorClasses;                                  // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          ParticleEffect;                                    // 0x0028(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             SecondaryDismemberPoints;                          // 0x0060(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDismemberPointData) == 0x000008, "Wrong alignment on FDismemberPointData");
static_assert(sizeof(FDismemberPointData) == 0x0000B0, "Wrong size on FDismemberPointData");
static_assert(offsetof(FDismemberPointData, BoneName) == 0x000000, "Member 'FDismemberPointData::BoneName' has a wrong offset!");
static_assert(offsetof(FDismemberPointData, bHideCharacter) == 0x000008, "Member 'FDismemberPointData::bHideCharacter' has a wrong offset!");
static_assert(offsetof(FDismemberPointData, IsDismembered) == 0x000009, "Member 'FDismemberPointData::IsDismembered' has a wrong offset!");
static_assert(offsetof(FDismemberPointData, DismemberDifficulty) == 0x00000C, "Member 'FDismemberPointData::DismemberDifficulty' has a wrong offset!");
static_assert(offsetof(FDismemberPointData, bOnlyOnDeath) == 0x000010, "Member 'FDismemberPointData::bOnlyOnDeath' has a wrong offset!");
static_assert(offsetof(FDismemberPointData, OnlyEnableAsFirstDismemberment) == 0x000011, "Member 'FDismemberPointData::OnlyEnableAsFirstDismemberment' has a wrong offset!");
static_assert(offsetof(FDismemberPointData, GoreActorClasses) == 0x000018, "Member 'FDismemberPointData::GoreActorClasses' has a wrong offset!");
static_assert(offsetof(FDismemberPointData, ParticleEffect) == 0x000028, "Member 'FDismemberPointData::ParticleEffect' has a wrong offset!");
static_assert(offsetof(FDismemberPointData, SecondaryDismemberPoints) == 0x000060, "Member 'FDismemberPointData::SecondaryDismemberPoints' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_HierarchySearchBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_HierarchySearchBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_HierarchySearchBase) == 0x000008, "Wrong alignment on FRigUnit_HierarchySearchBase");
static_assert(sizeof(FRigUnit_HierarchySearchBase) == 0x000008, "Wrong size on FRigUnit_HierarchySearchBase");

// ScriptStruct ObsidianFox.RigUnit_GetChild
// 0x0040 (0x0048 - 0x0008)
struct FRigUnit_GetChild final : public FRigUnit_HierarchySearchBase
{
public:
	struct FRigElementKey                         Parent;                                            // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChildIndex;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ChildFound;                                        // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKey                         Child;                                             // 0x001C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContainerVersion;                                  // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         CachedChild;                                       // 0x002C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         CachedParent;                                      // 0x0038(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedChildIndex;                                  // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_GetChild) == 0x000008, "Wrong alignment on FRigUnit_GetChild");
static_assert(sizeof(FRigUnit_GetChild) == 0x000048, "Wrong size on FRigUnit_GetChild");
static_assert(offsetof(FRigUnit_GetChild, Parent) == 0x000008, "Member 'FRigUnit_GetChild::Parent' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetChild, ChildIndex) == 0x000014, "Member 'FRigUnit_GetChild::ChildIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetChild, ChildFound) == 0x000018, "Member 'FRigUnit_GetChild::ChildFound' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetChild, Child) == 0x00001C, "Member 'FRigUnit_GetChild::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetChild, ContainerVersion) == 0x000028, "Member 'FRigUnit_GetChild::ContainerVersion' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetChild, CachedChild) == 0x00002C, "Member 'FRigUnit_GetChild::CachedChild' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetChild, CachedParent) == 0x000038, "Member 'FRigUnit_GetChild::CachedParent' has a wrong offset!");
static_assert(offsetof(FRigUnit_GetChild, CachedChildIndex) == 0x000044, "Member 'FRigUnit_GetChild::CachedChildIndex' has a wrong offset!");

// ScriptStruct ObsidianFox.BoneEffectorMetaData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FBoneEffectorMetaData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBoneEffectorMetaData) == 0x000004, "Wrong alignment on FBoneEffectorMetaData");
static_assert(sizeof(FBoneEffectorMetaData) == 0x000018, "Wrong size on FBoneEffectorMetaData");

// ScriptStruct ObsidianFox.RailingBoneData
// 0x00A0 (0x00A0 - 0x0000)
struct alignas(0x10) FRailingBoneData final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           IKStartMontage;                                    // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x30];                                      // 0x0070(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRailingBoneData) == 0x000010, "Wrong alignment on FRailingBoneData");
static_assert(sizeof(FRailingBoneData) == 0x0000A0, "Wrong size on FRailingBoneData");
static_assert(offsetof(FRailingBoneData, IKStartMontage) == 0x000068, "Member 'FRailingBoneData::IKStartMontage' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_HandIKBaseMutable
// 0x0000 (0x0068 - 0x0068)
struct FRigUnit_HandIKBaseMutable final : public FRigUnitMutable
{
};
static_assert(alignof(FRigUnit_HandIKBaseMutable) == 0x000008, "Wrong alignment on FRigUnit_HandIKBaseMutable");
static_assert(sizeof(FRigUnit_HandIKBaseMutable) == 0x000068, "Wrong size on FRigUnit_HandIKBaseMutable");

// ScriptStruct ObsidianFox.RailingSearchSettings
// 0x0068 (0x0068 - 0x0000)
struct FRailingSearchSettings final
{
public:
	class FName                                   HandBoneName;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ElbowBoneName;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShoulderName;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bFlipNormalRotation : 1;                           // 0x0018(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           IKStartMontage;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SearchOffset;                                      // 0x0028(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0034(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RailingForwardOffsetCurveName;                     // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RailingRightOffsetCurveName;                       // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RailingUpOffsetCurveName;                          // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngle;                                          // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAngle;                                          // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxNormalAngle;                                    // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRailingSearchSettings) == 0x000008, "Wrong alignment on FRailingSearchSettings");
static_assert(sizeof(FRailingSearchSettings) == 0x000068, "Wrong size on FRailingSearchSettings");
static_assert(offsetof(FRailingSearchSettings, HandBoneName) == 0x000000, "Member 'FRailingSearchSettings::HandBoneName' has a wrong offset!");
static_assert(offsetof(FRailingSearchSettings, ElbowBoneName) == 0x000008, "Member 'FRailingSearchSettings::ElbowBoneName' has a wrong offset!");
static_assert(offsetof(FRailingSearchSettings, ShoulderName) == 0x000010, "Member 'FRailingSearchSettings::ShoulderName' has a wrong offset!");
static_assert(offsetof(FRailingSearchSettings, IKStartMontage) == 0x000020, "Member 'FRailingSearchSettings::IKStartMontage' has a wrong offset!");
static_assert(offsetof(FRailingSearchSettings, SearchOffset) == 0x000028, "Member 'FRailingSearchSettings::SearchOffset' has a wrong offset!");
static_assert(offsetof(FRailingSearchSettings, LocationOffset) == 0x000034, "Member 'FRailingSearchSettings::LocationOffset' has a wrong offset!");
static_assert(offsetof(FRailingSearchSettings, RailingForwardOffsetCurveName) == 0x000040, "Member 'FRailingSearchSettings::RailingForwardOffsetCurveName' has a wrong offset!");
static_assert(offsetof(FRailingSearchSettings, RailingRightOffsetCurveName) == 0x000048, "Member 'FRailingSearchSettings::RailingRightOffsetCurveName' has a wrong offset!");
static_assert(offsetof(FRailingSearchSettings, RailingUpOffsetCurveName) == 0x000050, "Member 'FRailingSearchSettings::RailingUpOffsetCurveName' has a wrong offset!");
static_assert(offsetof(FRailingSearchSettings, MaxAngle) == 0x000058, "Member 'FRailingSearchSettings::MaxAngle' has a wrong offset!");
static_assert(offsetof(FRailingSearchSettings, MinAngle) == 0x00005C, "Member 'FRailingSearchSettings::MinAngle' has a wrong offset!");
static_assert(offsetof(FRailingSearchSettings, MaxNormalAngle) == 0x000060, "Member 'FRailingSearchSettings::MaxNormalAngle' has a wrong offset!");

// ScriptStruct ObsidianFox.AnimNode_BodyFocus
// 0x0060 (0x0128 - 0x00C8)
struct FAnimNode_BodyFocus final : public FAnimNode_SkeletalControlBase
{
public:
	TArray<struct FBoneReference>                 Bones;                                             // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 BoneWeights;                                       // 0x00D8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         bNormalizeWeights : 1;                             // 0x00E8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RotationAmount;                                    // 0x00EC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         RotationReferenceBone;                             // 0x00F8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RotationAlphaInfluence;                            // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RotationAlphaCurve;                                // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x10];                                     // 0x0118(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_BodyFocus) == 0x000008, "Wrong alignment on FAnimNode_BodyFocus");
static_assert(sizeof(FAnimNode_BodyFocus) == 0x000128, "Wrong size on FAnimNode_BodyFocus");
static_assert(offsetof(FAnimNode_BodyFocus, Bones) == 0x0000C8, "Member 'FAnimNode_BodyFocus::Bones' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyFocus, BoneWeights) == 0x0000D8, "Member 'FAnimNode_BodyFocus::BoneWeights' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyFocus, RotationAmount) == 0x0000EC, "Member 'FAnimNode_BodyFocus::RotationAmount' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyFocus, RotationReferenceBone) == 0x0000F8, "Member 'FAnimNode_BodyFocus::RotationReferenceBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyFocus, RotationAlphaInfluence) == 0x000108, "Member 'FAnimNode_BodyFocus::RotationAlphaInfluence' has a wrong offset!");
static_assert(offsetof(FAnimNode_BodyFocus, RotationAlphaCurve) == 0x000110, "Member 'FAnimNode_BodyFocus::RotationAlphaCurve' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_MakeRotationFromVectorBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_MakeRotationFromVectorBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_MakeRotationFromVectorBase) == 0x000008, "Wrong alignment on FRigUnit_MakeRotationFromVectorBase");
static_assert(sizeof(FRigUnit_MakeRotationFromVectorBase) == 0x000008, "Wrong size on FRigUnit_MakeRotationFromVectorBase");

// ScriptStruct ObsidianFox.RigUnit_MakeRotationFromVector
// 0x0028 (0x0030 - 0x0008)
struct FRigUnit_MakeRotationFromVector final : public FRigUnit_MakeRotationFromVectorBase
{
public:
	struct FVector                                Input;                                             // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMakeRotationVectorOrder                      Order;                                             // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0xB];                                       // 0x0015(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MakeRotationFromVector) == 0x000010, "Wrong alignment on FRigUnit_MakeRotationFromVector");
static_assert(sizeof(FRigUnit_MakeRotationFromVector) == 0x000030, "Wrong size on FRigUnit_MakeRotationFromVector");
static_assert(offsetof(FRigUnit_MakeRotationFromVector, Input) == 0x000008, "Member 'FRigUnit_MakeRotationFromVector::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_MakeRotationFromVector, Order) == 0x000014, "Member 'FRigUnit_MakeRotationFromVector::Order' has a wrong offset!");
static_assert(offsetof(FRigUnit_MakeRotationFromVector, Rotation) == 0x000020, "Member 'FRigUnit_MakeRotationFromVector::Rotation' has a wrong offset!");

// ScriptStruct ObsidianFox.AnimNode_PoseMatchSelectBlendSpacePlayer
// 0x0010 (0x0138 - 0x0128)
struct FAnimNode_PoseMatchSelectBlendSpacePlayer final : public FAnimNode_BlendSpacePlayer
{
public:
	TArray<class UBlendSpaceBase*>                Animations;                                        // 0x0128(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_PoseMatchSelectBlendSpacePlayer) == 0x000008, "Wrong alignment on FAnimNode_PoseMatchSelectBlendSpacePlayer");
static_assert(sizeof(FAnimNode_PoseMatchSelectBlendSpacePlayer) == 0x000138, "Wrong size on FAnimNode_PoseMatchSelectBlendSpacePlayer");
static_assert(offsetof(FAnimNode_PoseMatchSelectBlendSpacePlayer, Animations) == 0x000128, "Member 'FAnimNode_PoseMatchSelectBlendSpacePlayer::Animations' has a wrong offset!");

// ScriptStruct ObsidianFox.RangedWeaponAnimationData
// 0x0050 (0x0050 - 0x0000)
struct FRangedWeaponAnimationData final
{
public:
	TSoftObjectPtr<class UAnimMontage>            FireMontage;                                       // 0x0000(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            ReloadMontage;                                     // 0x0028(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRangedWeaponAnimationData) == 0x000008, "Wrong alignment on FRangedWeaponAnimationData");
static_assert(sizeof(FRangedWeaponAnimationData) == 0x000050, "Wrong size on FRangedWeaponAnimationData");
static_assert(offsetof(FRangedWeaponAnimationData, FireMontage) == 0x000000, "Member 'FRangedWeaponAnimationData::FireMontage' has a wrong offset!");
static_assert(offsetof(FRangedWeaponAnimationData, ReloadMontage) == 0x000028, "Member 'FRangedWeaponAnimationData::ReloadMontage' has a wrong offset!");

// ScriptStruct ObsidianFox.AnimNode_PoseMatchSelectPlayer
// 0x0010 (0x00C0 - 0x00B0)
struct FAnimNode_PoseMatchSelectPlayer final : public FAnimNode_SequencePlayer
{
public:
	TArray<class UAnimSequenceBase*>              Animations;                                        // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_PoseMatchSelectPlayer) == 0x000008, "Wrong alignment on FAnimNode_PoseMatchSelectPlayer");
static_assert(sizeof(FAnimNode_PoseMatchSelectPlayer) == 0x0000C0, "Wrong size on FAnimNode_PoseMatchSelectPlayer");
static_assert(offsetof(FAnimNode_PoseMatchSelectPlayer, Animations) == 0x0000B0, "Member 'FAnimNode_PoseMatchSelectPlayer::Animations' has a wrong offset!");

// ScriptStruct ObsidianFox.SW_LegDefinition
// 0x0024 (0x0024 - 0x0000)
struct FSW_LegDefinition final
{
public:
	struct FBoneReference                         IKFootBone;                                        // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         FKFootBone;                                        // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NumBonesInLimb;                                    // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSW_LegDefinition) == 0x000004, "Wrong alignment on FSW_LegDefinition");
static_assert(sizeof(FSW_LegDefinition) == 0x000024, "Wrong size on FSW_LegDefinition");
static_assert(offsetof(FSW_LegDefinition, IKFootBone) == 0x000000, "Member 'FSW_LegDefinition::IKFootBone' has a wrong offset!");
static_assert(offsetof(FSW_LegDefinition, FKFootBone) == 0x000010, "Member 'FSW_LegDefinition::FKFootBone' has a wrong offset!");
static_assert(offsetof(FSW_LegDefinition, NumBonesInLimb) == 0x000020, "Member 'FSW_LegDefinition::NumBonesInLimb' has a wrong offset!");

// ScriptStruct ObsidianFox.HipsAdjustmentInterp
// 0x0008 (0x0008 - 0x0000)
struct FHipsAdjustmentInterp final
{
public:
	float                                         Stiffness;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dampen;                                            // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHipsAdjustmentInterp) == 0x000004, "Wrong alignment on FHipsAdjustmentInterp");
static_assert(sizeof(FHipsAdjustmentInterp) == 0x000008, "Wrong size on FHipsAdjustmentInterp");
static_assert(offsetof(FHipsAdjustmentInterp, Stiffness) == 0x000000, "Member 'FHipsAdjustmentInterp::Stiffness' has a wrong offset!");
static_assert(offsetof(FHipsAdjustmentInterp, Dampen) == 0x000004, "Member 'FHipsAdjustmentInterp::Dampen' has a wrong offset!");

// ScriptStruct ObsidianFox.AnimNode_SpeedWarping
// 0x0098 (0x0160 - 0x00C8)
struct FAnimNode_SpeedWarping final : public FAnimNode_SkeletalControlBase
{
public:
	struct FBoneReference                         RootBone;                                          // 0x00C8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FSW_LegDefinition>              LegDefinitions;                                    // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         HipsBone;                                          // 0x00E8(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                HipsOffset;                                        // 0x00F8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedScaling;                                      // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MovementDirection;                                 // 0x0108(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneControlSpace                             Space;                                             // 0x0114(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HipsAdjustmentAlpha;                               // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHipsAdjustmentInterp                  HipsAdjustmentInterp;                              // 0x011C(0x0008)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         HipsInterpSpeed;                                   // 0x0124(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x38];                                     // 0x0128(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_SpeedWarping) == 0x000008, "Wrong alignment on FAnimNode_SpeedWarping");
static_assert(sizeof(FAnimNode_SpeedWarping) == 0x000160, "Wrong size on FAnimNode_SpeedWarping");
static_assert(offsetof(FAnimNode_SpeedWarping, RootBone) == 0x0000C8, "Member 'FAnimNode_SpeedWarping::RootBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, LegDefinitions) == 0x0000D8, "Member 'FAnimNode_SpeedWarping::LegDefinitions' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, HipsBone) == 0x0000E8, "Member 'FAnimNode_SpeedWarping::HipsBone' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, HipsOffset) == 0x0000F8, "Member 'FAnimNode_SpeedWarping::HipsOffset' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, SpeedScaling) == 0x000104, "Member 'FAnimNode_SpeedWarping::SpeedScaling' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, MovementDirection) == 0x000108, "Member 'FAnimNode_SpeedWarping::MovementDirection' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, Space) == 0x000114, "Member 'FAnimNode_SpeedWarping::Space' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, HipsAdjustmentAlpha) == 0x000118, "Member 'FAnimNode_SpeedWarping::HipsAdjustmentAlpha' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, HipsAdjustmentInterp) == 0x00011C, "Member 'FAnimNode_SpeedWarping::HipsAdjustmentInterp' has a wrong offset!");
static_assert(offsetof(FAnimNode_SpeedWarping, HipsInterpSpeed) == 0x000124, "Member 'FAnimNode_SpeedWarping::HipsInterpSpeed' has a wrong offset!");

// ScriptStruct ObsidianFox.LoadSaveGameUIData
// 0x0098 (0x0098 - 0x0000)
struct FLoadSaveGameUIData final
{
public:
	bool                                          bHasSaveGameExist;                                 // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutoSave;                                       // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UIIndex;                                           // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              TotalPlayTime;                                     // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0010(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           Progression;                                       // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ChapterName;                                       // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LevelName;                                         // 0x0058(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EPlayerCharacterType                          PlayerCharacterType;                               // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LastQuest;                                         // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              SaveTime;                                          // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDifficulty                                   DifficultyLevel;                                   // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerGuidanceLevel                          PlayerGuidanceLevel;                               // 0x0091(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_92[0x6];                                       // 0x0092(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadSaveGameUIData) == 0x000008, "Wrong alignment on FLoadSaveGameUIData");
static_assert(sizeof(FLoadSaveGameUIData) == 0x000098, "Wrong size on FLoadSaveGameUIData");
static_assert(offsetof(FLoadSaveGameUIData, bHasSaveGameExist) == 0x000000, "Member 'FLoadSaveGameUIData::bHasSaveGameExist' has a wrong offset!");
static_assert(offsetof(FLoadSaveGameUIData, bIsAutoSave) == 0x000001, "Member 'FLoadSaveGameUIData::bIsAutoSave' has a wrong offset!");
static_assert(offsetof(FLoadSaveGameUIData, UIIndex) == 0x000004, "Member 'FLoadSaveGameUIData::UIIndex' has a wrong offset!");
static_assert(offsetof(FLoadSaveGameUIData, TotalPlayTime) == 0x000008, "Member 'FLoadSaveGameUIData::TotalPlayTime' has a wrong offset!");
static_assert(offsetof(FLoadSaveGameUIData, Image) == 0x000010, "Member 'FLoadSaveGameUIData::Image' has a wrong offset!");
static_assert(offsetof(FLoadSaveGameUIData, Progression) == 0x000038, "Member 'FLoadSaveGameUIData::Progression' has a wrong offset!");
static_assert(offsetof(FLoadSaveGameUIData, ChapterName) == 0x000040, "Member 'FLoadSaveGameUIData::ChapterName' has a wrong offset!");
static_assert(offsetof(FLoadSaveGameUIData, LevelName) == 0x000058, "Member 'FLoadSaveGameUIData::LevelName' has a wrong offset!");
static_assert(offsetof(FLoadSaveGameUIData, PlayerCharacterType) == 0x000070, "Member 'FLoadSaveGameUIData::PlayerCharacterType' has a wrong offset!");
static_assert(offsetof(FLoadSaveGameUIData, LastQuest) == 0x000078, "Member 'FLoadSaveGameUIData::LastQuest' has a wrong offset!");
static_assert(offsetof(FLoadSaveGameUIData, SaveTime) == 0x000088, "Member 'FLoadSaveGameUIData::SaveTime' has a wrong offset!");
static_assert(offsetof(FLoadSaveGameUIData, DifficultyLevel) == 0x000090, "Member 'FLoadSaveGameUIData::DifficultyLevel' has a wrong offset!");
static_assert(offsetof(FLoadSaveGameUIData, PlayerGuidanceLevel) == 0x000091, "Member 'FLoadSaveGameUIData::PlayerGuidanceLevel' has a wrong offset!");

// ScriptStruct ObsidianFox.IKFootLocation
// 0x0030 (0x0030 - 0x0000)
struct FIKFootLocation final
{
public:
	struct FVector                                LimbRootLocation;                                  // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginLocation;                                    // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActualLocation;                                    // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewLocation;                                       // 0x0024(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIKFootLocation) == 0x000004, "Wrong alignment on FIKFootLocation");
static_assert(sizeof(FIKFootLocation) == 0x000030, "Wrong size on FIKFootLocation");
static_assert(offsetof(FIKFootLocation, LimbRootLocation) == 0x000000, "Member 'FIKFootLocation::LimbRootLocation' has a wrong offset!");
static_assert(offsetof(FIKFootLocation, OriginLocation) == 0x00000C, "Member 'FIKFootLocation::OriginLocation' has a wrong offset!");
static_assert(offsetof(FIKFootLocation, ActualLocation) == 0x000018, "Member 'FIKFootLocation::ActualLocation' has a wrong offset!");
static_assert(offsetof(FIKFootLocation, NewLocation) == 0x000024, "Member 'FIKFootLocation::NewLocation' has a wrong offset!");

// ScriptStruct ObsidianFox.IKHandParameters
// 0x0014 (0x0014 - 0x0000)
struct FIKHandParameters final
{
public:
	EIKHandRotationMode                           RotationMode;                                      // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TargetRotation;                                    // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUseProceduralGripping;                            // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIKHandParameters) == 0x000004, "Wrong alignment on FIKHandParameters");
static_assert(sizeof(FIKHandParameters) == 0x000014, "Wrong size on FIKHandParameters");
static_assert(offsetof(FIKHandParameters, RotationMode) == 0x000000, "Member 'FIKHandParameters::RotationMode' has a wrong offset!");
static_assert(offsetof(FIKHandParameters, TargetRotation) == 0x000004, "Member 'FIKHandParameters::TargetRotation' has a wrong offset!");
static_assert(offsetof(FIKHandParameters, bUseProceduralGripping) == 0x000010, "Member 'FIKHandParameters::bUseProceduralGripping' has a wrong offset!");

// ScriptStruct ObsidianFox.ArmIKCompensationData
// 0x0014 (0x0014 - 0x0000)
struct FArmIKCompensationData final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ConstantOffset;                                    // 0x0008(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmIKCompensationData) == 0x000004, "Wrong alignment on FArmIKCompensationData");
static_assert(sizeof(FArmIKCompensationData) == 0x000014, "Wrong size on FArmIKCompensationData");
static_assert(offsetof(FArmIKCompensationData, BoneName) == 0x000000, "Member 'FArmIKCompensationData::BoneName' has a wrong offset!");
static_assert(offsetof(FArmIKCompensationData, ConstantOffset) == 0x000008, "Member 'FArmIKCompensationData::ConstantOffset' has a wrong offset!");

// ScriptStruct ObsidianFox.ArmIKReferenceTarget
// 0x0010 (0x0010 - 0x0000)
struct FArmIKReferenceTarget final
{
public:
	uint8                                         bUseLocation : 1;                                  // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArmIKReferenceTarget) == 0x000004, "Wrong alignment on FArmIKReferenceTarget");
static_assert(sizeof(FArmIKReferenceTarget) == 0x000010, "Wrong size on FArmIKReferenceTarget");
static_assert(offsetof(FArmIKReferenceTarget, Location) == 0x000004, "Member 'FArmIKReferenceTarget::Location' has a wrong offset!");

// ScriptStruct ObsidianFox.CharacterSelectLight
// 0x0030 (0x0030 - 0x0000)
struct FCharacterSelectLight final
{
public:
	TSoftObjectPtr<class ALight>                  Light;                                             // 0x0000(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultIntensity;                                  // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterSelectLight) == 0x000008, "Wrong alignment on FCharacterSelectLight");
static_assert(sizeof(FCharacterSelectLight) == 0x000030, "Wrong size on FCharacterSelectLight");
static_assert(offsetof(FCharacterSelectLight, Light) == 0x000000, "Member 'FCharacterSelectLight::Light' has a wrong offset!");
static_assert(offsetof(FCharacterSelectLight, DefaultIntensity) == 0x000028, "Member 'FCharacterSelectLight::DefaultIntensity' has a wrong offset!");

// ScriptStruct ObsidianFox.PuzzleBreaker
// 0x0020 (0x0020 - 0x0000)
struct FPuzzleBreaker final
{
public:
	class USceneComponent*                        LeverComponent;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Enabled : 1;                                       // 0x0008(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 AffectedBreakerIndexes;                            // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPuzzleBreaker) == 0x000008, "Wrong alignment on FPuzzleBreaker");
static_assert(sizeof(FPuzzleBreaker) == 0x000020, "Wrong size on FPuzzleBreaker");
static_assert(offsetof(FPuzzleBreaker, LeverComponent) == 0x000000, "Member 'FPuzzleBreaker::LeverComponent' has a wrong offset!");
static_assert(offsetof(FPuzzleBreaker, AffectedBreakerIndexes) == 0x000010, "Member 'FPuzzleBreaker::AffectedBreakerIndexes' has a wrong offset!");

// ScriptStruct ObsidianFox.PlayerSubGraphAnimInstanceProxy
// 0x0010 (0x0780 - 0x0770)
struct FPlayerSubGraphAnimInstanceProxy : public FAnimInstanceProxy
{
public:
	class UPlayerSubGraphAnimInstance*            Owner;                                             // 0x0770(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasEvaluatedAnimGraph : 1;                        // 0x0778(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_779[0x7];                                      // 0x0779(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerSubGraphAnimInstanceProxy) == 0x000010, "Wrong alignment on FPlayerSubGraphAnimInstanceProxy");
static_assert(sizeof(FPlayerSubGraphAnimInstanceProxy) == 0x000780, "Wrong size on FPlayerSubGraphAnimInstanceProxy");
static_assert(offsetof(FPlayerSubGraphAnimInstanceProxy, Owner) == 0x000770, "Member 'FPlayerSubGraphAnimInstanceProxy::Owner' has a wrong offset!");

// ScriptStruct ObsidianFox.ContextualTraverseAnimInstanceProxy
// 0x0030 (0x07B0 - 0x0780)
struct FContextualTraverseAnimInstanceProxy final : public FPlayerSubGraphAnimInstanceProxy
{
public:
	float                                         MoveSpeed;                                         // 0x0780(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RelativeMoveDir;                                   // 0x0784(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MovementInput;                                     // 0x0790(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovementInputSize;                                 // 0x079C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveForwardAxisInput;                              // 0x07A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A4[0x4];                                      // 0x07A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AObsidianFoxCharacter*                  OwnerChar;                                         // 0x07A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContextualTraverseAnimInstanceProxy) == 0x000010, "Wrong alignment on FContextualTraverseAnimInstanceProxy");
static_assert(sizeof(FContextualTraverseAnimInstanceProxy) == 0x0007B0, "Wrong size on FContextualTraverseAnimInstanceProxy");
static_assert(offsetof(FContextualTraverseAnimInstanceProxy, MoveSpeed) == 0x000780, "Member 'FContextualTraverseAnimInstanceProxy::MoveSpeed' has a wrong offset!");
static_assert(offsetof(FContextualTraverseAnimInstanceProxy, RelativeMoveDir) == 0x000784, "Member 'FContextualTraverseAnimInstanceProxy::RelativeMoveDir' has a wrong offset!");
static_assert(offsetof(FContextualTraverseAnimInstanceProxy, MovementInput) == 0x000790, "Member 'FContextualTraverseAnimInstanceProxy::MovementInput' has a wrong offset!");
static_assert(offsetof(FContextualTraverseAnimInstanceProxy, MovementInputSize) == 0x00079C, "Member 'FContextualTraverseAnimInstanceProxy::MovementInputSize' has a wrong offset!");
static_assert(offsetof(FContextualTraverseAnimInstanceProxy, MoveForwardAxisInput) == 0x0007A0, "Member 'FContextualTraverseAnimInstanceProxy::MoveForwardAxisInput' has a wrong offset!");
static_assert(offsetof(FContextualTraverseAnimInstanceProxy, OwnerChar) == 0x0007A8, "Member 'FContextualTraverseAnimInstanceProxy::OwnerChar' has a wrong offset!");

// ScriptStruct ObsidianFox.CtrlButtonInfo
// 0x0028 (0x0028 - 0x0000)
struct FCtrlButtonInfo final
{
public:
	class UInputAction*                           InputAction;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         ButtonHorizontalBox;                               // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             DescriptionText;                                   // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x10];                                      // 0x0018(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCtrlButtonInfo) == 0x000008, "Wrong alignment on FCtrlButtonInfo");
static_assert(sizeof(FCtrlButtonInfo) == 0x000028, "Wrong size on FCtrlButtonInfo");
static_assert(offsetof(FCtrlButtonInfo, InputAction) == 0x000000, "Member 'FCtrlButtonInfo::InputAction' has a wrong offset!");
static_assert(offsetof(FCtrlButtonInfo, ButtonHorizontalBox) == 0x000008, "Member 'FCtrlButtonInfo::ButtonHorizontalBox' has a wrong offset!");
static_assert(offsetof(FCtrlButtonInfo, DescriptionText) == 0x000010, "Member 'FCtrlButtonInfo::DescriptionText' has a wrong offset!");

// ScriptStruct ObsidianFox.TerrainSplashEffects
// 0x0040 (0x0040 - 0x0000)
struct FTerrainSplashEffects final
{
public:
	ETerrainMaterialType                          TerrainType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPhysicalSurface>                      PhysSurfaces;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraSystem>          ParticleSystem;                                    // 0x0018(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTerrainSplashEffects) == 0x000008, "Wrong alignment on FTerrainSplashEffects");
static_assert(sizeof(FTerrainSplashEffects) == 0x000040, "Wrong size on FTerrainSplashEffects");
static_assert(offsetof(FTerrainSplashEffects, TerrainType) == 0x000000, "Member 'FTerrainSplashEffects::TerrainType' has a wrong offset!");
static_assert(offsetof(FTerrainSplashEffects, PhysSurfaces) == 0x000008, "Member 'FTerrainSplashEffects::PhysSurfaces' has a wrong offset!");
static_assert(offsetof(FTerrainSplashEffects, ParticleSystem) == 0x000018, "Member 'FTerrainSplashEffects::ParticleSystem' has a wrong offset!");

// ScriptStruct ObsidianFox.InteractBrushOverride
// 0x0010 (0x0010 - 0x0000)
struct FInteractBrushOverride final
{
public:
	ETerrainMaterialType                          TerrainType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     OverrideBrush;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractBrushOverride) == 0x000008, "Wrong alignment on FInteractBrushOverride");
static_assert(sizeof(FInteractBrushOverride) == 0x000010, "Wrong size on FInteractBrushOverride");
static_assert(offsetof(FInteractBrushOverride, TerrainType) == 0x000000, "Member 'FInteractBrushOverride::TerrainType' has a wrong offset!");
static_assert(offsetof(FInteractBrushOverride, OverrideBrush) == 0x000008, "Member 'FInteractBrushOverride::OverrideBrush' has a wrong offset!");

// ScriptStruct ObsidianFox.InteractionPoint
// 0x0014 (0x0014 - 0x0000)
struct FInteractionPoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Socket;                                            // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionPoint) == 0x000004, "Wrong alignment on FInteractionPoint");
static_assert(sizeof(FInteractionPoint) == 0x000014, "Wrong size on FInteractionPoint");
static_assert(offsetof(FInteractionPoint, Location) == 0x000000, "Member 'FInteractionPoint::Location' has a wrong offset!");
static_assert(offsetof(FInteractionPoint, Socket) == 0x00000C, "Member 'FInteractionPoint::Socket' has a wrong offset!");

// ScriptStruct ObsidianFox.DismemberSkeletalMeshData
// 0x0050 (0x0050 - 0x0000)
struct FDismemberSkeletalMeshData final
{
public:
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OffsetTransform;                                   // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShouldSimulateRoot;                               // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseForceCenter;                                   // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0xE];                                       // 0x0042(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDismemberSkeletalMeshData) == 0x000010, "Wrong alignment on FDismemberSkeletalMeshData");
static_assert(sizeof(FDismemberSkeletalMeshData) == 0x000050, "Wrong size on FDismemberSkeletalMeshData");
static_assert(offsetof(FDismemberSkeletalMeshData, SkeletalMesh) == 0x000000, "Member 'FDismemberSkeletalMeshData::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FDismemberSkeletalMeshData, OffsetTransform) == 0x000010, "Member 'FDismemberSkeletalMeshData::OffsetTransform' has a wrong offset!");
static_assert(offsetof(FDismemberSkeletalMeshData, bShouldSimulateRoot) == 0x000040, "Member 'FDismemberSkeletalMeshData::bShouldSimulateRoot' has a wrong offset!");
static_assert(offsetof(FDismemberSkeletalMeshData, bUseForceCenter) == 0x000041, "Member 'FDismemberSkeletalMeshData::bUseForceCenter' has a wrong offset!");

// ScriptStruct ObsidianFox.DismemberStaticMeshData
// 0x0050 (0x0050 - 0x0000)
struct FDismemberStaticMeshData final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OffsetTransform;                                   // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShouldSimulatePhysics;                            // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseForceCenter;                                   // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0xE];                                       // 0x0042(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDismemberStaticMeshData) == 0x000010, "Wrong alignment on FDismemberStaticMeshData");
static_assert(sizeof(FDismemberStaticMeshData) == 0x000050, "Wrong size on FDismemberStaticMeshData");
static_assert(offsetof(FDismemberStaticMeshData, StaticMesh) == 0x000000, "Member 'FDismemberStaticMeshData::StaticMesh' has a wrong offset!");
static_assert(offsetof(FDismemberStaticMeshData, OffsetTransform) == 0x000010, "Member 'FDismemberStaticMeshData::OffsetTransform' has a wrong offset!");
static_assert(offsetof(FDismemberStaticMeshData, bShouldSimulatePhysics) == 0x000040, "Member 'FDismemberStaticMeshData::bShouldSimulatePhysics' has a wrong offset!");
static_assert(offsetof(FDismemberStaticMeshData, bUseForceCenter) == 0x000041, "Member 'FDismemberStaticMeshData::bUseForceCenter' has a wrong offset!");

// ScriptStruct ObsidianFox.DoorCurveDataPair
// 0x0010 (0x0010 - 0x0000)
struct FDoorCurveDataPair final
{
public:
	class UCurveFloat*                            Clockwise;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            CounterClockwise;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDoorCurveDataPair) == 0x000008, "Wrong alignment on FDoorCurveDataPair");
static_assert(sizeof(FDoorCurveDataPair) == 0x000010, "Wrong size on FDoorCurveDataPair");
static_assert(offsetof(FDoorCurveDataPair, Clockwise) == 0x000000, "Member 'FDoorCurveDataPair::Clockwise' has a wrong offset!");
static_assert(offsetof(FDoorCurveDataPair, CounterClockwise) == 0x000008, "Member 'FDoorCurveDataPair::CounterClockwise' has a wrong offset!");

// ScriptStruct ObsidianFox.DoorCurveData
// 0x0070 (0x0070 - 0x0000)
struct FDoorCurveData final
{
public:
	struct FDoorCurveDataPair                     FirstTimeDoorOpen;                                 // 0x0000(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDoorCurveDataPair                     DoorOpen;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDoorCurveDataPair                     DoorLocked;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDoorCurveDataPair                     DoorLockedCombat;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDoorCurveDataPair                     HandleOpen;                                        // 0x0040(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDoorCurveDataPair                     HandleLocked;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FDoorCurveDataPair                     HandleLockedCombat;                                // 0x0060(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDoorCurveData) == 0x000008, "Wrong alignment on FDoorCurveData");
static_assert(sizeof(FDoorCurveData) == 0x000070, "Wrong size on FDoorCurveData");
static_assert(offsetof(FDoorCurveData, FirstTimeDoorOpen) == 0x000000, "Member 'FDoorCurveData::FirstTimeDoorOpen' has a wrong offset!");
static_assert(offsetof(FDoorCurveData, DoorOpen) == 0x000010, "Member 'FDoorCurveData::DoorOpen' has a wrong offset!");
static_assert(offsetof(FDoorCurveData, DoorLocked) == 0x000020, "Member 'FDoorCurveData::DoorLocked' has a wrong offset!");
static_assert(offsetof(FDoorCurveData, DoorLockedCombat) == 0x000030, "Member 'FDoorCurveData::DoorLockedCombat' has a wrong offset!");
static_assert(offsetof(FDoorCurveData, HandleOpen) == 0x000040, "Member 'FDoorCurveData::HandleOpen' has a wrong offset!");
static_assert(offsetof(FDoorCurveData, HandleLocked) == 0x000050, "Member 'FDoorCurveData::HandleLocked' has a wrong offset!");
static_assert(offsetof(FDoorCurveData, HandleLockedCombat) == 0x000060, "Member 'FDoorCurveData::HandleLockedCombat' has a wrong offset!");

// ScriptStruct ObsidianFox.DoorCurveTagOverrideData
// 0x0050 (0x0050 - 0x0000)
struct FDoorCurveTagOverrideData final
{
public:
	TMap<struct FGameplayTag, struct FDoorCurveData> TagCurveDataMap;                                   // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDoorCurveTagOverrideData) == 0x000008, "Wrong alignment on FDoorCurveTagOverrideData");
static_assert(sizeof(FDoorCurveTagOverrideData) == 0x000050, "Wrong size on FDoorCurveTagOverrideData");
static_assert(offsetof(FDoorCurveTagOverrideData, TagCurveDataMap) == 0x000000, "Member 'FDoorCurveTagOverrideData::TagCurveDataMap' has a wrong offset!");

// ScriptStruct ObsidianFox.InteractionEvent
// 0x0060 (0x0060 - 0x0000)
struct FInteractionEvent final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousTickWorldLocation;                         // 0x000C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeProgression;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightAboveGround;                                 // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEnvironmentInteractionType                   InteractionType;                                   // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               EventMaterialBrush;                                // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Tag;                                               // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawPerPixel;                                     // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionEvent) == 0x000008, "Wrong alignment on FInteractionEvent");
static_assert(sizeof(FInteractionEvent) == 0x000060, "Wrong size on FInteractionEvent");
static_assert(offsetof(FInteractionEvent, WorldLocation) == 0x000000, "Member 'FInteractionEvent::WorldLocation' has a wrong offset!");
static_assert(offsetof(FInteractionEvent, PreviousTickWorldLocation) == 0x00000C, "Member 'FInteractionEvent::PreviousTickWorldLocation' has a wrong offset!");
static_assert(offsetof(FInteractionEvent, TimeProgression) == 0x000018, "Member 'FInteractionEvent::TimeProgression' has a wrong offset!");
static_assert(offsetof(FInteractionEvent, Duration) == 0x00001C, "Member 'FInteractionEvent::Duration' has a wrong offset!");
static_assert(offsetof(FInteractionEvent, Size) == 0x000020, "Member 'FInteractionEvent::Size' has a wrong offset!");
static_assert(offsetof(FInteractionEvent, Strength) == 0x000024, "Member 'FInteractionEvent::Strength' has a wrong offset!");
static_assert(offsetof(FInteractionEvent, Velocity) == 0x000028, "Member 'FInteractionEvent::Velocity' has a wrong offset!");
static_assert(offsetof(FInteractionEvent, HeightAboveGround) == 0x000034, "Member 'FInteractionEvent::HeightAboveGround' has a wrong offset!");
static_assert(offsetof(FInteractionEvent, InteractionType) == 0x000038, "Member 'FInteractionEvent::InteractionType' has a wrong offset!");
static_assert(offsetof(FInteractionEvent, EventMaterialBrush) == 0x000040, "Member 'FInteractionEvent::EventMaterialBrush' has a wrong offset!");
static_assert(offsetof(FInteractionEvent, Tag) == 0x000048, "Member 'FInteractionEvent::Tag' has a wrong offset!");
static_assert(offsetof(FInteractionEvent, bDrawPerPixel) == 0x000058, "Member 'FInteractionEvent::bDrawPerPixel' has a wrong offset!");

// ScriptStruct ObsidianFox.InteractionLayer
// 0x00E0 (0x00E0 - 0x0000)
struct FInteractionLayer final
{
public:
	bool                                          IsLayerActive;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LayerAlpha;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeSpeed;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActivationDuration;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTextureRenderTarget2D>  RenderTarget;                                      // 0x0020(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTextureRenderTarget2D>  RenderTargetCache;                                 // 0x0048(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInteractionEvent>              InteractionEvents;                                 // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	struct FLinearColor                           RenderTargetClearColor;                            // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RenderTargetCacheClearColor;                       // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     DefaultInteractionBrush;                           // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     RTTransferBrush;                                   // 0x00A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     CacheTransferBrush;                                // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               CacheCopyBrush;                                    // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               CacheMainBrush;                                    // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CurrentLocation;                                   // 0x00C8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousTickLocation;                              // 0x00D4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInteractionLayer) == 0x000008, "Wrong alignment on FInteractionLayer");
static_assert(sizeof(FInteractionLayer) == 0x0000E0, "Wrong size on FInteractionLayer");
static_assert(offsetof(FInteractionLayer, IsLayerActive) == 0x000000, "Member 'FInteractionLayer::IsLayerActive' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, LayerAlpha) == 0x000004, "Member 'FInteractionLayer::LayerAlpha' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, Name) == 0x000008, "Member 'FInteractionLayer::Name' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, Radius) == 0x000010, "Member 'FInteractionLayer::Radius' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, FadeSpeed) == 0x000014, "Member 'FInteractionLayer::FadeSpeed' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, ActivationDuration) == 0x000018, "Member 'FInteractionLayer::ActivationDuration' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, RenderTarget) == 0x000020, "Member 'FInteractionLayer::RenderTarget' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, RenderTargetCache) == 0x000048, "Member 'FInteractionLayer::RenderTargetCache' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, InteractionEvents) == 0x000070, "Member 'FInteractionLayer::InteractionEvents' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, RenderTargetClearColor) == 0x000080, "Member 'FInteractionLayer::RenderTargetClearColor' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, RenderTargetCacheClearColor) == 0x000090, "Member 'FInteractionLayer::RenderTargetCacheClearColor' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, DefaultInteractionBrush) == 0x0000A0, "Member 'FInteractionLayer::DefaultInteractionBrush' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, RTTransferBrush) == 0x0000A8, "Member 'FInteractionLayer::RTTransferBrush' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, CacheTransferBrush) == 0x0000B0, "Member 'FInteractionLayer::CacheTransferBrush' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, CacheCopyBrush) == 0x0000B8, "Member 'FInteractionLayer::CacheCopyBrush' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, CacheMainBrush) == 0x0000C0, "Member 'FInteractionLayer::CacheMainBrush' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, CurrentLocation) == 0x0000C8, "Member 'FInteractionLayer::CurrentLocation' has a wrong offset!");
static_assert(offsetof(FInteractionLayer, PreviousTickLocation) == 0x0000D4, "Member 'FInteractionLayer::PreviousTickLocation' has a wrong offset!");

// ScriptStruct ObsidianFox.MaterialScalarInterpData
// 0x0020 (0x0020 - 0x0000)
struct FMaterialScalarInterpData final
{
public:
	struct FMaterialParameterInfo                 ParamInfo;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetValue;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpDuration;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentInterpDuration;                             // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMaterialScalarInterpData) == 0x000004, "Wrong alignment on FMaterialScalarInterpData");
static_assert(sizeof(FMaterialScalarInterpData) == 0x000020, "Wrong size on FMaterialScalarInterpData");
static_assert(offsetof(FMaterialScalarInterpData, ParamInfo) == 0x000000, "Member 'FMaterialScalarInterpData::ParamInfo' has a wrong offset!");
static_assert(offsetof(FMaterialScalarInterpData, TargetValue) == 0x000010, "Member 'FMaterialScalarInterpData::TargetValue' has a wrong offset!");
static_assert(offsetof(FMaterialScalarInterpData, InterpDuration) == 0x000014, "Member 'FMaterialScalarInterpData::InterpDuration' has a wrong offset!");
static_assert(offsetof(FMaterialScalarInterpData, CurrentInterpDuration) == 0x000018, "Member 'FMaterialScalarInterpData::CurrentInterpDuration' has a wrong offset!");
static_assert(offsetof(FMaterialScalarInterpData, InterpSpeed) == 0x00001C, "Member 'FMaterialScalarInterpData::InterpSpeed' has a wrong offset!");

// ScriptStruct ObsidianFox.VectorFieldInteraction
// 0x0014 (0x0014 - 0x0000)
struct FVectorFieldInteraction final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVectorFieldInteraction) == 0x000004, "Wrong alignment on FVectorFieldInteraction");
static_assert(sizeof(FVectorFieldInteraction) == 0x000014, "Wrong size on FVectorFieldInteraction");
static_assert(offsetof(FVectorFieldInteraction, WorldLocation) == 0x000000, "Member 'FVectorFieldInteraction::WorldLocation' has a wrong offset!");
static_assert(offsetof(FVectorFieldInteraction, Strength) == 0x00000C, "Member 'FVectorFieldInteraction::Strength' has a wrong offset!");
static_assert(offsetof(FVectorFieldInteraction, Radius) == 0x000010, "Member 'FVectorFieldInteraction::Radius' has a wrong offset!");

// ScriptStruct ObsidianFox.WaterTracePoint
// 0x0030 (0x0030 - 0x0000)
struct FWaterTracePoint final
{
public:
	class UNiagaraComponent*                      NiagaraComp;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceLocation;                                     // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x0020(0x000C)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHittingSurface;                                 // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWaterTracePoint) == 0x000008, "Wrong alignment on FWaterTracePoint");
static_assert(sizeof(FWaterTracePoint) == 0x000030, "Wrong size on FWaterTracePoint");
static_assert(offsetof(FWaterTracePoint, NiagaraComp) == 0x000000, "Member 'FWaterTracePoint::NiagaraComp' has a wrong offset!");
static_assert(offsetof(FWaterTracePoint, TraceLocation) == 0x000008, "Member 'FWaterTracePoint::TraceLocation' has a wrong offset!");
static_assert(offsetof(FWaterTracePoint, HitLocation) == 0x000014, "Member 'FWaterTracePoint::HitLocation' has a wrong offset!");
static_assert(offsetof(FWaterTracePoint, HitNormal) == 0x000020, "Member 'FWaterTracePoint::HitNormal' has a wrong offset!");
static_assert(offsetof(FWaterTracePoint, bIsHittingSurface) == 0x00002C, "Member 'FWaterTracePoint::bIsHittingSurface' has a wrong offset!");

// ScriptStruct ObsidianFox.EmoteMontageDataParameter
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FEmoteMontageDataParameter final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmoteMontageDataParameter) == 0x000008, "Wrong alignment on FEmoteMontageDataParameter");
static_assert(sizeof(FEmoteMontageDataParameter) == 0x000010, "Wrong size on FEmoteMontageDataParameter");

// ScriptStruct ObsidianFox.EmotePlayData
// 0x0018 (0x0018 - 0x0000)
struct FEmotePlayData final
{
public:
	struct FEmoteMontageDataParameter             MontageData;                                       // 0x0000(0x0010)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bInterruptIfNotIdleState;                          // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmotePlayData) == 0x000008, "Wrong alignment on FEmotePlayData");
static_assert(sizeof(FEmotePlayData) == 0x000018, "Wrong size on FEmotePlayData");
static_assert(offsetof(FEmotePlayData, MontageData) == 0x000000, "Member 'FEmotePlayData::MontageData' has a wrong offset!");
static_assert(offsetof(FEmotePlayData, bInterruptIfNotIdleState) == 0x000010, "Member 'FEmotePlayData::bInterruptIfNotIdleState' has a wrong offset!");

// ScriptStruct ObsidianFox.EnviromentVolumeProperties
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FEnviromentVolumeProperties final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnviromentVolumeProperties) == 0x000008, "Wrong alignment on FEnviromentVolumeProperties");
static_assert(sizeof(FEnviromentVolumeProperties) == 0x000010, "Wrong size on FEnviromentVolumeProperties");

// ScriptStruct ObsidianFox.FireSpreadSection
// 0x0040 (0x0040 - 0x0000)
struct FFireSpreadSection final
{
public:
	bool                                          bIsOnFire;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SectionTransform;                                  // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFireSpreadSection) == 0x000010, "Wrong alignment on FFireSpreadSection");
static_assert(sizeof(FFireSpreadSection) == 0x000040, "Wrong size on FFireSpreadSection");
static_assert(offsetof(FFireSpreadSection, bIsOnFire) == 0x000000, "Member 'FFireSpreadSection::bIsOnFire' has a wrong offset!");
static_assert(offsetof(FFireSpreadSection, SectionTransform) == 0x000010, "Member 'FFireSpreadSection::SectionTransform' has a wrong offset!");

// ScriptStruct ObsidianFox.Fluid
// 0x000C (0x000C - 0x0000)
struct FFluid final
{
public:
	class FName                                   FluidTag;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WetnessPercent;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFluid) == 0x000004, "Wrong alignment on FFluid");
static_assert(sizeof(FFluid) == 0x00000C, "Wrong size on FFluid");
static_assert(offsetof(FFluid, FluidTag) == 0x000000, "Member 'FFluid::FluidTag' has a wrong offset!");
static_assert(offsetof(FFluid, WetnessPercent) == 0x000008, "Member 'FFluid::WetnessPercent' has a wrong offset!");

// ScriptStruct ObsidianFox.FoliageInteractionParamNames
// 0x0020 (0x0020 - 0x0000)
struct FFoliageInteractionParamNames final
{
public:
	class FName                                   LocationParamName;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RadiusParamName;                                   // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CapsuleHalfHeightParamName;                        // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StrengthParamName;                                 // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFoliageInteractionParamNames) == 0x000004, "Wrong alignment on FFoliageInteractionParamNames");
static_assert(sizeof(FFoliageInteractionParamNames) == 0x000020, "Wrong size on FFoliageInteractionParamNames");
static_assert(offsetof(FFoliageInteractionParamNames, LocationParamName) == 0x000000, "Member 'FFoliageInteractionParamNames::LocationParamName' has a wrong offset!");
static_assert(offsetof(FFoliageInteractionParamNames, RadiusParamName) == 0x000008, "Member 'FFoliageInteractionParamNames::RadiusParamName' has a wrong offset!");
static_assert(offsetof(FFoliageInteractionParamNames, CapsuleHalfHeightParamName) == 0x000010, "Member 'FFoliageInteractionParamNames::CapsuleHalfHeightParamName' has a wrong offset!");
static_assert(offsetof(FFoliageInteractionParamNames, StrengthParamName) == 0x000018, "Member 'FFoliageInteractionParamNames::StrengthParamName' has a wrong offset!");

// ScriptStruct ObsidianFox.FoliageInteraction
// 0x0018 (0x0018 - 0x0000)
struct FFoliageInteraction final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CapsuleHalfHeight;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFoliageInteraction) == 0x000004, "Wrong alignment on FFoliageInteraction");
static_assert(sizeof(FFoliageInteraction) == 0x000018, "Wrong size on FFoliageInteraction");
static_assert(offsetof(FFoliageInteraction, Location) == 0x000000, "Member 'FFoliageInteraction::Location' has a wrong offset!");
static_assert(offsetof(FFoliageInteraction, Radius) == 0x00000C, "Member 'FFoliageInteraction::Radius' has a wrong offset!");
static_assert(offsetof(FFoliageInteraction, CapsuleHalfHeight) == 0x000010, "Member 'FFoliageInteraction::CapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(FFoliageInteraction, Strength) == 0x000014, "Member 'FFoliageInteraction::Strength' has a wrong offset!");

// ScriptStruct ObsidianFox.FootStepVFX
// 0x0010 (0x0010 - 0x0000)
struct FFootStepVFX final
{
public:
	EPhysicalSurface                              SurfaceType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraSystem*                         FootStepEffect;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFootStepVFX) == 0x000008, "Wrong alignment on FFootStepVFX");
static_assert(sizeof(FFootStepVFX) == 0x000010, "Wrong size on FFootStepVFX");
static_assert(offsetof(FFootStepVFX, SurfaceType) == 0x000000, "Member 'FFootStepVFX::SurfaceType' has a wrong offset!");
static_assert(offsetof(FFootStepVFX, FootStepEffect) == 0x000008, "Member 'FFootStepVFX::FootStepEffect' has a wrong offset!");

// ScriptStruct ObsidianFox.Foot
// 0x0060 (0x0060 - 0x0000)
struct FFoot final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bShouldInvertTraceDirection;                       // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WetnessPercent;                                    // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FluidTag;                                          // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysicalSurface                              CurrentSurfaceType;                                // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0xF];                                       // 0x0051(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFoot) == 0x000010, "Wrong alignment on FFoot");
static_assert(sizeof(FFoot) == 0x000060, "Wrong size on FFoot");
static_assert(offsetof(FFoot, BoneName) == 0x000000, "Member 'FFoot::BoneName' has a wrong offset!");
static_assert(offsetof(FFoot, SpawnTransform) == 0x000010, "Member 'FFoot::SpawnTransform' has a wrong offset!");
static_assert(offsetof(FFoot, bShouldInvertTraceDirection) == 0x000040, "Member 'FFoot::bShouldInvertTraceDirection' has a wrong offset!");
static_assert(offsetof(FFoot, WetnessPercent) == 0x000044, "Member 'FFoot::WetnessPercent' has a wrong offset!");
static_assert(offsetof(FFoot, FluidTag) == 0x000048, "Member 'FFoot::FluidTag' has a wrong offset!");
static_assert(offsetof(FFoot, CurrentSurfaceType) == 0x000050, "Member 'FFoot::CurrentSurfaceType' has a wrong offset!");

// ScriptStruct ObsidianFox.SurfaceFootPrint
// 0x0010 (0x0010 - 0x0000)
struct FSurfaceFootPrint final
{
public:
	EPhysicalSurface                              SurfaceType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     FootPrintDecal;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSurfaceFootPrint) == 0x000008, "Wrong alignment on FSurfaceFootPrint");
static_assert(sizeof(FSurfaceFootPrint) == 0x000010, "Wrong size on FSurfaceFootPrint");
static_assert(offsetof(FSurfaceFootPrint, SurfaceType) == 0x000000, "Member 'FSurfaceFootPrint::SurfaceType' has a wrong offset!");
static_assert(offsetof(FSurfaceFootPrint, FootPrintDecal) == 0x000008, "Member 'FSurfaceFootPrint::FootPrintDecal' has a wrong offset!");

// ScriptStruct ObsidianFox.RoomVolumeCollection
// 0x0018 (0x0018 - 0x0000)
struct FRoomVolumeCollection final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AMapTrackerVolume*>              Volumes;                                           // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomVolumeCollection) == 0x000008, "Wrong alignment on FRoomVolumeCollection");
static_assert(sizeof(FRoomVolumeCollection) == 0x000018, "Wrong size on FRoomVolumeCollection");
static_assert(offsetof(FRoomVolumeCollection, Volumes) == 0x000008, "Member 'FRoomVolumeCollection::Volumes' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_ApplyFootLocking
// 0x0048 (0x00B0 - 0x0068)
struct FRigUnit_ApplyFootLocking final : public FRigUnit_FootIKBaseMutable
{
public:
	struct FRigunitFootLockingOutput              Input;                                             // 0x0068(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         LocationAlpha;                                     // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationAlpha;                                     // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastLocationAlpha;                                 // 0x0088(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastRotationAlpha;                                 // 0x008C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LockedLocation;                                    // 0x0090(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  LockedRotation;                                    // 0x00A0(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_ApplyFootLocking) == 0x000010, "Wrong alignment on FRigUnit_ApplyFootLocking");
static_assert(sizeof(FRigUnit_ApplyFootLocking) == 0x0000B0, "Wrong size on FRigUnit_ApplyFootLocking");
static_assert(offsetof(FRigUnit_ApplyFootLocking, Input) == 0x000068, "Member 'FRigUnit_ApplyFootLocking::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFootLocking, LocationAlpha) == 0x000080, "Member 'FRigUnit_ApplyFootLocking::LocationAlpha' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFootLocking, RotationAlpha) == 0x000084, "Member 'FRigUnit_ApplyFootLocking::RotationAlpha' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFootLocking, LastLocationAlpha) == 0x000088, "Member 'FRigUnit_ApplyFootLocking::LastLocationAlpha' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFootLocking, LastRotationAlpha) == 0x00008C, "Member 'FRigUnit_ApplyFootLocking::LastRotationAlpha' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFootLocking, LockedLocation) == 0x000090, "Member 'FRigUnit_ApplyFootLocking::LockedLocation' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyFootLocking, LockedRotation) == 0x0000A0, "Member 'FRigUnit_ApplyFootLocking::LockedRotation' has a wrong offset!");

// ScriptStruct ObsidianFox.HitReactionAccumulatedDamageData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FHitReactionAccumulatedDamageData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitReactionAccumulatedDamageData) == 0x000008, "Wrong alignment on FHitReactionAccumulatedDamageData");
static_assert(sizeof(FHitReactionAccumulatedDamageData) == 0x000010, "Wrong size on FHitReactionAccumulatedDamageData");

// ScriptStruct ObsidianFox.ButtonDataStruct
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FButtonDataStruct final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FButtonDataStruct) == 0x000008, "Wrong alignment on FButtonDataStruct");
static_assert(sizeof(FButtonDataStruct) == 0x000048, "Wrong size on FButtonDataStruct");

// ScriptStruct ObsidianFox.HelpButtonStruct
// 0x0010 (0x0010 - 0x0000)
struct FHelpButtonStruct final
{
public:
	class UImage*                                 ButtonImage;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHelpButtonStruct) == 0x000008, "Wrong alignment on FHelpButtonStruct");
static_assert(sizeof(FHelpButtonStruct) == 0x000010, "Wrong size on FHelpButtonStruct");
static_assert(offsetof(FHelpButtonStruct, ButtonImage) == 0x000000, "Member 'FHelpButtonStruct::ButtonImage' has a wrong offset!");

// ScriptStruct ObsidianFox.PickupAnimationData
// 0x0018 (0x0018 - 0x0000)
struct FPickupAnimationData final
{
public:
	class UAnimSequenceBase*                      PickupAnimation;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PickupOffset;                                      // 0x0008(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUsingRightHand;                                  // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPickupAnimationData) == 0x000008, "Wrong alignment on FPickupAnimationData");
static_assert(sizeof(FPickupAnimationData) == 0x000018, "Wrong size on FPickupAnimationData");
static_assert(offsetof(FPickupAnimationData, PickupAnimation) == 0x000000, "Member 'FPickupAnimationData::PickupAnimation' has a wrong offset!");
static_assert(offsetof(FPickupAnimationData, PickupOffset) == 0x000008, "Member 'FPickupAnimationData::PickupOffset' has a wrong offset!");
static_assert(offsetof(FPickupAnimationData, IsUsingRightHand) == 0x000014, "Member 'FPickupAnimationData::IsUsingRightHand' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnitHipsOffsetInput
// 0x0018 (0x0018 - 0x0000)
struct FRigUnitHipsOffsetInput final
{
public:
	struct FRigElementKey                         EffectorControl;                                   // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         BoneReference;                                     // 0x000C(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnitHipsOffsetInput) == 0x000004, "Wrong alignment on FRigUnitHipsOffsetInput");
static_assert(sizeof(FRigUnitHipsOffsetInput) == 0x000018, "Wrong size on FRigUnitHipsOffsetInput");
static_assert(offsetof(FRigUnitHipsOffsetInput, EffectorControl) == 0x000000, "Member 'FRigUnitHipsOffsetInput::EffectorControl' has a wrong offset!");
static_assert(offsetof(FRigUnitHipsOffsetInput, BoneReference) == 0x00000C, "Member 'FRigUnitHipsOffsetInput::BoneReference' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_HipOffset
// 0x0018 (0x0080 - 0x0068)
struct FRigUnit_HipOffset final : public FRigUnit_FootIKBaseMutable
{
public:
	TArray<struct FRigUnitHipsOffsetInput>        Effectors;                                         // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         HipOffset;                                         // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_HipOffset) == 0x000008, "Wrong alignment on FRigUnit_HipOffset");
static_assert(sizeof(FRigUnit_HipOffset) == 0x000080, "Wrong size on FRigUnit_HipOffset");
static_assert(offsetof(FRigUnit_HipOffset, Effectors) == 0x000068, "Member 'FRigUnit_HipOffset::Effectors' has a wrong offset!");
static_assert(offsetof(FRigUnit_HipOffset, HipOffset) == 0x000078, "Member 'FRigUnit_HipOffset::HipOffset' has a wrong offset!");

// ScriptStruct ObsidianFox.IKModifierUpdateReturnValue
// 0x0040 (0x0040 - 0x0000)
struct alignas(0x10) FIKModifierUpdateReturnValue final
{
public:
	uint8                                         Pad_0[0x40];                                       // 0x0000(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIKModifierUpdateReturnValue) == 0x000010, "Wrong alignment on FIKModifierUpdateReturnValue");
static_assert(sizeof(FIKModifierUpdateReturnValue) == 0x000040, "Wrong size on FIKModifierUpdateReturnValue");

// ScriptStruct ObsidianFox.PhysicsAnimationSettings
// 0x0018 (0x0018 - 0x0000)
struct FPhysicsAnimationSettings final
{
public:
	uint8                                         bEnablePhysicsAnimation : 1;                       // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialBlendWeight;                                // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InitialForceBoneName;                              // 0x000C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Force;                                             // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhysicsAnimationSettings) == 0x000004, "Wrong alignment on FPhysicsAnimationSettings");
static_assert(sizeof(FPhysicsAnimationSettings) == 0x000018, "Wrong size on FPhysicsAnimationSettings");
static_assert(offsetof(FPhysicsAnimationSettings, InitialBlendWeight) == 0x000004, "Member 'FPhysicsAnimationSettings::InitialBlendWeight' has a wrong offset!");
static_assert(offsetof(FPhysicsAnimationSettings, Duration) == 0x000008, "Member 'FPhysicsAnimationSettings::Duration' has a wrong offset!");
static_assert(offsetof(FPhysicsAnimationSettings, InitialForceBoneName) == 0x00000C, "Member 'FPhysicsAnimationSettings::InitialForceBoneName' has a wrong offset!");
static_assert(offsetof(FPhysicsAnimationSettings, Force) == 0x000014, "Member 'FPhysicsAnimationSettings::Force' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_HyperExtensionFixerInput
// 0x0034 (0x0034 - 0x0000)
struct FRigUnit_HyperExtensionFixerInput final
{
public:
	struct FRigElementKey                         BaseItem;                                          // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         FKTip;                                             // 0x000C(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         IKEffector;                                        // 0x0018(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         IKClampedEffector;                                 // 0x0024(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LengthModifier;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_HyperExtensionFixerInput) == 0x000004, "Wrong alignment on FRigUnit_HyperExtensionFixerInput");
static_assert(sizeof(FRigUnit_HyperExtensionFixerInput) == 0x000034, "Wrong size on FRigUnit_HyperExtensionFixerInput");
static_assert(offsetof(FRigUnit_HyperExtensionFixerInput, BaseItem) == 0x000000, "Member 'FRigUnit_HyperExtensionFixerInput::BaseItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_HyperExtensionFixerInput, FKTip) == 0x00000C, "Member 'FRigUnit_HyperExtensionFixerInput::FKTip' has a wrong offset!");
static_assert(offsetof(FRigUnit_HyperExtensionFixerInput, IKEffector) == 0x000018, "Member 'FRigUnit_HyperExtensionFixerInput::IKEffector' has a wrong offset!");
static_assert(offsetof(FRigUnit_HyperExtensionFixerInput, IKClampedEffector) == 0x000024, "Member 'FRigUnit_HyperExtensionFixerInput::IKClampedEffector' has a wrong offset!");
static_assert(offsetof(FRigUnit_HyperExtensionFixerInput, LengthModifier) == 0x000030, "Member 'FRigUnit_HyperExtensionFixerInput::LengthModifier' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_HyperExtensionFixer
// 0x0010 (0x0078 - 0x0068)
struct FRigUnit_HyperExtensionFixer final : public FRigUnit_FootIKBaseMutable
{
public:
	TArray<struct FRigUnit_HyperExtensionFixerInput> Items;                                             // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_HyperExtensionFixer) == 0x000008, "Wrong alignment on FRigUnit_HyperExtensionFixer");
static_assert(sizeof(FRigUnit_HyperExtensionFixer) == 0x000078, "Wrong size on FRigUnit_HyperExtensionFixer");
static_assert(offsetof(FRigUnit_HyperExtensionFixer, Items) == 0x000068, "Member 'FRigUnit_HyperExtensionFixer::Items' has a wrong offset!");

// ScriptStruct ObsidianFox.WallHitSettings
// 0x003C (0x003C - 0x0000)
struct FWallHitSettings final
{
public:
	struct FGameplayTag                           WallHitMontage;                                    // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WallHitMontageWalk;                                // 0x0008(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           WallHitAnticipationMontage;                        // 0x0010(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RightHandBoneName;                                 // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LeftHandBoneName;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalOffset;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceRadius;                                       // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceLength;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BraceTraceLength;                                  // 0x0034(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseRightHand : 1;                                 // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseLeftHand : 1;                                  // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWallHitSettings) == 0x000004, "Wrong alignment on FWallHitSettings");
static_assert(sizeof(FWallHitSettings) == 0x00003C, "Wrong size on FWallHitSettings");
static_assert(offsetof(FWallHitSettings, WallHitMontage) == 0x000000, "Member 'FWallHitSettings::WallHitMontage' has a wrong offset!");
static_assert(offsetof(FWallHitSettings, WallHitMontageWalk) == 0x000008, "Member 'FWallHitSettings::WallHitMontageWalk' has a wrong offset!");
static_assert(offsetof(FWallHitSettings, WallHitAnticipationMontage) == 0x000010, "Member 'FWallHitSettings::WallHitAnticipationMontage' has a wrong offset!");
static_assert(offsetof(FWallHitSettings, RightHandBoneName) == 0x000018, "Member 'FWallHitSettings::RightHandBoneName' has a wrong offset!");
static_assert(offsetof(FWallHitSettings, LeftHandBoneName) == 0x000020, "Member 'FWallHitSettings::LeftHandBoneName' has a wrong offset!");
static_assert(offsetof(FWallHitSettings, NormalOffset) == 0x000028, "Member 'FWallHitSettings::NormalOffset' has a wrong offset!");
static_assert(offsetof(FWallHitSettings, TraceRadius) == 0x00002C, "Member 'FWallHitSettings::TraceRadius' has a wrong offset!");
static_assert(offsetof(FWallHitSettings, TraceLength) == 0x000030, "Member 'FWallHitSettings::TraceLength' has a wrong offset!");
static_assert(offsetof(FWallHitSettings, BraceTraceLength) == 0x000034, "Member 'FWallHitSettings::BraceTraceLength' has a wrong offset!");

// ScriptStruct ObsidianFox.PickupIncrementInfo
// 0x00F0 (0x00F0 - 0x0000)
struct FPickupIncrementInfo final
{
public:
	class UOFPickupIncrementWidget*               Widget;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemData*                              ItemData;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemDisplayInfo                       DisplayInfo;                                       // 0x0018(0x00D0)(NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x00E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPickupIncrementInfo) == 0x000008, "Wrong alignment on FPickupIncrementInfo");
static_assert(sizeof(FPickupIncrementInfo) == 0x0000F0, "Wrong size on FPickupIncrementInfo");
static_assert(offsetof(FPickupIncrementInfo, Widget) == 0x000000, "Member 'FPickupIncrementInfo::Widget' has a wrong offset!");
static_assert(offsetof(FPickupIncrementInfo, ItemData) == 0x000010, "Member 'FPickupIncrementInfo::ItemData' has a wrong offset!");
static_assert(offsetof(FPickupIncrementInfo, DisplayInfo) == 0x000018, "Member 'FPickupIncrementInfo::DisplayInfo' has a wrong offset!");
static_assert(offsetof(FPickupIncrementInfo, Amount) == 0x0000E8, "Member 'FPickupIncrementInfo::Amount' has a wrong offset!");

// ScriptStruct ObsidianFox.ItemInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FItemInfo
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bItemLookedAt;                                     // 0x0004(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ItemCategory;                                      // 0x0008(0x0008)(SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemInfo) == 0x000008, "Wrong alignment on FItemInfo");
static_assert(sizeof(FItemInfo) == 0x000020, "Wrong size on FItemInfo");
static_assert(offsetof(FItemInfo, Amount) == 0x000000, "Member 'FItemInfo::Amount' has a wrong offset!");
static_assert(offsetof(FItemInfo, bItemLookedAt) == 0x000004, "Member 'FItemInfo::bItemLookedAt' has a wrong offset!");
static_assert(offsetof(FItemInfo, ItemCategory) == 0x000008, "Member 'FItemInfo::ItemCategory' has a wrong offset!");

// ScriptStruct ObsidianFox.ArchivedItemInfo
// 0x0008 (0x0028 - 0x0020)
struct FArchivedItemInfo final : public FItemInfo
{
public:
	struct FGameplayTag                           ProgressionState;                                  // 0x0020(0x0008)(SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArchivedItemInfo) == 0x000008, "Wrong alignment on FArchivedItemInfo");
static_assert(sizeof(FArchivedItemInfo) == 0x000028, "Wrong size on FArchivedItemInfo");
static_assert(offsetof(FArchivedItemInfo, ProgressionState) == 0x000020, "Member 'FArchivedItemInfo::ProgressionState' has a wrong offset!");

// ScriptStruct ObsidianFox.InvestigationFolderData
// 0x0080 (0x0080 - 0x0000)
struct FInvestigationFolderData final
{
public:
	class FText                                   FolderLabel;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	class FText                                   FolderDescription;                                 // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              FolderImage;                                       // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              FolderImageHighlight;                              // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInvestigationFolderData) == 0x000008, "Wrong alignment on FInvestigationFolderData");
static_assert(sizeof(FInvestigationFolderData) == 0x000080, "Wrong size on FInvestigationFolderData");
static_assert(offsetof(FInvestigationFolderData, FolderLabel) == 0x000000, "Member 'FInvestigationFolderData::FolderLabel' has a wrong offset!");
static_assert(offsetof(FInvestigationFolderData, FolderDescription) == 0x000018, "Member 'FInvestigationFolderData::FolderDescription' has a wrong offset!");
static_assert(offsetof(FInvestigationFolderData, FolderImage) == 0x000030, "Member 'FInvestigationFolderData::FolderImage' has a wrong offset!");
static_assert(offsetof(FInvestigationFolderData, FolderImageHighlight) == 0x000058, "Member 'FInvestigationFolderData::FolderImageHighlight' has a wrong offset!");

// ScriptStruct ObsidianFox.EmotionData
// 0x0024 (0x0024 - 0x0000)
struct FEmotionData final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x8];                                        // 0x0004(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ValueInterpolationSpeed;                           // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecrementTime;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimeBeforeDecrement;                               // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          Locked;                                            // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEmotionData) == 0x000004, "Wrong alignment on FEmotionData");
static_assert(sizeof(FEmotionData) == 0x000024, "Wrong size on FEmotionData");
static_assert(offsetof(FEmotionData, Value) == 0x000000, "Member 'FEmotionData::Value' has a wrong offset!");
static_assert(offsetof(FEmotionData, ValueInterpolationSpeed) == 0x00000C, "Member 'FEmotionData::ValueInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(FEmotionData, DecrementTime) == 0x000010, "Member 'FEmotionData::DecrementTime' has a wrong offset!");
static_assert(offsetof(FEmotionData, TimeBeforeDecrement) == 0x000018, "Member 'FEmotionData::TimeBeforeDecrement' has a wrong offset!");
static_assert(offsetof(FEmotionData, Locked) == 0x000020, "Member 'FEmotionData::Locked' has a wrong offset!");

// ScriptStruct ObsidianFox.Emotions
// 0x0048 (0x0048 - 0x0000)
struct FEmotions final
{
public:
	struct FEmotionData                           Fear;                                              // 0x0000(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FEmotionData                           Carefulness;                                       // 0x0024(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmotions) == 0x000004, "Wrong alignment on FEmotions");
static_assert(sizeof(FEmotions) == 0x000048, "Wrong size on FEmotions");
static_assert(offsetof(FEmotions, Fear) == 0x000000, "Member 'FEmotions::Fear' has a wrong offset!");
static_assert(offsetof(FEmotions, Carefulness) == 0x000024, "Member 'FEmotions::Carefulness' has a wrong offset!");

// ScriptStruct ObsidianFox.ObjectiveChapter
// 0x0050 (0x0050 - 0x0000)
struct FObjectiveChapter final
{
public:
	TMap<TSoftObjectPtr<class UObjectivesData>, struct FObjectiveInfo> Objectives;                                        // 0x0000(0x0050)(SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveChapter) == 0x000008, "Wrong alignment on FObjectiveChapter");
static_assert(sizeof(FObjectiveChapter) == 0x000050, "Wrong size on FObjectiveChapter");
static_assert(offsetof(FObjectiveChapter, Objectives) == 0x000000, "Member 'FObjectiveChapter::Objectives' has a wrong offset!");

// ScriptStruct ObsidianFox.ObjectiveStruct
// 0x0028 (0x0028 - 0x0000)
struct FObjectiveStruct final
{
public:
	class FText                                   ObjectiveText;                                     // 0x0000(0x0018)(Edit, BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
	bool                                          bIsModernObjective;                                // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ObjectiveTag;                                      // 0x001C(0x0008)(Edit, BlueprintVisible, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObjectiveStruct) == 0x000008, "Wrong alignment on FObjectiveStruct");
static_assert(sizeof(FObjectiveStruct) == 0x000028, "Wrong size on FObjectiveStruct");
static_assert(offsetof(FObjectiveStruct, ObjectiveText) == 0x000000, "Member 'FObjectiveStruct::ObjectiveText' has a wrong offset!");
static_assert(offsetof(FObjectiveStruct, bIsModernObjective) == 0x000018, "Member 'FObjectiveStruct::bIsModernObjective' has a wrong offset!");
static_assert(offsetof(FObjectiveStruct, ObjectiveTag) == 0x00001C, "Member 'FObjectiveStruct::ObjectiveTag' has a wrong offset!");

// ScriptStruct ObsidianFox.FocusPointTimer
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FFocusPointTimer final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFocusPointTimer) == 0x000004, "Wrong alignment on FFocusPointTimer");
static_assert(sizeof(FFocusPointTimer) == 0x000008, "Wrong size on FFocusPointTimer");

// ScriptStruct ObsidianFox.SaveablePoseSnapshot
// 0x0060 (0x0060 - 0x0000)
struct FSaveablePoseSnapshot final
{
public:
	TArray<struct FTransform>                     LocalTransforms;                                   // 0x0000(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	TArray<class FName>                           BoneNames;                                         // 0x0010(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	class FName                                   SkeletalMeshName;                                  // 0x0020(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SnapshotName;                                      // 0x0028(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             RootTransform;                                     // 0x0030(0x0030)(SaveGame, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSaveablePoseSnapshot) == 0x000010, "Wrong alignment on FSaveablePoseSnapshot");
static_assert(sizeof(FSaveablePoseSnapshot) == 0x000060, "Wrong size on FSaveablePoseSnapshot");
static_assert(offsetof(FSaveablePoseSnapshot, LocalTransforms) == 0x000000, "Member 'FSaveablePoseSnapshot::LocalTransforms' has a wrong offset!");
static_assert(offsetof(FSaveablePoseSnapshot, BoneNames) == 0x000010, "Member 'FSaveablePoseSnapshot::BoneNames' has a wrong offset!");
static_assert(offsetof(FSaveablePoseSnapshot, SkeletalMeshName) == 0x000020, "Member 'FSaveablePoseSnapshot::SkeletalMeshName' has a wrong offset!");
static_assert(offsetof(FSaveablePoseSnapshot, SnapshotName) == 0x000028, "Member 'FSaveablePoseSnapshot::SnapshotName' has a wrong offset!");
static_assert(offsetof(FSaveablePoseSnapshot, RootTransform) == 0x000030, "Member 'FSaveablePoseSnapshot::RootTransform' has a wrong offset!");

// ScriptStruct ObsidianFox.OFGameplayAttributeData
// 0x0000 (0x0010 - 0x0010)
struct FOFGameplayAttributeData final : public FGameplayAttributeData
{
};
static_assert(alignof(FOFGameplayAttributeData) == 0x000008, "Wrong alignment on FOFGameplayAttributeData");
static_assert(sizeof(FOFGameplayAttributeData) == 0x000010, "Wrong size on FOFGameplayAttributeData");

// ScriptStruct ObsidianFox.ConsumableItemReference
// 0x0038 (0x0038 - 0x0000)
struct FConsumableItemReference final
{
public:
	EConsumableType                               Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemData*                              ItemToCheck;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UItemData>               ItemToSpawn;                                       // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConsumableItemReference) == 0x000008, "Wrong alignment on FConsumableItemReference");
static_assert(sizeof(FConsumableItemReference) == 0x000038, "Wrong size on FConsumableItemReference");
static_assert(offsetof(FConsumableItemReference, Type) == 0x000000, "Member 'FConsumableItemReference::Type' has a wrong offset!");
static_assert(offsetof(FConsumableItemReference, ItemToCheck) == 0x000008, "Member 'FConsumableItemReference::ItemToCheck' has a wrong offset!");
static_assert(offsetof(FConsumableItemReference, ItemToSpawn) == 0x000010, "Member 'FConsumableItemReference::ItemToSpawn' has a wrong offset!");

// ScriptStruct ObsidianFox.FrustumData
// 0x0180 (0x0180 - 0x0000)
struct alignas(0x10) FFrustumData final
{
public:
	float                                         FOV;                                               // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AspectRatio;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearPlane;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarPlane;                                          // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FrustumLocation;                                   // 0x0010(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x164];                                     // 0x001C(0x0164)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFrustumData) == 0x000010, "Wrong alignment on FFrustumData");
static_assert(sizeof(FFrustumData) == 0x000180, "Wrong size on FFrustumData");
static_assert(offsetof(FFrustumData, FOV) == 0x000000, "Member 'FFrustumData::FOV' has a wrong offset!");
static_assert(offsetof(FFrustumData, AspectRatio) == 0x000004, "Member 'FFrustumData::AspectRatio' has a wrong offset!");
static_assert(offsetof(FFrustumData, NearPlane) == 0x000008, "Member 'FFrustumData::NearPlane' has a wrong offset!");
static_assert(offsetof(FFrustumData, FarPlane) == 0x00000C, "Member 'FFrustumData::FarPlane' has a wrong offset!");
static_assert(offsetof(FFrustumData, FrustumLocation) == 0x000010, "Member 'FFrustumData::FrustumLocation' has a wrong offset!");

// ScriptStruct ObsidianFox.FrustumSettings
// 0x0010 (0x0010 - 0x0000)
struct FFrustumSettings final
{
public:
	float                                         VerticalFOV;                                       // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AspectRatio;                                       // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearPlane;                                         // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarPlane;                                          // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFrustumSettings) == 0x000004, "Wrong alignment on FFrustumSettings");
static_assert(sizeof(FFrustumSettings) == 0x000010, "Wrong size on FFrustumSettings");
static_assert(offsetof(FFrustumSettings, VerticalFOV) == 0x000000, "Member 'FFrustumSettings::VerticalFOV' has a wrong offset!");
static_assert(offsetof(FFrustumSettings, AspectRatio) == 0x000004, "Member 'FFrustumSettings::AspectRatio' has a wrong offset!");
static_assert(offsetof(FFrustumSettings, NearPlane) == 0x000008, "Member 'FFrustumSettings::NearPlane' has a wrong offset!");
static_assert(offsetof(FFrustumSettings, FarPlane) == 0x00000C, "Member 'FFrustumSettings::FarPlane' has a wrong offset!");

// ScriptStruct ObsidianFox.CameraBlendSettingsInput
// 0x0078 (0x0078 - 0x0000)
struct FCameraBlendSettingsInput final
{
public:
	struct FCameraFocusSettings                   FocusSettings;                                     // 0x0000(0x0058)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCameraLensSettings                    LensSettings;                                      // 0x0058(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FocalLength;                                       // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Aperture;                                          // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraBlendSettingsInput) == 0x000008, "Wrong alignment on FCameraBlendSettingsInput");
static_assert(sizeof(FCameraBlendSettingsInput) == 0x000078, "Wrong size on FCameraBlendSettingsInput");
static_assert(offsetof(FCameraBlendSettingsInput, FocusSettings) == 0x000000, "Member 'FCameraBlendSettingsInput::FocusSettings' has a wrong offset!");
static_assert(offsetof(FCameraBlendSettingsInput, LensSettings) == 0x000058, "Member 'FCameraBlendSettingsInput::LensSettings' has a wrong offset!");
static_assert(offsetof(FCameraBlendSettingsInput, FocalLength) == 0x000070, "Member 'FCameraBlendSettingsInput::FocalLength' has a wrong offset!");
static_assert(offsetof(FCameraBlendSettingsInput, Aperture) == 0x000074, "Member 'FCameraBlendSettingsInput::Aperture' has a wrong offset!");

// ScriptStruct ObsidianFox.PushPlane
// 0x001C (0x001C - 0x0000)
struct FPushPlane final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPushPlane) == 0x000004, "Wrong alignment on FPushPlane");
static_assert(sizeof(FPushPlane) == 0x00001C, "Wrong size on FPushPlane");
static_assert(offsetof(FPushPlane, Location) == 0x000000, "Member 'FPushPlane::Location' has a wrong offset!");
static_assert(offsetof(FPushPlane, Normal) == 0x00000C, "Member 'FPushPlane::Normal' has a wrong offset!");
static_assert(offsetof(FPushPlane, Strength) == 0x000018, "Member 'FPushPlane::Strength' has a wrong offset!");

// ScriptStruct ObsidianFox.AttractionPoint
// 0x0018 (0x0018 - 0x0000)
struct FAttractionPoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExponentialStrength;                               // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttractionPoint) == 0x000004, "Wrong alignment on FAttractionPoint");
static_assert(sizeof(FAttractionPoint) == 0x000018, "Wrong size on FAttractionPoint");
static_assert(offsetof(FAttractionPoint, Location) == 0x000000, "Member 'FAttractionPoint::Location' has a wrong offset!");
static_assert(offsetof(FAttractionPoint, Range) == 0x00000C, "Member 'FAttractionPoint::Range' has a wrong offset!");
static_assert(offsetof(FAttractionPoint, Strength) == 0x000010, "Member 'FAttractionPoint::Strength' has a wrong offset!");
static_assert(offsetof(FAttractionPoint, ExponentialStrength) == 0x000014, "Member 'FAttractionPoint::ExponentialStrength' has a wrong offset!");

// ScriptStruct ObsidianFox.Boid
// 0x0040 (0x0040 - 0x0000)
struct FBoid final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Velocity;                                          // 0x0030(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeshInstanceID;                                    // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoid) == 0x000010, "Wrong alignment on FBoid");
static_assert(sizeof(FBoid) == 0x000040, "Wrong size on FBoid");
static_assert(offsetof(FBoid, Transform) == 0x000000, "Member 'FBoid::Transform' has a wrong offset!");
static_assert(offsetof(FBoid, Velocity) == 0x000030, "Member 'FBoid::Velocity' has a wrong offset!");
static_assert(offsetof(FBoid, MeshInstanceID) == 0x00003C, "Member 'FBoid::MeshInstanceID' has a wrong offset!");

// ScriptStruct ObsidianFox.SequenceAutoBlendData
// 0x0038 (0x0038 - 0x0000)
struct FSequenceAutoBlendData final
{
public:
	class UAnimSequenceBase*                      Animation;                                         // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UObject>                 LockReference;                                     // 0x0010(0x0028)(SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSequenceAutoBlendData) == 0x000008, "Wrong alignment on FSequenceAutoBlendData");
static_assert(sizeof(FSequenceAutoBlendData) == 0x000038, "Wrong size on FSequenceAutoBlendData");
static_assert(offsetof(FSequenceAutoBlendData, Animation) == 0x000000, "Member 'FSequenceAutoBlendData::Animation' has a wrong offset!");
static_assert(offsetof(FSequenceAutoBlendData, BlendTime) == 0x000008, "Member 'FSequenceAutoBlendData::BlendTime' has a wrong offset!");
static_assert(offsetof(FSequenceAutoBlendData, LockReference) == 0x000010, "Member 'FSequenceAutoBlendData::LockReference' has a wrong offset!");

// ScriptStruct ObsidianFox.OFInGameHUDClass
// 0x0030 (0x0030 - 0x0000)
struct FOFInGameHUDClass final
{
public:
	TSoftClassPtr<class UClass>                   DisplayWidget;                                     // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZIndex;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOFInGameHUDClass) == 0x000008, "Wrong alignment on FOFInGameHUDClass");
static_assert(sizeof(FOFInGameHUDClass) == 0x000030, "Wrong size on FOFInGameHUDClass");
static_assert(offsetof(FOFInGameHUDClass, DisplayWidget) == 0x000000, "Member 'FOFInGameHUDClass::DisplayWidget' has a wrong offset!");
static_assert(offsetof(FOFInGameHUDClass, ZIndex) == 0x000028, "Member 'FOFInGameHUDClass::ZIndex' has a wrong offset!");

// ScriptStruct ObsidianFox.OFGameplayAbilityBindInfo
// 0x0038 (0x0038 - 0x0000)
struct FOFGameplayAbilityBindInfo final
{
public:
	TSoftClassPtr<class UClass>                   GameplayAbilityClass;                              // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InputTag;                                          // 0x0028(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAbilityInput                                 InputBinding;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOFGameplayAbilityBindInfo) == 0x000008, "Wrong alignment on FOFGameplayAbilityBindInfo");
static_assert(sizeof(FOFGameplayAbilityBindInfo) == 0x000038, "Wrong size on FOFGameplayAbilityBindInfo");
static_assert(offsetof(FOFGameplayAbilityBindInfo, GameplayAbilityClass) == 0x000000, "Member 'FOFGameplayAbilityBindInfo::GameplayAbilityClass' has a wrong offset!");
static_assert(offsetof(FOFGameplayAbilityBindInfo, InputTag) == 0x000028, "Member 'FOFGameplayAbilityBindInfo::InputTag' has a wrong offset!");
static_assert(offsetof(FOFGameplayAbilityBindInfo, InputBinding) == 0x000030, "Member 'FOFGameplayAbilityBindInfo::InputBinding' has a wrong offset!");

// ScriptStruct ObsidianFox.OFGameplayEffectContext
// 0x0038 (0x00A8 - 0x0070)
struct FOFGameplayEffectContext final : public FGameplayEffectContext
{
public:
	uint8                                         Pad_70[0x38];                                      // 0x0070(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOFGameplayEffectContext) == 0x000008, "Wrong alignment on FOFGameplayEffectContext");
static_assert(sizeof(FOFGameplayEffectContext) == 0x0000A8, "Wrong size on FOFGameplayEffectContext");

// ScriptStruct ObsidianFox.OFGameplayAbilityTargetData_HitResultArray
// 0x0088 (0x0090 - 0x0008)
struct FOFGameplayAbilityTargetData_HitResultArray final : public FGameplayAbilityTargetData
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAbilityTargetingLocationInfo  SourceLocation;                                    // 0x0010(0x0070)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FHitResult>                     HitResults;                                        // 0x0080(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FOFGameplayAbilityTargetData_HitResultArray) == 0x000010, "Wrong alignment on FOFGameplayAbilityTargetData_HitResultArray");
static_assert(sizeof(FOFGameplayAbilityTargetData_HitResultArray) == 0x000090, "Wrong size on FOFGameplayAbilityTargetData_HitResultArray");
static_assert(offsetof(FOFGameplayAbilityTargetData_HitResultArray, SourceLocation) == 0x000010, "Member 'FOFGameplayAbilityTargetData_HitResultArray::SourceLocation' has a wrong offset!");
static_assert(offsetof(FOFGameplayAbilityTargetData_HitResultArray, HitResults) == 0x000080, "Member 'FOFGameplayAbilityTargetData_HitResultArray::HitResults' has a wrong offset!");

// ScriptStruct ObsidianFox.CanvasGeometryInterpolationHelper
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x04) FCanvasGeometryInterpolationHelper final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCanvasGeometryInterpolationHelper) == 0x000004, "Wrong alignment on FCanvasGeometryInterpolationHelper");
static_assert(sizeof(FCanvasGeometryInterpolationHelper) == 0x000028, "Wrong size on FCanvasGeometryInterpolationHelper");

// ScriptStruct ObsidianFox.OFNPCSubGraphAnimInstanceProxy
// 0x0010 (0x0780 - 0x0770)
struct FOFNPCSubGraphAnimInstanceProxy final : public FAnimInstanceProxy
{
public:
	class UOFNPCSubGraphAnimInstance*             Owner;                                             // 0x0770(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasEvaluatedAnimGraph : 1;                        // 0x0778(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_779[0x7];                                      // 0x0779(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOFNPCSubGraphAnimInstanceProxy) == 0x000010, "Wrong alignment on FOFNPCSubGraphAnimInstanceProxy");
static_assert(sizeof(FOFNPCSubGraphAnimInstanceProxy) == 0x000780, "Wrong size on FOFNPCSubGraphAnimInstanceProxy");
static_assert(offsetof(FOFNPCSubGraphAnimInstanceProxy, Owner) == 0x000770, "Member 'FOFNPCSubGraphAnimInstanceProxy::Owner' has a wrong offset!");

// ScriptStruct ObsidianFox.OFPostProcessAnimInstanceProxy
// 0x0010 (0x0780 - 0x0770)
struct FOFPostProcessAnimInstanceProxy final : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_770[0x10];                                     // 0x0770(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOFPostProcessAnimInstanceProxy) == 0x000010, "Wrong alignment on FOFPostProcessAnimInstanceProxy");
static_assert(sizeof(FOFPostProcessAnimInstanceProxy) == 0x000780, "Wrong size on FOFPostProcessAnimInstanceProxy");

// ScriptStruct ObsidianFox.RichUserWidgetRow
// 0x0060 (0x0068 - 0x0008)
struct FRichUserWidgetRow final : public FTableRowBase
{
public:
	TSubclassOf<class UPlatformSpecificKeyWidget> Widget;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            InputAction;                                       // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPiecesInputMappingContext> InputMappingContext;                               // 0x0038(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInputActionType                              InputActionType;                                   // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRichUserWidgetRow) == 0x000008, "Wrong alignment on FRichUserWidgetRow");
static_assert(sizeof(FRichUserWidgetRow) == 0x000068, "Wrong size on FRichUserWidgetRow");
static_assert(offsetof(FRichUserWidgetRow, Widget) == 0x000008, "Member 'FRichUserWidgetRow::Widget' has a wrong offset!");
static_assert(offsetof(FRichUserWidgetRow, InputAction) == 0x000010, "Member 'FRichUserWidgetRow::InputAction' has a wrong offset!");
static_assert(offsetof(FRichUserWidgetRow, InputMappingContext) == 0x000038, "Member 'FRichUserWidgetRow::InputMappingContext' has a wrong offset!");
static_assert(offsetof(FRichUserWidgetRow, InputActionType) == 0x000060, "Member 'FRichUserWidgetRow::InputActionType' has a wrong offset!");

// ScriptStruct ObsidianFox.CollectibleSaveData
// 0x0020 (0x0020 - 0x0000)
struct FCollectibleSaveData final
{
public:
	class FString                                 UniqueName;                                        // 0x0000(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UItemData>>       GatheredItems;                                     // 0x0010(0x0010)(ZeroConstructor, SaveGame, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectibleSaveData) == 0x000008, "Wrong alignment on FCollectibleSaveData");
static_assert(sizeof(FCollectibleSaveData) == 0x000020, "Wrong size on FCollectibleSaveData");
static_assert(offsetof(FCollectibleSaveData, UniqueName) == 0x000000, "Member 'FCollectibleSaveData::UniqueName' has a wrong offset!");
static_assert(offsetof(FCollectibleSaveData, GatheredItems) == 0x000010, "Member 'FCollectibleSaveData::GatheredItems' has a wrong offset!");

// ScriptStruct ObsidianFox.HandPosesData
// 0x0020 (0x0020 - 0x0000)
struct FHandPosesData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      AnimSequence;                                      // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHandPosesData) == 0x000008, "Wrong alignment on FHandPosesData");
static_assert(sizeof(FHandPosesData) == 0x000020, "Wrong size on FHandPosesData");
static_assert(offsetof(FHandPosesData, AnimSequence) == 0x000008, "Member 'FHandPosesData::AnimSequence' has a wrong offset!");

// ScriptStruct ObsidianFox.PlayerAnimInstanceProxy
// 0x0010 (0x0780 - 0x0770)
struct FPlayerAnimInstanceProxy final : public FAnimInstanceProxy
{
public:
	uint8                                         Pad_770[0x10];                                     // 0x0770(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerAnimInstanceProxy) == 0x000010, "Wrong alignment on FPlayerAnimInstanceProxy");
static_assert(sizeof(FPlayerAnimInstanceProxy) == 0x000780, "Wrong size on FPlayerAnimInstanceProxy");

// ScriptStruct ObsidianFox.PreStreamTexturesJob
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FPreStreamTexturesJob final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreStreamTexturesJob) == 0x000004, "Wrong alignment on FPreStreamTexturesJob");
static_assert(sizeof(FPreStreamTexturesJob) == 0x000020, "Wrong size on FPreStreamTexturesJob");

// ScriptStruct ObsidianFox.ProgressionInfo
// 0x0080 (0x0080 - 0x0000)
struct FProgressionInfo final
{
public:
	struct FGameplayTag                           ProgressionTag;                                    // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SaveSlotImage;                                     // 0x0008(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              MenuImage;                                         // 0x0030(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              LoadingScreenImage;                                // 0x0058(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProgressionInfo) == 0x000008, "Wrong alignment on FProgressionInfo");
static_assert(sizeof(FProgressionInfo) == 0x000080, "Wrong size on FProgressionInfo");
static_assert(offsetof(FProgressionInfo, ProgressionTag) == 0x000000, "Member 'FProgressionInfo::ProgressionTag' has a wrong offset!");
static_assert(offsetof(FProgressionInfo, SaveSlotImage) == 0x000008, "Member 'FProgressionInfo::SaveSlotImage' has a wrong offset!");
static_assert(offsetof(FProgressionInfo, MenuImage) == 0x000030, "Member 'FProgressionInfo::MenuImage' has a wrong offset!");
static_assert(offsetof(FProgressionInfo, LoadingScreenImage) == 0x000058, "Member 'FProgressionInfo::LoadingScreenImage' has a wrong offset!");

// ScriptStruct ObsidianFox.LevelInfo
// 0x0020 (0x0020 - 0x0000)
struct FLevelInfo final
{
public:
	struct FGameplayTag                           LevelTag;                                          // 0x0000(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   LevelName;                                         // 0x0008(0x0018)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelInfo) == 0x000008, "Wrong alignment on FLevelInfo");
static_assert(sizeof(FLevelInfo) == 0x000020, "Wrong size on FLevelInfo");
static_assert(offsetof(FLevelInfo, LevelTag) == 0x000000, "Member 'FLevelInfo::LevelTag' has a wrong offset!");
static_assert(offsetof(FLevelInfo, LevelName) == 0x000008, "Member 'FLevelInfo::LevelName' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_AccumulateRotator
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_AccumulateRotator final : public FRigUnit
{
public:
	struct FRotator                               TargetValue;                                       // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               InitialValue;                                      // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Blend;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               Result;                                            // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               AccumulatedValue;                                  // 0x0034(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_AccumulateRotator) == 0x000008, "Wrong alignment on FRigUnit_AccumulateRotator");
static_assert(sizeof(FRigUnit_AccumulateRotator) == 0x000040, "Wrong size on FRigUnit_AccumulateRotator");
static_assert(offsetof(FRigUnit_AccumulateRotator, TargetValue) == 0x000008, "Member 'FRigUnit_AccumulateRotator::TargetValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateRotator, InitialValue) == 0x000014, "Member 'FRigUnit_AccumulateRotator::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateRotator, Blend) == 0x000020, "Member 'FRigUnit_AccumulateRotator::Blend' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateRotator, bIntegrateDeltaTime) == 0x000024, "Member 'FRigUnit_AccumulateRotator::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateRotator, Result) == 0x000028, "Member 'FRigUnit_AccumulateRotator::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_AccumulateRotator, AccumulatedValue) == 0x000034, "Member 'FRigUnit_AccumulateRotator::AccumulatedValue' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnitBodyFocusJointInput
// 0x0048 (0x0048 - 0x0000)
struct FRigUnitBodyFocusJointInput final
{
public:
	struct FRigElementKey                         Item;                                              // 0x0000(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         LimitSpace;                                        // 0x000C(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Stiffness;                                         // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MinRotation;                                       // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               MaxRotation;                                       // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LimitOffset;                                       // 0x0034(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawLimit;                                   // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnitBodyFocusJointInput) == 0x000004, "Wrong alignment on FRigUnitBodyFocusJointInput");
static_assert(sizeof(FRigUnitBodyFocusJointInput) == 0x000048, "Wrong size on FRigUnitBodyFocusJointInput");
static_assert(offsetof(FRigUnitBodyFocusJointInput, Item) == 0x000000, "Member 'FRigUnitBodyFocusJointInput::Item' has a wrong offset!");
static_assert(offsetof(FRigUnitBodyFocusJointInput, LimitSpace) == 0x00000C, "Member 'FRigUnitBodyFocusJointInput::LimitSpace' has a wrong offset!");
static_assert(offsetof(FRigUnitBodyFocusJointInput, Stiffness) == 0x000018, "Member 'FRigUnitBodyFocusJointInput::Stiffness' has a wrong offset!");
static_assert(offsetof(FRigUnitBodyFocusJointInput, MinRotation) == 0x00001C, "Member 'FRigUnitBodyFocusJointInput::MinRotation' has a wrong offset!");
static_assert(offsetof(FRigUnitBodyFocusJointInput, MaxRotation) == 0x000028, "Member 'FRigUnitBodyFocusJointInput::MaxRotation' has a wrong offset!");
static_assert(offsetof(FRigUnitBodyFocusJointInput, LimitOffset) == 0x000034, "Member 'FRigUnitBodyFocusJointInput::LimitOffset' has a wrong offset!");
static_assert(offsetof(FRigUnitBodyFocusJointInput, Alpha) == 0x000040, "Member 'FRigUnitBodyFocusJointInput::Alpha' has a wrong offset!");
static_assert(offsetof(FRigUnitBodyFocusJointInput, bDebugDrawLimit) == 0x000044, "Member 'FRigUnitBodyFocusJointInput::bDebugDrawLimit' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_BodyFocus
// 0x0058 (0x00C0 - 0x0068)
struct FRigUnit_BodyFocus final : public FRigUnitMutable
{
public:
	float                                         BlendSpeed;                                        // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x006C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FocusLocation;                                     // 0x0070(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         ReferenceItem;                                     // 0x007C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReferenceUpAxis;                                   // 0x0088(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigUnitBodyFocusJointInput>    Items;                                             // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bInterpolateLongDistanceAt180Degrees;              // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReverseOrder;                                     // 0x00A9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Alpha;                                             // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FQuat>                          InterpolatedRotations;                             // 0x00B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_BodyFocus) == 0x000008, "Wrong alignment on FRigUnit_BodyFocus");
static_assert(sizeof(FRigUnit_BodyFocus) == 0x0000C0, "Wrong size on FRigUnit_BodyFocus");
static_assert(offsetof(FRigUnit_BodyFocus, BlendSpeed) == 0x000068, "Member 'FRigUnit_BodyFocus::BlendSpeed' has a wrong offset!");
static_assert(offsetof(FRigUnit_BodyFocus, bIntegrateDeltaTime) == 0x00006C, "Member 'FRigUnit_BodyFocus::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_BodyFocus, FocusLocation) == 0x000070, "Member 'FRigUnit_BodyFocus::FocusLocation' has a wrong offset!");
static_assert(offsetof(FRigUnit_BodyFocus, ReferenceItem) == 0x00007C, "Member 'FRigUnit_BodyFocus::ReferenceItem' has a wrong offset!");
static_assert(offsetof(FRigUnit_BodyFocus, ReferenceUpAxis) == 0x000088, "Member 'FRigUnit_BodyFocus::ReferenceUpAxis' has a wrong offset!");
static_assert(offsetof(FRigUnit_BodyFocus, Items) == 0x000098, "Member 'FRigUnit_BodyFocus::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_BodyFocus, bInterpolateLongDistanceAt180Degrees) == 0x0000A8, "Member 'FRigUnit_BodyFocus::bInterpolateLongDistanceAt180Degrees' has a wrong offset!");
static_assert(offsetof(FRigUnit_BodyFocus, bReverseOrder) == 0x0000A9, "Member 'FRigUnit_BodyFocus::bReverseOrder' has a wrong offset!");
static_assert(offsetof(FRigUnit_BodyFocus, Alpha) == 0x0000AC, "Member 'FRigUnit_BodyFocus::Alpha' has a wrong offset!");
static_assert(offsetof(FRigUnit_BodyFocus, InterpolatedRotations) == 0x0000B0, "Member 'FRigUnit_BodyFocus::InterpolatedRotations' has a wrong offset!");

// ScriptStruct ObsidianFox.RigunitFootLockingInput
// 0x0008 (0x0020 - 0x0018)
struct FRigunitFootLockingInput final : public FRigunitFootLockingOutput
{
public:
	class FName                                   FootPlantedCurve;                                  // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigunitFootLockingInput) == 0x000004, "Wrong alignment on FRigunitFootLockingInput");
static_assert(sizeof(FRigunitFootLockingInput) == 0x000020, "Wrong size on FRigunitFootLockingInput");
static_assert(offsetof(FRigunitFootLockingInput, FootPlantedCurve) == 0x000018, "Member 'FRigunitFootLockingInput::FootPlantedCurve' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_FootLocking
// 0x00B0 (0x0118 - 0x0068)
struct FRigUnit_FootLocking final : public FRigUnit_FootIKBaseMutable
{
public:
	TArray<struct FRigunitFootLockingInput>       Input;                                             // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRigunitFootLockingOutput              Items;                                             // 0x0078(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	float                                         CurveAlpha;                                        // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngularDistance;                                   // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 CurveCache;                                        // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Index;                                             // 0x00A8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x00AC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Continue;                                          // 0x00B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FControlRigExecuteContext              Completed;                                         // 0x00B8(0x0060)(Edit, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_FootLocking) == 0x000008, "Wrong alignment on FRigUnit_FootLocking");
static_assert(sizeof(FRigUnit_FootLocking) == 0x000118, "Wrong size on FRigUnit_FootLocking");
static_assert(offsetof(FRigUnit_FootLocking, Input) == 0x000068, "Member 'FRigUnit_FootLocking::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootLocking, Items) == 0x000078, "Member 'FRigUnit_FootLocking::Items' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootLocking, CurveAlpha) == 0x000090, "Member 'FRigUnit_FootLocking::CurveAlpha' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootLocking, AngularDistance) == 0x000094, "Member 'FRigUnit_FootLocking::AngularDistance' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootLocking, CurveCache) == 0x000098, "Member 'FRigUnit_FootLocking::CurveCache' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootLocking, Index) == 0x0000A8, "Member 'FRigUnit_FootLocking::Index' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootLocking, Count) == 0x0000AC, "Member 'FRigUnit_FootLocking::Count' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootLocking, Continue) == 0x0000B0, "Member 'FRigUnit_FootLocking::Continue' has a wrong offset!");
static_assert(offsetof(FRigUnit_FootLocking, Completed) == 0x0000B8, "Member 'FRigUnit_FootLocking::Completed' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_HandIKBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_HandIKBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_HandIKBase) == 0x000008, "Wrong alignment on FRigUnit_HandIKBase");
static_assert(sizeof(FRigUnit_HandIKBase) == 0x000008, "Wrong size on FRigUnit_HandIKBase");

// ScriptStruct ObsidianFox.RigUnit_HandIKRefOffset
// 0x00B8 (0x00C0 - 0x0008)
struct FRigUnit_HandIKRefOffset final : public FRigUnit_HandIKBase
{
public:
	struct FRigElementKey                         BaseElement;                                       // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0xC];                                       // 0x0014(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             TargetTransform;                                   // 0x0020(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             ReferenceTransform;                                // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LocationAlpha;                                     // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationAlpha;                                     // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleAlpha;                                        // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseBaseElementAsOrigin;                           // 0x008C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Output;                                            // 0x0090(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_HandIKRefOffset) == 0x000010, "Wrong alignment on FRigUnit_HandIKRefOffset");
static_assert(sizeof(FRigUnit_HandIKRefOffset) == 0x0000C0, "Wrong size on FRigUnit_HandIKRefOffset");
static_assert(offsetof(FRigUnit_HandIKRefOffset, BaseElement) == 0x000008, "Member 'FRigUnit_HandIKRefOffset::BaseElement' has a wrong offset!");
static_assert(offsetof(FRigUnit_HandIKRefOffset, TargetTransform) == 0x000020, "Member 'FRigUnit_HandIKRefOffset::TargetTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_HandIKRefOffset, ReferenceTransform) == 0x000050, "Member 'FRigUnit_HandIKRefOffset::ReferenceTransform' has a wrong offset!");
static_assert(offsetof(FRigUnit_HandIKRefOffset, LocationAlpha) == 0x000080, "Member 'FRigUnit_HandIKRefOffset::LocationAlpha' has a wrong offset!");
static_assert(offsetof(FRigUnit_HandIKRefOffset, RotationAlpha) == 0x000084, "Member 'FRigUnit_HandIKRefOffset::RotationAlpha' has a wrong offset!");
static_assert(offsetof(FRigUnit_HandIKRefOffset, ScaleAlpha) == 0x000088, "Member 'FRigUnit_HandIKRefOffset::ScaleAlpha' has a wrong offset!");
static_assert(offsetof(FRigUnit_HandIKRefOffset, bUseBaseElementAsOrigin) == 0x00008C, "Member 'FRigUnit_HandIKRefOffset::bUseBaseElementAsOrigin' has a wrong offset!");
static_assert(offsetof(FRigUnit_HandIKRefOffset, Output) == 0x000090, "Member 'FRigUnit_HandIKRefOffset::Output' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_HierarchySearch
// 0x0040 (0x0048 - 0x0008)
struct FRigUnit_HierarchySearch final : public FRigUnit_HierarchySearchBase
{
public:
	struct FRigElementKey                         Child;                                             // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PartialName;                                       // 0x0014(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ParentFound;                                       // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigElementKey                         Parent;                                            // 0x0020(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContainerVersion;                                  // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         CachedChild;                                       // 0x0030(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         CachedParent;                                      // 0x003C(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_HierarchySearch) == 0x000008, "Wrong alignment on FRigUnit_HierarchySearch");
static_assert(sizeof(FRigUnit_HierarchySearch) == 0x000048, "Wrong size on FRigUnit_HierarchySearch");
static_assert(offsetof(FRigUnit_HierarchySearch, Child) == 0x000008, "Member 'FRigUnit_HierarchySearch::Child' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchySearch, PartialName) == 0x000014, "Member 'FRigUnit_HierarchySearch::PartialName' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchySearch, ParentFound) == 0x00001C, "Member 'FRigUnit_HierarchySearch::ParentFound' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchySearch, Parent) == 0x000020, "Member 'FRigUnit_HierarchySearch::Parent' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchySearch, ContainerVersion) == 0x00002C, "Member 'FRigUnit_HierarchySearch::ContainerVersion' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchySearch, CachedChild) == 0x000030, "Member 'FRigUnit_HierarchySearch::CachedChild' has a wrong offset!");
static_assert(offsetof(FRigUnit_HierarchySearch, CachedParent) == 0x00003C, "Member 'FRigUnit_HierarchySearch::CachedParent' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_IKSpaceConversion
// 0x0078 (0x0080 - 0x0008)
struct FRigUnit_IKSpaceConversion final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Effector;                                          // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRigElementKey                         RotationBase;                                      // 0x0040(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Result;                                            // 0x0050(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_IKSpaceConversion) == 0x000010, "Wrong alignment on FRigUnit_IKSpaceConversion");
static_assert(sizeof(FRigUnit_IKSpaceConversion) == 0x000080, "Wrong size on FRigUnit_IKSpaceConversion");
static_assert(offsetof(FRigUnit_IKSpaceConversion, Effector) == 0x000010, "Member 'FRigUnit_IKSpaceConversion::Effector' has a wrong offset!");
static_assert(offsetof(FRigUnit_IKSpaceConversion, RotationBase) == 0x000040, "Member 'FRigUnit_IKSpaceConversion::RotationBase' has a wrong offset!");
static_assert(offsetof(FRigUnit_IKSpaceConversion, Result) == 0x000050, "Member 'FRigUnit_IKSpaceConversion::Result' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_LimitRotation
// 0x0058 (0x0060 - 0x0008)
struct FRigUnit_LimitRotation final : public FRigUnit
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0010(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  InitialRotation;                                   // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                MinDegrees;                                        // 0x0030(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxDegrees;                                        // 0x003C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Output;                                            // 0x0050(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_LimitRotation) == 0x000010, "Wrong alignment on FRigUnit_LimitRotation");
static_assert(sizeof(FRigUnit_LimitRotation) == 0x000060, "Wrong size on FRigUnit_LimitRotation");
static_assert(offsetof(FRigUnit_LimitRotation, Rotation) == 0x000010, "Member 'FRigUnit_LimitRotation::Rotation' has a wrong offset!");
static_assert(offsetof(FRigUnit_LimitRotation, InitialRotation) == 0x000020, "Member 'FRigUnit_LimitRotation::InitialRotation' has a wrong offset!");
static_assert(offsetof(FRigUnit_LimitRotation, MinDegrees) == 0x000030, "Member 'FRigUnit_LimitRotation::MinDegrees' has a wrong offset!");
static_assert(offsetof(FRigUnit_LimitRotation, MaxDegrees) == 0x00003C, "Member 'FRigUnit_LimitRotation::MaxDegrees' has a wrong offset!");
static_assert(offsetof(FRigUnit_LimitRotation, Output) == 0x000050, "Member 'FRigUnit_LimitRotation::Output' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_MakeRotationFromTwoVectors
// 0x0038 (0x0040 - 0x0008)
struct FRigUnit_MakeRotationFromTwoVectors final : public FRigUnit_MakeRotationFromVectorBase
{
public:
	struct FVector                                A;                                                 // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMakeRotationTwoVectorOrder                   Order;                                             // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0xF];                                       // 0x0021(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MakeRotationFromTwoVectors) == 0x000010, "Wrong alignment on FRigUnit_MakeRotationFromTwoVectors");
static_assert(sizeof(FRigUnit_MakeRotationFromTwoVectors) == 0x000040, "Wrong size on FRigUnit_MakeRotationFromTwoVectors");
static_assert(offsetof(FRigUnit_MakeRotationFromTwoVectors, A) == 0x000008, "Member 'FRigUnit_MakeRotationFromTwoVectors::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_MakeRotationFromTwoVectors, B) == 0x000014, "Member 'FRigUnit_MakeRotationFromTwoVectors::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_MakeRotationFromTwoVectors, Order) == 0x000020, "Member 'FRigUnit_MakeRotationFromTwoVectors::Order' has a wrong offset!");
static_assert(offsetof(FRigUnit_MakeRotationFromTwoVectors, Rotation) == 0x000030, "Member 'FRigUnit_MakeRotationFromTwoVectors::Rotation' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_MakeRotationFromZX
// 0x0028 (0x0030 - 0x0008)
struct FRigUnit_MakeRotationFromZX final : public FRigUnit_MakeRotationFromVectorBase
{
public:
	struct FVector                                Z;                                                 // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                X;                                                 // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FQuat                                  Result;                                            // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_MakeRotationFromZX) == 0x000010, "Wrong alignment on FRigUnit_MakeRotationFromZX");
static_assert(sizeof(FRigUnit_MakeRotationFromZX) == 0x000030, "Wrong size on FRigUnit_MakeRotationFromZX");
static_assert(offsetof(FRigUnit_MakeRotationFromZX, Z) == 0x000008, "Member 'FRigUnit_MakeRotationFromZX::Z' has a wrong offset!");
static_assert(offsetof(FRigUnit_MakeRotationFromZX, X) == 0x000014, "Member 'FRigUnit_MakeRotationFromZX::X' has a wrong offset!");
static_assert(offsetof(FRigUnit_MakeRotationFromZX, Result) == 0x000020, "Member 'FRigUnit_MakeRotationFromZX::Result' has a wrong offset!");

// ScriptStruct ObsidianFox.RigUnit_VectorPlaneProject
// 0x0028 (0x0030 - 0x0008)
struct FRigUnit_VectorPlaneProject final : public FRigUnit
{
public:
	struct FVector                                Input;                                             // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaneNormal;                                       // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Output;                                            // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_VectorPlaneProject) == 0x000008, "Wrong alignment on FRigUnit_VectorPlaneProject");
static_assert(sizeof(FRigUnit_VectorPlaneProject) == 0x000030, "Wrong size on FRigUnit_VectorPlaneProject");
static_assert(offsetof(FRigUnit_VectorPlaneProject, Input) == 0x000008, "Member 'FRigUnit_VectorPlaneProject::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_VectorPlaneProject, PlaneNormal) == 0x000014, "Member 'FRigUnit_VectorPlaneProject::PlaneNormal' has a wrong offset!");
static_assert(offsetof(FRigUnit_VectorPlaneProject, Output) == 0x000020, "Member 'FRigUnit_VectorPlaneProject::Output' has a wrong offset!");

// ScriptStruct ObsidianFox.EnemyThreatData
// 0x000C (0x000C - 0x0000)
struct ObsidianFox::FEnemyThreatData final
{
public:
	TWeakObjectPtr<class AActor>                  EnemyActor;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Threat;                                            // 0x0008(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ObsidianFox::FEnemyThreatData) == 0x000004, "Wrong alignment on ObsidianFox::FEnemyThreatData");
static_assert(sizeof(ObsidianFox::FEnemyThreatData) == 0x00000C, "Wrong size on ObsidianFox::FEnemyThreatData");
static_assert(offsetof(ObsidianFox::FEnemyThreatData, EnemyActor) == 0x000000, "Member 'ObsidianFox::FEnemyThreatData::EnemyActor' has a wrong offset!");
static_assert(offsetof(ObsidianFox::FEnemyThreatData, Threat) == 0x000008, "Member 'ObsidianFox::FEnemyThreatData::Threat' has a wrong offset!");

// ScriptStruct ObsidianFox.TimedObjective
// 0x0030 (0x0030 - 0x0000)
struct FTimedObjective final
{
public:
	class UObjectivesData*                        Objective;                                         // 0x0000(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectiveParts                               ObjectivePart;                                     // 0x0008(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ObjectiveTag;                                      // 0x000C(0x0008)(SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           IdentityTag;                                       // 0x0014(0x0008)(SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeRemaining;                                     // 0x001C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsManuallyPaused;                                 // 0x0020(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0xF];                                       // 0x0021(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimedObjective) == 0x000008, "Wrong alignment on FTimedObjective");
static_assert(sizeof(FTimedObjective) == 0x000030, "Wrong size on FTimedObjective");
static_assert(offsetof(FTimedObjective, Objective) == 0x000000, "Member 'FTimedObjective::Objective' has a wrong offset!");
static_assert(offsetof(FTimedObjective, ObjectivePart) == 0x000008, "Member 'FTimedObjective::ObjectivePart' has a wrong offset!");
static_assert(offsetof(FTimedObjective, ObjectiveTag) == 0x00000C, "Member 'FTimedObjective::ObjectiveTag' has a wrong offset!");
static_assert(offsetof(FTimedObjective, IdentityTag) == 0x000014, "Member 'FTimedObjective::IdentityTag' has a wrong offset!");
static_assert(offsetof(FTimedObjective, TimeRemaining) == 0x00001C, "Member 'FTimedObjective::TimeRemaining' has a wrong offset!");
static_assert(offsetof(FTimedObjective, bIsManuallyPaused) == 0x000020, "Member 'FTimedObjective::bIsManuallyPaused' has a wrong offset!");

// ScriptStruct ObsidianFox.WallSplineCharacterPathPoint
// 0x0018 (0x0018 - 0x0000)
struct FWallSplineCharacterPathPoint final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GravityDirection;                                  // 0x000C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWallSplineCharacterPathPoint) == 0x000004, "Wrong alignment on FWallSplineCharacterPathPoint");
static_assert(sizeof(FWallSplineCharacterPathPoint) == 0x000018, "Wrong size on FWallSplineCharacterPathPoint");
static_assert(offsetof(FWallSplineCharacterPathPoint, Location) == 0x000000, "Member 'FWallSplineCharacterPathPoint::Location' has a wrong offset!");
static_assert(offsetof(FWallSplineCharacterPathPoint, GravityDirection) == 0x00000C, "Member 'FWallSplineCharacterPathPoint::GravityDirection' has a wrong offset!");

// ScriptStruct ObsidianFox.WeaponAnimationData
// 0x00C8 (0x00C8 - 0x0000)
struct FWeaponAnimationData final
{
public:
	TSoftObjectPtr<class UAnimMontage>            HolsterMontage;                                    // 0x0000(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            UnholsterMontage;                                  // 0x0028(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            SwitchWeaponMontage;                               // 0x0050(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRangedWeaponAnimationData             RangedAnimationData;                               // 0x0078(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeaponAnimationData) == 0x000008, "Wrong alignment on FWeaponAnimationData");
static_assert(sizeof(FWeaponAnimationData) == 0x0000C8, "Wrong size on FWeaponAnimationData");
static_assert(offsetof(FWeaponAnimationData, HolsterMontage) == 0x000000, "Member 'FWeaponAnimationData::HolsterMontage' has a wrong offset!");
static_assert(offsetof(FWeaponAnimationData, UnholsterMontage) == 0x000028, "Member 'FWeaponAnimationData::UnholsterMontage' has a wrong offset!");
static_assert(offsetof(FWeaponAnimationData, SwitchWeaponMontage) == 0x000050, "Member 'FWeaponAnimationData::SwitchWeaponMontage' has a wrong offset!");
static_assert(offsetof(FWeaponAnimationData, RangedAnimationData) == 0x000078, "Member 'FWeaponAnimationData::RangedAnimationData' has a wrong offset!");

// ScriptStruct ObsidianFox.WeighFocusPointsParameters
// 0x0020 (0x0020 - 0x0000)
struct FWeighFocusPointsParameters final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            InterestConeCurve;                                 // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWeighFocusPointsParameters) == 0x000008, "Wrong alignment on FWeighFocusPointsParameters");
static_assert(sizeof(FWeighFocusPointsParameters) == 0x000020, "Wrong size on FWeighFocusPointsParameters");
static_assert(offsetof(FWeighFocusPointsParameters, InterestConeCurve) == 0x000018, "Member 'FWeighFocusPointsParameters::InterestConeCurve' has a wrong offset!");

// ScriptStruct ObsidianFox.SplinePointResult
// 0x0028 (0x0028 - 0x0000)
struct FSplinePointResult final
{
public:
	struct FVector                                NearestPoint;                                      // 0x0000(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x000C(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URailingSplineComponent*                Spline;                                            // 0x0018(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bSplineIsValid : 1;                                // 0x0020(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSplinePointResult) == 0x000008, "Wrong alignment on FSplinePointResult");
static_assert(sizeof(FSplinePointResult) == 0x000028, "Wrong size on FSplinePointResult");
static_assert(offsetof(FSplinePointResult, NearestPoint) == 0x000000, "Member 'FSplinePointResult::NearestPoint' has a wrong offset!");
static_assert(offsetof(FSplinePointResult, Direction) == 0x00000C, "Member 'FSplinePointResult::Direction' has a wrong offset!");
static_assert(offsetof(FSplinePointResult, Spline) == 0x000018, "Member 'FSplinePointResult::Spline' has a wrong offset!");

}

