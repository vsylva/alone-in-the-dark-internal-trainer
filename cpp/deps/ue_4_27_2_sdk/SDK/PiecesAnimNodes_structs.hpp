#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PiecesAnimNodes

#include "Basic.hpp"

#include "AnimGraphRuntime_structs.hpp"
#include "Engine_structs.hpp"
#include "ControlRig_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Enum PiecesAnimNodes.EBarkPriority
// NumValues: 0x0003
enum class EBarkPriority : uint8
{
	Low                                      = 0,
	High                                     = 1,
	EBarkPriority_MAX                        = 2,
};

// Enum PiecesAnimNodes.EPiecesBlendSpacePlayerBlendMethod
// NumValues: 0x0003
enum class EPiecesBlendSpacePlayerBlendMethod : uint8
{
	Standard                                 = 0,
	Inertialization                          = 1,
	EPiecesBlendSpacePlayerBlendMethod_MAX   = 2,
};

// Enum PiecesAnimNodes.EPiecesBlendSpacePlayerBlendDirection
// NumValues: 0x0004
enum class EPiecesBlendSpacePlayerBlendDirection : uint8
{
	In                                       = 0,
	Out                                      = 1,
	None                                     = 2,
	EPiecesBlendSpacePlayerBlendDirection_MAX = 3,
};

// Enum PiecesAnimNodes.EUpdatePriority
// NumValues: 0x0005
enum class EUpdatePriority : uint8
{
	High                                     = 0,
	Medium                                   = 1,
	Low                                      = 2,
	Lowest                                   = 3,
	EUpdatePriority_MAX                      = 4,
};

// Enum PiecesAnimNodes.ERigUnit_SaveCollectionTransformSpaceType
// NumValues: 0x0003
enum class ERigUnit_SaveCollectionTransformSpaceType : uint8
{
	Global                                   = 0,
	Local                                    = 1,
	ERigUnit_MAX                             = 2,
};

// ScriptStruct PiecesAnimNodes.AnimationTagData
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FAnimationTagData final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimationTagData) == 0x000008, "Wrong alignment on FAnimationTagData");
static_assert(sizeof(FAnimationTagData) == 0x000058, "Wrong size on FAnimationTagData");

// ScriptStruct PiecesAnimNodes.PiecesBlendSpaceBlendOutData
// 0x00F8 (0x00F8 - 0x0000)
struct FPiecesBlendSpaceBlendOutData final
{
public:
	class UBlendSpaceBase*                        BlendSpace;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0xF0];                                       // 0x0008(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPiecesBlendSpaceBlendOutData) == 0x000008, "Wrong alignment on FPiecesBlendSpaceBlendOutData");
static_assert(sizeof(FPiecesBlendSpaceBlendOutData) == 0x0000F8, "Wrong size on FPiecesBlendSpaceBlendOutData");
static_assert(offsetof(FPiecesBlendSpaceBlendOutData, BlendSpace) == 0x000000, "Member 'FPiecesBlendSpaceBlendOutData::BlendSpace' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.AnimNode_PiecesBlendSpacePlayer
// 0x0038 (0x0160 - 0x0128)
struct FAnimNode_PiecesBlendSpacePlayer final : public FAnimNode_BlendSpacePlayer
{
public:
	float                                         ManualPosition;                                    // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoBlendOnPositionChange;                         // 0x012C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoBlendOnBlendOutInterrupted;                    // 0x012D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12E[0x2];                                      // 0x012E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InternalBlendTime;                                 // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPiecesBlendSpacePlayerBlendMethod            AutoBlendMethod;                                   // 0x0134(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPiecesBlendSpaceBlendOutData>  BlendOutInstances;                                 // 0x0138(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x18];                                     // 0x0148(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_PiecesBlendSpacePlayer) == 0x000008, "Wrong alignment on FAnimNode_PiecesBlendSpacePlayer");
static_assert(sizeof(FAnimNode_PiecesBlendSpacePlayer) == 0x000160, "Wrong size on FAnimNode_PiecesBlendSpacePlayer");
static_assert(offsetof(FAnimNode_PiecesBlendSpacePlayer, ManualPosition) == 0x000128, "Member 'FAnimNode_PiecesBlendSpacePlayer::ManualPosition' has a wrong offset!");
static_assert(offsetof(FAnimNode_PiecesBlendSpacePlayer, AutoBlendOnPositionChange) == 0x00012C, "Member 'FAnimNode_PiecesBlendSpacePlayer::AutoBlendOnPositionChange' has a wrong offset!");
static_assert(offsetof(FAnimNode_PiecesBlendSpacePlayer, AutoBlendOnBlendOutInterrupted) == 0x00012D, "Member 'FAnimNode_PiecesBlendSpacePlayer::AutoBlendOnBlendOutInterrupted' has a wrong offset!");
static_assert(offsetof(FAnimNode_PiecesBlendSpacePlayer, InternalBlendTime) == 0x000130, "Member 'FAnimNode_PiecesBlendSpacePlayer::InternalBlendTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_PiecesBlendSpacePlayer, AutoBlendMethod) == 0x000134, "Member 'FAnimNode_PiecesBlendSpacePlayer::AutoBlendMethod' has a wrong offset!");
static_assert(offsetof(FAnimNode_PiecesBlendSpacePlayer, BlendOutInstances) == 0x000138, "Member 'FAnimNode_PiecesBlendSpacePlayer::BlendOutInstances' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.AnimNode_PiecesSequencePlayer
// 0x0008 (0x00B8 - 0x00B0)
struct FAnimNode_PiecesSequencePlayer : public FAnimNode_SequencePlayer
{
public:
	bool                                          bRandomizeStartPosition;                           // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_PiecesSequencePlayer) == 0x000008, "Wrong alignment on FAnimNode_PiecesSequencePlayer");
static_assert(sizeof(FAnimNode_PiecesSequencePlayer) == 0x0000B8, "Wrong size on FAnimNode_PiecesSequencePlayer");
static_assert(offsetof(FAnimNode_PiecesSequencePlayer, bRandomizeStartPosition) == 0x0000B0, "Member 'FAnimNode_PiecesSequencePlayer::bRandomizeStartPosition' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.SequenceBlendData
// 0x0050 (0x0050 - 0x0000)
struct FSequenceBlendData final
{
public:
	class UAnimSequenceBase*                      AnimSequence;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x48];                                       // 0x0008(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSequenceBlendData) == 0x000008, "Wrong alignment on FSequenceBlendData");
static_assert(sizeof(FSequenceBlendData) == 0x000050, "Wrong size on FSequenceBlendData");
static_assert(offsetof(FSequenceBlendData, AnimSequence) == 0x000000, "Member 'FSequenceBlendData::AnimSequence' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.AnimNode_SequenceAutoBlendPlayer
// 0x0028 (0x00D8 - 0x00B0)
struct FAnimNode_SequenceAutoBlendPlayer final : public FAnimNode_SequencePlayer
{
public:
	struct FPoseLink                              BasePose;                                          // 0x00B0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAlphaBlendOption                             BlendType;                                         // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSequenceBlendData>             Blends;                                            // 0x00C8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimNode_SequenceAutoBlendPlayer) == 0x000008, "Wrong alignment on FAnimNode_SequenceAutoBlendPlayer");
static_assert(sizeof(FAnimNode_SequenceAutoBlendPlayer) == 0x0000D8, "Wrong size on FAnimNode_SequenceAutoBlendPlayer");
static_assert(offsetof(FAnimNode_SequenceAutoBlendPlayer, BasePose) == 0x0000B0, "Member 'FAnimNode_SequenceAutoBlendPlayer::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_SequenceAutoBlendPlayer, BlendTime) == 0x0000C0, "Member 'FAnimNode_SequenceAutoBlendPlayer::BlendTime' has a wrong offset!");
static_assert(offsetof(FAnimNode_SequenceAutoBlendPlayer, BlendType) == 0x0000C4, "Member 'FAnimNode_SequenceAutoBlendPlayer::BlendType' has a wrong offset!");
static_assert(offsetof(FAnimNode_SequenceAutoBlendPlayer, Blends) == 0x0000C8, "Member 'FAnimNode_SequenceAutoBlendPlayer::Blends' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.BarkCollection
// 0x0050 (0x0050 - 0x0000)
struct FBarkCollection final
{
public:
	TMap<TSoftObjectPtr<class USkeleton>, TSoftObjectPtr<class UAnimMontage>> SkeletonMontageMapping;                            // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBarkCollection) == 0x000008, "Wrong alignment on FBarkCollection");
static_assert(sizeof(FBarkCollection) == 0x000050, "Wrong size on FBarkCollection");
static_assert(offsetof(FBarkCollection, SkeletonMontageMapping) == 0x000000, "Member 'FBarkCollection::SkeletonMontageMapping' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RegisteredBarkBlueprintDataWrapper
// 0x0018 (0x0018 - 0x0000)
struct FRegisteredBarkBlueprintDataWrapper final
{
public:
	class FString                                 BarkName;                                          // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeLeft;                                          // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRegisteredBarkBlueprintDataWrapper) == 0x000008, "Wrong alignment on FRegisteredBarkBlueprintDataWrapper");
static_assert(sizeof(FRegisteredBarkBlueprintDataWrapper) == 0x000018, "Wrong size on FRegisteredBarkBlueprintDataWrapper");
static_assert(offsetof(FRegisteredBarkBlueprintDataWrapper, BarkName) == 0x000000, "Member 'FRegisteredBarkBlueprintDataWrapper::BarkName' has a wrong offset!");
static_assert(offsetof(FRegisteredBarkBlueprintDataWrapper, Weight) == 0x000010, "Member 'FRegisteredBarkBlueprintDataWrapper::Weight' has a wrong offset!");
static_assert(offsetof(FRegisteredBarkBlueprintDataWrapper, TimeLeft) == 0x000014, "Member 'FRegisteredBarkBlueprintDataWrapper::TimeLeft' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_FingersBaseMutable
// 0x0000 (0x0068 - 0x0068)
struct FRigUnit_FingersBaseMutable : public FRigUnitMutable
{
};
static_assert(alignof(FRigUnit_FingersBaseMutable) == 0x000008, "Wrong alignment on FRigUnit_FingersBaseMutable");
static_assert(sizeof(FRigUnit_FingersBaseMutable) == 0x000068, "Wrong size on FRigUnit_FingersBaseMutable");

// ScriptStruct PiecesAnimNodes.RigunitHandGripLoopGroupPreset
// 0x0018 (0x0018 - 0x0000)
struct FRigunitHandGripLoopGroupPreset final
{
public:
	struct FRotator                               MinRotation;                                       // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               MaxRotation;                                       // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigunitHandGripLoopGroupPreset) == 0x000004, "Wrong alignment on FRigunitHandGripLoopGroupPreset");
static_assert(sizeof(FRigunitHandGripLoopGroupPreset) == 0x000018, "Wrong size on FRigunitHandGripLoopGroupPreset");
static_assert(offsetof(FRigunitHandGripLoopGroupPreset, MinRotation) == 0x000000, "Member 'FRigunitHandGripLoopGroupPreset::MinRotation' has a wrong offset!");
static_assert(offsetof(FRigunitHandGripLoopGroupPreset, MaxRotation) == 0x00000C, "Member 'FRigunitHandGripLoopGroupPreset::MaxRotation' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigunitHandGripLoopGroup
// 0x0050 (0x0050 - 0x0000)
struct FRigunitHandGripLoopGroup final
{
public:
	struct FRigElementKeyCollection               ResultItems;                                       // 0x0000(0x0010)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigElementKey                         TraceOrigin;                                       // 0x0010(0x000C)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TraceSpaceRotation;                                // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ArcLength;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArcRadius;                                         // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TraceSegments;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TraceSphereRadius;                                 // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitOffset;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigunitHandGripLoopGroupPreset> Presets;                                           // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigunitHandGripLoopGroup) == 0x000008, "Wrong alignment on FRigunitHandGripLoopGroup");
static_assert(sizeof(FRigunitHandGripLoopGroup) == 0x000050, "Wrong size on FRigunitHandGripLoopGroup");
static_assert(offsetof(FRigunitHandGripLoopGroup, ResultItems) == 0x000000, "Member 'FRigunitHandGripLoopGroup::ResultItems' has a wrong offset!");
static_assert(offsetof(FRigunitHandGripLoopGroup, TraceOrigin) == 0x000010, "Member 'FRigunitHandGripLoopGroup::TraceOrigin' has a wrong offset!");
static_assert(offsetof(FRigunitHandGripLoopGroup, TraceSpaceRotation) == 0x00001C, "Member 'FRigunitHandGripLoopGroup::TraceSpaceRotation' has a wrong offset!");
static_assert(offsetof(FRigunitHandGripLoopGroup, ArcLength) == 0x000028, "Member 'FRigunitHandGripLoopGroup::ArcLength' has a wrong offset!");
static_assert(offsetof(FRigunitHandGripLoopGroup, ArcRadius) == 0x00002C, "Member 'FRigunitHandGripLoopGroup::ArcRadius' has a wrong offset!");
static_assert(offsetof(FRigunitHandGripLoopGroup, TraceSegments) == 0x000030, "Member 'FRigunitHandGripLoopGroup::TraceSegments' has a wrong offset!");
static_assert(offsetof(FRigunitHandGripLoopGroup, TraceSphereRadius) == 0x000034, "Member 'FRigunitHandGripLoopGroup::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(FRigunitHandGripLoopGroup, HitOffset) == 0x000038, "Member 'FRigunitHandGripLoopGroup::HitOffset' has a wrong offset!");
static_assert(offsetof(FRigunitHandGripLoopGroup, Presets) == 0x000040, "Member 'FRigunitHandGripLoopGroup::Presets' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_FingerGripLoopApplyData
// 0x0060 (0x00C8 - 0x0068)
struct FRigUnit_FingerGripLoopApplyData final : public FRigUnit_FingersBaseMutable
{
public:
	struct FRigunitHandGripLoopGroup              Group;                                             // 0x0068(0x0050)(NativeAccessSpecifierPublic)
	float                                         RotationWeight;                                    // 0x00B8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x00BC(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveSettingPreset;                               // 0x00C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_FingerGripLoopApplyData) == 0x000008, "Wrong alignment on FRigUnit_FingerGripLoopApplyData");
static_assert(sizeof(FRigUnit_FingerGripLoopApplyData) == 0x0000C8, "Wrong size on FRigUnit_FingerGripLoopApplyData");
static_assert(offsetof(FRigUnit_FingerGripLoopApplyData, Group) == 0x000068, "Member 'FRigUnit_FingerGripLoopApplyData::Group' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoopApplyData, RotationWeight) == 0x0000B8, "Member 'FRigUnit_FingerGripLoopApplyData::RotationWeight' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoopApplyData, Alpha) == 0x0000BC, "Member 'FRigUnit_FingerGripLoopApplyData::Alpha' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoopApplyData, ActiveSettingPreset) == 0x0000C0, "Member 'FRigUnit_FingerGripLoopApplyData::ActiveSettingPreset' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_FingerGripLoopSequentialTraceCacheData
// 0x0008 (0x0008 - 0x0000)
struct FRigUnit_FingerGripLoopSequentialTraceCacheData final
{
public:
	bool                                          bHit;                                              // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitTime;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_FingerGripLoopSequentialTraceCacheData) == 0x000004, "Wrong alignment on FRigUnit_FingerGripLoopSequentialTraceCacheData");
static_assert(sizeof(FRigUnit_FingerGripLoopSequentialTraceCacheData) == 0x000008, "Wrong size on FRigUnit_FingerGripLoopSequentialTraceCacheData");
static_assert(offsetof(FRigUnit_FingerGripLoopSequentialTraceCacheData, bHit) == 0x000000, "Member 'FRigUnit_FingerGripLoopSequentialTraceCacheData::bHit' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoopSequentialTraceCacheData, HitTime) == 0x000004, "Member 'FRigUnit_FingerGripLoopSequentialTraceCacheData::HitTime' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_FingerGripLoop
// 0x00F8 (0x0160 - 0x0068)
struct FRigUnit_FingerGripLoop final : public FRigUnit_FingersBaseMutable
{
public:
	int32                                         Index;                                             // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Continue;                                          // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigunitHandGripLoopGroup>      Groups;                                            // 0x0078(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          SkipTrace;                                         // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawTraceDebug;                                   // 0x0089(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSequentialDeferredTrace;                          // 0x008A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B[0x5];                                       // 0x008B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigunitHandGripLoopGroup              Group;                                             // 0x0090(0x0050)(NativeAccessSpecifierPublic)
	float                                         RotationWeight;                                    // 0x00E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceHit;                                         // 0x00E4(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SequentialTraceIndex;                              // 0x00E8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FRigUnit_FingerGripLoopSequentialTraceCacheData> SequentialHitCacheData;                            // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FControlRigExecuteContext              Completed;                                         // 0x0100(0x0060)(Edit, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_FingerGripLoop) == 0x000008, "Wrong alignment on FRigUnit_FingerGripLoop");
static_assert(sizeof(FRigUnit_FingerGripLoop) == 0x000160, "Wrong size on FRigUnit_FingerGripLoop");
static_assert(offsetof(FRigUnit_FingerGripLoop, Index) == 0x000068, "Member 'FRigUnit_FingerGripLoop::Index' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoop, Count) == 0x00006C, "Member 'FRigUnit_FingerGripLoop::Count' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoop, Continue) == 0x000070, "Member 'FRigUnit_FingerGripLoop::Continue' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoop, Groups) == 0x000078, "Member 'FRigUnit_FingerGripLoop::Groups' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoop, SkipTrace) == 0x000088, "Member 'FRigUnit_FingerGripLoop::SkipTrace' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoop, bDrawTraceDebug) == 0x000089, "Member 'FRigUnit_FingerGripLoop::bDrawTraceDebug' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoop, bSequentialDeferredTrace) == 0x00008A, "Member 'FRigUnit_FingerGripLoop::bSequentialDeferredTrace' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoop, Group) == 0x000090, "Member 'FRigUnit_FingerGripLoop::Group' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoop, RotationWeight) == 0x0000E0, "Member 'FRigUnit_FingerGripLoop::RotationWeight' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoop, bTraceHit) == 0x0000E4, "Member 'FRigUnit_FingerGripLoop::bTraceHit' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoop, SequentialTraceIndex) == 0x0000E8, "Member 'FRigUnit_FingerGripLoop::SequentialTraceIndex' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoop, SequentialHitCacheData) == 0x0000F0, "Member 'FRigUnit_FingerGripLoop::SequentialHitCacheData' has a wrong offset!");
static_assert(offsetof(FRigUnit_FingerGripLoop, Completed) == 0x000100, "Member 'FRigUnit_FingerGripLoop::Completed' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_FingersBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_FingersBase final : public FRigUnit
{
};
static_assert(alignof(FRigUnit_FingersBase) == 0x000008, "Wrong alignment on FRigUnit_FingersBase");
static_assert(sizeof(FRigUnit_FingersBase) == 0x000008, "Wrong size on FRigUnit_FingersBase");

// ScriptStruct PiecesAnimNodes.ActiveRootMotionData
// 0x0010 (0x0010 - 0x0000)
struct FActiveRootMotionData final
{
public:
	class UAnimationAsset*                        AnimSequence;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveRootMotionData) == 0x000008, "Wrong alignment on FActiveRootMotionData");
static_assert(sizeof(FActiveRootMotionData) == 0x000010, "Wrong size on FActiveRootMotionData");
static_assert(offsetof(FActiveRootMotionData, AnimSequence) == 0x000000, "Member 'FActiveRootMotionData::AnimSequence' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.PiecesAnimNode_AnimDynamics
// 0x0000 (0x0440 - 0x0440)
struct FPiecesAnimNode_AnimDynamics final : public FAnimNode_AnimDynamics
{
};
static_assert(alignof(FPiecesAnimNode_AnimDynamics) == 0x000010, "Wrong alignment on FPiecesAnimNode_AnimDynamics");
static_assert(sizeof(FPiecesAnimNode_AnimDynamics) == 0x000440, "Wrong size on FPiecesAnimNode_AnimDynamics");

// ScriptStruct PiecesAnimNodes.PiecesAnimNode_ApplyAdditive
// 0x0040 (0x0108 - 0x00C8)
struct FPiecesAnimNode_ApplyAdditive final : public FAnimNode_ApplyAdditive
{
public:
	TArray<struct FInputBlendPose>                LayerSetup;                                        // 0x00C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x10];                                      // 0x00D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  SkeletonGuid;                                      // 0x00E8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGuid                                  VirtualBoneGuid;                                   // 0x00F8(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
};
static_assert(alignof(FPiecesAnimNode_ApplyAdditive) == 0x000008, "Wrong alignment on FPiecesAnimNode_ApplyAdditive");
static_assert(sizeof(FPiecesAnimNode_ApplyAdditive) == 0x000108, "Wrong size on FPiecesAnimNode_ApplyAdditive");
static_assert(offsetof(FPiecesAnimNode_ApplyAdditive, LayerSetup) == 0x0000C8, "Member 'FPiecesAnimNode_ApplyAdditive::LayerSetup' has a wrong offset!");
static_assert(offsetof(FPiecesAnimNode_ApplyAdditive, SkeletonGuid) == 0x0000E8, "Member 'FPiecesAnimNode_ApplyAdditive::SkeletonGuid' has a wrong offset!");
static_assert(offsetof(FPiecesAnimNode_ApplyAdditive, VirtualBoneGuid) == 0x0000F8, "Member 'FPiecesAnimNode_ApplyAdditive::VirtualBoneGuid' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.PiecesAnimNode_DynamicsResetter
// 0x0090 (0x00A0 - 0x0010)
struct alignas(0x10) FPiecesAnimNode_DynamicsResetter final : public FAnimNode_Base
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0010(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         ReferenceBone;                                     // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	ETeleportType                                 TeleportType;                                      // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TeleportDistance;                                  // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x68];                                      // 0x0038(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPiecesAnimNode_DynamicsResetter) == 0x000010, "Wrong alignment on FPiecesAnimNode_DynamicsResetter");
static_assert(sizeof(FPiecesAnimNode_DynamicsResetter) == 0x0000A0, "Wrong size on FPiecesAnimNode_DynamicsResetter");
static_assert(offsetof(FPiecesAnimNode_DynamicsResetter, BasePose) == 0x000010, "Member 'FPiecesAnimNode_DynamicsResetter::BasePose' has a wrong offset!");
static_assert(offsetof(FPiecesAnimNode_DynamicsResetter, ReferenceBone) == 0x000020, "Member 'FPiecesAnimNode_DynamicsResetter::ReferenceBone' has a wrong offset!");
static_assert(offsetof(FPiecesAnimNode_DynamicsResetter, TeleportType) == 0x000030, "Member 'FPiecesAnimNode_DynamicsResetter::TeleportType' has a wrong offset!");
static_assert(offsetof(FPiecesAnimNode_DynamicsResetter, TeleportDistance) == 0x000034, "Member 'FPiecesAnimNode_DynamicsResetter::TeleportDistance' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.PiecesAnimNode_PoseRecorder
// 0x0038 (0x0048 - 0x0010)
struct FPiecesAnimNode_PoseRecorder final : public FAnimNode_Base
{
public:
	struct FPoseLink                              Source;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   PoseName;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          HasPose;                                           // 0x0040(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPiecesAnimNode_PoseRecorder) == 0x000008, "Wrong alignment on FPiecesAnimNode_PoseRecorder");
static_assert(sizeof(FPiecesAnimNode_PoseRecorder) == 0x000048, "Wrong size on FPiecesAnimNode_PoseRecorder");
static_assert(offsetof(FPiecesAnimNode_PoseRecorder, Source) == 0x000010, "Member 'FPiecesAnimNode_PoseRecorder::Source' has a wrong offset!");
static_assert(offsetof(FPiecesAnimNode_PoseRecorder, PoseName) == 0x000020, "Member 'FPiecesAnimNode_PoseRecorder::PoseName' has a wrong offset!");
static_assert(offsetof(FPiecesAnimNode_PoseRecorder, HasPose) == 0x000040, "Member 'FPiecesAnimNode_PoseRecorder::HasPose' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.PiecesRandomBlendSpacePlayerEntry
// 0x0008 (0x0008 - 0x0000)
struct FPiecesRandomBlendSpacePlayerEntry final
{
public:
	class UBlendSpaceBase*                        BlendSpace;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPiecesRandomBlendSpacePlayerEntry) == 0x000008, "Wrong alignment on FPiecesRandomBlendSpacePlayerEntry");
static_assert(sizeof(FPiecesRandomBlendSpacePlayerEntry) == 0x000008, "Wrong size on FPiecesRandomBlendSpacePlayerEntry");
static_assert(offsetof(FPiecesRandomBlendSpacePlayerEntry, BlendSpace) == 0x000000, "Member 'FPiecesRandomBlendSpacePlayerEntry::BlendSpace' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.PiecesAnimNode_RandomBlendSpacePlayer
// 0x0010 (0x0138 - 0x0128)
struct FPiecesAnimNode_RandomBlendSpacePlayer final : public FAnimNode_BlendSpacePlayer
{
public:
	TArray<struct FPiecesRandomBlendSpacePlayerEntry> BlendSpaces;                                       // 0x0128(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPiecesAnimNode_RandomBlendSpacePlayer) == 0x000008, "Wrong alignment on FPiecesAnimNode_RandomBlendSpacePlayer");
static_assert(sizeof(FPiecesAnimNode_RandomBlendSpacePlayer) == 0x000138, "Wrong size on FPiecesAnimNode_RandomBlendSpacePlayer");
static_assert(offsetof(FPiecesAnimNode_RandomBlendSpacePlayer, BlendSpaces) == 0x000128, "Member 'FPiecesAnimNode_RandomBlendSpacePlayer::BlendSpaces' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.PiecesRandomSequencePlayerEntry
// 0x0008 (0x0008 - 0x0000)
struct FPiecesRandomSequencePlayerEntry final
{
public:
	class UAnimSequenceBase*                      Sequence;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPiecesRandomSequencePlayerEntry) == 0x000008, "Wrong alignment on FPiecesRandomSequencePlayerEntry");
static_assert(sizeof(FPiecesRandomSequencePlayerEntry) == 0x000008, "Wrong size on FPiecesRandomSequencePlayerEntry");
static_assert(offsetof(FPiecesRandomSequencePlayerEntry, Sequence) == 0x000000, "Member 'FPiecesRandomSequencePlayerEntry::Sequence' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.PiecesAnimNode_RandomSequencePlayer
// 0x0010 (0x00C8 - 0x00B8)
struct FPiecesAnimNode_RandomSequencePlayer final : public FAnimNode_PiecesSequencePlayer
{
public:
	TArray<struct FPiecesRandomSequencePlayerEntry> Sequences;                                         // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPiecesAnimNode_RandomSequencePlayer) == 0x000008, "Wrong alignment on FPiecesAnimNode_RandomSequencePlayer");
static_assert(sizeof(FPiecesAnimNode_RandomSequencePlayer) == 0x0000C8, "Wrong size on FPiecesAnimNode_RandomSequencePlayer");
static_assert(offsetof(FPiecesAnimNode_RandomSequencePlayer, Sequences) == 0x0000B8, "Member 'FPiecesAnimNode_RandomSequencePlayer::Sequences' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.PiecesAnimNode_RigidBody
// 0x0010 (0x0860 - 0x0850)
struct FPiecesAnimNode_RigidBody final : public FAnimNode_RigidBody
{
public:
	uint8                                         Pad_850[0x10];                                     // 0x0850(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPiecesAnimNode_RigidBody) == 0x000010, "Wrong alignment on FPiecesAnimNode_RigidBody");
static_assert(sizeof(FPiecesAnimNode_RigidBody) == 0x000860, "Wrong size on FPiecesAnimNode_RigidBody");

// ScriptStruct PiecesAnimNodes.PiecesRootMotionData
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x10) FPiecesRootMotionData final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPiecesRootMotionData) == 0x000010, "Wrong alignment on FPiecesRootMotionData");
static_assert(sizeof(FPiecesRootMotionData) == 0x000050, "Wrong size on FPiecesRootMotionData");

// ScriptStruct PiecesAnimNodes.PiecesRootMotionMaskParams
// 0x0001 (0x0001 - 0x0000)
struct FPiecesRootMotionMaskParams final
{
public:
	uint8                                         X : 1;                                             // 0x0000(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Y : 1;                                             // 0x0000(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Z : 1;                                             // 0x0000(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Roll : 1;                                          // 0x0000(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pitch : 1;                                         // 0x0000(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Yaw : 1;                                           // 0x0000(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
};
static_assert(alignof(FPiecesRootMotionMaskParams) == 0x000001, "Wrong alignment on FPiecesRootMotionMaskParams");
static_assert(sizeof(FPiecesRootMotionMaskParams) == 0x000001, "Wrong size on FPiecesRootMotionMaskParams");

// ScriptStruct PiecesAnimNodes.RigUnit_ArcTrace
// 0x0060 (0x0068 - 0x0008)
struct FRigUnit_ArcTrace final : public FRigUnit
{
public:
	struct FVector                                Center;                                            // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Axis;                                              // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArcLength;                                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArcRadius;                                         // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TraceRadius;                                       // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             Channel;                                           // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHit;                                              // 0x003D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x0040(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x004C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ArcTrace) == 0x000008, "Wrong alignment on FRigUnit_ArcTrace");
static_assert(sizeof(FRigUnit_ArcTrace) == 0x000068, "Wrong size on FRigUnit_ArcTrace");
static_assert(offsetof(FRigUnit_ArcTrace, Center) == 0x000008, "Member 'FRigUnit_ArcTrace::Center' has a wrong offset!");
static_assert(offsetof(FRigUnit_ArcTrace, Start) == 0x000014, "Member 'FRigUnit_ArcTrace::Start' has a wrong offset!");
static_assert(offsetof(FRigUnit_ArcTrace, Axis) == 0x000020, "Member 'FRigUnit_ArcTrace::Axis' has a wrong offset!");
static_assert(offsetof(FRigUnit_ArcTrace, ArcLength) == 0x00002C, "Member 'FRigUnit_ArcTrace::ArcLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_ArcTrace, ArcRadius) == 0x000030, "Member 'FRigUnit_ArcTrace::ArcRadius' has a wrong offset!");
static_assert(offsetof(FRigUnit_ArcTrace, Segments) == 0x000034, "Member 'FRigUnit_ArcTrace::Segments' has a wrong offset!");
static_assert(offsetof(FRigUnit_ArcTrace, TraceRadius) == 0x000038, "Member 'FRigUnit_ArcTrace::TraceRadius' has a wrong offset!");
static_assert(offsetof(FRigUnit_ArcTrace, Channel) == 0x00003C, "Member 'FRigUnit_ArcTrace::Channel' has a wrong offset!");
static_assert(offsetof(FRigUnit_ArcTrace, bHit) == 0x00003D, "Member 'FRigUnit_ArcTrace::bHit' has a wrong offset!");
static_assert(offsetof(FRigUnit_ArcTrace, HitLocation) == 0x000040, "Member 'FRigUnit_ArcTrace::HitLocation' has a wrong offset!");
static_assert(offsetof(FRigUnit_ArcTrace, HitNormal) == 0x00004C, "Member 'FRigUnit_ArcTrace::HitNormal' has a wrong offset!");
static_assert(offsetof(FRigUnit_ArcTrace, Angle) == 0x000058, "Member 'FRigUnit_ArcTrace::Angle' has a wrong offset!");
static_assert(offsetof(FRigUnit_ArcTrace, Time) == 0x00005C, "Member 'FRigUnit_ArcTrace::Time' has a wrong offset!");
static_assert(offsetof(FRigUnit_ArcTrace, bDrawDebug) == 0x000060, "Member 'FRigUnit_ArcTrace::bDrawDebug' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_PiecesMathBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_PiecesMathBase : public FRigUnit
{
};
static_assert(alignof(FRigUnit_PiecesMathBase) == 0x000008, "Wrong alignment on FRigUnit_PiecesMathBase");
static_assert(sizeof(FRigUnit_PiecesMathBase) == 0x000008, "Wrong size on FRigUnit_PiecesMathBase");

// ScriptStruct PiecesAnimNodes.RigUnit_PiecesMathFloatBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_PiecesMathFloatBase : public FRigUnit_PiecesMathBase
{
};
static_assert(alignof(FRigUnit_PiecesMathFloatBase) == 0x000008, "Wrong alignment on FRigUnit_PiecesMathFloatBase");
static_assert(sizeof(FRigUnit_PiecesMathFloatBase) == 0x000008, "Wrong size on FRigUnit_PiecesMathFloatBase");

// ScriptStruct PiecesAnimNodes.RigUnit_PiecesFloatInterpolate
// 0x0018 (0x0020 - 0x0008)
struct FRigUnit_PiecesFloatInterpolate final : public FRigUnit_PiecesMathFloatBase
{
public:
	float                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         T;                                                 // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   Function;                                          // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Exponent;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Output;                                            // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PiecesFloatInterpolate) == 0x000008, "Wrong alignment on FRigUnit_PiecesFloatInterpolate");
static_assert(sizeof(FRigUnit_PiecesFloatInterpolate) == 0x000020, "Wrong size on FRigUnit_PiecesFloatInterpolate");
static_assert(offsetof(FRigUnit_PiecesFloatInterpolate, A) == 0x000008, "Member 'FRigUnit_PiecesFloatInterpolate::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesFloatInterpolate, B) == 0x00000C, "Member 'FRigUnit_PiecesFloatInterpolate::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesFloatInterpolate, T) == 0x000010, "Member 'FRigUnit_PiecesFloatInterpolate::T' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesFloatInterpolate, Function) == 0x000014, "Member 'FRigUnit_PiecesFloatInterpolate::Function' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesFloatInterpolate, Exponent) == 0x000018, "Member 'FRigUnit_PiecesFloatInterpolate::Exponent' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesFloatInterpolate, Output) == 0x00001C, "Member 'FRigUnit_PiecesFloatInterpolate::Output' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_PiecesFloatConstantInterpolation
// 0x0018 (0x0020 - 0x0008)
struct FRigUnit_PiecesFloatConstantInterpolation final : public FRigUnit_PiecesMathFloatBase
{
public:
	float                                         TargetValue;                                       // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialValue;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Output;                                            // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentValue;                                      // 0x0018(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_PiecesFloatConstantInterpolation) == 0x000008, "Wrong alignment on FRigUnit_PiecesFloatConstantInterpolation");
static_assert(sizeof(FRigUnit_PiecesFloatConstantInterpolation) == 0x000020, "Wrong size on FRigUnit_PiecesFloatConstantInterpolation");
static_assert(offsetof(FRigUnit_PiecesFloatConstantInterpolation, TargetValue) == 0x000008, "Member 'FRigUnit_PiecesFloatConstantInterpolation::TargetValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesFloatConstantInterpolation, InitialValue) == 0x00000C, "Member 'FRigUnit_PiecesFloatConstantInterpolation::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesFloatConstantInterpolation, Speed) == 0x000010, "Member 'FRigUnit_PiecesFloatConstantInterpolation::Speed' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesFloatConstantInterpolation, Output) == 0x000014, "Member 'FRigUnit_PiecesFloatConstantInterpolation::Output' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesFloatConstantInterpolation, CurrentValue) == 0x000018, "Member 'FRigUnit_PiecesFloatConstantInterpolation::CurrentValue' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_PiecesMathFloatCompare
// 0x0018 (0x0020 - 0x0008)
struct FRigUnit_PiecesMathFloatCompare final : public FRigUnit_PiecesMathFloatBase
{
public:
	float                                         A;                                                 // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Greater;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Equal;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lower;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Output;                                            // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PiecesMathFloatCompare) == 0x000008, "Wrong alignment on FRigUnit_PiecesMathFloatCompare");
static_assert(sizeof(FRigUnit_PiecesMathFloatCompare) == 0x000020, "Wrong size on FRigUnit_PiecesMathFloatCompare");
static_assert(offsetof(FRigUnit_PiecesMathFloatCompare, A) == 0x000008, "Member 'FRigUnit_PiecesMathFloatCompare::A' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathFloatCompare, B) == 0x00000C, "Member 'FRigUnit_PiecesMathFloatCompare::B' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathFloatCompare, Greater) == 0x000010, "Member 'FRigUnit_PiecesMathFloatCompare::Greater' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathFloatCompare, Equal) == 0x000014, "Member 'FRigUnit_PiecesMathFloatCompare::Equal' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathFloatCompare, Lower) == 0x000018, "Member 'FRigUnit_PiecesMathFloatCompare::Lower' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathFloatCompare, Output) == 0x00001C, "Member 'FRigUnit_PiecesMathFloatCompare::Output' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_PiecesMathFloatGate
// 0x0010 (0x0018 - 0x0008)
struct FRigUnit_PiecesMathFloatGate final : public FRigUnit_PiecesMathFloatBase
{
public:
	float                                         Input;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Threshold;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Output;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0014(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PiecesMathFloatGate) == 0x000008, "Wrong alignment on FRigUnit_PiecesMathFloatGate");
static_assert(sizeof(FRigUnit_PiecesMathFloatGate) == 0x000018, "Wrong size on FRigUnit_PiecesMathFloatGate");
static_assert(offsetof(FRigUnit_PiecesMathFloatGate, Input) == 0x000008, "Member 'FRigUnit_PiecesMathFloatGate::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathFloatGate, Threshold) == 0x00000C, "Member 'FRigUnit_PiecesMathFloatGate::Threshold' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathFloatGate, Output) == 0x000010, "Member 'FRigUnit_PiecesMathFloatGate::Output' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathFloatGate, Value) == 0x000014, "Member 'FRigUnit_PiecesMathFloatGate::Value' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_PiecesMathQuaternionBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_PiecesMathQuaternionBase : public FRigUnit_PiecesMathBase
{
};
static_assert(alignof(FRigUnit_PiecesMathQuaternionBase) == 0x000008, "Wrong alignment on FRigUnit_PiecesMathQuaternionBase");
static_assert(sizeof(FRigUnit_PiecesMathQuaternionBase) == 0x000008, "Wrong size on FRigUnit_PiecesMathQuaternionBase");

// ScriptStruct PiecesAnimNodes.RigUnit_PiecesMathQuatAccumulateLerp
// 0x0068 (0x0070 - 0x0008)
struct FRigUnit_PiecesMathQuatAccumulateLerp final : public FRigUnit_PiecesMathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  TargetValue;                                       // 0x0010(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  InitialValue;                                      // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Result;                                            // 0x0040(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  AccumulatedValue;                                  // 0x0050(0x0010)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIntegrateDeltaTime;                               // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConstantInterpolation;                            // 0x0061(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0xE];                                       // 0x0062(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_PiecesMathQuatAccumulateLerp) == 0x000010, "Wrong alignment on FRigUnit_PiecesMathQuatAccumulateLerp");
static_assert(sizeof(FRigUnit_PiecesMathQuatAccumulateLerp) == 0x000070, "Wrong size on FRigUnit_PiecesMathQuatAccumulateLerp");
static_assert(offsetof(FRigUnit_PiecesMathQuatAccumulateLerp, TargetValue) == 0x000010, "Member 'FRigUnit_PiecesMathQuatAccumulateLerp::TargetValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathQuatAccumulateLerp, InitialValue) == 0x000020, "Member 'FRigUnit_PiecesMathQuatAccumulateLerp::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathQuatAccumulateLerp, Speed) == 0x000030, "Member 'FRigUnit_PiecesMathQuatAccumulateLerp::Speed' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathQuatAccumulateLerp, Result) == 0x000040, "Member 'FRigUnit_PiecesMathQuatAccumulateLerp::Result' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathQuatAccumulateLerp, AccumulatedValue) == 0x000050, "Member 'FRigUnit_PiecesMathQuatAccumulateLerp::AccumulatedValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathQuatAccumulateLerp, bIntegrateDeltaTime) == 0x000060, "Member 'FRigUnit_PiecesMathQuatAccumulateLerp::bIntegrateDeltaTime' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathQuatAccumulateLerp, bConstantInterpolation) == 0x000061, "Member 'FRigUnit_PiecesMathQuatAccumulateLerp::bConstantInterpolation' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_PiecesMathQuatConstantInterpolation
// 0x0058 (0x0060 - 0x0008)
struct FRigUnit_PiecesMathQuatConstantInterpolation final : public FRigUnit_PiecesMathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  TargetValue;                                       // 0x0010(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  InitialValue;                                      // 0x0020(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Output;                                            // 0x0040(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  CurrentValue;                                      // 0x0050(0x0010)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PiecesMathQuatConstantInterpolation) == 0x000010, "Wrong alignment on FRigUnit_PiecesMathQuatConstantInterpolation");
static_assert(sizeof(FRigUnit_PiecesMathQuatConstantInterpolation) == 0x000060, "Wrong size on FRigUnit_PiecesMathQuatConstantInterpolation");
static_assert(offsetof(FRigUnit_PiecesMathQuatConstantInterpolation, TargetValue) == 0x000010, "Member 'FRigUnit_PiecesMathQuatConstantInterpolation::TargetValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathQuatConstantInterpolation, InitialValue) == 0x000020, "Member 'FRigUnit_PiecesMathQuatConstantInterpolation::InitialValue' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathQuatConstantInterpolation, Speed) == 0x000030, "Member 'FRigUnit_PiecesMathQuatConstantInterpolation::Speed' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathQuatConstantInterpolation, Output) == 0x000040, "Member 'FRigUnit_PiecesMathQuatConstantInterpolation::Output' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathQuatConstantInterpolation, CurrentValue) == 0x000050, "Member 'FRigUnit_PiecesMathQuatConstantInterpolation::CurrentValue' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_PiecesMathQuatGate
// 0x0058 (0x0060 - 0x0008)
struct FRigUnit_PiecesMathQuatGate final : public FRigUnit_PiecesMathQuaternionBase
{
public:
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Input;                                             // 0x0010(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         AngleDegreeThreshold;                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Output;                                            // 0x0030(0x0010)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FQuat                                  Value;                                             // 0x0040(0x0010)(Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ComparisonThreshold;                               // 0x0050(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousThreshold;                                 // 0x0054(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_PiecesMathQuatGate) == 0x000010, "Wrong alignment on FRigUnit_PiecesMathQuatGate");
static_assert(sizeof(FRigUnit_PiecesMathQuatGate) == 0x000060, "Wrong size on FRigUnit_PiecesMathQuatGate");
static_assert(offsetof(FRigUnit_PiecesMathQuatGate, Input) == 0x000010, "Member 'FRigUnit_PiecesMathQuatGate::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathQuatGate, AngleDegreeThreshold) == 0x000020, "Member 'FRigUnit_PiecesMathQuatGate::AngleDegreeThreshold' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathQuatGate, Output) == 0x000030, "Member 'FRigUnit_PiecesMathQuatGate::Output' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathQuatGate, Value) == 0x000040, "Member 'FRigUnit_PiecesMathQuatGate::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathQuatGate, ComparisonThreshold) == 0x000050, "Member 'FRigUnit_PiecesMathQuatGate::ComparisonThreshold' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathQuatGate, PreviousThreshold) == 0x000054, "Member 'FRigUnit_PiecesMathQuatGate::PreviousThreshold' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_PiecesMathVectorGate
// 0x0028 (0x0030 - 0x0008)
struct FRigUnit_PiecesMathVectorGate final : public FRigUnit_PiecesMathBase
{
public:
	struct FVector                                Input;                                             // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceThreshold;                                 // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Output;                                            // 0x0018(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Value;                                             // 0x0024(0x000C)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_PiecesMathVectorGate) == 0x000008, "Wrong alignment on FRigUnit_PiecesMathVectorGate");
static_assert(sizeof(FRigUnit_PiecesMathVectorGate) == 0x000030, "Wrong size on FRigUnit_PiecesMathVectorGate");
static_assert(offsetof(FRigUnit_PiecesMathVectorGate, Input) == 0x000008, "Member 'FRigUnit_PiecesMathVectorGate::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathVectorGate, DistanceThreshold) == 0x000014, "Member 'FRigUnit_PiecesMathVectorGate::DistanceThreshold' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathVectorGate, Output) == 0x000018, "Member 'FRigUnit_PiecesMathVectorGate::Output' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathVectorGate, Value) == 0x000024, "Member 'FRigUnit_PiecesMathVectorGate::Value' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_PiecesMathVectorBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_PiecesMathVectorBase : public FRigUnit_PiecesMathBase
{
};
static_assert(alignof(FRigUnit_PiecesMathVectorBase) == 0x000008, "Wrong alignment on FRigUnit_PiecesMathVectorBase");
static_assert(sizeof(FRigUnit_PiecesMathVectorBase) == 0x000008, "Wrong size on FRigUnit_PiecesMathVectorBase");

// ScriptStruct PiecesAnimNodes.RigUnit_PiecesMathVectorClampLength
// 0x0030 (0x0038 - 0x0008)
struct FRigUnit_PiecesMathVectorClampLength final : public FRigUnit_PiecesMathVectorBase
{
public:
	struct FRigElementKey                         TransformSpace;                                    // 0x0008(0x000C)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Value;                                             // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumLength;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumLength;                                     // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Result;                                            // 0x0028(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_PiecesMathVectorClampLength) == 0x000008, "Wrong alignment on FRigUnit_PiecesMathVectorClampLength");
static_assert(sizeof(FRigUnit_PiecesMathVectorClampLength) == 0x000038, "Wrong size on FRigUnit_PiecesMathVectorClampLength");
static_assert(offsetof(FRigUnit_PiecesMathVectorClampLength, TransformSpace) == 0x000008, "Member 'FRigUnit_PiecesMathVectorClampLength::TransformSpace' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathVectorClampLength, Value) == 0x000014, "Member 'FRigUnit_PiecesMathVectorClampLength::Value' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathVectorClampLength, MinimumLength) == 0x000020, "Member 'FRigUnit_PiecesMathVectorClampLength::MinimumLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathVectorClampLength, MaximumLength) == 0x000024, "Member 'FRigUnit_PiecesMathVectorClampLength::MaximumLength' has a wrong offset!");
static_assert(offsetof(FRigUnit_PiecesMathVectorClampLength, Result) == 0x000028, "Member 'FRigUnit_PiecesMathVectorClampLength::Result' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_CollectionTransformBaseMutable
// 0x0000 (0x0068 - 0x0068)
struct FRigUnit_CollectionTransformBaseMutable : public FRigUnit_HighlevelBaseMutable
{
};
static_assert(alignof(FRigUnit_CollectionTransformBaseMutable) == 0x000008, "Wrong alignment on FRigUnit_CollectionTransformBaseMutable");
static_assert(sizeof(FRigUnit_CollectionTransformBaseMutable) == 0x000068, "Wrong size on FRigUnit_CollectionTransformBaseMutable");

// ScriptStruct PiecesAnimNodes.RigUnit_SaveCollectionTransientData
// 0x0050 (0x0050 - 0x0000)
struct FRigUnit_SaveCollectionTransientData final
{
public:
	struct FRigElementKey                         Element;                                           // 0x0000(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ERigUnit_SaveCollectionTransformSpaceType     Space;                                             // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_SaveCollectionTransientData) == 0x000010, "Wrong alignment on FRigUnit_SaveCollectionTransientData");
static_assert(sizeof(FRigUnit_SaveCollectionTransientData) == 0x000050, "Wrong size on FRigUnit_SaveCollectionTransientData");
static_assert(offsetof(FRigUnit_SaveCollectionTransientData, Element) == 0x000000, "Member 'FRigUnit_SaveCollectionTransientData::Element' has a wrong offset!");
static_assert(offsetof(FRigUnit_SaveCollectionTransientData, Transform) == 0x000010, "Member 'FRigUnit_SaveCollectionTransientData::Transform' has a wrong offset!");
static_assert(offsetof(FRigUnit_SaveCollectionTransientData, Space) == 0x000040, "Member 'FRigUnit_SaveCollectionTransientData::Space' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_SaveCollectionTransformTransientDataCollection
// 0x0050 (0x0050 - 0x0000)
struct FRigUnit_SaveCollectionTransformTransientDataCollection final
{
public:
	TMap<struct FRigElementKey, struct FRigUnit_SaveCollectionTransientData> Entries;                                           // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SaveCollectionTransformTransientDataCollection) == 0x000008, "Wrong alignment on FRigUnit_SaveCollectionTransformTransientDataCollection");
static_assert(sizeof(FRigUnit_SaveCollectionTransformTransientDataCollection) == 0x000050, "Wrong size on FRigUnit_SaveCollectionTransformTransientDataCollection");
static_assert(offsetof(FRigUnit_SaveCollectionTransformTransientDataCollection, Entries) == 0x000000, "Member 'FRigUnit_SaveCollectionTransformTransientDataCollection::Entries' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_ApplyCollectionTransform
// 0x0058 (0x00C0 - 0x0068)
struct FRigUnit_ApplyCollectionTransform final : public FRigUnit_CollectionTransformBaseMutable
{
public:
	struct FRigUnit_SaveCollectionTransformTransientDataCollection Input;                                             // 0x0068(0x0050)(NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x00B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyLocation;                                    // 0x00B9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyRotation;                                    // 0x00BA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRigUnit_ApplyCollectionTransform) == 0x000008, "Wrong alignment on FRigUnit_ApplyCollectionTransform");
static_assert(sizeof(FRigUnit_ApplyCollectionTransform) == 0x0000C0, "Wrong size on FRigUnit_ApplyCollectionTransform");
static_assert(offsetof(FRigUnit_ApplyCollectionTransform, Input) == 0x000068, "Member 'FRigUnit_ApplyCollectionTransform::Input' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyCollectionTransform, bPropagateToChildren) == 0x0000B8, "Member 'FRigUnit_ApplyCollectionTransform::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyCollectionTransform, bApplyLocation) == 0x0000B9, "Member 'FRigUnit_ApplyCollectionTransform::bApplyLocation' has a wrong offset!");
static_assert(offsetof(FRigUnit_ApplyCollectionTransform, bApplyRotation) == 0x0000BA, "Member 'FRigUnit_ApplyCollectionTransform::bApplyRotation' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_SaveCollectionTransform
// 0x0068 (0x00D0 - 0x0068)
struct FRigUnit_SaveCollectionTransform final : public FRigUnit_CollectionTransformBaseMutable
{
public:
	struct FRigElementKeyCollection               Collection;                                        // 0x0068(0x0010)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERigUnit_SaveCollectionTransformSpaceType     Space;                                             // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTransformInitial;                                 // 0x0079(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRigUnit_SaveCollectionTransformTransientDataCollection SavedTransforms;                                   // 0x0080(0x0050)(Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SaveCollectionTransform) == 0x000008, "Wrong alignment on FRigUnit_SaveCollectionTransform");
static_assert(sizeof(FRigUnit_SaveCollectionTransform) == 0x0000D0, "Wrong size on FRigUnit_SaveCollectionTransform");
static_assert(offsetof(FRigUnit_SaveCollectionTransform, Collection) == 0x000068, "Member 'FRigUnit_SaveCollectionTransform::Collection' has a wrong offset!");
static_assert(offsetof(FRigUnit_SaveCollectionTransform, Space) == 0x000078, "Member 'FRigUnit_SaveCollectionTransform::Space' has a wrong offset!");
static_assert(offsetof(FRigUnit_SaveCollectionTransform, bTransformInitial) == 0x000079, "Member 'FRigUnit_SaveCollectionTransform::bTransformInitial' has a wrong offset!");
static_assert(offsetof(FRigUnit_SaveCollectionTransform, SavedTransforms) == 0x000080, "Member 'FRigUnit_SaveCollectionTransform::SavedTransforms' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_CollectionTransformBase
// 0x0000 (0x0008 - 0x0008)
struct FRigUnit_CollectionTransformBase final : public FRigUnit_HighlevelBase
{
};
static_assert(alignof(FRigUnit_CollectionTransformBase) == 0x000008, "Wrong alignment on FRigUnit_CollectionTransformBase");
static_assert(sizeof(FRigUnit_CollectionTransformBase) == 0x000008, "Wrong size on FRigUnit_CollectionTransformBase");

// ScriptStruct PiecesAnimNodes.RigunitSphereTraceExtraOptionsDebugSettings
// 0x0002 (0x0002 - 0x0000)
struct FRigunitSphereTraceExtraOptionsDebugSettings final
{
public:
	bool                                          bDrawDebug;                                        // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawInWorld;                                      // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigunitSphereTraceExtraOptionsDebugSettings) == 0x000001, "Wrong alignment on FRigunitSphereTraceExtraOptionsDebugSettings");
static_assert(sizeof(FRigunitSphereTraceExtraOptionsDebugSettings) == 0x000002, "Wrong size on FRigunitSphereTraceExtraOptionsDebugSettings");
static_assert(offsetof(FRigunitSphereTraceExtraOptionsDebugSettings, bDrawDebug) == 0x000000, "Member 'FRigunitSphereTraceExtraOptionsDebugSettings::bDrawDebug' has a wrong offset!");
static_assert(offsetof(FRigunitSphereTraceExtraOptionsDebugSettings, bDrawInWorld) == 0x000001, "Member 'FRigunitSphereTraceExtraOptionsDebugSettings::bDrawInWorld' has a wrong offset!");

// ScriptStruct PiecesAnimNodes.RigUnit_SphereTraceExtraOptions
// 0x0060 (0x0068 - 0x0008)
struct FRigUnit_SphereTraceExtraOptions final : public FRigUnit_HighlevelBase
{
public:
	struct FVector                                Start;                                             // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFlipDirection;                                    // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             Channel;                                           // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRigunitSphereTraceExtraOptionsDebugSettings DebugOptions;                                      // 0x0029(0x0002)(NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHit;                                              // 0x002B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x0038(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0044(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0050(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPenetrationOnStart;                               // 0x005C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PenetrationDepth;                                  // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRigUnit_SphereTraceExtraOptions) == 0x000008, "Wrong alignment on FRigUnit_SphereTraceExtraOptions");
static_assert(sizeof(FRigUnit_SphereTraceExtraOptions) == 0x000068, "Wrong size on FRigUnit_SphereTraceExtraOptions");
static_assert(offsetof(FRigUnit_SphereTraceExtraOptions, Start) == 0x000008, "Member 'FRigUnit_SphereTraceExtraOptions::Start' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceExtraOptions, End) == 0x000014, "Member 'FRigUnit_SphereTraceExtraOptions::End' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceExtraOptions, bFlipDirection) == 0x000020, "Member 'FRigUnit_SphereTraceExtraOptions::bFlipDirection' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceExtraOptions, Channel) == 0x000021, "Member 'FRigUnit_SphereTraceExtraOptions::Channel' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceExtraOptions, Radius) == 0x000024, "Member 'FRigUnit_SphereTraceExtraOptions::Radius' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceExtraOptions, bTraceComplex) == 0x000028, "Member 'FRigUnit_SphereTraceExtraOptions::bTraceComplex' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceExtraOptions, DebugOptions) == 0x000029, "Member 'FRigUnit_SphereTraceExtraOptions::DebugOptions' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceExtraOptions, bHit) == 0x00002B, "Member 'FRigUnit_SphereTraceExtraOptions::bHit' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceExtraOptions, HitLocation) == 0x00002C, "Member 'FRigUnit_SphereTraceExtraOptions::HitLocation' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceExtraOptions, HitNormal) == 0x000038, "Member 'FRigUnit_SphereTraceExtraOptions::HitNormal' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceExtraOptions, Location) == 0x000044, "Member 'FRigUnit_SphereTraceExtraOptions::Location' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceExtraOptions, Normal) == 0x000050, "Member 'FRigUnit_SphereTraceExtraOptions::Normal' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceExtraOptions, bPenetrationOnStart) == 0x00005C, "Member 'FRigUnit_SphereTraceExtraOptions::bPenetrationOnStart' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceExtraOptions, PenetrationDepth) == 0x000060, "Member 'FRigUnit_SphereTraceExtraOptions::PenetrationDepth' has a wrong offset!");
static_assert(offsetof(FRigUnit_SphereTraceExtraOptions, Time) == 0x000064, "Member 'FRigUnit_SphereTraceExtraOptions::Time' has a wrong offset!");

}

