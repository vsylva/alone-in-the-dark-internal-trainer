#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Flow

#include "Basic.hpp"

#include "Flow_classes.hpp"
#include "Flow_parameters.hpp"


namespace SDK
{

// Function Flow.FlowNode.GetClassDescription
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UObject>              Class_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlowNode::GetClassDescription(const TSubclassOf<class UObject> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlowNode", "GetClassDescription");

	Params::FlowNode_GetClassDescription Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.GetIdentityTagDescription
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlowNode::GetIdentityTagDescription(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlowNode", "GetIdentityTagDescription");

	Params::FlowNode_GetIdentityTagDescription Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.GetIdentityTagsDescription
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlowNode::GetIdentityTagsDescription(const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlowNode", "GetIdentityTagsDescription");

	Params::FlowNode_GetIdentityTagsDescription Parms{};

	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.GetNotifyTagsDescription
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlowNode::GetNotifyTagsDescription(const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlowNode", "GetNotifyTagsDescription");

	Params::FlowNode_GetNotifyTagsDescription Parms{};

	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.GetProgressAsString
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlowNode::GetProgressAsString(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FlowNode", "GetProgressAsString");

	Params::FlowNode_GetProgressAsString Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.Finish
// (Final, Native, Protected, BlueprintCallable)

void UFlowNode::Finish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "Finish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowNode.K2_Cleanup
// (Event, Protected, BlueprintEvent)

void UFlowNode::K2_Cleanup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "K2_Cleanup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flow.FlowNode.K2_ExecuteInput
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             PinName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowNode::K2_ExecuteInput(const class FName& PinName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "K2_ExecuteInput");

	Params::FlowNode_K2_ExecuteInput Parms{};

	Parms.PinName = PinName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Flow.FlowNode.K2_FlushContent
// (Event, Protected, BlueprintEvent)

void UFlowNode::K2_FlushContent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "K2_FlushContent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flow.FlowNode.K2_ForceFinishNode
// (Event, Protected, BlueprintEvent)

void UFlowNode::K2_ForceFinishNode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "K2_ForceFinishNode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flow.FlowNode.K2_GetActorToFocus
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UFlowNode::K2_GetActorToFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "K2_GetActorToFocus");

	Params::FlowNode_K2_GetActorToFocus Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.K2_GetAssetPath
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlowNode::K2_GetAssetPath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "K2_GetAssetPath");

	Params::FlowNode_K2_GetAssetPath Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.K2_GetAssetToEdit
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UFlowNode::K2_GetAssetToEdit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "K2_GetAssetToEdit");

	Params::FlowNode_K2_GetAssetToEdit Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.K2_InitializeInstance
// (Event, Protected, BlueprintEvent)

void UFlowNode::K2_InitializeInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "K2_InitializeInstance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flow.FlowNode.K2_PreloadContent
// (Event, Protected, BlueprintEvent)

void UFlowNode::K2_PreloadContent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "K2_PreloadContent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Flow.FlowNode.LoadInstance
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFlowNodeSaveData                NodeRecord                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFlowNode::LoadInstance(const struct FFlowNodeSaveData& NodeRecord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "LoadInstance");

	Params::FlowNode_LoadInstance Parms{};

	Parms.NodeRecord = std::move(NodeRecord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowNode.OnLoad
// (Native, Event, Protected, BlueprintEvent)

void UFlowNode::OnLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "OnLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowNode.OnSave
// (Native, Event, Protected, BlueprintEvent)

void UFlowNode::OnSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "OnSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowNode.SaveInstance
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFlowNodeSaveData                NodeRecord                                             (Parm, OutParm, NativeAccessSpecifierPublic)

void UFlowNode::SaveInstance(struct FFlowNodeSaveData* NodeRecord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "SaveInstance");

	Params::FlowNode_SaveInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NodeRecord != nullptr)
		*NodeRecord = std::move(Parms.NodeRecord);
}


// Function Flow.FlowNode.TriggerFirstOutput
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bFinish                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowNode::TriggerFirstOutput(const bool bFinish)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "TriggerFirstOutput");

	Params::FlowNode_TriggerFirstOutput Parms{};

	Parms.bFinish = bFinish;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowNode.TriggerOutput
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             PinName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFinish                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowNode::TriggerOutput(const class FName& PinName, const bool bFinish)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "TriggerOutput");

	Params::FlowNode_TriggerOutput Parms{};

	Parms.PinName = PinName;
	Parms.bFinish = bFinish;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowNode.GetFlowAsset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFlowAsset*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlowAsset* UFlowNode::GetFlowAsset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "GetFlowAsset");

	Params::FlowNode_GetFlowAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.GetFlowSubsystem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFlowSubsystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlowSubsystem* UFlowNode::GetFlowSubsystem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "GetFlowSubsystem");

	Params::FlowNode_GetFlowSubsystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.GetInputNames
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UFlowNode::GetInputNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "GetInputNames");

	Params::FlowNode_GetInputNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.GetOutputNames
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UFlowNode::GetOutputNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "GetOutputNames");

	Params::FlowNode_GetOutputNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.IsInputConnected
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             PinName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlowNode::IsInputConnected(const class FName& PinName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "IsInputConnected");

	Params::FlowNode_IsInputConnected Parms{};

	Parms.PinName = PinName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.IsOutputConnected
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             PinName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlowNode::IsOutputConnected(const class FName& PinName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "IsOutputConnected");

	Params::FlowNode_IsOutputConnected Parms{};

	Parms.PinName = PinName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.K2_CanUserAddInput
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlowNode::K2_CanUserAddInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "K2_CanUserAddInput");

	Params::FlowNode_K2_CanUserAddInput Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.K2_CanUserAddOutput
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlowNode::K2_CanUserAddOutput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "K2_CanUserAddOutput");

	Params::FlowNode_K2_CanUserAddOutput Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.K2_GetNodeDescription
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlowNode::K2_GetNodeDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "K2_GetNodeDescription");

	Params::FlowNode_K2_GetNodeDescription Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.K2_GetStatusString
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFlowNode::K2_GetStatusString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "K2_GetStatusString");

	Params::FlowNode_K2_GetStatusString Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Flow.FlowNode.LogError
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFlowOnScreenMessageType                OnScreenMessageType                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowNode::LogError(const class FString& Message, const EFlowOnScreenMessageType OnScreenMessageType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode", "LogError");

	Params::FlowNode_LogError Parms{};

	Parms.Message = std::move(Message);
	Parms.OnScreenMessageType = OnScreenMessageType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowNode_ComponentObserver.OnComponentRegistered
// (Native, Protected)
// Parameters:
// class UFlowComponent*                   Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowNode_ComponentObserver::OnComponentRegistered(class UFlowComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_ComponentObserver", "OnComponentRegistered");

	Params::FlowNode_ComponentObserver_OnComponentRegistered Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowNode_ComponentObserver.OnComponentTagAdded
// (Native, Protected, HasOutParams)
// Parameters:
// class UFlowComponent*                   Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            AddedTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFlowNode_ComponentObserver::OnComponentTagAdded(class UFlowComponent* Component, const struct FGameplayTagContainer& AddedTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_ComponentObserver", "OnComponentTagAdded");

	Params::FlowNode_ComponentObserver_OnComponentTagAdded Parms{};

	Parms.Component = Component;
	Parms.AddedTags = std::move(AddedTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowNode_ComponentObserver.OnComponentTagRemoved
// (Native, Protected, HasOutParams)
// Parameters:
// class UFlowComponent*                   Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            RemovedTags                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFlowNode_ComponentObserver::OnComponentTagRemoved(class UFlowComponent* Component, const struct FGameplayTagContainer& RemovedTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_ComponentObserver", "OnComponentTagRemoved");

	Params::FlowNode_ComponentObserver_OnComponentTagRemoved Parms{};

	Parms.Component = Component;
	Parms.RemovedTags = std::move(RemovedTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowNode_ComponentObserver.OnComponentUnregistered
// (Native, Protected)
// Parameters:
// class UFlowComponent*                   Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowNode_ComponentObserver::OnComponentUnregistered(class UFlowComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_ComponentObserver", "OnComponentUnregistered");

	Params::FlowNode_ComponentObserver_OnComponentUnregistered Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowNode_ComponentObserver.OnEventReceived
// (Native, Protected)

void UFlowNode_ComponentObserver::OnEventReceived()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_ComponentObserver", "OnEventReceived");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowAsset.IsBoundToWorld
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlowAsset::IsBoundToWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowAsset", "IsBoundToWorld");

	Params::FlowAsset_IsBoundToWorld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowAsset.LoadInstance
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFlowAssetSaveData               AssetRecord                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFlowAsset::LoadInstance(const struct FFlowAssetSaveData& AssetRecord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowAsset", "LoadInstance");

	Params::FlowAsset_LoadInstance Parms{};

	Parms.AssetRecord = std::move(AssetRecord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowAsset.OnLoad
// (Native, Event, Protected, BlueprintEvent)

void UFlowAsset::OnLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowAsset", "OnLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowAsset.OnSave
// (Native, Event, Protected, BlueprintEvent)

void UFlowAsset::OnSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowAsset", "OnSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowAsset.SaveInstance
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FFlowAssetSaveData>       SavedFlowInstances                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FFlowAssetSaveData               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FFlowAssetSaveData UFlowAsset::SaveInstance(TArray<struct FFlowAssetSaveData>* SavedFlowInstances)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowAsset", "SaveInstance");

	Params::FlowAsset_SaveInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SavedFlowInstances != nullptr)
		*SavedFlowInstances = std::move(Parms.SavedFlowInstances);

	return Parms.ReturnValue;
}


// Function Flow.FlowAsset.GetActiveNodes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UFlowNode*>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UFlowNode*> UFlowAsset::GetActiveNodes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowAsset", "GetActiveNodes");

	Params::FlowAsset_GetActiveNodes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowAsset.GetOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UFlowAsset::GetOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowAsset", "GetOwner");

	Params::FlowAsset_GetOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowAsset.GetRecordedNodes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UFlowNode*>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UFlowNode*> UFlowAsset::GetRecordedNodes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowAsset", "GetRecordedNodes");

	Params::FlowAsset_GetRecordedNodes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowAsset.IsActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlowAsset::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowAsset", "IsActive");

	Params::FlowAsset_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowComponent.AddIdentityTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFlowNetMode                            NetMode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowComponent::AddIdentityTag(const struct FGameplayTag& Tag, const EFlowNetMode NetMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "AddIdentityTag");

	Params::FlowComponent_AddIdentityTag Parms{};

	Parms.Tag = std::move(Tag);
	Parms.NetMode = NetMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.AddIdentityTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (Parm, NativeAccessSpecifierPublic)
// EFlowNetMode                            NetMode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowComponent::AddIdentityTags(const struct FGameplayTagContainer& Tags, const EFlowNetMode NetMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "AddIdentityTags");

	Params::FlowComponent_AddIdentityTags Parms{};

	Parms.Tags = std::move(Tags);
	Parms.NetMode = NetMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.BulkNotifyGraph
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            NotifyTags                                             (ConstParm, Parm, NativeAccessSpecifierPublic)
// EFlowNetMode                            NetMode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowComponent::BulkNotifyGraph(const struct FGameplayTagContainer& NotifyTags, const EFlowNetMode NetMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "BulkNotifyGraph");

	Params::FlowComponent_BulkNotifyGraph Parms{};

	Parms.NotifyTags = std::move(NotifyTags);
	Parms.NetMode = NetMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.FinishRootFlow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFlowFinishPolicy                       FinishPolicy                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowComponent::FinishRootFlow(const EFlowFinishPolicy FinishPolicy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "FinishRootFlow");

	Params::FlowComponent_FinishRootFlow Parms{};

	Parms.FinishPolicy = FinishPolicy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.GetRootFlowInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UFlowAsset*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlowAsset* UFlowComponent::GetRootFlowInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "GetRootFlowInstance");

	Params::FlowComponent_GetRootFlowInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowComponent.LoadInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlowComponent::LoadInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "LoadInstance");

	Params::FlowComponent_LoadInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowComponent.LoadRootFlow
// (Native, Public, BlueprintCallable)

void UFlowComponent::LoadRootFlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "LoadRootFlow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.NotifyActor
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ActorTag                                               (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     NotifyTag                                              (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFlowNetMode                            NetMode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowComponent::NotifyActor(const struct FGameplayTag& ActorTag, const struct FGameplayTag& NotifyTag, const EFlowNetMode NetMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "NotifyActor");

	Params::FlowComponent_NotifyActor Parms{};

	Parms.ActorTag = std::move(ActorTag);
	Parms.NotifyTag = std::move(NotifyTag);
	Parms.NetMode = NetMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.NotifyGraph
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NotifyTag                                              (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFlowNetMode                            NetMode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowComponent::NotifyGraph(const struct FGameplayTag& NotifyTag, const EFlowNetMode NetMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "NotifyGraph");

	Params::FlowComponent_NotifyGraph Parms{};

	Parms.NotifyTag = std::move(NotifyTag);
	Parms.NetMode = NetMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.OnLoad
// (Native, Event, Protected, BlueprintEvent)

void UFlowComponent::OnLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "OnLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.OnRep_AddedIdentityTags
// (Final, Native, Private)

void UFlowComponent::OnRep_AddedIdentityTags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "OnRep_AddedIdentityTags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.OnRep_NotifyTagsFromAnotherComponent
// (Final, Native, Private)

void UFlowComponent::OnRep_NotifyTagsFromAnotherComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "OnRep_NotifyTagsFromAnotherComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.OnRep_NotifyTagsFromGraph
// (Final, Native, Private)

void UFlowComponent::OnRep_NotifyTagsFromGraph()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "OnRep_NotifyTagsFromGraph");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.OnRep_RemovedIdentityTags
// (Final, Native, Private)

void UFlowComponent::OnRep_RemovedIdentityTags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "OnRep_RemovedIdentityTags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.OnRep_SentNotifyTags
// (Final, Native, Private)

void UFlowComponent::OnRep_SentNotifyTags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "OnRep_SentNotifyTags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.OnSave
// (Native, Event, Protected, BlueprintEvent)

void UFlowComponent::OnSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "OnSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.RemoveIdentityTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFlowNetMode                            NetMode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowComponent::RemoveIdentityTag(const struct FGameplayTag& Tag, const EFlowNetMode NetMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "RemoveIdentityTag");

	Params::FlowComponent_RemoveIdentityTag Parms{};

	Parms.Tag = std::move(Tag);
	Parms.NetMode = NetMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.RemoveIdentityTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (Parm, NativeAccessSpecifierPublic)
// EFlowNetMode                            NetMode                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowComponent::RemoveIdentityTags(const struct FGameplayTagContainer& Tags, const EFlowNetMode NetMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "RemoveIdentityTags");

	Params::FlowComponent_RemoveIdentityTags Parms{};

	Parms.Tags = std::move(Tags);
	Parms.NetMode = NetMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowComponent.SaveInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FFlowComponentSaveData           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FFlowComponentSaveData UFlowComponent::SaveInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "SaveInstance");

	Params::FlowComponent_SaveInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowComponent.SaveRootFlow
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FFlowAssetSaveData>       SavedFlowInstances                                     (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UFlowComponent::SaveRootFlow(TArray<struct FFlowAssetSaveData>* SavedFlowInstances)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "SaveRootFlow");

	Params::FlowComponent_SaveRootFlow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SavedFlowInstances != nullptr)
		*SavedFlowInstances = std::move(Parms.SavedFlowInstances);
}


// Function Flow.FlowComponent.StartRootFlow
// (Final, Native, Public, BlueprintCallable)

void UFlowComponent::StartRootFlow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowComponent", "StartRootFlow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowNode_ForceTriggerBase.K2_ForceTrigger
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// TArray<struct FFlowNodeSaveData>        InNodeRecords                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UFlowNode_ForceTriggerBase::K2_ForceTrigger(const TArray<struct FFlowNodeSaveData>& InNodeRecords) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_ForceTriggerBase", "K2_ForceTrigger");

	Params::FlowNode_ForceTriggerBase_K2_ForceTrigger Parms{};

	Parms.InNodeRecords = std::move(InNodeRecords);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowNode_ForceTriggerBase.K2_ShouldForceTrigger
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// TArray<struct FFlowNodeSaveData>        InNodeRecords                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFlowNode_ForceTriggerBase::K2_ShouldForceTrigger(const TArray<struct FFlowNodeSaveData>& InNodeRecords) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_ForceTriggerBase", "K2_ShouldForceTrigger");

	Params::FlowNode_ForceTriggerBase_K2_ShouldForceTrigger Parms{};

	Parms.InNodeRecords = std::move(InNodeRecords);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowNode_PlayLevelSequence.OnPlaybackFinished
// (Native, Protected)

void UFlowNode_PlayLevelSequence::OnPlaybackFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_PlayLevelSequence", "OnPlaybackFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowNode_Timer.OnCompletion
// (Final, Native, Private)

void UFlowNode_Timer::OnCompletion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_Timer", "OnCompletion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowNode_Timer.OnStep
// (Final, Native, Private)

void UFlowNode_Timer::OnStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_Timer", "OnStep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowSubsystem.FinishRootFlow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFlowFinishPolicy                       FinishPolicy                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowSubsystem::FinishRootFlow(class UObject* Owner, const EFlowFinishPolicy FinishPolicy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowSubsystem", "FinishRootFlow");

	Params::FlowSubsystem_FinishRootFlow Parms{};

	Parms.Owner = Owner;
	Parms.FinishPolicy = FinishPolicy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowSubsystem.OnGameLoaded
// (Native, Public, BlueprintCallable)
// Parameters:
// class UFlowSaveGame*                    SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowSubsystem::OnGameLoaded(class UFlowSaveGame* SaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowSubsystem", "OnGameLoaded");

	Params::FlowSubsystem_OnGameLoaded Parms{};

	Parms.SaveGame = SaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowSubsystem.OnGameSaved
// (Native, Public, BlueprintCallable)
// Parameters:
// class UFlowSaveGame*                    SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowSubsystem::OnGameSaved(class UFlowSaveGame* SaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowSubsystem", "OnGameSaved");

	Params::FlowSubsystem_OnGameSaved Parms{};

	Parms.SaveGame = SaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowSubsystem.StartRootFlow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFlowAsset*                       FlowAsset                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAllowMultipleInstances                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowSubsystem::StartRootFlow(class UObject* Owner, class UFlowAsset* FlowAsset, const bool bAllowMultipleInstances)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowSubsystem", "StartRootFlow");

	Params::FlowSubsystem_StartRootFlow Parms{};

	Parms.Owner = Owner;
	Parms.FlowAsset = FlowAsset;
	Parms.bAllowMultipleInstances = bAllowMultipleInstances;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Flow.FlowSubsystem.GetFlowActorsAndComponentsByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class AActor*, class UFlowComponent*>ReturnValue                                            (ExportObject, Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TMap<class AActor*, class UFlowComponent*> UFlowSubsystem::GetFlowActorsAndComponentsByTag(const struct FGameplayTag& Tag, const TSubclassOf<class AActor> ActorClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowSubsystem", "GetFlowActorsAndComponentsByTag");

	Params::FlowSubsystem_GetFlowActorsAndComponentsByTag Parms{};

	Parms.Tag = std::move(Tag);
	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowSubsystem.GetFlowActorsAndComponentsByTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, NativeAccessSpecifierPublic)
// EGameplayContainerMatchType             MatchType                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class AActor*, class UFlowComponent*>ReturnValue                                            (ExportObject, Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TMap<class AActor*, class UFlowComponent*> UFlowSubsystem::GetFlowActorsAndComponentsByTags(const struct FGameplayTagContainer& Tags, const EGameplayContainerMatchType MatchType, const TSubclassOf<class AActor> ActorClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowSubsystem", "GetFlowActorsAndComponentsByTags");

	Params::FlowSubsystem_GetFlowActorsAndComponentsByTags Parms{};

	Parms.Tags = std::move(Tags);
	Parms.MatchType = MatchType;
	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowSubsystem.GetFlowActorsByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<class AActor*>                     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<class AActor*> UFlowSubsystem::GetFlowActorsByTag(const struct FGameplayTag& Tag, const TSubclassOf<class AActor> ActorClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowSubsystem", "GetFlowActorsByTag");

	Params::FlowSubsystem_GetFlowActorsByTag Parms{};

	Parms.Tag = std::move(Tag);
	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowSubsystem.GetFlowActorsByTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, NativeAccessSpecifierPublic)
// EGameplayContainerMatchType             MatchType                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<class AActor*>                     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<class AActor*> UFlowSubsystem::GetFlowActorsByTags(const struct FGameplayTagContainer& Tags, const EGameplayContainerMatchType MatchType, const TSubclassOf<class AActor> ActorClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowSubsystem", "GetFlowActorsByTags");

	Params::FlowSubsystem_GetFlowActorsByTags Parms{};

	Parms.Tags = std::move(Tags);
	Parms.MatchType = MatchType;
	Parms.ActorClass = ActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowSubsystem.GetFlowComponentsByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UFlowComponent>       ComponentClass                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<class UFlowComponent*>             ReturnValue                                            (ExportObject, Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TSet<class UFlowComponent*> UFlowSubsystem::GetFlowComponentsByTag(const struct FGameplayTag& Tag, const TSubclassOf<class UFlowComponent> ComponentClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowSubsystem", "GetFlowComponentsByTag");

	Params::FlowSubsystem_GetFlowComponentsByTag Parms{};

	Parms.Tag = std::move(Tag);
	Parms.ComponentClass = ComponentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowSubsystem.GetFlowComponentsByTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, NativeAccessSpecifierPublic)
// EGameplayContainerMatchType             MatchType                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UFlowComponent>       ComponentClass                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<class UFlowComponent*>             ReturnValue                                            (ExportObject, Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TSet<class UFlowComponent*> UFlowSubsystem::GetFlowComponentsByTags(const struct FGameplayTagContainer& Tags, const EGameplayContainerMatchType MatchType, const TSubclassOf<class UFlowComponent> ComponentClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowSubsystem", "GetFlowComponentsByTags");

	Params::FlowSubsystem_GetFlowComponentsByTags Parms{};

	Parms.Tags = std::move(Tags);
	Parms.MatchType = MatchType;
	Parms.ComponentClass = ComponentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowSubsystem.GetInstancedSubFlows
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class UFlowNode_SubGraph*, class UFlowAsset*>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class UFlowNode_SubGraph*, class UFlowAsset*> UFlowSubsystem::GetInstancedSubFlows() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowSubsystem", "GetInstancedSubFlows");

	Params::FlowSubsystem_GetInstancedSubFlows Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowSubsystem.GetLoadedSaveGame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UFlowSaveGame*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlowSaveGame* UFlowSubsystem::GetLoadedSaveGame() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowSubsystem", "GetLoadedSaveGame");

	Params::FlowSubsystem_GetLoadedSaveGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowSubsystem.GetRootFlow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFlowAsset*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFlowAsset* UFlowSubsystem::GetRootFlow(class UObject* Owner) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowSubsystem", "GetRootFlow");

	Params::FlowSubsystem_GetRootFlow Parms{};

	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Flow.FlowSubsystem.GetRootInstances
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<class UObject*, class UFlowAsset*> ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class UObject*, class UFlowAsset*> UFlowSubsystem::GetRootInstances() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowSubsystem", "GetRootInstances");

	Params::FlowSubsystem_GetRootInstances Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

