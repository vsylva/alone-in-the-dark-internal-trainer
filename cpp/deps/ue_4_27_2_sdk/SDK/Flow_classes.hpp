#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Flow

#include "Basic.hpp"

#include "Flow_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "LevelSequence_structs.hpp"
#include "LevelSequence_classes.hpp"
#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "MovieSceneTracks_structs.hpp"
#include "MovieScene_structs.hpp"
#include "MovieScene_classes.hpp"
#include "DeveloperSettings_classes.hpp"


namespace SDK
{

// Class Flow.FlowNode
// 0x01A8 (0x01D0 - 0x0028)
class UFlowNode : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UEdGraphNode*                           GraphNode;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGuid                                  NodeGuid;                                          // 0x0038(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFlowPin>                       InputPins;                                         // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFlowPin>                       OutputPins;                                        // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FConnectedPin>       Connections;                                       // 0x0068(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0xF0];                                      // 0x00B8(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	EFlowNodeState                                ActivationState;                                   // 0x01A8(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A9[0x7];                                      // 0x01A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           InputNames;                                        // 0x01B0(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)
	TArray<class FName>                           OutputNames;                                       // 0x01C0(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPrivate)

public:
	static class FString GetClassDescription(const TSubclassOf<class UObject> Class_0);
	static class FString GetIdentityTagDescription(const struct FGameplayTag& Tag);
	static class FString GetIdentityTagsDescription(const struct FGameplayTagContainer& Tags);
	static class FString GetNotifyTagsDescription(const struct FGameplayTagContainer& Tags);
	static class FString GetProgressAsString(float Value);

	void Finish();
	void K2_Cleanup();
	void K2_ExecuteInput(const class FName& PinName);
	void K2_FlushContent();
	void K2_ForceFinishNode();
	class AActor* K2_GetActorToFocus();
	class FString K2_GetAssetPath();
	class UObject* K2_GetAssetToEdit();
	void K2_InitializeInstance();
	void K2_PreloadContent();
	void LoadInstance(const struct FFlowNodeSaveData& NodeRecord);
	void OnLoad();
	void OnSave();
	void SaveInstance(struct FFlowNodeSaveData* NodeRecord);
	void TriggerFirstOutput(const bool bFinish);
	void TriggerOutput(const class FName& PinName, const bool bFinish);

	class UFlowAsset* GetFlowAsset() const;
	class UFlowSubsystem* GetFlowSubsystem() const;
	TArray<class FName> GetInputNames() const;
	TArray<class FName> GetOutputNames() const;
	bool IsInputConnected(const class FName& PinName) const;
	bool IsOutputConnected(const class FName& PinName) const;
	bool K2_CanUserAddInput() const;
	bool K2_CanUserAddOutput() const;
	class FString K2_GetNodeDescription() const;
	class FString K2_GetStatusString() const;
	void LogError(const class FString& Message, const EFlowOnScreenMessageType OnScreenMessageType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode">();
	}
	static class UFlowNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode>();
	}
};
static_assert(alignof(UFlowNode) == 0x000008, "Wrong alignment on UFlowNode");
static_assert(sizeof(UFlowNode) == 0x0001D0, "Wrong size on UFlowNode");
static_assert(offsetof(UFlowNode, GraphNode) == 0x000030, "Member 'UFlowNode::GraphNode' has a wrong offset!");
static_assert(offsetof(UFlowNode, NodeGuid) == 0x000038, "Member 'UFlowNode::NodeGuid' has a wrong offset!");
static_assert(offsetof(UFlowNode, InputPins) == 0x000048, "Member 'UFlowNode::InputPins' has a wrong offset!");
static_assert(offsetof(UFlowNode, OutputPins) == 0x000058, "Member 'UFlowNode::OutputPins' has a wrong offset!");
static_assert(offsetof(UFlowNode, Connections) == 0x000068, "Member 'UFlowNode::Connections' has a wrong offset!");
static_assert(offsetof(UFlowNode, ActivationState) == 0x0001A8, "Member 'UFlowNode::ActivationState' has a wrong offset!");
static_assert(offsetof(UFlowNode, InputNames) == 0x0001B0, "Member 'UFlowNode::InputNames' has a wrong offset!");
static_assert(offsetof(UFlowNode, OutputNames) == 0x0001C0, "Member 'UFlowNode::OutputNames' has a wrong offset!");

// Class Flow.FlowNode_ComponentObserver
// 0x0088 (0x0258 - 0x01D0)
class UFlowNode_ComponentObserver : public UFlowNode
{
public:
	struct FGameplayTagContainer                  IdentityTags;                                      // 0x01D0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	EFlowTagContainerMatchType                    IdentityMatchType;                                 // 0x01F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F1[0x3];                                      // 0x01F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SuccessLimit;                                      // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SuccessCount;                                      // 0x01F8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC[0x54];                                     // 0x01FC(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           IdentityTag;                                       // 0x0250(0x0008)(Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnComponentRegistered(class UFlowComponent* Component);
	void OnComponentTagAdded(class UFlowComponent* Component, const struct FGameplayTagContainer& AddedTags);
	void OnComponentTagRemoved(class UFlowComponent* Component, const struct FGameplayTagContainer& RemovedTags);
	void OnComponentUnregistered(class UFlowComponent* Component);
	void OnEventReceived();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_ComponentObserver">();
	}
	static class UFlowNode_ComponentObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_ComponentObserver>();
	}
};
static_assert(alignof(UFlowNode_ComponentObserver) == 0x000008, "Wrong alignment on UFlowNode_ComponentObserver");
static_assert(sizeof(UFlowNode_ComponentObserver) == 0x000258, "Wrong size on UFlowNode_ComponentObserver");
static_assert(offsetof(UFlowNode_ComponentObserver, IdentityTags) == 0x0001D0, "Member 'UFlowNode_ComponentObserver::IdentityTags' has a wrong offset!");
static_assert(offsetof(UFlowNode_ComponentObserver, IdentityMatchType) == 0x0001F0, "Member 'UFlowNode_ComponentObserver::IdentityMatchType' has a wrong offset!");
static_assert(offsetof(UFlowNode_ComponentObserver, SuccessLimit) == 0x0001F4, "Member 'UFlowNode_ComponentObserver::SuccessLimit' has a wrong offset!");
static_assert(offsetof(UFlowNode_ComponentObserver, SuccessCount) == 0x0001F8, "Member 'UFlowNode_ComponentObserver::SuccessCount' has a wrong offset!");
static_assert(offsetof(UFlowNode_ComponentObserver, IdentityTag) == 0x000250, "Member 'UFlowNode_ComponentObserver::IdentityTag' has a wrong offset!");

// Class Flow.FlowAsset
// 0x01D8 (0x0200 - 0x0028)
class UFlowAsset final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGuid, class UFlowNode*>          Nodes;                                             // 0x0048(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class FName>                           CustomInputs;                                      // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FName>                           CustomOutputs;                                     // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UFlowAsset*>                     ActiveInstances;                                   // 0x00B8(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UFlowAsset*                             TemplateAsset;                                     // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0x60];                                      // 0x00D0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlowNode_Start*                        StartNode;                                         // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class UFlowNode_CustomInput*> CustomInputNodes;                                  // 0x0138(0x0050)(NativeAccessSpecifierPrivate)
	TSet<class UFlowNode*>                        PreloadedNodes;                                    // 0x0188(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class UFlowNode*>                      ActiveNodes;                                       // 0x01D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UFlowNode*>                      RecordedNodes;                                     // 0x01E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8[0x1];                                      // 0x01F8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsWorldBound;                                     // 0x01F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1FA[0x6];                                      // 0x01FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsBoundToWorld();
	void LoadInstance(const struct FFlowAssetSaveData& AssetRecord);
	void OnLoad();
	void OnSave();
	struct FFlowAssetSaveData SaveInstance(TArray<struct FFlowAssetSaveData>* SavedFlowInstances);

	TArray<class UFlowNode*> GetActiveNodes() const;
	class UObject* GetOwner() const;
	TArray<class UFlowNode*> GetRecordedNodes() const;
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowAsset">();
	}
	static class UFlowAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowAsset>();
	}
};
static_assert(alignof(UFlowAsset) == 0x000008, "Wrong alignment on UFlowAsset");
static_assert(sizeof(UFlowAsset) == 0x000200, "Wrong size on UFlowAsset");
static_assert(offsetof(UFlowAsset, Nodes) == 0x000048, "Member 'UFlowAsset::Nodes' has a wrong offset!");
static_assert(offsetof(UFlowAsset, CustomInputs) == 0x000098, "Member 'UFlowAsset::CustomInputs' has a wrong offset!");
static_assert(offsetof(UFlowAsset, CustomOutputs) == 0x0000A8, "Member 'UFlowAsset::CustomOutputs' has a wrong offset!");
static_assert(offsetof(UFlowAsset, ActiveInstances) == 0x0000B8, "Member 'UFlowAsset::ActiveInstances' has a wrong offset!");
static_assert(offsetof(UFlowAsset, TemplateAsset) == 0x0000C8, "Member 'UFlowAsset::TemplateAsset' has a wrong offset!");
static_assert(offsetof(UFlowAsset, StartNode) == 0x000130, "Member 'UFlowAsset::StartNode' has a wrong offset!");
static_assert(offsetof(UFlowAsset, CustomInputNodes) == 0x000138, "Member 'UFlowAsset::CustomInputNodes' has a wrong offset!");
static_assert(offsetof(UFlowAsset, PreloadedNodes) == 0x000188, "Member 'UFlowAsset::PreloadedNodes' has a wrong offset!");
static_assert(offsetof(UFlowAsset, ActiveNodes) == 0x0001D8, "Member 'UFlowAsset::ActiveNodes' has a wrong offset!");
static_assert(offsetof(UFlowAsset, RecordedNodes) == 0x0001E8, "Member 'UFlowAsset::RecordedNodes' has a wrong offset!");
static_assert(offsetof(UFlowAsset, bIsWorldBound) == 0x0001F9, "Member 'UFlowAsset::bIsWorldBound' has a wrong offset!");

// Class Flow.FlowNode_Counter
// 0x0008 (0x01D8 - 0x01D0)
class UFlowNode_Counter final : public UFlowNode
{
public:
	int32                                         Goal;                                              // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentSum;                                        // 0x01D4(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Counter">();
	}
	static class UFlowNode_Counter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Counter>();
	}
};
static_assert(alignof(UFlowNode_Counter) == 0x000008, "Wrong alignment on UFlowNode_Counter");
static_assert(sizeof(UFlowNode_Counter) == 0x0001D8, "Wrong size on UFlowNode_Counter");
static_assert(offsetof(UFlowNode_Counter, Goal) == 0x0001D0, "Member 'UFlowNode_Counter::Goal' has a wrong offset!");
static_assert(offsetof(UFlowNode_Counter, CurrentSum) == 0x0001D4, "Member 'UFlowNode_Counter::CurrentSum' has a wrong offset!");

// Class Flow.FlowComponent
// 0x0118 (0x01D0 - 0x00B8)
class UFlowComponent : public UActorComponent
{
public:
	struct FGameplayTagContainer                  IdentityTags;                                      // 0x00B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AddedIdentityTags;                                 // 0x00D8(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  RemovedIdentityTags;                               // 0x00F8(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnIdentityTagsAdded;                               // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIdentityTagsRemoved;                             // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  RecentlySentNotifyTags;                            // 0x0138(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_158[0x18];                                     // 0x0158(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  NotifyTagsFromGraph;                               // 0x0170(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             ReceiveNotify;                                     // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FNotifyTagReplication>          NotifyTagsFromAnotherComponent;                    // 0x01A0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	class UFlowAsset*                             RootFlow;                                          // 0x01B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoStartRootFlow;                                // 0x01B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFlowNetMode                                  RootFlowMode;                                      // 0x01B9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowMultipleInstances;                           // 0x01BA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BB[0x5];                                      // 0x01BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SavedAssetInstanceName;                            // 0x01C0(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddIdentityTag(const struct FGameplayTag& Tag, const EFlowNetMode NetMode);
	void AddIdentityTags(const struct FGameplayTagContainer& Tags, const EFlowNetMode NetMode);
	void BulkNotifyGraph(const struct FGameplayTagContainer& NotifyTags, const EFlowNetMode NetMode);
	void FinishRootFlow(const EFlowFinishPolicy FinishPolicy);
	class UFlowAsset* GetRootFlowInstance();
	bool LoadInstance();
	void LoadRootFlow();
	void NotifyActor(const struct FGameplayTag& ActorTag, const struct FGameplayTag& NotifyTag, const EFlowNetMode NetMode);
	void NotifyGraph(const struct FGameplayTag& NotifyTag, const EFlowNetMode NetMode);
	void OnLoad();
	void OnRep_AddedIdentityTags();
	void OnRep_NotifyTagsFromAnotherComponent();
	void OnRep_NotifyTagsFromGraph();
	void OnRep_RemovedIdentityTags();
	void OnRep_SentNotifyTags();
	void OnSave();
	void RemoveIdentityTag(const struct FGameplayTag& Tag, const EFlowNetMode NetMode);
	void RemoveIdentityTags(const struct FGameplayTagContainer& Tags, const EFlowNetMode NetMode);
	struct FFlowComponentSaveData SaveInstance();
	void SaveRootFlow(TArray<struct FFlowAssetSaveData>* SavedFlowInstances);
	void StartRootFlow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowComponent">();
	}
	static class UFlowComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowComponent>();
	}
};
static_assert(alignof(UFlowComponent) == 0x000008, "Wrong alignment on UFlowComponent");
static_assert(sizeof(UFlowComponent) == 0x0001D0, "Wrong size on UFlowComponent");
static_assert(offsetof(UFlowComponent, IdentityTags) == 0x0000B8, "Member 'UFlowComponent::IdentityTags' has a wrong offset!");
static_assert(offsetof(UFlowComponent, AddedIdentityTags) == 0x0000D8, "Member 'UFlowComponent::AddedIdentityTags' has a wrong offset!");
static_assert(offsetof(UFlowComponent, RemovedIdentityTags) == 0x0000F8, "Member 'UFlowComponent::RemovedIdentityTags' has a wrong offset!");
static_assert(offsetof(UFlowComponent, OnIdentityTagsAdded) == 0x000118, "Member 'UFlowComponent::OnIdentityTagsAdded' has a wrong offset!");
static_assert(offsetof(UFlowComponent, OnIdentityTagsRemoved) == 0x000128, "Member 'UFlowComponent::OnIdentityTagsRemoved' has a wrong offset!");
static_assert(offsetof(UFlowComponent, RecentlySentNotifyTags) == 0x000138, "Member 'UFlowComponent::RecentlySentNotifyTags' has a wrong offset!");
static_assert(offsetof(UFlowComponent, NotifyTagsFromGraph) == 0x000170, "Member 'UFlowComponent::NotifyTagsFromGraph' has a wrong offset!");
static_assert(offsetof(UFlowComponent, ReceiveNotify) == 0x000190, "Member 'UFlowComponent::ReceiveNotify' has a wrong offset!");
static_assert(offsetof(UFlowComponent, NotifyTagsFromAnotherComponent) == 0x0001A0, "Member 'UFlowComponent::NotifyTagsFromAnotherComponent' has a wrong offset!");
static_assert(offsetof(UFlowComponent, RootFlow) == 0x0001B0, "Member 'UFlowComponent::RootFlow' has a wrong offset!");
static_assert(offsetof(UFlowComponent, bAutoStartRootFlow) == 0x0001B8, "Member 'UFlowComponent::bAutoStartRootFlow' has a wrong offset!");
static_assert(offsetof(UFlowComponent, RootFlowMode) == 0x0001B9, "Member 'UFlowComponent::RootFlowMode' has a wrong offset!");
static_assert(offsetof(UFlowComponent, bAllowMultipleInstances) == 0x0001BA, "Member 'UFlowComponent::bAllowMultipleInstances' has a wrong offset!");
static_assert(offsetof(UFlowComponent, SavedAssetInstanceName) == 0x0001C0, "Member 'UFlowComponent::SavedAssetInstanceName' has a wrong offset!");

// Class Flow.FlowLevelSequenceActor
// 0x0000 (0x02D0 - 0x02D0)
class AFlowLevelSequenceActor final : public ALevelSequenceActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowLevelSequenceActor">();
	}
	static class AFlowLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlowLevelSequenceActor>();
	}
};
static_assert(alignof(AFlowLevelSequenceActor) == 0x000008, "Wrong alignment on AFlowLevelSequenceActor");
static_assert(sizeof(AFlowLevelSequenceActor) == 0x0002D0, "Wrong size on AFlowLevelSequenceActor");

// Class Flow.FlowLevelSequencePlayer
// 0x0008 (0x0608 - 0x0600)
class UFlowLevelSequencePlayer final : public ULevelSequencePlayer
{
public:
	class UFlowNode*                              FlowEventReceiver;                                 // 0x0600(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowLevelSequencePlayer">();
	}
	static class UFlowLevelSequencePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowLevelSequencePlayer>();
	}
};
static_assert(alignof(UFlowLevelSequencePlayer) == 0x000008, "Wrong alignment on UFlowLevelSequencePlayer");
static_assert(sizeof(UFlowLevelSequencePlayer) == 0x000608, "Wrong size on UFlowLevelSequencePlayer");
static_assert(offsetof(UFlowLevelSequencePlayer, FlowEventReceiver) == 0x000600, "Member 'UFlowLevelSequencePlayer::FlowEventReceiver' has a wrong offset!");

// Class Flow.FlowNode_Checkpoint
// 0x0000 (0x01D0 - 0x01D0)
class UFlowNode_Checkpoint final : public UFlowNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Checkpoint">();
	}
	static class UFlowNode_Checkpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Checkpoint>();
	}
};
static_assert(alignof(UFlowNode_Checkpoint) == 0x000008, "Wrong alignment on UFlowNode_Checkpoint");
static_assert(sizeof(UFlowNode_Checkpoint) == 0x0001D0, "Wrong size on UFlowNode_Checkpoint");

// Class Flow.FlowNode_CustomInput
// 0x0008 (0x01D8 - 0x01D0)
class UFlowNode_CustomInput final : public UFlowNode
{
public:
	class FName                                   EventName;                                         // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_CustomInput">();
	}
	static class UFlowNode_CustomInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_CustomInput>();
	}
};
static_assert(alignof(UFlowNode_CustomInput) == 0x000008, "Wrong alignment on UFlowNode_CustomInput");
static_assert(sizeof(UFlowNode_CustomInput) == 0x0001D8, "Wrong size on UFlowNode_CustomInput");
static_assert(offsetof(UFlowNode_CustomInput, EventName) == 0x0001D0, "Member 'UFlowNode_CustomInput::EventName' has a wrong offset!");

// Class Flow.FlowNode_CustomOutput
// 0x0008 (0x01D8 - 0x01D0)
class UFlowNode_CustomOutput final : public UFlowNode
{
public:
	class FName                                   EventName;                                         // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_CustomOutput">();
	}
	static class UFlowNode_CustomOutput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_CustomOutput>();
	}
};
static_assert(alignof(UFlowNode_CustomOutput) == 0x000008, "Wrong alignment on UFlowNode_CustomOutput");
static_assert(sizeof(UFlowNode_CustomOutput) == 0x0001D8, "Wrong size on UFlowNode_CustomOutput");
static_assert(offsetof(UFlowNode_CustomOutput, EventName) == 0x0001D0, "Member 'UFlowNode_CustomOutput::EventName' has a wrong offset!");

// Class Flow.FlowNode_ExecutionMultiGate
// 0x0020 (0x01F0 - 0x01D0)
class UFlowNode_ExecutionMultiGate final : public UFlowNode
{
public:
	bool                                          bRandom;                                           // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x01D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D2[0x2];                                      // 0x01D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartIndex;                                        // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextOutput;                                        // 0x01D8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DC[0x4];                                      // 0x01DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  Completed;                                         // 0x01E0(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_ExecutionMultiGate">();
	}
	static class UFlowNode_ExecutionMultiGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_ExecutionMultiGate>();
	}
};
static_assert(alignof(UFlowNode_ExecutionMultiGate) == 0x000008, "Wrong alignment on UFlowNode_ExecutionMultiGate");
static_assert(sizeof(UFlowNode_ExecutionMultiGate) == 0x0001F0, "Wrong size on UFlowNode_ExecutionMultiGate");
static_assert(offsetof(UFlowNode_ExecutionMultiGate, bRandom) == 0x0001D0, "Member 'UFlowNode_ExecutionMultiGate::bRandom' has a wrong offset!");
static_assert(offsetof(UFlowNode_ExecutionMultiGate, bLoop) == 0x0001D1, "Member 'UFlowNode_ExecutionMultiGate::bLoop' has a wrong offset!");
static_assert(offsetof(UFlowNode_ExecutionMultiGate, StartIndex) == 0x0001D4, "Member 'UFlowNode_ExecutionMultiGate::StartIndex' has a wrong offset!");
static_assert(offsetof(UFlowNode_ExecutionMultiGate, NextOutput) == 0x0001D8, "Member 'UFlowNode_ExecutionMultiGate::NextOutput' has a wrong offset!");
static_assert(offsetof(UFlowNode_ExecutionMultiGate, Completed) == 0x0001E0, "Member 'UFlowNode_ExecutionMultiGate::Completed' has a wrong offset!");

// Class Flow.FlowNode_ExecutionSequence
// 0x0000 (0x01D0 - 0x01D0)
class UFlowNode_ExecutionSequence final : public UFlowNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_ExecutionSequence">();
	}
	static class UFlowNode_ExecutionSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_ExecutionSequence>();
	}
};
static_assert(alignof(UFlowNode_ExecutionSequence) == 0x000008, "Wrong alignment on UFlowNode_ExecutionSequence");
static_assert(sizeof(UFlowNode_ExecutionSequence) == 0x0001D0, "Wrong size on UFlowNode_ExecutionSequence");

// Class Flow.FlowNode_Finish
// 0x0000 (0x01D0 - 0x01D0)
class UFlowNode_Finish final : public UFlowNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Finish">();
	}
	static class UFlowNode_Finish* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Finish>();
	}
};
static_assert(alignof(UFlowNode_Finish) == 0x000008, "Wrong alignment on UFlowNode_Finish");
static_assert(sizeof(UFlowNode_Finish) == 0x0001D0, "Wrong size on UFlowNode_Finish");

// Class Flow.FlowNode_ForceTriggerBase
// 0x0000 (0x01D0 - 0x01D0)
class UFlowNode_ForceTriggerBase : public UFlowNode
{
public:
	void K2_ForceTrigger(const TArray<struct FFlowNodeSaveData>& InNodeRecords) const;
	bool K2_ShouldForceTrigger(const TArray<struct FFlowNodeSaveData>& InNodeRecords) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_ForceTriggerBase">();
	}
	static class UFlowNode_ForceTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_ForceTriggerBase>();
	}
};
static_assert(alignof(UFlowNode_ForceTriggerBase) == 0x000008, "Wrong alignment on UFlowNode_ForceTriggerBase");
static_assert(sizeof(UFlowNode_ForceTriggerBase) == 0x0001D0, "Wrong size on UFlowNode_ForceTriggerBase");

// Class Flow.FlowNode_ForceTriggerActivate
// 0x0000 (0x01D0 - 0x01D0)
class UFlowNode_ForceTriggerActivate final : public UFlowNode_ForceTriggerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_ForceTriggerActivate">();
	}
	static class UFlowNode_ForceTriggerActivate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_ForceTriggerActivate>();
	}
};
static_assert(alignof(UFlowNode_ForceTriggerActivate) == 0x000008, "Wrong alignment on UFlowNode_ForceTriggerActivate");
static_assert(sizeof(UFlowNode_ForceTriggerActivate) == 0x0001D0, "Wrong size on UFlowNode_ForceTriggerActivate");

// Class Flow.FlowNode_Log
// 0x0020 (0x01F0 - 0x01D0)
class UFlowNode_Log final : public UFlowNode
{
public:
	class FString                                 Message;                                           // 0x01D0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EFlowLogVerbosity                             Verbosity;                                         // 0x01E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPrintToScreen;                                    // 0x01E1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E2[0x2];                                      // 0x01E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FColor                                 TextColor;                                         // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Log">();
	}
	static class UFlowNode_Log* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Log>();
	}
};
static_assert(alignof(UFlowNode_Log) == 0x000008, "Wrong alignment on UFlowNode_Log");
static_assert(sizeof(UFlowNode_Log) == 0x0001F0, "Wrong size on UFlowNode_Log");
static_assert(offsetof(UFlowNode_Log, Message) == 0x0001D0, "Member 'UFlowNode_Log::Message' has a wrong offset!");
static_assert(offsetof(UFlowNode_Log, Verbosity) == 0x0001E0, "Member 'UFlowNode_Log::Verbosity' has a wrong offset!");
static_assert(offsetof(UFlowNode_Log, bPrintToScreen) == 0x0001E1, "Member 'UFlowNode_Log::bPrintToScreen' has a wrong offset!");
static_assert(offsetof(UFlowNode_Log, Duration) == 0x0001E4, "Member 'UFlowNode_Log::Duration' has a wrong offset!");
static_assert(offsetof(UFlowNode_Log, TextColor) == 0x0001E8, "Member 'UFlowNode_Log::TextColor' has a wrong offset!");

// Class Flow.FlowNode_LogicalAND
// 0x0050 (0x0220 - 0x01D0)
class UFlowNode_LogicalAND final : public UFlowNode
{
public:
	TSet<class FName>                             ExecutedInputNames;                                // 0x01D0(0x0050)(SaveGame, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_LogicalAND">();
	}
	static class UFlowNode_LogicalAND* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_LogicalAND>();
	}
};
static_assert(alignof(UFlowNode_LogicalAND) == 0x000008, "Wrong alignment on UFlowNode_LogicalAND");
static_assert(sizeof(UFlowNode_LogicalAND) == 0x000220, "Wrong size on UFlowNode_LogicalAND");
static_assert(offsetof(UFlowNode_LogicalAND, ExecutedInputNames) == 0x0001D0, "Member 'UFlowNode_LogicalAND::ExecutedInputNames' has a wrong offset!");

// Class Flow.FlowNode_LogicalOR
// 0x0000 (0x01D0 - 0x01D0)
class UFlowNode_LogicalOR final : public UFlowNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_LogicalOR">();
	}
	static class UFlowNode_LogicalOR* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_LogicalOR>();
	}
};
static_assert(alignof(UFlowNode_LogicalOR) == 0x000008, "Wrong alignment on UFlowNode_LogicalOR");
static_assert(sizeof(UFlowNode_LogicalOR) == 0x0001D0, "Wrong size on UFlowNode_LogicalOR");

// Class Flow.FlowNode_NotifyActor
// 0x0058 (0x0228 - 0x01D0)
class UFlowNode_NotifyActor final : public UFlowNode
{
public:
	struct FGameplayTagContainer                  IdentityTags;                                      // 0x01D0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  NotifyTags;                                        // 0x01F0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	EFlowNetMode                                  NetMode;                                           // 0x0210(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           IdentityTag;                                       // 0x0214(0x0008)(Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           NotifyTag;                                         // 0x021C(0x0008)(Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_NotifyActor">();
	}
	static class UFlowNode_NotifyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_NotifyActor>();
	}
};
static_assert(alignof(UFlowNode_NotifyActor) == 0x000008, "Wrong alignment on UFlowNode_NotifyActor");
static_assert(sizeof(UFlowNode_NotifyActor) == 0x000228, "Wrong size on UFlowNode_NotifyActor");
static_assert(offsetof(UFlowNode_NotifyActor, IdentityTags) == 0x0001D0, "Member 'UFlowNode_NotifyActor::IdentityTags' has a wrong offset!");
static_assert(offsetof(UFlowNode_NotifyActor, NotifyTags) == 0x0001F0, "Member 'UFlowNode_NotifyActor::NotifyTags' has a wrong offset!");
static_assert(offsetof(UFlowNode_NotifyActor, NetMode) == 0x000210, "Member 'UFlowNode_NotifyActor::NetMode' has a wrong offset!");
static_assert(offsetof(UFlowNode_NotifyActor, IdentityTag) == 0x000214, "Member 'UFlowNode_NotifyActor::IdentityTag' has a wrong offset!");
static_assert(offsetof(UFlowNode_NotifyActor, NotifyTag) == 0x00021C, "Member 'UFlowNode_NotifyActor::NotifyTag' has a wrong offset!");

// Class Flow.FlowNode_OnActorRegistered
// 0x0000 (0x0258 - 0x0258)
class UFlowNode_OnActorRegistered final : public UFlowNode_ComponentObserver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_OnActorRegistered">();
	}
	static class UFlowNode_OnActorRegistered* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_OnActorRegistered>();
	}
};
static_assert(alignof(UFlowNode_OnActorRegistered) == 0x000008, "Wrong alignment on UFlowNode_OnActorRegistered");
static_assert(sizeof(UFlowNode_OnActorRegistered) == 0x000258, "Wrong size on UFlowNode_OnActorRegistered");

// Class Flow.FlowNode_OnActorUnregistered
// 0x0000 (0x0258 - 0x0258)
class UFlowNode_OnActorUnregistered final : public UFlowNode_ComponentObserver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_OnActorUnregistered">();
	}
	static class UFlowNode_OnActorUnregistered* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_OnActorUnregistered>();
	}
};
static_assert(alignof(UFlowNode_OnActorUnregistered) == 0x000008, "Wrong alignment on UFlowNode_OnActorUnregistered");
static_assert(sizeof(UFlowNode_OnActorUnregistered) == 0x000258, "Wrong size on UFlowNode_OnActorUnregistered");

// Class Flow.FlowNode_OnNotifyFromActor
// 0x0030 (0x0288 - 0x0258)
class UFlowNode_OnNotifyFromActor final : public UFlowNode_ComponentObserver
{
public:
	struct FGameplayTagContainer                  NotifyTags;                                        // 0x0258(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bRetroactive;                                      // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           NotifyTag;                                         // 0x027C(0x0008)(Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_OnNotifyFromActor">();
	}
	static class UFlowNode_OnNotifyFromActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_OnNotifyFromActor>();
	}
};
static_assert(alignof(UFlowNode_OnNotifyFromActor) == 0x000008, "Wrong alignment on UFlowNode_OnNotifyFromActor");
static_assert(sizeof(UFlowNode_OnNotifyFromActor) == 0x000288, "Wrong size on UFlowNode_OnNotifyFromActor");
static_assert(offsetof(UFlowNode_OnNotifyFromActor, NotifyTags) == 0x000258, "Member 'UFlowNode_OnNotifyFromActor::NotifyTags' has a wrong offset!");
static_assert(offsetof(UFlowNode_OnNotifyFromActor, bRetroactive) == 0x000278, "Member 'UFlowNode_OnNotifyFromActor::bRetroactive' has a wrong offset!");
static_assert(offsetof(UFlowNode_OnNotifyFromActor, NotifyTag) == 0x00027C, "Member 'UFlowNode_OnNotifyFromActor::NotifyTag' has a wrong offset!");

// Class Flow.FlowNode_PlayLevelSequence
// 0x0060 (0x0230 - 0x01D0)
class UFlowNode_PlayLevelSequence final : public UFlowNode
{
public:
	TSoftObjectPtr<class ULevelSequence>          Sequence;                                          // 0x01D0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMovieSceneSequencePlaybackSettings    PlaybackSettings;                                  // 0x01F8(0x0014)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bApplyOwnerTimeDilation;                           // 0x020C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLevelSequenceCameraSettings           CameraSettings;                                    // 0x020D(0x0002)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F[0x1];                                      // 0x020F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelSequence*                         LoadedSequence;                                    // 0x0210(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlowLevelSequencePlayer*               SequencePlayer;                                    // 0x0218(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_220[0x4];                                      // 0x0220(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x0224(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ElapsedTime;                                       // 0x0228(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeDilation;                                      // 0x022C(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlaybackFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_PlayLevelSequence">();
	}
	static class UFlowNode_PlayLevelSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_PlayLevelSequence>();
	}
};
static_assert(alignof(UFlowNode_PlayLevelSequence) == 0x000008, "Wrong alignment on UFlowNode_PlayLevelSequence");
static_assert(sizeof(UFlowNode_PlayLevelSequence) == 0x000230, "Wrong size on UFlowNode_PlayLevelSequence");
static_assert(offsetof(UFlowNode_PlayLevelSequence, Sequence) == 0x0001D0, "Member 'UFlowNode_PlayLevelSequence::Sequence' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, PlaybackSettings) == 0x0001F8, "Member 'UFlowNode_PlayLevelSequence::PlaybackSettings' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, bApplyOwnerTimeDilation) == 0x00020C, "Member 'UFlowNode_PlayLevelSequence::bApplyOwnerTimeDilation' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, CameraSettings) == 0x00020D, "Member 'UFlowNode_PlayLevelSequence::CameraSettings' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, LoadedSequence) == 0x000210, "Member 'UFlowNode_PlayLevelSequence::LoadedSequence' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, SequencePlayer) == 0x000218, "Member 'UFlowNode_PlayLevelSequence::SequencePlayer' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, StartTime) == 0x000224, "Member 'UFlowNode_PlayLevelSequence::StartTime' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, ElapsedTime) == 0x000228, "Member 'UFlowNode_PlayLevelSequence::ElapsedTime' has a wrong offset!");
static_assert(offsetof(UFlowNode_PlayLevelSequence, TimeDilation) == 0x00022C, "Member 'UFlowNode_PlayLevelSequence::TimeDilation' has a wrong offset!");

// Class Flow.FlowNode_Reroute
// 0x0000 (0x01D0 - 0x01D0)
class UFlowNode_Reroute final : public UFlowNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Reroute">();
	}
	static class UFlowNode_Reroute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Reroute>();
	}
};
static_assert(alignof(UFlowNode_Reroute) == 0x000008, "Wrong alignment on UFlowNode_Reroute");
static_assert(sizeof(UFlowNode_Reroute) == 0x0001D0, "Wrong size on UFlowNode_Reroute");

// Class Flow.FlowNode_Start
// 0x0000 (0x01D0 - 0x01D0)
class UFlowNode_Start final : public UFlowNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Start">();
	}
	static class UFlowNode_Start* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Start>();
	}
};
static_assert(alignof(UFlowNode_Start) == 0x000008, "Wrong alignment on UFlowNode_Start");
static_assert(sizeof(UFlowNode_Start) == 0x0001D0, "Wrong size on UFlowNode_Start");

// Class Flow.FlowNode_SubGraph
// 0x0038 (0x0208 - 0x01D0)
class UFlowNode_SubGraph final : public UFlowNode
{
public:
	TSoftObjectPtr<class UFlowAsset>              Asset;                                             // 0x01D0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SavedAssetInstanceName;                            // 0x01F8(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_SubGraph">();
	}
	static class UFlowNode_SubGraph* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_SubGraph>();
	}
};
static_assert(alignof(UFlowNode_SubGraph) == 0x000008, "Wrong alignment on UFlowNode_SubGraph");
static_assert(sizeof(UFlowNode_SubGraph) == 0x000208, "Wrong size on UFlowNode_SubGraph");
static_assert(offsetof(UFlowNode_SubGraph, Asset) == 0x0001D0, "Member 'UFlowNode_SubGraph::Asset' has a wrong offset!");
static_assert(offsetof(UFlowNode_SubGraph, SavedAssetInstanceName) == 0x0001F8, "Member 'UFlowNode_SubGraph::SavedAssetInstanceName' has a wrong offset!");

// Class Flow.FlowNode_Subroutine
// 0x0000 (0x01D0 - 0x01D0)
class UFlowNode_Subroutine final : public UFlowNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Subroutine">();
	}
	static class UFlowNode_Subroutine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Subroutine>();
	}
};
static_assert(alignof(UFlowNode_Subroutine) == 0x000008, "Wrong alignment on UFlowNode_Subroutine");
static_assert(sizeof(UFlowNode_Subroutine) == 0x0001D0, "Wrong size on UFlowNode_Subroutine");

// Class Flow.FlowNode_Timer
// 0x0028 (0x01F8 - 0x01D0)
class UFlowNode_Timer final : public UFlowNode
{
public:
	float                                         CompletionTime;                                    // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StepTime;                                          // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D8[0x10];                                     // 0x01D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SumOfSteps;                                        // 0x01E8(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RemainingCompletionTime;                           // 0x01EC(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RemainingStepTime;                                 // 0x01F0(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F4[0x4];                                      // 0x01F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCompletion();
	void OnStep();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Timer">();
	}
	static class UFlowNode_Timer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Timer>();
	}
};
static_assert(alignof(UFlowNode_Timer) == 0x000008, "Wrong alignment on UFlowNode_Timer");
static_assert(sizeof(UFlowNode_Timer) == 0x0001F8, "Wrong size on UFlowNode_Timer");
static_assert(offsetof(UFlowNode_Timer, CompletionTime) == 0x0001D0, "Member 'UFlowNode_Timer::CompletionTime' has a wrong offset!");
static_assert(offsetof(UFlowNode_Timer, StepTime) == 0x0001D4, "Member 'UFlowNode_Timer::StepTime' has a wrong offset!");
static_assert(offsetof(UFlowNode_Timer, SumOfSteps) == 0x0001E8, "Member 'UFlowNode_Timer::SumOfSteps' has a wrong offset!");
static_assert(offsetof(UFlowNode_Timer, RemainingCompletionTime) == 0x0001EC, "Member 'UFlowNode_Timer::RemainingCompletionTime' has a wrong offset!");
static_assert(offsetof(UFlowNode_Timer, RemainingStepTime) == 0x0001F0, "Member 'UFlowNode_Timer::RemainingStepTime' has a wrong offset!");

// Class Flow.FlowNodeBlueprint
// 0x0000 (0x00A0 - 0x00A0)
class UFlowNodeBlueprint final : public UBlueprint
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNodeBlueprint">();
	}
	static class UFlowNodeBlueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNodeBlueprint>();
	}
};
static_assert(alignof(UFlowNodeBlueprint) == 0x000008, "Wrong alignment on UFlowNodeBlueprint");
static_assert(sizeof(UFlowNodeBlueprint) == 0x0000A0, "Wrong size on UFlowNodeBlueprint");

// Class Flow.FlowSaveGame
// 0x0030 (0x0058 - 0x0028)
class UFlowSaveGame final : public USaveGame
{
public:
	class FString                                 SaveSlotName;                                      // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFlowComponentSaveData>         FlowComponents;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FFlowAssetSaveData>             FlowInstances;                                     // 0x0048(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowSaveGame">();
	}
	static class UFlowSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowSaveGame>();
	}
};
static_assert(alignof(UFlowSaveGame) == 0x000008, "Wrong alignment on UFlowSaveGame");
static_assert(sizeof(UFlowSaveGame) == 0x000058, "Wrong size on UFlowSaveGame");
static_assert(offsetof(UFlowSaveGame, SaveSlotName) == 0x000028, "Member 'UFlowSaveGame::SaveSlotName' has a wrong offset!");
static_assert(offsetof(UFlowSaveGame, FlowComponents) == 0x000038, "Member 'UFlowSaveGame::FlowComponents' has a wrong offset!");
static_assert(offsetof(UFlowSaveGame, FlowInstances) == 0x000048, "Member 'UFlowSaveGame::FlowInstances' has a wrong offset!");

// Class Flow.FlowSettings
// 0x0058 (0x0090 - 0x0038)
class UFlowSettings final : public UDeveloperSettings
{
public:
	bool                                          bCreateFlowSubsystemOnClients;                     // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSoftClassPtr<class UClass>, int32>      DefaultPreloadDepth;                               // 0x0040(0x0050)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowSettings">();
	}
	static class UFlowSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowSettings>();
	}
};
static_assert(alignof(UFlowSettings) == 0x000008, "Wrong alignment on UFlowSettings");
static_assert(sizeof(UFlowSettings) == 0x000090, "Wrong size on UFlowSettings");
static_assert(offsetof(UFlowSettings, bCreateFlowSubsystemOnClients) == 0x000038, "Member 'UFlowSettings::bCreateFlowSubsystemOnClients' has a wrong offset!");
static_assert(offsetof(UFlowSettings, DefaultPreloadDepth) == 0x000040, "Member 'UFlowSettings::DefaultPreloadDepth' has a wrong offset!");

// Class Flow.FlowSubsystem
// 0x0240 (0x0270 - 0x0030)
class UFlowSubsystem : public UGameInstanceSubsystem
{
public:
	TArray<class UFlowAsset*>                     InstancedTemplates;                                // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<TWeakObjectPtr<class UObject>, class UFlowAsset*> RootInstances;                                     // 0x0040(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class UFlowNode_SubGraph*, class UFlowAsset*> InstancedSubFlows;                                 // 0x0090(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0xE8];                                      // 0x00E0(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlowSaveGame*                          LoadedSaveGame;                                    // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnSaveGame;                                        // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E0[0x50];                                     // 0x01E0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnComponentRegistered;                             // 0x0230(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnComponentTagAdded;                               // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnComponentUnregistered;                           // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnComponentTagRemoved;                             // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void FinishRootFlow(class UObject* Owner, const EFlowFinishPolicy FinishPolicy);
	void OnGameLoaded(class UFlowSaveGame* SaveGame);
	void OnGameSaved(class UFlowSaveGame* SaveGame);
	void StartRootFlow(class UObject* Owner, class UFlowAsset* FlowAsset, const bool bAllowMultipleInstances);

	TMap<class AActor*, class UFlowComponent*> GetFlowActorsAndComponentsByTag(const struct FGameplayTag& Tag, const TSubclassOf<class AActor> ActorClass) const;
	TMap<class AActor*, class UFlowComponent*> GetFlowActorsAndComponentsByTags(const struct FGameplayTagContainer& Tags, const EGameplayContainerMatchType MatchType, const TSubclassOf<class AActor> ActorClass) const;
	TSet<class AActor*> GetFlowActorsByTag(const struct FGameplayTag& Tag, const TSubclassOf<class AActor> ActorClass) const;
	TSet<class AActor*> GetFlowActorsByTags(const struct FGameplayTagContainer& Tags, const EGameplayContainerMatchType MatchType, const TSubclassOf<class AActor> ActorClass) const;
	TSet<class UFlowComponent*> GetFlowComponentsByTag(const struct FGameplayTag& Tag, const TSubclassOf<class UFlowComponent> ComponentClass) const;
	TSet<class UFlowComponent*> GetFlowComponentsByTags(const struct FGameplayTagContainer& Tags, const EGameplayContainerMatchType MatchType, const TSubclassOf<class UFlowComponent> ComponentClass) const;
	TMap<class UFlowNode_SubGraph*, class UFlowAsset*> GetInstancedSubFlows() const;
	class UFlowSaveGame* GetLoadedSaveGame() const;
	class UFlowAsset* GetRootFlow(class UObject* Owner) const;
	TMap<class UObject*, class UFlowAsset*> GetRootInstances() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowSubsystem">();
	}
	static class UFlowSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowSubsystem>();
	}
};
static_assert(alignof(UFlowSubsystem) == 0x000008, "Wrong alignment on UFlowSubsystem");
static_assert(sizeof(UFlowSubsystem) == 0x000270, "Wrong size on UFlowSubsystem");
static_assert(offsetof(UFlowSubsystem, InstancedTemplates) == 0x000030, "Member 'UFlowSubsystem::InstancedTemplates' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, RootInstances) == 0x000040, "Member 'UFlowSubsystem::RootInstances' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, InstancedSubFlows) == 0x000090, "Member 'UFlowSubsystem::InstancedSubFlows' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, LoadedSaveGame) == 0x0001C8, "Member 'UFlowSubsystem::LoadedSaveGame' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, OnSaveGame) == 0x0001D0, "Member 'UFlowSubsystem::OnSaveGame' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, OnComponentRegistered) == 0x000230, "Member 'UFlowSubsystem::OnComponentRegistered' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, OnComponentTagAdded) == 0x000240, "Member 'UFlowSubsystem::OnComponentTagAdded' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, OnComponentUnregistered) == 0x000250, "Member 'UFlowSubsystem::OnComponentUnregistered' has a wrong offset!");
static_assert(offsetof(UFlowSubsystem, OnComponentTagRemoved) == 0x000260, "Member 'UFlowSubsystem::OnComponentTagRemoved' has a wrong offset!");

// Class Flow.FlowWorldSettings
// 0x0010 (0x03C8 - 0x03B8)
class AFlowWorldSettings final : public AWorldSettings
{
public:
	class UFlowComponent*                         FlowComponent;                                     // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFlowAsset*                             FlowAsset;                                         // 0x03C0(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowWorldSettings">();
	}
	static class AFlowWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlowWorldSettings>();
	}
};
static_assert(alignof(AFlowWorldSettings) == 0x000008, "Wrong alignment on AFlowWorldSettings");
static_assert(sizeof(AFlowWorldSettings) == 0x0003C8, "Wrong size on AFlowWorldSettings");
static_assert(offsetof(AFlowWorldSettings, FlowComponent) == 0x0003B8, "Member 'AFlowWorldSettings::FlowComponent' has a wrong offset!");
static_assert(offsetof(AFlowWorldSettings, FlowAsset) == 0x0003C0, "Member 'AFlowWorldSettings::FlowAsset' has a wrong offset!");

// Class Flow.MovieSceneFlowSectionBase
// 0x0000 (0x00E8 - 0x00E8)
class UMovieSceneFlowSectionBase : public UMovieSceneSection
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneFlowSectionBase">();
	}
	static class UMovieSceneFlowSectionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneFlowSectionBase>();
	}
};
static_assert(alignof(UMovieSceneFlowSectionBase) == 0x000008, "Wrong alignment on UMovieSceneFlowSectionBase");
static_assert(sizeof(UMovieSceneFlowSectionBase) == 0x0000E8, "Wrong size on UMovieSceneFlowSectionBase");

// Class Flow.MovieSceneFlowRepeaterSection
// 0x0010 (0x00F8 - 0x00E8)
class UMovieSceneFlowRepeaterSection final : public UMovieSceneFlowSectionBase
{
public:
	class FString                                 EventName;                                         // 0x00E8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneFlowRepeaterSection">();
	}
	static class UMovieSceneFlowRepeaterSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneFlowRepeaterSection>();
	}
};
static_assert(alignof(UMovieSceneFlowRepeaterSection) == 0x000008, "Wrong alignment on UMovieSceneFlowRepeaterSection");
static_assert(sizeof(UMovieSceneFlowRepeaterSection) == 0x0000F8, "Wrong size on UMovieSceneFlowRepeaterSection");
static_assert(offsetof(UMovieSceneFlowRepeaterSection, EventName) == 0x0000E8, "Member 'UMovieSceneFlowRepeaterSection::EventName' has a wrong offset!");

// Class Flow.MovieSceneFlowTrack
// 0x0020 (0x00B0 - 0x0090)
class UMovieSceneFlowTrack final : public UMovieSceneNameableTrack
{
public:
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bFireEventsWhenForwards : 1;                       // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bFireEventsWhenBackwards : 1;                      // 0x0098(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	EFireEventsAtPosition                         EventPosition;                                     // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x00A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneFlowTrack">();
	}
	static class UMovieSceneFlowTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneFlowTrack>();
	}
};
static_assert(alignof(UMovieSceneFlowTrack) == 0x000008, "Wrong alignment on UMovieSceneFlowTrack");
static_assert(sizeof(UMovieSceneFlowTrack) == 0x0000B0, "Wrong size on UMovieSceneFlowTrack");
static_assert(offsetof(UMovieSceneFlowTrack, EventPosition) == 0x00009C, "Member 'UMovieSceneFlowTrack::EventPosition' has a wrong offset!");
static_assert(offsetof(UMovieSceneFlowTrack, Sections) == 0x0000A0, "Member 'UMovieSceneFlowTrack::Sections' has a wrong offset!");

// Class Flow.MovieSceneFlowTriggerSection
// 0x00A0 (0x0188 - 0x00E8)
class UMovieSceneFlowTriggerSection final : public UMovieSceneFlowSectionBase
{
public:
	struct FMovieSceneStringChannel               StringChannel;                                     // 0x00E8(0x00A0)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneFlowTriggerSection">();
	}
	static class UMovieSceneFlowTriggerSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneFlowTriggerSection>();
	}
};
static_assert(alignof(UMovieSceneFlowTriggerSection) == 0x000008, "Wrong alignment on UMovieSceneFlowTriggerSection");
static_assert(sizeof(UMovieSceneFlowTriggerSection) == 0x000188, "Wrong size on UMovieSceneFlowTriggerSection");
static_assert(offsetof(UMovieSceneFlowTriggerSection, StringChannel) == 0x0000E8, "Member 'UMovieSceneFlowTriggerSection::StringChannel' has a wrong offset!");

}

