#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PiecesSequence

#include "Basic.hpp"

#include "PiecesSequence_classes.hpp"
#include "PiecesSequence_parameters.hpp"


namespace SDK
{

// Function PiecesSequence.PiecesLevelSequenceActor.OnCameraCutHandler
// (Final, Native, Private)
// Parameters:
// class UCameraComponent*                 CameraComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APiecesLevelSequenceActor::OnCameraCutHandler(class UCameraComponent* CameraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequenceActor", "OnCameraCutHandler");

	Params::PiecesLevelSequenceActor_OnCameraCutHandler Parms{};

	Parms.CameraComponent = CameraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesLevelSequenceActor.OnSequenceFinished
// (Native, Protected)

void APiecesLevelSequenceActor::OnSequenceFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequenceActor", "OnSequenceFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesLevelSequenceActor.OnSequenceSkipped
// (Native, Protected)
// Parameters:
// class UPiecesLevelSequencePlayer*       SkippingSequencePlayer                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APiecesLevelSequenceActor::OnSequenceSkipped(class UPiecesLevelSequencePlayer* SkippingSequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequenceActor", "OnSequenceSkipped");

	Params::PiecesLevelSequenceActor_OnSequenceSkipped Parms{};

	Parms.SkippingSequencePlayer = SkippingSequencePlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesLevelSequenceActor.Play
// (Native, Public, BlueprintCallable)

void APiecesLevelSequenceActor::Play()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequenceActor", "Play");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesLevelSequenceActor.PreAutoPlay
// (Final, Native, Public)

void APiecesLevelSequenceActor::PreAutoPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequenceActor", "PreAutoPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesLevelSequenceActor.GetFirstMetaData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UPiecesSequenceMetaData>MetaDataClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UPiecesSequenceMetaData*    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UPiecesSequenceMetaData* APiecesLevelSequenceActor::GetFirstMetaData(TSubclassOf<class UPiecesSequenceMetaData> MetaDataClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequenceActor", "GetFirstMetaData");

	Params::PiecesLevelSequenceActor_GetFirstMetaData Parms{};

	Parms.MetaDataClass = MetaDataClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PiecesSequence.PiecesLevelSequenceActor.GetMetadata
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UPiecesSequenceMetaData>MetaDataClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPiecesSequenceMetaData*>  OutMetaData                                            (ConstParm, Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APiecesLevelSequenceActor::GetMetadata(TSubclassOf<class UPiecesSequenceMetaData> MetaDataClass, const TArray<class UPiecesSequenceMetaData*>* OutMetaData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequenceActor", "GetMetadata");

	Params::PiecesLevelSequenceActor_GetMetadata Parms{};

	Parms.MetaDataClass = MetaDataClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMetaData != nullptr)
		*OutMetaData = std::move(Parms.OutMetaData);

	return Parms.ReturnValue;
}


// Function PiecesSequence.PiecesLevelSequenceActor.TeleportPlayer
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UPiecesSequenceMetadataGoalLocation*GoalLocationMetadata                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APiecesLevelSequenceActor::TeleportPlayer(const class UPiecesSequenceMetadataGoalLocation* GoalLocationMetadata) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequenceActor", "TeleportPlayer");

	Params::PiecesLevelSequenceActor_TeleportPlayer Parms{};

	Parms.GoalLocationMetadata = GoalLocationMetadata;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.InteractiveLevelSequenceActor.InteractiveSegmentStarted
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   SegmentNumber                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractiveLevelSequenceActor::InteractiveSegmentStarted(int32 SegmentNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveLevelSequenceActor", "InteractiveSegmentStarted");

	Params::InteractiveLevelSequenceActor_InteractiveSegmentStarted Parms{};

	Parms.SegmentNumber = SegmentNumber;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PiecesSequence.InteractiveLevelSequenceActor.InteractiveSegmentTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractiveLevelSequenceActor::InteractiveSegmentTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveLevelSequenceActor", "InteractiveSegmentTick");

	Params::InteractiveLevelSequenceActor_InteractiveSegmentTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PiecesSequence.InteractiveLevelSequenceActor.OnSequenceObjectSpawned
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovieSceneEvaluationOperand     Operand                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AInteractiveLevelSequenceActor::OnSequenceObjectSpawned(class UObject* Object, const struct FMovieSceneEvaluationOperand& Operand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveLevelSequenceActor", "OnSequenceObjectSpawned");

	Params::InteractiveLevelSequenceActor_OnSequenceObjectSpawned Parms{};

	Parms.Object = Object;
	Parms.Operand = std::move(Operand);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.InteractiveLevelSequenceActor.StartNextSection
// (Final, Native, Protected, BlueprintCallable)

void AInteractiveLevelSequenceActor::StartNextSection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveLevelSequenceActor", "StartNextSection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.InteractiveLevelSequenceActor.CanActivateInteractiveSegment
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   SectionNumber                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractiveLevelSequenceActor::CanActivateInteractiveSegment(int32 SectionNumber) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveLevelSequenceActor", "CanActivateInteractiveSegment");

	Params::InteractiveLevelSequenceActor_CanActivateInteractiveSegment Parms{};

	Parms.SectionNumber = SectionNumber;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function PiecesSequence.InteractiveLevelSequenceActor.GetLevelSequenceAsSoftObject
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class ULevelSequence>    ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class ULevelSequence> AInteractiveLevelSequenceActor::GetLevelSequenceAsSoftObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveLevelSequenceActor", "GetLevelSequenceAsSoftObject");

	Params::InteractiveLevelSequenceActor_GetLevelSequenceAsSoftObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PiecesSequence.InteractiveLevelSequenceActor.GetSectionSequenceData
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   SectionNumber                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInteractiveSequenceSegment      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInteractiveSequenceSegment AInteractiveLevelSequenceActor::GetSectionSequenceData(int32 SectionNumber) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveLevelSequenceActor", "GetSectionSequenceData");

	Params::InteractiveLevelSequenceActor_GetSectionSequenceData Parms{};

	Parms.SectionNumber = SectionNumber;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function PiecesSequence.InteractiveLevelSequenceActor.HasSection
// (Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   SectionNumber                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AInteractiveLevelSequenceActor::HasSection(int32 SectionNumber) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveLevelSequenceActor", "HasSection");

	Params::InteractiveLevelSequenceActor_HasSection Parms{};

	Parms.SectionNumber = SectionNumber;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function PiecesSequence.InteractiveSequenceCameraModifier.GetBlendValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractiveSequenceCameraModifier::GetBlendValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractiveSequenceCameraModifier", "GetBlendValue");

	Params::InteractiveSequenceCameraModifier_GetBlendValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PiecesSequence.PiecesCutsceneWidget.BeginAutoDestroy
// (Final, Native, Public, BlueprintCallable)

void UPiecesCutsceneWidget::BeginAutoDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesCutsceneWidget", "BeginAutoDestroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesCutsceneWidget.ListenForInputSequence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ActionNames                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UPiecesCutsceneWidget::ListenForInputSequence(const TArray<class FName>& ActionNames, EInputEvent EventType, bool bConsume, TDelegate<void()> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesCutsceneWidget", "ListenForInputSequence");

	Params::PiecesCutsceneWidget_ListenForInputSequence Parms{};

	Parms.ActionNames = std::move(ActionNames);
	Parms.EventType = EventType;
	Parms.bConsume = bConsume;
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesCutsceneWidget.OnAutoDestroy
// (Final, Native, Protected)

void UPiecesCutsceneWidget::OnAutoDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesCutsceneWidget", "OnAutoDestroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesCutsceneWidget.OnSkipCutscene
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bPressed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPiecesCutsceneWidget::OnSkipCutscene(bool bPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesCutsceneWidget", "OnSkipCutscene");

	Params::PiecesCutsceneWidget_OnSkipCutscene Parms{};

	Parms.bPressed = bPressed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PiecesSequence.PiecesCutsceneWidget.SetFadeToBlackOnSkip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPiecesCutsceneWidget::SetFadeToBlackOnSkip(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesCutsceneWidget", "SetFadeToBlackOnSkip");

	Params::PiecesCutsceneWidget_SetFadeToBlackOnSkip Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesCutsceneWidget.SetupInput
// (Final, Native, Public, BlueprintCallable)

void UPiecesCutsceneWidget::SetupInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesCutsceneWidget", "SetupInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesCutsceneWidget.SkipCutsceneActionHandler
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FInputActionValue                InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPiecesCutsceneWidget::SkipCutsceneActionHandler(const struct FInputActionValue& InputActionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesCutsceneWidget", "SkipCutsceneActionHandler");

	Params::PiecesCutsceneWidget_SkipCutsceneActionHandler Parms{};

	Parms.InputActionValue = std::move(InputActionValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesCutsceneWidget.StartFadingOutBlackScreen
// (Event, Public, BlueprintEvent)

void UPiecesCutsceneWidget::StartFadingOutBlackScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesCutsceneWidget", "StartFadingOutBlackScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PiecesSequence.PiecesCutsceneWidget.UseFadeOutBlackScreen
// (Event, Public, BlueprintEvent)

void UPiecesCutsceneWidget::UseFadeOutBlackScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesCutsceneWidget", "UseFadeOutBlackScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function PiecesSequence.PiecesCutsceneWidget.IsAutoDestroyActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPiecesCutsceneWidget::IsAutoDestroyActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesCutsceneWidget", "IsAutoDestroyActive");

	Params::PiecesCutsceneWidget_IsAutoDestroyActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PiecesSequence.PiecesLevelSequenceDirector.EndInteractiveSequenceModifier
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UInteractiveSequenceModifier*     Modifier                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPiecesLevelSequenceDirector::EndInteractiveSequenceModifier(class UInteractiveSequenceModifier* Modifier, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequenceDirector", "EndInteractiveSequenceModifier");

	Params::PiecesLevelSequenceDirector_EndInteractiveSequenceModifier Parms{};

	Parms.Modifier = Modifier;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesLevelSequenceDirector.StartInteractiveSequenceModifier
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UInteractiveSequenceModifier*     Modifier                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPiecesLevelSequenceDirector::StartInteractiveSequenceModifier(class UInteractiveSequenceModifier* Modifier, class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequenceDirector", "StartInteractiveSequenceModifier");

	Params::PiecesLevelSequenceDirector_StartInteractiveSequenceModifier Parms{};

	Parms.Modifier = Modifier;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesLevelSequenceDirector.TriggerSequenceNotify
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     EventTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPiecesLevelSequenceDirector::TriggerSequenceNotify(const struct FGameplayTag& EventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequenceDirector", "TriggerSequenceNotify");

	Params::PiecesLevelSequenceDirector_TriggerSequenceNotify Parms{};

	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesLevelSequenceDirector.GetSequencePlayer
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPiecesLevelSequencePlayer*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPiecesLevelSequencePlayer* UPiecesLevelSequenceDirector::GetSequencePlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequenceDirector", "GetSequencePlayer");

	Params::PiecesLevelSequenceDirector_GetSequencePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PiecesSequence.PiecesLevelSequencePlayer.CreatePiecesLevelSequencePlayer
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequence*                   InLevelSequence                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovieSceneSequencePlaybackSettingsSettings                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FPiecesLevelSequencePlayerPlaybackSettingsPiecesSettings                                         (Parm, NativeAccessSpecifierPublic)
// class APiecesLevelSequenceActor*        OutActor                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPiecesLevelSequencePlayer*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPiecesLevelSequencePlayer* UPiecesLevelSequencePlayer::CreatePiecesLevelSequencePlayer(class UObject* WorldContextObject, class ULevelSequence* InLevelSequence, const struct FMovieSceneSequencePlaybackSettings& Settings, const struct FPiecesLevelSequencePlayerPlaybackSettings& PiecesSettings, class APiecesLevelSequenceActor** OutActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PiecesLevelSequencePlayer", "CreatePiecesLevelSequencePlayer");

	Params::PiecesLevelSequencePlayer_CreatePiecesLevelSequencePlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InLevelSequence = InLevelSequence;
	Parms.Settings = std::move(Settings);
	Parms.PiecesSettings = std::move(PiecesSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActor != nullptr)
		*OutActor = Parms.OutActor;

	return Parms.ReturnValue;
}


// Function PiecesSequence.PiecesLevelSequencePlayer.OnCameraCutHandler
// (Final, Native, Protected)
// Parameters:
// class UCameraComponent*                 CameraComponent                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPiecesLevelSequencePlayer::OnCameraCutHandler(class UCameraComponent* CameraComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequencePlayer", "OnCameraCutHandler");

	Params::PiecesLevelSequencePlayer_OnCameraCutHandler Parms{};

	Parms.CameraComponent = CameraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction PiecesSequence.PiecesLevelSequencePlayer.OnSequenceSkipped__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UPiecesLevelSequencePlayer*       SequencePlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPiecesLevelSequencePlayer::OnSequenceSkipped__DelegateSignature(class UPiecesLevelSequencePlayer* SequencePlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequencePlayer", "OnSequenceSkipped__DelegateSignature");

	Params::PiecesLevelSequencePlayer_OnSequenceSkipped__DelegateSignature Parms{};

	Parms.SequencePlayer = SequencePlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function PiecesSequence.PiecesLevelSequencePlayer.QueueSkipForOnStartPlaying
// (Final, Native, Public, BlueprintCallable)

void UPiecesLevelSequencePlayer::QueueSkipForOnStartPlaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequencePlayer", "QueueSkipForOnStartPlaying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesLevelSequencePlayer.ResetDynamics
// (Final, Native, Public, BlueprintCallable)

void UPiecesLevelSequencePlayer::ResetDynamics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequencePlayer", "ResetDynamics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesLevelSequencePlayer.SetCameraCut
// (Final, Native, Public, BlueprintCallable)

void UPiecesLevelSequencePlayer::SetCameraCut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequencePlayer", "SetCameraCut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesLevelSequencePlayer.SkipSequence
// (Final, Native, Public, BlueprintCallable)

void UPiecesLevelSequencePlayer::SkipSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequencePlayer", "SkipSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesLevelSequencePlayer.IsSkipInitiated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPiecesLevelSequencePlayer::IsSkipInitiated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesLevelSequencePlayer", "IsSkipInitiated");

	Params::PiecesLevelSequencePlayer_IsSkipInitiated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PiecesSequence.PiecesMovieSceneLetterboxWidget.FadeOutAndRemoveFromParent
// (Native, Event, Public, BlueprintEvent)

void UPiecesMovieSceneLetterboxWidget::FadeOutAndRemoveFromParent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesMovieSceneLetterboxWidget", "FadeOutAndRemoveFromParent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesMovieSceneLetterboxWidget.SetAlpha
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPiecesMovieSceneLetterboxWidget::SetAlpha(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesMovieSceneLetterboxWidget", "SetAlpha");

	Params::PiecesMovieSceneLetterboxWidget_SetAlpha Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PiecesSequence.PiecesSequenceEngineSubsystem.OnSequenceFinished
// (Final, Native, Private)

void UPiecesSequenceEngineSubsystem::OnSequenceFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesSequenceEngineSubsystem", "OnSequenceFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

