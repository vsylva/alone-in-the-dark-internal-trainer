#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ObsidianFox

#include "Basic.hpp"

#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "SlateCore_structs.hpp"
#include "PiecesGameplaySession_classes.hpp"
#include "OBJPool_structs.hpp"
#include "OBJPool_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "ObsidianFox_structs.hpp"
#include "PiecesGameplayAbilities_classes.hpp"
#include "Flow_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "PiecesSaveSystem_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "ObsidianFoxSettings_structs.hpp"
#include "ObsidianFoxSettings_classes.hpp"
#include "PiecesUI_classes.hpp"
#include "GunfireSaveSystem_structs.hpp"
#include "GunfireSaveSystem_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "PiecesAnimNodes_classes.hpp"
#include "PiecesUtils_structs.hpp"
#include "PiecesThirdPersonCamera_classes.hpp"
#include "InputCore_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "FMODStudio_structs.hpp"
#include "Slate_structs.hpp"
#include "PiecesFactsDB_structs.hpp"
#include "PiecesOnline_classes.hpp"
#include "Niagara_classes.hpp"
#include "Gauntlet_classes.hpp"


namespace SDK
{

// Class ObsidianFox.AnimNotify_FootStep
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_FootStep : public UAnimNotify
{
public:
	class FName                                   BoneName;                                          // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_FootStep">();
	}
	static class UAnimNotify_FootStep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_FootStep>();
	}
};
static_assert(alignof(UAnimNotify_FootStep) == 0x000008, "Wrong alignment on UAnimNotify_FootStep");
static_assert(sizeof(UAnimNotify_FootStep) == 0x000040, "Wrong size on UAnimNotify_FootStep");
static_assert(offsetof(UAnimNotify_FootStep, BoneName) == 0x000038, "Member 'UAnimNotify_FootStep::BoneName' has a wrong offset!");

// Class ObsidianFox.AnimNotify_FootStepLeft
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_FootStepLeft final : public UAnimNotify_FootStep
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_FootStepLeft">();
	}
	static class UAnimNotify_FootStepLeft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_FootStepLeft>();
	}
};
static_assert(alignof(UAnimNotify_FootStepLeft) == 0x000008, "Wrong alignment on UAnimNotify_FootStepLeft");
static_assert(sizeof(UAnimNotify_FootStepLeft) == 0x000040, "Wrong size on UAnimNotify_FootStepLeft");

// Class ObsidianFox.AbilityTask_ApplyRootMotionJumpTargetForce
// 0x0040 (0x0150 - 0x0110)
class UAbilityTask_ApplyRootMotionJumpTargetForce final : public UAbilityTask_ApplyRootMotionJumpForce
{
public:
	uint8                                         Pad_110[0x40];                                     // 0x0110(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_ApplyRootMotionJumpTargetForce* ApplyRootMotionJumpTargetForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FVector& JumpTargetLocation, const struct FRotator& JumpTargetRotation, EEasingFunc RotationTargetEasingFunction, float JumpHeight, float JumpDuration, float InMinimumLandedTriggerTime, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, class UCurveVector* InPathOffsetCurve, class UCurveFloat* InTimeMappingCurve);

	void OnLanded(const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_ApplyRootMotionJumpTargetForce">();
	}
	static class UAbilityTask_ApplyRootMotionJumpTargetForce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_ApplyRootMotionJumpTargetForce>();
	}
};
static_assert(alignof(UAbilityTask_ApplyRootMotionJumpTargetForce) == 0x000008, "Wrong alignment on UAbilityTask_ApplyRootMotionJumpTargetForce");
static_assert(sizeof(UAbilityTask_ApplyRootMotionJumpTargetForce) == 0x000150, "Wrong size on UAbilityTask_ApplyRootMotionJumpTargetForce");

// Class ObsidianFox.ProgressionStateChangedInterface
// 0x0000 (0x0028 - 0x0028)
class IProgressionStateChangedInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionStateChangedInterface">();
	}
	static class IProgressionStateChangedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IProgressionStateChangedInterface>();
	}
};
static_assert(alignof(IProgressionStateChangedInterface) == 0x000008, "Wrong alignment on IProgressionStateChangedInterface");
static_assert(sizeof(IProgressionStateChangedInterface) == 0x000028, "Wrong size on IProgressionStateChangedInterface");

// Class ObsidianFox.AnimNotify_FootStepRight
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_FootStepRight final : public UAnimNotify_FootStep
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_FootStepRight">();
	}
	static class UAnimNotify_FootStepRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_FootStepRight>();
	}
};
static_assert(alignof(UAnimNotify_FootStepRight) == 0x000008, "Wrong alignment on UAnimNotify_FootStepRight");
static_assert(sizeof(UAnimNotify_FootStepRight) == 0x000040, "Wrong size on UAnimNotify_FootStepRight");

// Class ObsidianFox.OFNiagaraComponent
// 0x0010 (0x0620 - 0x0610)
class UOFNiagaraComponent final : public UNiagaraComponent
{
public:
	float                                         EmissiveIntensity;                                 // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyUpdateValuesOnStart;                          // 0x060C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_60D[0x3];                                      // 0x060D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EmissiveParamName;                                 // 0x0610(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_618[0x8];                                      // 0x0618(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFNiagaraComponent">();
	}
	static class UOFNiagaraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFNiagaraComponent>();
	}
};
static_assert(alignof(UOFNiagaraComponent) == 0x000010, "Wrong alignment on UOFNiagaraComponent");
static_assert(sizeof(UOFNiagaraComponent) == 0x000620, "Wrong size on UOFNiagaraComponent");
static_assert(offsetof(UOFNiagaraComponent, EmissiveIntensity) == 0x000608, "Member 'UOFNiagaraComponent::EmissiveIntensity' has a wrong offset!");
static_assert(offsetof(UOFNiagaraComponent, bOnlyUpdateValuesOnStart) == 0x00060C, "Member 'UOFNiagaraComponent::bOnlyUpdateValuesOnStart' has a wrong offset!");
static_assert(offsetof(UOFNiagaraComponent, EmissiveParamName) == 0x000610, "Member 'UOFNiagaraComponent::EmissiveParamName' has a wrong offset!");

// Class ObsidianFox.AbilityTask_WaitInputAction
// 0x0010 (0x0090 - 0x0080)
class UAbilityTask_WaitInputAction : public UAbilityTask
{
public:
	class UInputAction*                           BoundInputAction;                                  // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitInputAction">();
	}
	static class UAbilityTask_WaitInputAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitInputAction>();
	}
};
static_assert(alignof(UAbilityTask_WaitInputAction) == 0x000008, "Wrong alignment on UAbilityTask_WaitInputAction");
static_assert(sizeof(UAbilityTask_WaitInputAction) == 0x000090, "Wrong size on UAbilityTask_WaitInputAction");
static_assert(offsetof(UAbilityTask_WaitInputAction, BoundInputAction) == 0x000080, "Member 'UAbilityTask_WaitInputAction::BoundInputAction' has a wrong offset!");

// Class ObsidianFox.AnimNotify_FootStepUp
// 0x0000 (0x0040 - 0x0040)
class UAnimNotify_FootStepUp final : public UAnimNotify_FootStep
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_FootStepUp">();
	}
	static class UAnimNotify_FootStepUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_FootStepUp>();
	}
};
static_assert(alignof(UAnimNotify_FootStepUp) == 0x000008, "Wrong alignment on UAnimNotify_FootStepUp");
static_assert(sizeof(UAnimNotify_FootStepUp) == 0x000040, "Wrong size on UAnimNotify_FootStepUp");

// Class ObsidianFox.AbilityTask_WaitInputActionAll
// 0x0060 (0x00F0 - 0x0090)
class UAbilityTask_WaitInputActionAll final : public UAbilityTask_WaitInputAction
{
public:
	FMulticastInlineDelegateProperty_             Started;                                           // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             Ongoing;                                           // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             Canceled;                                          // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             Triggered;                                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             Completed;                                         // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             NoInput;                                           // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UAbilityTask_WaitInputActionAll* WaitInputActionTriggered(class UGameplayAbility* OwningAbility, class UInputAction* InputAction, bool bFinishOnComplete);

	void WaitInputDelegate__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitInputActionAll">();
	}
	static class UAbilityTask_WaitInputActionAll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitInputActionAll>();
	}
};
static_assert(alignof(UAbilityTask_WaitInputActionAll) == 0x000008, "Wrong alignment on UAbilityTask_WaitInputActionAll");
static_assert(sizeof(UAbilityTask_WaitInputActionAll) == 0x0000F0, "Wrong size on UAbilityTask_WaitInputActionAll");
static_assert(offsetof(UAbilityTask_WaitInputActionAll, Started) == 0x000090, "Member 'UAbilityTask_WaitInputActionAll::Started' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitInputActionAll, Ongoing) == 0x0000A0, "Member 'UAbilityTask_WaitInputActionAll::Ongoing' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitInputActionAll, Canceled) == 0x0000B0, "Member 'UAbilityTask_WaitInputActionAll::Canceled' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitInputActionAll, Triggered) == 0x0000C0, "Member 'UAbilityTask_WaitInputActionAll::Triggered' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitInputActionAll, Completed) == 0x0000D0, "Member 'UAbilityTask_WaitInputActionAll::Completed' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitInputActionAll, NoInput) == 0x0000E0, "Member 'UAbilityTask_WaitInputActionAll::NoInput' has a wrong offset!");

// Class ObsidianFox.PlayerStartTransitionInterface
// 0x0000 (0x0028 - 0x0028)
class IPlayerStartTransitionInterface final : public IInterface
{
public:
	void InitTransition(class AController* SpawnedController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStartTransitionInterface">();
	}
	static class IPlayerStartTransitionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerStartTransitionInterface>();
	}
};
static_assert(alignof(IPlayerStartTransitionInterface) == 0x000008, "Wrong alignment on IPlayerStartTransitionInterface");
static_assert(sizeof(IPlayerStartTransitionInterface) == 0x000028, "Wrong size on IPlayerStartTransitionInterface");

// Class ObsidianFox.AnimNotify_InteractionReach
// 0x0008 (0x0040 - 0x0038)
class UAnimNotify_InteractionReach final : public UAnimNotify
{
public:
	class FName                                   InteractionBone;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_InteractionReach">();
	}
	static class UAnimNotify_InteractionReach* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_InteractionReach>();
	}
};
static_assert(alignof(UAnimNotify_InteractionReach) == 0x000008, "Wrong alignment on UAnimNotify_InteractionReach");
static_assert(sizeof(UAnimNotify_InteractionReach) == 0x000040, "Wrong size on UAnimNotify_InteractionReach");
static_assert(offsetof(UAnimNotify_InteractionReach, InteractionBone) == 0x000038, "Member 'UAnimNotify_InteractionReach::InteractionBone' has a wrong offset!");

// Class ObsidianFox.OFInvestigationSelectionWidget
// 0x0030 (0x0290 - 0x0260)
class UOFInvestigationSelectionWidget final : public UUserWidget
{
public:
	class UGridPanel*                             GridPanelItems;                                    // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OverlayLabelBox;                                   // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             LabelText;                                         // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             InfoDescription;                                   // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInvestigationSlotWidget*               HoveredSlot;                                       // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              RelativeLabelPositionInSlot;                       // 0x0288(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateLabelBox();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFInvestigationSelectionWidget">();
	}
	static class UOFInvestigationSelectionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFInvestigationSelectionWidget>();
	}
};
static_assert(alignof(UOFInvestigationSelectionWidget) == 0x000008, "Wrong alignment on UOFInvestigationSelectionWidget");
static_assert(sizeof(UOFInvestigationSelectionWidget) == 0x000290, "Wrong size on UOFInvestigationSelectionWidget");
static_assert(offsetof(UOFInvestigationSelectionWidget, GridPanelItems) == 0x000260, "Member 'UOFInvestigationSelectionWidget::GridPanelItems' has a wrong offset!");
static_assert(offsetof(UOFInvestigationSelectionWidget, OverlayLabelBox) == 0x000268, "Member 'UOFInvestigationSelectionWidget::OverlayLabelBox' has a wrong offset!");
static_assert(offsetof(UOFInvestigationSelectionWidget, LabelText) == 0x000270, "Member 'UOFInvestigationSelectionWidget::LabelText' has a wrong offset!");
static_assert(offsetof(UOFInvestigationSelectionWidget, InfoDescription) == 0x000278, "Member 'UOFInvestigationSelectionWidget::InfoDescription' has a wrong offset!");
static_assert(offsetof(UOFInvestigationSelectionWidget, HoveredSlot) == 0x000280, "Member 'UOFInvestigationSelectionWidget::HoveredSlot' has a wrong offset!");
static_assert(offsetof(UOFInvestigationSelectionWidget, RelativeLabelPositionInSlot) == 0x000288, "Member 'UOFInvestigationSelectionWidget::RelativeLabelPositionInSlot' has a wrong offset!");

// Class ObsidianFox.AbilityTask_WaitInputActionOngoing
// 0x0010 (0x00A0 - 0x0090)
class UAbilityTask_WaitInputActionOngoing final : public UAbilityTask_WaitInputAction
{
public:
	FMulticastInlineDelegateProperty_             Ongoing;                                           // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UAbilityTask_WaitInputActionOngoing* WaitInputActionOngoing(class UGameplayAbility* OwningAbility, class UInputAction* InputAction, bool bFinishOnComplete);

	void WaitInputOngoingDelegate__DelegateSignature(float ElapsedTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitInputActionOngoing">();
	}
	static class UAbilityTask_WaitInputActionOngoing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitInputActionOngoing>();
	}
};
static_assert(alignof(UAbilityTask_WaitInputActionOngoing) == 0x000008, "Wrong alignment on UAbilityTask_WaitInputActionOngoing");
static_assert(sizeof(UAbilityTask_WaitInputActionOngoing) == 0x0000A0, "Wrong size on UAbilityTask_WaitInputActionOngoing");
static_assert(offsetof(UAbilityTask_WaitInputActionOngoing, Ongoing) == 0x000090, "Member 'UAbilityTask_WaitInputActionOngoing::Ongoing' has a wrong offset!");

// Class ObsidianFox.AnimNotify_Marker
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_Marker final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_Marker">();
	}
	static class UAnimNotify_Marker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_Marker>();
	}
};
static_assert(alignof(UAnimNotify_Marker) == 0x000008, "Wrong alignment on UAnimNotify_Marker");
static_assert(sizeof(UAnimNotify_Marker) == 0x000038, "Wrong size on UAnimNotify_Marker");

// Class ObsidianFox.AbilityTask_WaitInputActionTriggered
// 0x0008 (0x0098 - 0x0090)
class UAbilityTask_WaitInputActionTriggered : public UAbilityTask_WaitInputAction
{
public:
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitInputActionTriggered">();
	}
	static class UAbilityTask_WaitInputActionTriggered* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitInputActionTriggered>();
	}
};
static_assert(alignof(UAbilityTask_WaitInputActionTriggered) == 0x000008, "Wrong alignment on UAbilityTask_WaitInputActionTriggered");
static_assert(sizeof(UAbilityTask_WaitInputActionTriggered) == 0x000098, "Wrong size on UAbilityTask_WaitInputActionTriggered");

// Class ObsidianFox.PlayerLocationTrackingVolume
// 0x0020 (0x0290 - 0x0270)
class APlayerLocationTrackingVolume final : public AVolume
{
public:
	struct FGameplayTagContainer                  LocationTags;                                      // 0x0270(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void ComponentBeginOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bFromSweep, const struct FHitResult& InSweepResult);
	void ComponentEndOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerLocationTrackingVolume">();
	}
	static class APlayerLocationTrackingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerLocationTrackingVolume>();
	}
};
static_assert(alignof(APlayerLocationTrackingVolume) == 0x000008, "Wrong alignment on APlayerLocationTrackingVolume");
static_assert(sizeof(APlayerLocationTrackingVolume) == 0x000290, "Wrong size on APlayerLocationTrackingVolume");
static_assert(offsetof(APlayerLocationTrackingVolume, LocationTags) == 0x000270, "Member 'APlayerLocationTrackingVolume::LocationTags' has a wrong offset!");

// Class ObsidianFox.AnimNotify_TurnInPlaceCacheInput
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_TurnInPlaceCacheInput final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_TurnInPlaceCacheInput">();
	}
	static class UAnimNotify_TurnInPlaceCacheInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_TurnInPlaceCacheInput>();
	}
};
static_assert(alignof(UAnimNotify_TurnInPlaceCacheInput) == 0x000008, "Wrong alignment on UAnimNotify_TurnInPlaceCacheInput");
static_assert(sizeof(UAnimNotify_TurnInPlaceCacheInput) == 0x000038, "Wrong size on UAnimNotify_TurnInPlaceCacheInput");

// Class ObsidianFox.AbilityTask_WaitInputActionTriggered_Bool
// 0x0010 (0x00A8 - 0x0098)
class UAbilityTask_WaitInputActionTriggered_Bool final : public UAbilityTask_WaitInputActionTriggered
{
public:
	FMulticastInlineDelegateProperty_             Triggered;                                         // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UAbilityTask_WaitInputActionTriggered_Bool* WaitInputActionTriggered(class UGameplayAbility* OwningAbility, class UInputAction* InputAction, bool bFinishOnComplete, bool bFinishOnTriggered);

	void WaitInputTriggeredDelegate__DelegateSignature(bool Value, float ElapsedTime, float TriggeredSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitInputActionTriggered_Bool">();
	}
	static class UAbilityTask_WaitInputActionTriggered_Bool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitInputActionTriggered_Bool>();
	}
};
static_assert(alignof(UAbilityTask_WaitInputActionTriggered_Bool) == 0x000008, "Wrong alignment on UAbilityTask_WaitInputActionTriggered_Bool");
static_assert(sizeof(UAbilityTask_WaitInputActionTriggered_Bool) == 0x0000A8, "Wrong size on UAbilityTask_WaitInputActionTriggered_Bool");
static_assert(offsetof(UAbilityTask_WaitInputActionTriggered_Bool, Triggered) == 0x000098, "Member 'UAbilityTask_WaitInputActionTriggered_Bool::Triggered' has a wrong offset!");

// Class ObsidianFox.AbilityTask_WaitInputActionTriggered_Float
// 0x0010 (0x00A8 - 0x0098)
class UAbilityTask_WaitInputActionTriggered_Float final : public UAbilityTask_WaitInputActionTriggered
{
public:
	FMulticastInlineDelegateProperty_             Triggered;                                         // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UAbilityTask_WaitInputActionTriggered_Float* WaitInputActionTriggered(class UGameplayAbility* OwningAbility, class UInputAction* InputAction, bool bFinishOnComplete, bool bFinishOnTriggered);

	void WaitInputTriggeredDelegate__DelegateSignature(float Value, float ElapsedTime, float TriggeredSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitInputActionTriggered_Float">();
	}
	static class UAbilityTask_WaitInputActionTriggered_Float* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitInputActionTriggered_Float>();
	}
};
static_assert(alignof(UAbilityTask_WaitInputActionTriggered_Float) == 0x000008, "Wrong alignment on UAbilityTask_WaitInputActionTriggered_Float");
static_assert(sizeof(UAbilityTask_WaitInputActionTriggered_Float) == 0x0000A8, "Wrong size on UAbilityTask_WaitInputActionTriggered_Float");
static_assert(offsetof(UAbilityTask_WaitInputActionTriggered_Float, Triggered) == 0x000098, "Member 'UAbilityTask_WaitInputActionTriggered_Float::Triggered' has a wrong offset!");

// Class ObsidianFox.OFLocalPlayer
// 0x0010 (0x0268 - 0x0258)
class UOFLocalPlayer final : public ULocalPlayer
{
public:
	bool                                          DynamicAspectRatioConstraint;                      // 0x0258(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_259[0x3];                                      // 0x0259(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AspectRatioConstrainTargetRatio;                   // 0x025C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFLocalPlayer">();
	}
	static class UOFLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFLocalPlayer>();
	}
};
static_assert(alignof(UOFLocalPlayer) == 0x000008, "Wrong alignment on UOFLocalPlayer");
static_assert(sizeof(UOFLocalPlayer) == 0x000268, "Wrong size on UOFLocalPlayer");
static_assert(offsetof(UOFLocalPlayer, DynamicAspectRatioConstraint) == 0x000258, "Member 'UOFLocalPlayer::DynamicAspectRatioConstraint' has a wrong offset!");
static_assert(offsetof(UOFLocalPlayer, AspectRatioConstrainTargetRatio) == 0x00025C, "Member 'UOFLocalPlayer::AspectRatioConstrainTargetRatio' has a wrong offset!");

// Class ObsidianFox.AbilityTask_WaitInputActionTriggered_Vector2D
// 0x0010 (0x00A8 - 0x0098)
class UAbilityTask_WaitInputActionTriggered_Vector2D final : public UAbilityTask_WaitInputActionTriggered
{
public:
	FMulticastInlineDelegateProperty_             Triggered;                                         // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UAbilityTask_WaitInputActionTriggered_Vector2D* WaitInputActionTriggered(class UGameplayAbility* OwningAbility, class UInputAction* InputAction, bool bFinishOnComplete, bool bFinishOnTriggered);

	void WaitInputTriggeredDelegate__DelegateSignature(const struct FVector2D& Value, float ElapsedTime, float TriggeredSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitInputActionTriggered_Vector2D">();
	}
	static class UAbilityTask_WaitInputActionTriggered_Vector2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitInputActionTriggered_Vector2D>();
	}
};
static_assert(alignof(UAbilityTask_WaitInputActionTriggered_Vector2D) == 0x000008, "Wrong alignment on UAbilityTask_WaitInputActionTriggered_Vector2D");
static_assert(sizeof(UAbilityTask_WaitInputActionTriggered_Vector2D) == 0x0000A8, "Wrong size on UAbilityTask_WaitInputActionTriggered_Vector2D");
static_assert(offsetof(UAbilityTask_WaitInputActionTriggered_Vector2D, Triggered) == 0x000098, "Member 'UAbilityTask_WaitInputActionTriggered_Vector2D::Triggered' has a wrong offset!");

// Class ObsidianFox.AchievementDeveloperSettings
// 0x01C8 (0x0200 - 0x0038)
class UAchievementDeveloperSettings final : public UOFDeveloperSettingsBase
{
public:
	TSoftObjectPtr<class UDataTable>              AchievementIdTable;                                // 0x0038(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              StatIdTable;                                       // 0x0060(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RangedAttackDeathTag;                              // 0x0088(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MeleeAttackDeathTag;                               // 0x0090(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OpportunityDeathTag;                               // 0x0098(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           FireDeathTag;                                      // 0x00A0(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  FireDeathUnallowedTags;                            // 0x00A8(0x0020)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ShotgunDeathTag;                                   // 0x00C8(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TommygunDeathTag;                                  // 0x00D0(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RangedAttackAchievementTag;                        // 0x00D8(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ShotgunAchievementTag;                             // 0x00E0(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TommygunAchievementTag;                            // 0x00E8(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MeleeAttackAchievementTag;                         // 0x00F0(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OpportunityAchievementTag;                         // 0x00F8(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           FireAchievementTag;                                // 0x0100(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CollectibleAchievementTag;                         // 0x0108(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AllCollectiblesAchievementTag;                     // 0x0110(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SpeedRunAchievementTag;                            // 0x0118(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TotalTimePlayedAchievementTag;                     // 0x0120(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           NoHealAchievementTag;                              // 0x0128(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AllBantersAchievementTag;                          // 0x0130(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AllCluesAchievementTag;                            // 0x0138(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AllLocksAchievementTag;                            // 0x0140(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AllAchievementsUnlockedAchievementTag;             // 0x0148(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameFinishedFacts;                                 // 0x0150(0x0020)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         SpeedrunAchievementTimeLimit;                      // 0x0170(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ItemClueCategories;                                // 0x0178(0x0020)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FCompletedBanter>               RequiredBantersToComplete;                         // 0x0198(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  GameFinishedAchievements;                          // 0x01A8(0x0020)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FString>                         RequiredLockPaths;                                 // 0x01C8(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   PS5TrophySetName;                                  // 0x01D8(0x0018)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 PS5UDSServiceLabel;                                // 0x01F0(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementDeveloperSettings">();
	}
	static class UAchievementDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementDeveloperSettings>();
	}
};
static_assert(alignof(UAchievementDeveloperSettings) == 0x000008, "Wrong alignment on UAchievementDeveloperSettings");
static_assert(sizeof(UAchievementDeveloperSettings) == 0x000200, "Wrong size on UAchievementDeveloperSettings");
static_assert(offsetof(UAchievementDeveloperSettings, AchievementIdTable) == 0x000038, "Member 'UAchievementDeveloperSettings::AchievementIdTable' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, StatIdTable) == 0x000060, "Member 'UAchievementDeveloperSettings::StatIdTable' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, RangedAttackDeathTag) == 0x000088, "Member 'UAchievementDeveloperSettings::RangedAttackDeathTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, MeleeAttackDeathTag) == 0x000090, "Member 'UAchievementDeveloperSettings::MeleeAttackDeathTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, OpportunityDeathTag) == 0x000098, "Member 'UAchievementDeveloperSettings::OpportunityDeathTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, FireDeathTag) == 0x0000A0, "Member 'UAchievementDeveloperSettings::FireDeathTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, FireDeathUnallowedTags) == 0x0000A8, "Member 'UAchievementDeveloperSettings::FireDeathUnallowedTags' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, ShotgunDeathTag) == 0x0000C8, "Member 'UAchievementDeveloperSettings::ShotgunDeathTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, TommygunDeathTag) == 0x0000D0, "Member 'UAchievementDeveloperSettings::TommygunDeathTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, RangedAttackAchievementTag) == 0x0000D8, "Member 'UAchievementDeveloperSettings::RangedAttackAchievementTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, ShotgunAchievementTag) == 0x0000E0, "Member 'UAchievementDeveloperSettings::ShotgunAchievementTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, TommygunAchievementTag) == 0x0000E8, "Member 'UAchievementDeveloperSettings::TommygunAchievementTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, MeleeAttackAchievementTag) == 0x0000F0, "Member 'UAchievementDeveloperSettings::MeleeAttackAchievementTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, OpportunityAchievementTag) == 0x0000F8, "Member 'UAchievementDeveloperSettings::OpportunityAchievementTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, FireAchievementTag) == 0x000100, "Member 'UAchievementDeveloperSettings::FireAchievementTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, CollectibleAchievementTag) == 0x000108, "Member 'UAchievementDeveloperSettings::CollectibleAchievementTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, AllCollectiblesAchievementTag) == 0x000110, "Member 'UAchievementDeveloperSettings::AllCollectiblesAchievementTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, SpeedRunAchievementTag) == 0x000118, "Member 'UAchievementDeveloperSettings::SpeedRunAchievementTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, TotalTimePlayedAchievementTag) == 0x000120, "Member 'UAchievementDeveloperSettings::TotalTimePlayedAchievementTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, NoHealAchievementTag) == 0x000128, "Member 'UAchievementDeveloperSettings::NoHealAchievementTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, AllBantersAchievementTag) == 0x000130, "Member 'UAchievementDeveloperSettings::AllBantersAchievementTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, AllCluesAchievementTag) == 0x000138, "Member 'UAchievementDeveloperSettings::AllCluesAchievementTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, AllLocksAchievementTag) == 0x000140, "Member 'UAchievementDeveloperSettings::AllLocksAchievementTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, AllAchievementsUnlockedAchievementTag) == 0x000148, "Member 'UAchievementDeveloperSettings::AllAchievementsUnlockedAchievementTag' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, GameFinishedFacts) == 0x000150, "Member 'UAchievementDeveloperSettings::GameFinishedFacts' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, SpeedrunAchievementTimeLimit) == 0x000170, "Member 'UAchievementDeveloperSettings::SpeedrunAchievementTimeLimit' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, ItemClueCategories) == 0x000178, "Member 'UAchievementDeveloperSettings::ItemClueCategories' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, RequiredBantersToComplete) == 0x000198, "Member 'UAchievementDeveloperSettings::RequiredBantersToComplete' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, GameFinishedAchievements) == 0x0001A8, "Member 'UAchievementDeveloperSettings::GameFinishedAchievements' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, RequiredLockPaths) == 0x0001C8, "Member 'UAchievementDeveloperSettings::RequiredLockPaths' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, PS5TrophySetName) == 0x0001D8, "Member 'UAchievementDeveloperSettings::PS5TrophySetName' has a wrong offset!");
static_assert(offsetof(UAchievementDeveloperSettings, PS5UDSServiceLabel) == 0x0001F0, "Member 'UAchievementDeveloperSettings::PS5UDSServiceLabel' has a wrong offset!");

// Class ObsidianFox.OFNPCSubGraphAnimInstance
// 0x0780 (0x0A50 - 0x02D0)
class UOFNPCSubGraphAnimInstance : public UAnimInstance
{
public:
	uint8                                         bMovementComponentIsValid : 1;                     // 0x02C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOFNPCSubGraphAnimInstanceProxy        SubGraphProxy;                                     // 0x02D0(0x0780)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFNPCSubGraphAnimInstance">();
	}
	static class UOFNPCSubGraphAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFNPCSubGraphAnimInstance>();
	}
};
static_assert(alignof(UOFNPCSubGraphAnimInstance) == 0x000010, "Wrong alignment on UOFNPCSubGraphAnimInstance");
static_assert(sizeof(UOFNPCSubGraphAnimInstance) == 0x000A50, "Wrong size on UOFNPCSubGraphAnimInstance");
static_assert(offsetof(UOFNPCSubGraphAnimInstance, SubGraphProxy) == 0x0002D0, "Member 'UOFNPCSubGraphAnimInstance::SubGraphProxy' has a wrong offset!");

// Class ObsidianFox.AchievementSubSystem
// 0x0128 (0x0158 - 0x0030)
class UAchievementSubSystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnAchievementCompleted;                            // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x118];                                     // 0x0040(0x0118)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CompleteAchievement(const struct FGameplayTag& AchievementTag);
	const struct FAchievementInfo GetAchievementInfo(const struct FGameplayTag& AchievementTag);
	float GetAchievementProgress(const struct FGameplayTag& AchievementTag);
	float GetStatValueFloat(const struct FGameplayTag& StatTag);
	int32 GetStatValueInt(const struct FGameplayTag& StatTag);
	void ProgressAchievement(const struct FGameplayTag& AchievementTag, float Progress);
	void ResetAchievements();
	void UpdateStatFloat(const struct FGameplayTag& StatTag, float Value);
	void UpdateStatInt(const struct FGameplayTag& StatTag, int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementSubSystem">();
	}
	static class UAchievementSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementSubSystem>();
	}
};
static_assert(alignof(UAchievementSubSystem) == 0x000008, "Wrong alignment on UAchievementSubSystem");
static_assert(sizeof(UAchievementSubSystem) == 0x000158, "Wrong size on UAchievementSubSystem");
static_assert(offsetof(UAchievementSubSystem, OnAchievementCompleted) == 0x000030, "Member 'UAchievementSubSystem::OnAchievementCompleted' has a wrong offset!");

// Class ObsidianFox.ObsidianFoxCharacter
// 0x01F0 (0x0750 - 0x0560)
#pragma pack(push, 0x1)
class alignas(0x10) AObsidianFoxCharacter : public APooledCharacter
{
public:
	uint8                                         Pad_560[0x20];                                     // 0x0560(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsDead;                                           // 0x0580(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_581[0x7];                                      // 0x0581(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDeath;                                           // 0x0588(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPossessDelegate;                                 // 0x0598(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCinematicModeChanged;                            // 0x05A8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBeginPlayNoSaveDelegate;                         // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPhysicalAnimationComponent*            PhysicsAnimationComponent;                         // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFlowComponent*                         FlowComponent;                                     // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOFAttributeSet*                        AttributeSet;                                      // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPiecesAbilitySystemComponent*          AbilitySystemComponent;                            // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFocusPointComponent*                   FocusPointComponent;                               // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FocusPointComponentAttachmentPoint;                // 0x05F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStartleComponent*                      StartleComponent;                                  // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJointAlignerComponent*                 JointAlignerComponent;                             // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationTagComponent*                 AnimationTagComponent;                             // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOFAnimSaveGameDataContainerComponent*  AnimationSaveGameDataContainerComponent;           // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    StartingGameplayEffects;                           // 0x0618(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         StartingGameplayEffectsLevel;                      // 0x0628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_62C[0x4];                                      // 0x062C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DeathTransform;                                    // 0x0630(0x0030)(BlueprintVisible, BlueprintReadOnly, SaveGame, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSet<TSubclassOf<class UGameplayAbility>>     StartingAbilities;                                 // 0x0660(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, AdvancedDisplay, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UOFGameplayAbilitySet*                  StartingAbilitySet;                                // 0x06B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHealthChanged;                                   // 0x06B8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMoveSpeedChange;                                 // 0x06C8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class AOFWeaponActor*>                 EquippedWeapons;                                   // 0x06D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnAiming;                                          // 0x06E8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDodging;                                         // 0x06F8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_708[0x1];                                      // 0x0708(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsReloading;                                      // 0x0709(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70A[0x1E];                                     // 0x070A(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	class UPersistenceComponent*                  PersistenceComponent;                              // 0x0728(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_730[0x10];                                     // 0x0730(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CinematicDisableCollisionTag;                      // 0x0740(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddWeapon(class AOFWeaponActor* NewWeapon);
	void AimingSignature__DelegateSignature(bool bIsAiming);
	void AttributeChange__DelegateSignature(float AttributeValue, float DeltaValue, const struct FGameplayTagContainer& EventTags);
	void BeginWeaponAttack(const struct FGameplayTag& EventTag, const struct FGameplayTagContainer& AttackingWeaponsTags);
	void BeginWeaponAttacks(const struct FGameplayTag& EventTag);
	void CancelAbilitiesWithTag(const struct FGameplayTagContainer& AbilityTag);
	void Death(const struct FGameplayTagContainer& EventTags, const struct FGameplayEffectContextHandle& Context);
	void DodgingSignature__DelegateSignature(bool bIsDodging);
	void EndWeaponAttack(const struct FGameplayTagContainer& AttackingWeaponsTags);
	void EndWeaponAttacks();
	bool EquipWeapon(class AOFWeaponActor* Weapon, class FName AttachSocket);
	bool GetInvicibillity();
	void GrantAbility(TSubclassOf<class UGameplayAbility> NewAbility);
	void GrantAbilityBySpec(const struct FGameplayAbilitySpec& NewAbilitySpec);
	void HealthChangeSignature__DelegateSignature(float NewCurrentHealth, float DeltaValue, const struct FGameplayTagContainer& EventTags);
	void InitializeAttributeSet();
	void K2_OnCinematicModeChange(bool bInCinematicMode);
	void OnEquipWeaponAnimationNotify();
	void OnPlayStateChanged(EGameMainState OldState, EGameMainState NewGameState);
	void OnUnequipWeaponAnimationNotify();
	void OnWeaponAttackHit(float HitStrength, float HitForce, float Duration, const struct FVector& HitDirection, const struct FVector& HitDirectionNormalAdjusted, ECardinalDirection HitQuadrant, const struct FHitResult& HitInfo, const struct FGameplayTagContainer& DamageTags);
	void RemoveWeapon(class AOFWeaponActor* WeaponToRemove);
	void ResetHealthToMax();
	void SetCinematicMode(bool bShouldBeInCinematicMode);
	void SetInvicibillity(bool bValue);
	bool UnequipWeapon(class AOFWeaponActor* Weapon, bool bDestroyWeaponActor, class FName AttachSocket);

	class AOFWeaponActor* GetActiveMeleeWeapon() const;
	class AOFWeaponActor* GetActiveWeapon() const;
	TArray<class AOFWeaponActor*> GetEquippedWeapons() const;
	bool IsCharacterDead() const;
	bool IsInCinematicMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObsidianFoxCharacter">();
	}
	static class AObsidianFoxCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AObsidianFoxCharacter>();
	}
};
#pragma pack(pop)
static_assert(alignof(AObsidianFoxCharacter) == 0x000010, "Wrong alignment on AObsidianFoxCharacter");
static_assert(sizeof(AObsidianFoxCharacter) == 0x000750, "Wrong size on AObsidianFoxCharacter");
static_assert(offsetof(AObsidianFoxCharacter, bIsDead) == 0x000580, "Member 'AObsidianFoxCharacter::bIsDead' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, OnDeath) == 0x000588, "Member 'AObsidianFoxCharacter::OnDeath' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, OnPossessDelegate) == 0x000598, "Member 'AObsidianFoxCharacter::OnPossessDelegate' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, OnCinematicModeChanged) == 0x0005A8, "Member 'AObsidianFoxCharacter::OnCinematicModeChanged' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, OnBeginPlayNoSaveDelegate) == 0x0005B8, "Member 'AObsidianFoxCharacter::OnBeginPlayNoSaveDelegate' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, PhysicsAnimationComponent) == 0x0005C8, "Member 'AObsidianFoxCharacter::PhysicsAnimationComponent' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, FlowComponent) == 0x0005D0, "Member 'AObsidianFoxCharacter::FlowComponent' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, AttributeSet) == 0x0005D8, "Member 'AObsidianFoxCharacter::AttributeSet' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, AbilitySystemComponent) == 0x0005E0, "Member 'AObsidianFoxCharacter::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, FocusPointComponent) == 0x0005E8, "Member 'AObsidianFoxCharacter::FocusPointComponent' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, FocusPointComponentAttachmentPoint) == 0x0005F0, "Member 'AObsidianFoxCharacter::FocusPointComponentAttachmentPoint' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, StartleComponent) == 0x0005F8, "Member 'AObsidianFoxCharacter::StartleComponent' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, JointAlignerComponent) == 0x000600, "Member 'AObsidianFoxCharacter::JointAlignerComponent' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, AnimationTagComponent) == 0x000608, "Member 'AObsidianFoxCharacter::AnimationTagComponent' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, AnimationSaveGameDataContainerComponent) == 0x000610, "Member 'AObsidianFoxCharacter::AnimationSaveGameDataContainerComponent' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, StartingGameplayEffects) == 0x000618, "Member 'AObsidianFoxCharacter::StartingGameplayEffects' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, StartingGameplayEffectsLevel) == 0x000628, "Member 'AObsidianFoxCharacter::StartingGameplayEffectsLevel' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, DeathTransform) == 0x000630, "Member 'AObsidianFoxCharacter::DeathTransform' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, StartingAbilities) == 0x000660, "Member 'AObsidianFoxCharacter::StartingAbilities' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, StartingAbilitySet) == 0x0006B0, "Member 'AObsidianFoxCharacter::StartingAbilitySet' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, OnHealthChanged) == 0x0006B8, "Member 'AObsidianFoxCharacter::OnHealthChanged' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, OnMoveSpeedChange) == 0x0006C8, "Member 'AObsidianFoxCharacter::OnMoveSpeedChange' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, EquippedWeapons) == 0x0006D8, "Member 'AObsidianFoxCharacter::EquippedWeapons' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, OnAiming) == 0x0006E8, "Member 'AObsidianFoxCharacter::OnAiming' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, OnDodging) == 0x0006F8, "Member 'AObsidianFoxCharacter::OnDodging' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, bIsReloading) == 0x000709, "Member 'AObsidianFoxCharacter::bIsReloading' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, PersistenceComponent) == 0x000728, "Member 'AObsidianFoxCharacter::PersistenceComponent' has a wrong offset!");
static_assert(offsetof(AObsidianFoxCharacter, CinematicDisableCollisionTag) == 0x000740, "Member 'AObsidianFoxCharacter::CinematicDisableCollisionTag' has a wrong offset!");

// Class ObsidianFox.OFFLevelUtils
// 0x0000 (0x0028 - 0x0028)
class UOFFLevelUtils final : public UBlueprintFunctionLibrary
{
public:
	static class ULevelStreaming* GetStreamingLevelFromWorld(const class UObject* WorldContextObject, const TSoftObjectPtr<class UWorld> InWorld);
	static class FName GetWorldAssetName(const TSoftObjectPtr<class UWorld> InWorld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFFLevelUtils">();
	}
	static class UOFFLevelUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFFLevelUtils>();
	}
};
static_assert(alignof(UOFFLevelUtils) == 0x000008, "Wrong alignment on UOFFLevelUtils");
static_assert(sizeof(UOFFLevelUtils) == 0x000028, "Wrong size on UOFFLevelUtils");

// Class ObsidianFox.ActorMoodComponent
// 0x00A0 (0x02B0 - 0x0210)
class UActorMoodComponent final : public USceneComponent
{
public:
	uint8                                         Pad_208[0x1];                                      // 0x0208(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bInCombat : 1;                                     // 0x0209(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsFacingEnemy : 1;                                // 0x0209(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_20A[0x2];                                      // 0x020A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CombatVisionCone;                                  // 0x020C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_210[0x4];                                      // 0x0210(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CombatTimeRecoveryThreshold;                       // 0x0214(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CombatRecoveryTime;                                // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CombatRecoveryTimer;                               // 0x021C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeInSprint;                                      // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintTimeRecoveryThreshold;                       // 0x0224(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintRecoveryTime;                                // 0x0228(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintRecoveryTimer;                               // 0x022C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Health;                                            // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthPercentage;                                  // 0x0234(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintLeanAmount;                                  // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInGauntlet;                                       // 0x023C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23D[0x3];                                      // 0x023D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEmotions                              Emotions;                                          // 0x0240(0x0048)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         NewRoomExploredCarefulnessIncrement;               // 0x0288(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AOFPlayerCharacter*                     PlayerCharacter;                                   // 0x0290(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UOFCharacterMovementComponent*          CharacterMovementComponent;                        // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0x8];                                      // 0x02A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCombatStatusChanged(bool InCombat);
	void OnEnterGauntlet(bool FirstTime);
	void OnExitGauntlet(bool FirstTime);
	void OnHealthChanged(float NewCurrentHealth, float DeltaValue, const struct FGameplayTagContainer& EventTags);
	void OnNewRoomExplored(const struct FGameplayTag& NewRoomTag);
	void OnSprintStateChange(bool IsSprinting);
	void RequestEmotionChange(const TMap<EEmotion, float>& EmotionDeltas);

	float GetBreathRecoveryTimer(class UCurveFloat* TransformationCurve) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorMoodComponent">();
	}
	static class UActorMoodComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorMoodComponent>();
	}
};
static_assert(alignof(UActorMoodComponent) == 0x000010, "Wrong alignment on UActorMoodComponent");
static_assert(sizeof(UActorMoodComponent) == 0x0002B0, "Wrong size on UActorMoodComponent");
static_assert(offsetof(UActorMoodComponent, CombatVisionCone) == 0x00020C, "Member 'UActorMoodComponent::CombatVisionCone' has a wrong offset!");
static_assert(offsetof(UActorMoodComponent, CombatTimeRecoveryThreshold) == 0x000214, "Member 'UActorMoodComponent::CombatTimeRecoveryThreshold' has a wrong offset!");
static_assert(offsetof(UActorMoodComponent, CombatRecoveryTime) == 0x000218, "Member 'UActorMoodComponent::CombatRecoveryTime' has a wrong offset!");
static_assert(offsetof(UActorMoodComponent, CombatRecoveryTimer) == 0x00021C, "Member 'UActorMoodComponent::CombatRecoveryTimer' has a wrong offset!");
static_assert(offsetof(UActorMoodComponent, TimeInSprint) == 0x000220, "Member 'UActorMoodComponent::TimeInSprint' has a wrong offset!");
static_assert(offsetof(UActorMoodComponent, SprintTimeRecoveryThreshold) == 0x000224, "Member 'UActorMoodComponent::SprintTimeRecoveryThreshold' has a wrong offset!");
static_assert(offsetof(UActorMoodComponent, SprintRecoveryTime) == 0x000228, "Member 'UActorMoodComponent::SprintRecoveryTime' has a wrong offset!");
static_assert(offsetof(UActorMoodComponent, SprintRecoveryTimer) == 0x00022C, "Member 'UActorMoodComponent::SprintRecoveryTimer' has a wrong offset!");
static_assert(offsetof(UActorMoodComponent, Health) == 0x000230, "Member 'UActorMoodComponent::Health' has a wrong offset!");
static_assert(offsetof(UActorMoodComponent, HealthPercentage) == 0x000234, "Member 'UActorMoodComponent::HealthPercentage' has a wrong offset!");
static_assert(offsetof(UActorMoodComponent, SprintLeanAmount) == 0x000238, "Member 'UActorMoodComponent::SprintLeanAmount' has a wrong offset!");
static_assert(offsetof(UActorMoodComponent, bInGauntlet) == 0x00023C, "Member 'UActorMoodComponent::bInGauntlet' has a wrong offset!");
static_assert(offsetof(UActorMoodComponent, Emotions) == 0x000240, "Member 'UActorMoodComponent::Emotions' has a wrong offset!");
static_assert(offsetof(UActorMoodComponent, NewRoomExploredCarefulnessIncrement) == 0x000288, "Member 'UActorMoodComponent::NewRoomExploredCarefulnessIncrement' has a wrong offset!");
static_assert(offsetof(UActorMoodComponent, PlayerCharacter) == 0x000290, "Member 'UActorMoodComponent::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UActorMoodComponent, CharacterMovementComponent) == 0x0002A0, "Member 'UActorMoodComponent::CharacterMovementComponent' has a wrong offset!");

// Class ObsidianFox.ActorTransformComponent
// 0x0098 (0x0150 - 0x00B8)
class alignas(0x10) UActorTransformComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnTransformCompleted;                              // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCloseEnough;                                     // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x28];                                     // 0x0128(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceStop(bool StopTranslation, bool StopRotation, bool SnapCharacterToTargetLocation, bool SnapCharacterToTargetRotation);
	void StartTransform();
	void TransformCompleted__DelegateSignature(class AActor* TransformedActor, class UActorTransformComponent* TransformingComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorTransformComponent">();
	}
	static class UActorTransformComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorTransformComponent>();
	}
};
static_assert(alignof(UActorTransformComponent) == 0x000010, "Wrong alignment on UActorTransformComponent");
static_assert(sizeof(UActorTransformComponent) == 0x000150, "Wrong size on UActorTransformComponent");
static_assert(offsetof(UActorTransformComponent, OnTransformCompleted) == 0x000108, "Member 'UActorTransformComponent::OnTransformCompleted' has a wrong offset!");
static_assert(offsetof(UActorTransformComponent, OnCloseEnough) == 0x000118, "Member 'UActorTransformComponent::OnCloseEnough' has a wrong offset!");

// Class ObsidianFox.OFPickupIncrementWidget
// 0x0018 (0x0278 - 0x0260)
class UOFPickupIncrementWidget : public UUserWidget
{
public:
	class UTextBlock*                             TextBlockAmount;                                   // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlockName;                                     // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageIcon;                                         // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PlayEyeCatcherAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFPickupIncrementWidget">();
	}
	static class UOFPickupIncrementWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFPickupIncrementWidget>();
	}
};
static_assert(alignof(UOFPickupIncrementWidget) == 0x000008, "Wrong alignment on UOFPickupIncrementWidget");
static_assert(sizeof(UOFPickupIncrementWidget) == 0x000278, "Wrong size on UOFPickupIncrementWidget");
static_assert(offsetof(UOFPickupIncrementWidget, TextBlockAmount) == 0x000260, "Member 'UOFPickupIncrementWidget::TextBlockAmount' has a wrong offset!");
static_assert(offsetof(UOFPickupIncrementWidget, TextBlockName) == 0x000268, "Member 'UOFPickupIncrementWidget::TextBlockName' has a wrong offset!");
static_assert(offsetof(UOFPickupIncrementWidget, ImageIcon) == 0x000270, "Member 'UOFPickupIncrementWidget::ImageIcon' has a wrong offset!");

// Class ObsidianFox.ActorVelocityTransformComponent
// 0x0020 (0x0170 - 0x0150)
class UActorVelocityTransformComponent final : public UActorTransformComponent
{
public:
	uint8                                         Pad_150[0x20];                                     // 0x0150(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorVelocityTransformComponent">();
	}
	static class UActorVelocityTransformComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorVelocityTransformComponent>();
	}
};
static_assert(alignof(UActorVelocityTransformComponent) == 0x000010, "Wrong alignment on UActorVelocityTransformComponent");
static_assert(sizeof(UActorVelocityTransformComponent) == 0x000170, "Wrong size on UActorVelocityTransformComponent");

// Class ObsidianFox.ActWorldData
// 0x0020 (0x0050 - 0x0030)
class UActWorldData final : public UDataAsset
{
public:
	TArray<struct FActWorldInfo>                  ActWorlds;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FSubLevelPersistentLevelAssociations> SubLevelPersistentLevelAssociations;               // 0x0040(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActWorldData">();
	}
	static class UActWorldData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActWorldData>();
	}
};
static_assert(alignof(UActWorldData) == 0x000008, "Wrong alignment on UActWorldData");
static_assert(sizeof(UActWorldData) == 0x000050, "Wrong size on UActWorldData");
static_assert(offsetof(UActWorldData, ActWorlds) == 0x000030, "Member 'UActWorldData::ActWorlds' has a wrong offset!");
static_assert(offsetof(UActWorldData, SubLevelPersistentLevelAssociations) == 0x000040, "Member 'UActWorldData::SubLevelPersistentLevelAssociations' has a wrong offset!");

// Class ObsidianFox.OFPostProcessAnimInstance
// 0x07A0 (0x0A70 - 0x02D0)
class UOFPostProcessAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_2C8[0x788];                                    // 0x02C8(0x0788)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 OwnerComponent;                                    // 0x0A50(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DynamicsAlpha;                                     // 0x0A58(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A5C[0x14];                                     // 0x0A5C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CopyDynamicsAlphaFromOwnerABP(float& DestinationVariable, const struct FGameplayTag& DynamicsKey);
	class UAnimInstance* GetParentAnimInstance(TSubclassOf<class UAnimInstance> Class_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFPostProcessAnimInstance">();
	}
	static class UOFPostProcessAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFPostProcessAnimInstance>();
	}
};
static_assert(alignof(UOFPostProcessAnimInstance) == 0x000010, "Wrong alignment on UOFPostProcessAnimInstance");
static_assert(sizeof(UOFPostProcessAnimInstance) == 0x000A70, "Wrong size on UOFPostProcessAnimInstance");
static_assert(offsetof(UOFPostProcessAnimInstance, OwnerComponent) == 0x000A50, "Member 'UOFPostProcessAnimInstance::OwnerComponent' has a wrong offset!");
static_assert(offsetof(UOFPostProcessAnimInstance, DynamicsAlpha) == 0x000A58, "Member 'UOFPostProcessAnimInstance::DynamicsAlpha' has a wrong offset!");

// Class ObsidianFox.ActWorldSubSystem
// 0x0010 (0x0040 - 0x0030)
class UActWorldSubSystem final : public UWorldSubsystem
{
public:
	class UActWorldData*                          ActWorldData;                                      // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetCurrentActWorldIndex() const;
	class FName GetCurrentActWorldName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActWorldSubSystem">();
	}
	static class UActWorldSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActWorldSubSystem>();
	}
};
static_assert(alignof(UActWorldSubSystem) == 0x000008, "Wrong alignment on UActWorldSubSystem");
static_assert(sizeof(UActWorldSubSystem) == 0x000040, "Wrong size on UActWorldSubSystem");
static_assert(offsetof(UActWorldSubSystem, ActWorldData) == 0x000030, "Member 'UActWorldSubSystem::ActWorldData' has a wrong offset!");

// Class ObsidianFox.AIEmotePointInterface
// 0x0000 (0x0028 - 0x0028)
class IAIEmotePointInterface final : public IInterface
{
public:
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIEmotePointInterface">();
	}
	static class IAIEmotePointInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAIEmotePointInterface>();
	}
};
static_assert(alignof(IAIEmotePointInterface) == 0x000008, "Wrong alignment on IAIEmotePointInterface");
static_assert(sizeof(IAIEmotePointInterface) == 0x000028, "Wrong size on IAIEmotePointInterface");

// Class ObsidianFox.OFPlayerCameraManager
// 0x0010 (0x2870 - 0x2860)
class AOFPlayerCameraManager : public AThirdPersonPlayerCameraManager
{
public:
	class UCameraModifier*                        ActiveModiferExtra;                                // 0x2858(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraModifier*                        ModiferCharacter1982;                              // 0x2860(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2868[0x8];                                     // 0x2868(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSettingsChangedHandler(class UOFGameUserSettings* Settings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFPlayerCameraManager">();
	}
	static class AOFPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOFPlayerCameraManager>();
	}
};
static_assert(alignof(AOFPlayerCameraManager) == 0x000010, "Wrong alignment on AOFPlayerCameraManager");
static_assert(sizeof(AOFPlayerCameraManager) == 0x002870, "Wrong size on AOFPlayerCameraManager");
static_assert(offsetof(AOFPlayerCameraManager, ActiveModiferExtra) == 0x002858, "Member 'AOFPlayerCameraManager::ActiveModiferExtra' has a wrong offset!");
static_assert(offsetof(AOFPlayerCameraManager, ModiferCharacter1982) == 0x002860, "Member 'AOFPlayerCameraManager::ModiferCharacter1982' has a wrong offset!");

// Class ObsidianFox.AimAssistInterface
// 0x0000 (0x0028 - 0x0028)
class IAimAssistInterface final : public IInterface
{
public:
	const class FName GetAimAssistMainSocket();
	const class USceneComponent* GetAimAssistSocketComponent();
	const TArray<class FName> GetAimAssistSockets(const bool bIncludeMainAimSocket);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimAssistInterface">();
	}
	static class IAimAssistInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAimAssistInterface>();
	}
};
static_assert(alignof(IAimAssistInterface) == 0x000008, "Wrong alignment on IAimAssistInterface");
static_assert(sizeof(IAimAssistInterface) == 0x000028, "Wrong size on IAimAssistInterface");

// Class ObsidianFox.OFPerfSampleBlueprintGauntletController
// 0x0040 (0x0070 - 0x0030)
class UOFPerfSampleBlueprintGauntletController final : public UGauntletTestController
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActorFinished();
	void StartTest();
	void StopTest();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFPerfSampleBlueprintGauntletController">();
	}
	static class UOFPerfSampleBlueprintGauntletController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFPerfSampleBlueprintGauntletController>();
	}
};
static_assert(alignof(UOFPerfSampleBlueprintGauntletController) == 0x000008, "Wrong alignment on UOFPerfSampleBlueprintGauntletController");
static_assert(sizeof(UOFPerfSampleBlueprintGauntletController) == 0x000070, "Wrong size on UOFPerfSampleBlueprintGauntletController");

// Class ObsidianFox.AISenseConfig_PlayerProximity
// 0x0010 (0x0058 - 0x0048)
class UAISenseConfig_PlayerProximity final : public UAISenseConfig
{
public:
	TSubclassOf<class UAISense_PlayerProximity>   Implementation;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoClear, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerRadius;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISenseConfig_PlayerProximity">();
	}
	static class UAISenseConfig_PlayerProximity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISenseConfig_PlayerProximity>();
	}
};
static_assert(alignof(UAISenseConfig_PlayerProximity) == 0x000008, "Wrong alignment on UAISenseConfig_PlayerProximity");
static_assert(sizeof(UAISenseConfig_PlayerProximity) == 0x000058, "Wrong size on UAISenseConfig_PlayerProximity");
static_assert(offsetof(UAISenseConfig_PlayerProximity, Implementation) == 0x000048, "Member 'UAISenseConfig_PlayerProximity::Implementation' has a wrong offset!");
static_assert(offsetof(UAISenseConfig_PlayerProximity, PlayerRadius) == 0x000050, "Member 'UAISenseConfig_PlayerProximity::PlayerRadius' has a wrong offset!");

// Class ObsidianFox.OFPlayerController
// 0x0128 (0x06C0 - 0x0598)
class AOFPlayerController : public APlayerController
{
public:
	FMulticastInlineDelegateProperty_             OnSetLookInputIgnored;                             // 0x0598(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSetGameplayInputIgnored;                         // 0x05A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSetMoveInputIgnored;                             // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C8[0x18];                                     // 0x05C8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectiveComponent*                    ObjectiveComponent;                                // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             InputTypeChanged;                                  // 0x05E8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   InGameMenuClass;                                   // 0x0600(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PauseMenuClass;                                    // 0x0628(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            InGameMenuWidget;                                  // 0x0650(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            PauseMenuWidget;                                   // 0x0658(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventory*                             Inventory;                                         // 0x0660(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   InteractionHudBP;                                  // 0x0668(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPathFollowingComponent*                PathFollowingComponent;                            // 0x0690(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerMoveToComponent*                 PlayerMoveToComponent;                             // 0x0698(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOFLocalPlayer*                         LocalPlayer;                                       // 0x06A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UConsoleCommandsManager*                ConsoleCommandsManager;                            // 0x06A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPersistenceComponent*                  PersistenceComponent;                              // 0x06B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B8[0x8];                                      // 0x06B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseInGameMenu();
	void ClosePauseMenu();
	void InputIgnoredDelegate__DelegateSignature();
	void InputTypeChanged__DelegateSignature(bool IsGamepadType);
	void IsGameplayInputIgnoredBranched(EInputIgnoreBranch* Branches);
	void OnCharacterPosessed(const class AOFPlayerCharacter* PossesedCharacter);
	void OnSettingsChanged(class UOFGameUserSettings* Settings);
	void OpenInGameMenu();
	void OpenPauseMenu();
	void ResetIgnoreGameplayInput();
	void SetIgnoreGameplayInput(bool bNewGameplayInput);
	void SetOptionsWhenClosingAMenu();
	void SetOptionsWhenOpeningANewMenu();

	class UUserWidget* GetInGameUIWidget() const;
	bool IsGamepadLastInputTypeUsed() const;
	bool IsGameplayInputIgnored() const;
	bool IsInCinematicMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFPlayerController">();
	}
	static class AOFPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOFPlayerController>();
	}
};
static_assert(alignof(AOFPlayerController) == 0x000008, "Wrong alignment on AOFPlayerController");
static_assert(sizeof(AOFPlayerController) == 0x0006C0, "Wrong size on AOFPlayerController");
static_assert(offsetof(AOFPlayerController, OnSetLookInputIgnored) == 0x000598, "Member 'AOFPlayerController::OnSetLookInputIgnored' has a wrong offset!");
static_assert(offsetof(AOFPlayerController, OnSetGameplayInputIgnored) == 0x0005A8, "Member 'AOFPlayerController::OnSetGameplayInputIgnored' has a wrong offset!");
static_assert(offsetof(AOFPlayerController, OnSetMoveInputIgnored) == 0x0005B8, "Member 'AOFPlayerController::OnSetMoveInputIgnored' has a wrong offset!");
static_assert(offsetof(AOFPlayerController, ObjectiveComponent) == 0x0005E0, "Member 'AOFPlayerController::ObjectiveComponent' has a wrong offset!");
static_assert(offsetof(AOFPlayerController, InputTypeChanged) == 0x0005E8, "Member 'AOFPlayerController::InputTypeChanged' has a wrong offset!");
static_assert(offsetof(AOFPlayerController, InGameMenuClass) == 0x000600, "Member 'AOFPlayerController::InGameMenuClass' has a wrong offset!");
static_assert(offsetof(AOFPlayerController, PauseMenuClass) == 0x000628, "Member 'AOFPlayerController::PauseMenuClass' has a wrong offset!");
static_assert(offsetof(AOFPlayerController, InGameMenuWidget) == 0x000650, "Member 'AOFPlayerController::InGameMenuWidget' has a wrong offset!");
static_assert(offsetof(AOFPlayerController, PauseMenuWidget) == 0x000658, "Member 'AOFPlayerController::PauseMenuWidget' has a wrong offset!");
static_assert(offsetof(AOFPlayerController, Inventory) == 0x000660, "Member 'AOFPlayerController::Inventory' has a wrong offset!");
static_assert(offsetof(AOFPlayerController, InteractionHudBP) == 0x000668, "Member 'AOFPlayerController::InteractionHudBP' has a wrong offset!");
static_assert(offsetof(AOFPlayerController, PathFollowingComponent) == 0x000690, "Member 'AOFPlayerController::PathFollowingComponent' has a wrong offset!");
static_assert(offsetof(AOFPlayerController, PlayerMoveToComponent) == 0x000698, "Member 'AOFPlayerController::PlayerMoveToComponent' has a wrong offset!");
static_assert(offsetof(AOFPlayerController, LocalPlayer) == 0x0006A0, "Member 'AOFPlayerController::LocalPlayer' has a wrong offset!");
static_assert(offsetof(AOFPlayerController, ConsoleCommandsManager) == 0x0006A8, "Member 'AOFPlayerController::ConsoleCommandsManager' has a wrong offset!");
static_assert(offsetof(AOFPlayerController, PersistenceComponent) == 0x0006B0, "Member 'AOFPlayerController::PersistenceComponent' has a wrong offset!");

// Class ObsidianFox.AISense_PlayerProximity
// 0x0010 (0x0090 - 0x0080)
class UAISense_PlayerProximity final : public UAISense
{
public:
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_PlayerProximity">();
	}
	static class UAISense_PlayerProximity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_PlayerProximity>();
	}
};
static_assert(alignof(UAISense_PlayerProximity) == 0x000008, "Wrong alignment on UAISense_PlayerProximity");
static_assert(sizeof(UAISense_PlayerProximity) == 0x000090, "Wrong size on UAISense_PlayerProximity");

// Class ObsidianFox.AlternativeEndingCharacterAnimInstance
// 0x0010 (0x02E0 - 0x02D0)
class UAlternativeEndingCharacterAnimInstance final : public UAnimInstance
{
public:
	FMulticastInlineDelegateProperty_             TransitionToNextSequence;                          // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTransitionAnimationFinished(bool PlayAlternativeEnding);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AlternativeEndingCharacterAnimInstance">();
	}
	static class UAlternativeEndingCharacterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAlternativeEndingCharacterAnimInstance>();
	}
};
static_assert(alignof(UAlternativeEndingCharacterAnimInstance) == 0x000010, "Wrong alignment on UAlternativeEndingCharacterAnimInstance");
static_assert(sizeof(UAlternativeEndingCharacterAnimInstance) == 0x0002E0, "Wrong size on UAlternativeEndingCharacterAnimInstance");
static_assert(offsetof(UAlternativeEndingCharacterAnimInstance, TransitionToNextSequence) == 0x0002C8, "Member 'UAlternativeEndingCharacterAnimInstance::TransitionToNextSequence' has a wrong offset!");

// Class ObsidianFox.AnimationDataAssetBase
// 0x0000 (0x0030 - 0x0030)
class UAnimationDataAssetBase : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationDataAssetBase">();
	}
	static class UAnimationDataAssetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationDataAssetBase>();
	}
};
static_assert(alignof(UAnimationDataAssetBase) == 0x000008, "Wrong alignment on UAnimationDataAssetBase");
static_assert(sizeof(UAnimationDataAssetBase) == 0x000030, "Wrong size on UAnimationDataAssetBase");

// Class ObsidianFox.OFBFL_Math
// 0x0000 (0x0028 - 0x0028)
class UOFBFL_Math final : public UBlueprintFunctionLibrary
{
public:
	static float AbsMax_FloatFloat(float A, float B);
	static void DebugDrawFrustum(const class UObject* WorldContextObject, const struct FFrustumData& FrustumData, const struct FLinearColor& Color);
	static bool DoesFrustumIntersectPoint(const struct FFrustumData& FrustumData, const struct FVector& Point);
	static void DrawDebugCircleSegment(const class UObject* WorldContextObject, const struct FVector& Origin, float AngleDegrees, float Resolution, const struct FVector& AngleAxis, const struct FVector& StartDirection, float Radius, const struct FLinearColor& Color, float Lifetime, uint8 DepthPriority, float Thickness, bool bRenderClockWise, bool bRenderEdges);
	static float FindAngleBetweenVectors(const struct FVector& A, const struct FVector& B);
	static float GetAngleToVector2D(const struct FVector& OriginDirection, const struct FVector& DestinationDirection);
	static struct FFrustumData GetFrustumData(const struct FFrustumSettings& FrustumSettings, const struct FRotator& FrustumRotation, const struct FVector& FrustumLocation);
	static ECardinalDirection GetHitQuadrantFromHitResult(const struct FHitResult& HitResult);
	static ECardinalDirection GetQuadrantFromDirection(const struct FVector& Direction, const struct FVector& Forward);
	static void RotateAroundObject(class AActor* ObjectToRotate, const class USceneComponent* ObjectToRotateAround, float Degrees);
	static float SmoothStep(const float A, const float B, const float X);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFBFL_Math">();
	}
	static class UOFBFL_Math* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFBFL_Math>();
	}
};
static_assert(alignof(UOFBFL_Math) == 0x000008, "Wrong alignment on UOFBFL_Math");
static_assert(sizeof(UOFBFL_Math) == 0x000028, "Wrong size on UOFBFL_Math");

// Class ObsidianFox.AnimationEnvironmentSettings
// 0x0000 (0x0210 - 0x0210)
class UAnimationEnvironmentSettings final : public USceneComponent
{
public:
	bool                                          bIsImpassableTerrainObstacle;                      // 0x0208(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWallTwistObstacle;                              // 0x0209(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20A[0x6];                                      // 0x020A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationEnvironmentSettings">();
	}
	static class UAnimationEnvironmentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationEnvironmentSettings>();
	}
};
static_assert(alignof(UAnimationEnvironmentSettings) == 0x000010, "Wrong alignment on UAnimationEnvironmentSettings");
static_assert(sizeof(UAnimationEnvironmentSettings) == 0x000210, "Wrong size on UAnimationEnvironmentSettings");
static_assert(offsetof(UAnimationEnvironmentSettings, bIsImpassableTerrainObstacle) == 0x000208, "Member 'UAnimationEnvironmentSettings::bIsImpassableTerrainObstacle' has a wrong offset!");
static_assert(offsetof(UAnimationEnvironmentSettings, bIsWallTwistObstacle) == 0x000209, "Member 'UAnimationEnvironmentSettings::bIsWallTwistObstacle' has a wrong offset!");

// Class ObsidianFox.AnimationHitReactionInterface
// 0x0000 (0x0028 - 0x0028)
class IAnimationHitReactionInterface final : public IInterface
{
public:
	void TriggerAnimationBlueprintHitReaction(const struct FHitReactionData& HitReactionData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationHitReactionInterface">();
	}
	static class IAnimationHitReactionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimationHitReactionInterface>();
	}
};
static_assert(alignof(IAnimationHitReactionInterface) == 0x000008, "Wrong alignment on IAnimationHitReactionInterface");
static_assert(sizeof(IAnimationHitReactionInterface) == 0x000028, "Wrong size on IAnimationHitReactionInterface");

// Class ObsidianFox.OFCharacterTypeSpecificSettings
// 0x0058 (0x0090 - 0x0038)
class UOFCharacterTypeSpecificSettings final : public UDeveloperSettings
{
public:
	bool                                          OpenInGameMenuEnabled_Edward;                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OpenInGameMenuEnabled_Emily;                       // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OpenInGameMenuEnabled_Grace;                       // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPlayerCharacterType, TSoftClassPtr<class UClass>> CharacterPauseMenu;                                // 0x0040(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFCharacterTypeSpecificSettings">();
	}
	static class UOFCharacterTypeSpecificSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFCharacterTypeSpecificSettings>();
	}
};
static_assert(alignof(UOFCharacterTypeSpecificSettings) == 0x000008, "Wrong alignment on UOFCharacterTypeSpecificSettings");
static_assert(sizeof(UOFCharacterTypeSpecificSettings) == 0x000090, "Wrong size on UOFCharacterTypeSpecificSettings");
static_assert(offsetof(UOFCharacterTypeSpecificSettings, OpenInGameMenuEnabled_Edward) == 0x000038, "Member 'UOFCharacterTypeSpecificSettings::OpenInGameMenuEnabled_Edward' has a wrong offset!");
static_assert(offsetof(UOFCharacterTypeSpecificSettings, OpenInGameMenuEnabled_Emily) == 0x000039, "Member 'UOFCharacterTypeSpecificSettings::OpenInGameMenuEnabled_Emily' has a wrong offset!");
static_assert(offsetof(UOFCharacterTypeSpecificSettings, OpenInGameMenuEnabled_Grace) == 0x00003A, "Member 'UOFCharacterTypeSpecificSettings::OpenInGameMenuEnabled_Grace' has a wrong offset!");
static_assert(offsetof(UOFCharacterTypeSpecificSettings, CharacterPauseMenu) == 0x000040, "Member 'UOFCharacterTypeSpecificSettings::CharacterPauseMenu' has a wrong offset!");

// Class ObsidianFox.AnimationLookupTableMap
// 0x0038 (0x0060 - 0x0028)
class UAnimationLookupTableMap final : public UObject
{
public:
	TArray<struct FAnimationLookupTableEntry>     Animations;                                        // 0x0028(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class USkeleton>               CurrentSkeleton;                                   // 0x0038(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationLookupTableMap">();
	}
	static class UAnimationLookupTableMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationLookupTableMap>();
	}
};
static_assert(alignof(UAnimationLookupTableMap) == 0x000008, "Wrong alignment on UAnimationLookupTableMap");
static_assert(sizeof(UAnimationLookupTableMap) == 0x000060, "Wrong size on UAnimationLookupTableMap");
static_assert(offsetof(UAnimationLookupTableMap, Animations) == 0x000028, "Member 'UAnimationLookupTableMap::Animations' has a wrong offset!");
static_assert(offsetof(UAnimationLookupTableMap, CurrentSkeleton) == 0x000038, "Member 'UAnimationLookupTableMap::CurrentSkeleton' has a wrong offset!");

// Class ObsidianFox.AnimationLookupTable
// 0x0030 (0x0058 - 0x0028)
class UAnimationLookupTable final : public UObject
{
public:
	TSoftObjectPtr<class USkeleton>               Skeleton;                                          // 0x0028(0x0028)(Edit, AssetRegistrySearchable, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationLookupTableMap*               AnimationMap;                                      // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationLookupTable">();
	}
	static class UAnimationLookupTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationLookupTable>();
	}
};
static_assert(alignof(UAnimationLookupTable) == 0x000008, "Wrong alignment on UAnimationLookupTable");
static_assert(sizeof(UAnimationLookupTable) == 0x000058, "Wrong size on UAnimationLookupTable");
static_assert(offsetof(UAnimationLookupTable, Skeleton) == 0x000028, "Member 'UAnimationLookupTable::Skeleton' has a wrong offset!");
static_assert(offsetof(UAnimationLookupTable, AnimationMap) == 0x000050, "Member 'UAnimationLookupTable::AnimationMap' has a wrong offset!");

// Class ObsidianFox.OFBlueprintUtils
// 0x0000 (0x0028 - 0x0028)
class UOFBlueprintUtils final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector GetBestPointForAttacking(const struct FVector& CurrentPos, const struct FVector& TargetPos, const TArray<struct FVector>& PointsArray, const float Tolerance);
	static class FString GetGameVersion();
	static TArray<TSoftObjectPtr<class UWorld>> GetGlobalListOfLevelsToIgnoreForPreStreaming();
	static bool IsWithEditor();
	static void RebuildNavmesh(const class UObject* WorldContextObject);
	static int32 WaitForAssetStreamingToComplete(float Timeout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFBlueprintUtils">();
	}
	static class UOFBlueprintUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFBlueprintUtils>();
	}
};
static_assert(alignof(UOFBlueprintUtils) == 0x000008, "Wrong alignment on UOFBlueprintUtils");
static_assert(sizeof(UOFBlueprintUtils) == 0x000028, "Wrong size on UOFBlueprintUtils");

// Class ObsidianFox.AnimationMotionInterface
// 0x0000 (0x0028 - 0x0028)
class IAnimationMotionInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationMotionInterface">();
	}
	static class IAnimationMotionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimationMotionInterface>();
	}
};
static_assert(alignof(IAnimationMotionInterface) == 0x000008, "Wrong alignment on IAnimationMotionInterface");
static_assert(sizeof(IAnimationMotionInterface) == 0x000028, "Wrong size on IAnimationMotionInterface");

// Class ObsidianFox.AnimationRagdollInterface
// 0x0000 (0x0028 - 0x0028)
class IAnimationRagdollInterface final : public IInterface
{
public:
	void BeginBasicRagdoll(class UObject* SessionOwner, class FName RootBoneName, class FName ProfileName, const struct FRagdollWeightCurves& WeightCurveNames);
	void BeginVelocityBlendOutRagdoll(class UObject* SessionOwner, class FName RootBoneName, class FName ProfileName, const struct FRagdollWeightCurves& WeightCurveNames, const struct FRagdollAutoBlendOutParameters& ExtraParameters, const TDelegate<void()>& BlendOutBeginEvent);
	void EndRagdoll(class UObject* SessionOwner, class FName SnapshotName);
	void OnRagdollNotifyBegin(class UObject* SessionOwner, const class FName& RagdollRootBone, const class FName& ProfileName, const struct FRagdollWeightCurves& WeightCurveNames);
	void OnRagdollNotifyEnd(class UObject* SessionOwner, class FName SnapshotName, bool bKeepRagdollAfterNotifyEnd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationRagdollInterface">();
	}
	static class IAnimationRagdollInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimationRagdollInterface>();
	}
};
static_assert(alignof(IAnimationRagdollInterface) == 0x000008, "Wrong alignment on IAnimationRagdollInterface");
static_assert(sizeof(IAnimationRagdollInterface) == 0x000028, "Wrong size on IAnimationRagdollInterface");

// Class ObsidianFox.AnimationTagMetaData
// 0x0010 (0x0038 - 0x0028)
class UAnimationTagMetaData final : public UAnimMetaData
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0028(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SubTag;                                            // 0x0030(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationTagMetaData">();
	}
	static class UAnimationTagMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationTagMetaData>();
	}
};
static_assert(alignof(UAnimationTagMetaData) == 0x000008, "Wrong alignment on UAnimationTagMetaData");
static_assert(sizeof(UAnimationTagMetaData) == 0x000038, "Wrong size on UAnimationTagMetaData");
static_assert(offsetof(UAnimationTagMetaData, Tag) == 0x000028, "Member 'UAnimationTagMetaData::Tag' has a wrong offset!");
static_assert(offsetof(UAnimationTagMetaData, SubTag) == 0x000030, "Member 'UAnimationTagMetaData::SubTag' has a wrong offset!");

// Class ObsidianFox.AnimComponent
// 0x0028 (0x0050 - 0x0028)
class UAnimComponent : public UObject
{
public:
	class UOFAnimInstance*                        AnimInstance;                                      // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AObsidianFoxCharacter*                  OwnerChar;                                         // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 OwnerComponent;                                    // 0x0038(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsActive : 1;                                     // 0x0040(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActualBeginPlay();
	void Blueprint_Initialize();
	void Blueprint_Update(float DeltaTime);
	void OnPreSave(ESaveTypePolicy SaveTypePolicy);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimComponent">();
	}
	static class UAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimComponent>();
	}
};
static_assert(alignof(UAnimComponent) == 0x000008, "Wrong alignment on UAnimComponent");
static_assert(sizeof(UAnimComponent) == 0x000050, "Wrong size on UAnimComponent");
static_assert(offsetof(UAnimComponent, AnimInstance) == 0x000028, "Member 'UAnimComponent::AnimInstance' has a wrong offset!");
static_assert(offsetof(UAnimComponent, OwnerChar) == 0x000030, "Member 'UAnimComponent::OwnerChar' has a wrong offset!");
static_assert(offsetof(UAnimComponent, OwnerComponent) == 0x000038, "Member 'UAnimComponent::OwnerComponent' has a wrong offset!");

// Class ObsidianFox.AnimComponentAIFocus
// 0x0100 (0x0150 - 0x0050)
class UAnimComponentAIFocus final : public UAnimComponent
{
public:
	struct FBlendableRotator                      FocalPointBodyRotation;                            // 0x0050(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBlendableRotator                      MovementBodyRotation;                              // 0x0080(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                FocalPoint;                                        // 0x00B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHasFocalPoint : 1;                                // 0x00BC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFocusDisabled : 1;                                // 0x00BC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_BC_2 : 6;                                   // 0x00BC(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_BD[0x63];                                      // 0x00BD(0x0063)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bDisableFocusWhenMoving : 1;                       // 0x0120(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseBlackBoardKeys : 1;                            // 0x0120(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_121[0x3];                                      // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FocusPointKey;                                     // 0x0124(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HasFocusPointKey;                                  // 0x012C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               FocusRotationLimit;                                // 0x0134(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x10];                                     // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimComponentAIFocus">();
	}
	static class UAnimComponentAIFocus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimComponentAIFocus>();
	}
};
static_assert(alignof(UAnimComponentAIFocus) == 0x000010, "Wrong alignment on UAnimComponentAIFocus");
static_assert(sizeof(UAnimComponentAIFocus) == 0x000150, "Wrong size on UAnimComponentAIFocus");
static_assert(offsetof(UAnimComponentAIFocus, FocalPointBodyRotation) == 0x000050, "Member 'UAnimComponentAIFocus::FocalPointBodyRotation' has a wrong offset!");
static_assert(offsetof(UAnimComponentAIFocus, MovementBodyRotation) == 0x000080, "Member 'UAnimComponentAIFocus::MovementBodyRotation' has a wrong offset!");
static_assert(offsetof(UAnimComponentAIFocus, FocalPoint) == 0x0000B0, "Member 'UAnimComponentAIFocus::FocalPoint' has a wrong offset!");
static_assert(offsetof(UAnimComponentAIFocus, FocusPointKey) == 0x000124, "Member 'UAnimComponentAIFocus::FocusPointKey' has a wrong offset!");
static_assert(offsetof(UAnimComponentAIFocus, HasFocusPointKey) == 0x00012C, "Member 'UAnimComponentAIFocus::HasFocusPointKey' has a wrong offset!");
static_assert(offsetof(UAnimComponentAIFocus, FocusRotationLimit) == 0x000134, "Member 'UAnimComponentAIFocus::FocusRotationLimit' has a wrong offset!");

// Class ObsidianFox.ArmIKEffectorSession
// 0x0080 (0x00A8 - 0x0028)
class UArmIKEffectorSession final : public UObject
{
public:
	TWeakObjectPtr<class UObject>                 SessionOwner;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FArmIKReferenceTarget                  TargetReferenceData;                               // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x28];                                      // 0x0080(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmIKEffectorSession">();
	}
	static class UArmIKEffectorSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmIKEffectorSession>();
	}
};
static_assert(alignof(UArmIKEffectorSession) == 0x000008, "Wrong alignment on UArmIKEffectorSession");
static_assert(sizeof(UArmIKEffectorSession) == 0x0000A8, "Wrong size on UArmIKEffectorSession");
static_assert(offsetof(UArmIKEffectorSession, SessionOwner) == 0x000028, "Member 'UArmIKEffectorSession::SessionOwner' has a wrong offset!");
static_assert(offsetof(UArmIKEffectorSession, TargetReferenceData) == 0x000070, "Member 'UArmIKEffectorSession::TargetReferenceData' has a wrong offset!");

// Class ObsidianFox.AnimComponentArmIK
// 0x00A0 (0x00F0 - 0x0050)
class UAnimComponentArmIK final : public UAnimComponent
{
public:
	TMap<class FName, struct FArmIKEffectorStack> StackMap;                                          // 0x0050(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class UObject*, class UArmIKEffectorSession*> SessionDataQueue;                                  // 0x00A0(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	struct FArmIKEffectorData GetEffectorData(const class FName BoneName, const class FName FKLocationBoneName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimComponentArmIK">();
	}
	static class UAnimComponentArmIK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimComponentArmIK>();
	}
};
static_assert(alignof(UAnimComponentArmIK) == 0x000008, "Wrong alignment on UAnimComponentArmIK");
static_assert(sizeof(UAnimComponentArmIK) == 0x0000F0, "Wrong size on UAnimComponentArmIK");
static_assert(offsetof(UAnimComponentArmIK, StackMap) == 0x000050, "Member 'UAnimComponentArmIK::StackMap' has a wrong offset!");
static_assert(offsetof(UAnimComponentArmIK, SessionDataQueue) == 0x0000A0, "Member 'UAnimComponentArmIK::SessionDataQueue' has a wrong offset!");

// Class ObsidianFox.OFSpringArmComponent
// 0x0090 (0x0320 - 0x0290)
class UOFSpringArmComponent final : public USpringArmComponent
{
public:
	struct FVector                                RelativeCameraOffset;                              // 0x0290(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomAlpha;                                         // 0x029C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ZoomSocketOffset;                                  // 0x02A0(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SocketOffsetUnzoomed;                              // 0x02AC(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        RelativeTarget;                                    // 0x02B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomTargetArmLength;                               // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTargetArmLength;                                // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCameraStepLag;                              // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraLagSpeedWalkMultiplier;                      // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraLagSpeedRunMultiplier;                       // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StepLagWalkDuration;                               // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StepLagRunDuration;                                // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StepLagInterpSpeed;                                // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OffsetZMin;                                        // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmLengthZoomIn;                                   // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetDistanceMin;                                 // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TargetDistanceSwapSideMin;                         // 0x02EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x30];                                     // 0x02F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAiming(bool bInIsAiming);
	void ResetCameraLag();
	void StepLag(bool bIsRunning);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFSpringArmComponent">();
	}
	static class UOFSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFSpringArmComponent>();
	}
};
static_assert(alignof(UOFSpringArmComponent) == 0x000010, "Wrong alignment on UOFSpringArmComponent");
static_assert(sizeof(UOFSpringArmComponent) == 0x000320, "Wrong size on UOFSpringArmComponent");
static_assert(offsetof(UOFSpringArmComponent, RelativeCameraOffset) == 0x000290, "Member 'UOFSpringArmComponent::RelativeCameraOffset' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, ZoomAlpha) == 0x00029C, "Member 'UOFSpringArmComponent::ZoomAlpha' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, ZoomSocketOffset) == 0x0002A0, "Member 'UOFSpringArmComponent::ZoomSocketOffset' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, SocketOffsetUnzoomed) == 0x0002AC, "Member 'UOFSpringArmComponent::SocketOffsetUnzoomed' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, RelativeTarget) == 0x0002B8, "Member 'UOFSpringArmComponent::RelativeTarget' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, ZoomTargetArmLength) == 0x0002C0, "Member 'UOFSpringArmComponent::ZoomTargetArmLength' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, MaxTargetArmLength) == 0x0002C4, "Member 'UOFSpringArmComponent::MaxTargetArmLength' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, bEnableCameraStepLag) == 0x0002C8, "Member 'UOFSpringArmComponent::bEnableCameraStepLag' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, CameraLagSpeedWalkMultiplier) == 0x0002CC, "Member 'UOFSpringArmComponent::CameraLagSpeedWalkMultiplier' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, CameraLagSpeedRunMultiplier) == 0x0002D0, "Member 'UOFSpringArmComponent::CameraLagSpeedRunMultiplier' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, StepLagWalkDuration) == 0x0002D4, "Member 'UOFSpringArmComponent::StepLagWalkDuration' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, StepLagRunDuration) == 0x0002D8, "Member 'UOFSpringArmComponent::StepLagRunDuration' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, StepLagInterpSpeed) == 0x0002DC, "Member 'UOFSpringArmComponent::StepLagInterpSpeed' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, OffsetZMin) == 0x0002E0, "Member 'UOFSpringArmComponent::OffsetZMin' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, ArmLengthZoomIn) == 0x0002E4, "Member 'UOFSpringArmComponent::ArmLengthZoomIn' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, TargetDistanceMin) == 0x0002E8, "Member 'UOFSpringArmComponent::TargetDistanceMin' has a wrong offset!");
static_assert(offsetof(UOFSpringArmComponent, TargetDistanceSwapSideMin) == 0x0002EC, "Member 'UOFSpringArmComponent::TargetDistanceSwapSideMin' has a wrong offset!");

// Class ObsidianFox.AnimComponentDismemberment
// 0x0028 (0x0078 - 0x0050)
class UAnimComponentDismemberment final : public UAnimComponent
{
public:
	class UDataTable*                             DismemberLinksDataTable;                           // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDismemberPointData>            DismemberPoints;                                   // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAllowMultipleDismemberments;                      // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RootBoneName;                                      // 0x006C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void TriggerDismemberment(const struct FHitResult& Hit, const float HitMagnitude, bool IsKillingHit);

	struct FDismemberPointData GetDismemberPointDataFromIndex(const int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimComponentDismemberment">();
	}
	static class UAnimComponentDismemberment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimComponentDismemberment>();
	}
};
static_assert(alignof(UAnimComponentDismemberment) == 0x000008, "Wrong alignment on UAnimComponentDismemberment");
static_assert(sizeof(UAnimComponentDismemberment) == 0x000078, "Wrong size on UAnimComponentDismemberment");
static_assert(offsetof(UAnimComponentDismemberment, DismemberLinksDataTable) == 0x000050, "Member 'UAnimComponentDismemberment::DismemberLinksDataTable' has a wrong offset!");
static_assert(offsetof(UAnimComponentDismemberment, DismemberPoints) == 0x000058, "Member 'UAnimComponentDismemberment::DismemberPoints' has a wrong offset!");
static_assert(offsetof(UAnimComponentDismemberment, bAllowMultipleDismemberments) == 0x000068, "Member 'UAnimComponentDismemberment::bAllowMultipleDismemberments' has a wrong offset!");
static_assert(offsetof(UAnimComponentDismemberment, RootBoneName) == 0x00006C, "Member 'UAnimComponentDismemberment::RootBoneName' has a wrong offset!");

// Class ObsidianFox.AnimComponentDistanceRotation
// 0x0098 (0x00E8 - 0x0050)
class UAnimComponentDistanceRotation final : public UAnimComponent
{
public:
	float                                         CurrentTurnAngle;                                  // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PreviousTurnAngle;                                 // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x50];                                      // 0x0058(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeshRotationResetInterpolationSpeed;               // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MeshRotationTurnInterpolationSpeed;                // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActorRotateSpeed;                                  // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsRotating : 1;                                   // 0x00B4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               MeshOffsetRotation;                                // 0x00B8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C4[0xC];                                       // 0x00C4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationCancelAngleThreshold;                      // 0x00D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActorRotationSpeed;                                // 0x00D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bConsiderInput : 1;                                // 0x00D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_D9[0xF];                                       // 0x00D9(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimComponentDistanceRotation">();
	}
	static class UAnimComponentDistanceRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimComponentDistanceRotation>();
	}
};
static_assert(alignof(UAnimComponentDistanceRotation) == 0x000008, "Wrong alignment on UAnimComponentDistanceRotation");
static_assert(sizeof(UAnimComponentDistanceRotation) == 0x0000E8, "Wrong size on UAnimComponentDistanceRotation");
static_assert(offsetof(UAnimComponentDistanceRotation, CurrentTurnAngle) == 0x000050, "Member 'UAnimComponentDistanceRotation::CurrentTurnAngle' has a wrong offset!");
static_assert(offsetof(UAnimComponentDistanceRotation, PreviousTurnAngle) == 0x000054, "Member 'UAnimComponentDistanceRotation::PreviousTurnAngle' has a wrong offset!");
static_assert(offsetof(UAnimComponentDistanceRotation, MeshRotationResetInterpolationSpeed) == 0x0000A8, "Member 'UAnimComponentDistanceRotation::MeshRotationResetInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UAnimComponentDistanceRotation, MeshRotationTurnInterpolationSpeed) == 0x0000AC, "Member 'UAnimComponentDistanceRotation::MeshRotationTurnInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UAnimComponentDistanceRotation, ActorRotateSpeed) == 0x0000B0, "Member 'UAnimComponentDistanceRotation::ActorRotateSpeed' has a wrong offset!");
static_assert(offsetof(UAnimComponentDistanceRotation, MeshOffsetRotation) == 0x0000B8, "Member 'UAnimComponentDistanceRotation::MeshOffsetRotation' has a wrong offset!");
static_assert(offsetof(UAnimComponentDistanceRotation, RotationCancelAngleThreshold) == 0x0000D0, "Member 'UAnimComponentDistanceRotation::RotationCancelAngleThreshold' has a wrong offset!");
static_assert(offsetof(UAnimComponentDistanceRotation, ActorRotationSpeed) == 0x0000D4, "Member 'UAnimComponentDistanceRotation::ActorRotationSpeed' has a wrong offset!");

// Class ObsidianFox.PauseInterface
// 0x0000 (0x0028 - 0x0028)
class IPauseInterface final : public IInterface
{
public:
	void OnPauseChanged(bool bPaused);

	void GetRunningTimers(TArray<struct FTimerHandle>* OutTimers) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PauseInterface">();
	}
	static class IPauseInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPauseInterface>();
	}
};
static_assert(alignof(IPauseInterface) == 0x000008, "Wrong alignment on IPauseInterface");
static_assert(sizeof(IPauseInterface) == 0x000028, "Wrong size on IPauseInterface");

// Class ObsidianFox.AnimComponentFootIKDebugDrawer
// 0x0000 (0x0028 - 0x0028)
class UAnimComponentFootIKDebugDrawer final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimComponentFootIKDebugDrawer">();
	}
	static class UAnimComponentFootIKDebugDrawer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimComponentFootIKDebugDrawer>();
	}
};
static_assert(alignof(UAnimComponentFootIKDebugDrawer) == 0x000008, "Wrong alignment on UAnimComponentFootIKDebugDrawer");
static_assert(sizeof(UAnimComponentFootIKDebugDrawer) == 0x000028, "Wrong size on UAnimComponentFootIKDebugDrawer");

// Class ObsidianFox.AnimComponentFootIK
// 0x0158 (0x01A8 - 0x0050)
class UAnimComponentFootIK final : public UAnimComponent
{
public:
	class UAnimComponentFootIKDebugDrawer*        DebugDrawer;                                       // 0x0050(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             CollisionChannel;                                  // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IKAlpha;                                           // 0x005C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LegIKMaxOffsetHeight;                              // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalInterpolationSpeed;                        // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HorizontalInterpolationSpeed;                      // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FeetPlantBreakVerticalDifference;                  // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FeetPlantBreakHorizontalDifference;                // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceHeight;                                       // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KeepFootPlantedCurveName;                          // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bTraceStaticOnly : 1;                              // 0x0080(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bXForward : 1;                                     // 0x0080(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableKeepFootPlantedIK : 1;                      // 0x0080(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bKeepFootPlantedAlways : 1;                        // 0x0080(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableKeepFootPlantedDuringSprint : 1;           // 0x0080(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FIKFootSettings>                Bones;                                             // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_98[0x50];                                      // 0x0098(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UOFCharacterMovementComponent*          CharacterMovementComponent;                        // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F0[0x8];                                       // 0x00F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FFootIKModifierArrayWrapper> BoneIKModifierStack;                               // 0x00F8(0x0050)(Protected, NativeAccessSpecifierProtected)
	int32                                         NumStepTraces;                                     // 0x0148(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StepLengthCurveName;                               // 0x014C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FootRadius;                                        // 0x0154(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x50];                                     // 0x0158(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UFootIKModifier* AddIKModifier(const class FName BoneName, TSubclassOf<class UFootIKModifier> ModifierClass);
	void OnFootDown(const struct FVector& StepLocation, EFootType FootStepType, const class FName& BoneName);
	void OnFootUp(const struct FVector& StepLocation, EFootType FootStepType, const class FName& BoneName);
	void RemoveIKModifier(const class FName BoneName, class UFootIKModifier* Modifier);

	struct FVector GetEffectorLocation(const class FName BoneName) const;
	struct FRotator GetEffectorRotation(const class FName BoneName) const;
	EPhysicalSurface GetEffectorSurfaceType(const class FName BoneName) const;
	struct FVector GetEffectorTargetLocation(const class FName BoneName) const;
	void GetEffectorTransform(const class FName BoneName, struct FTransform* OutTransform) const;
	void GetFeetPlantData(struct FFeetPlantData* FeetPlantData, const class FName BoneName) const;
	struct FVector GetPoleVectorLocation(const class FName BoneName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimComponentFootIK">();
	}
	static class UAnimComponentFootIK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimComponentFootIK>();
	}
};
static_assert(alignof(UAnimComponentFootIK) == 0x000008, "Wrong alignment on UAnimComponentFootIK");
static_assert(sizeof(UAnimComponentFootIK) == 0x0001A8, "Wrong size on UAnimComponentFootIK");
static_assert(offsetof(UAnimComponentFootIK, DebugDrawer) == 0x000050, "Member 'UAnimComponentFootIK::DebugDrawer' has a wrong offset!");
static_assert(offsetof(UAnimComponentFootIK, CollisionChannel) == 0x000058, "Member 'UAnimComponentFootIK::CollisionChannel' has a wrong offset!");
static_assert(offsetof(UAnimComponentFootIK, IKAlpha) == 0x00005C, "Member 'UAnimComponentFootIK::IKAlpha' has a wrong offset!");
static_assert(offsetof(UAnimComponentFootIK, LegIKMaxOffsetHeight) == 0x000060, "Member 'UAnimComponentFootIK::LegIKMaxOffsetHeight' has a wrong offset!");
static_assert(offsetof(UAnimComponentFootIK, VerticalInterpolationSpeed) == 0x000064, "Member 'UAnimComponentFootIK::VerticalInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UAnimComponentFootIK, HorizontalInterpolationSpeed) == 0x000068, "Member 'UAnimComponentFootIK::HorizontalInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UAnimComponentFootIK, FeetPlantBreakVerticalDifference) == 0x00006C, "Member 'UAnimComponentFootIK::FeetPlantBreakVerticalDifference' has a wrong offset!");
static_assert(offsetof(UAnimComponentFootIK, FeetPlantBreakHorizontalDifference) == 0x000070, "Member 'UAnimComponentFootIK::FeetPlantBreakHorizontalDifference' has a wrong offset!");
static_assert(offsetof(UAnimComponentFootIK, TraceHeight) == 0x000074, "Member 'UAnimComponentFootIK::TraceHeight' has a wrong offset!");
static_assert(offsetof(UAnimComponentFootIK, KeepFootPlantedCurveName) == 0x000078, "Member 'UAnimComponentFootIK::KeepFootPlantedCurveName' has a wrong offset!");
static_assert(offsetof(UAnimComponentFootIK, Bones) == 0x000088, "Member 'UAnimComponentFootIK::Bones' has a wrong offset!");
static_assert(offsetof(UAnimComponentFootIK, CharacterMovementComponent) == 0x0000E8, "Member 'UAnimComponentFootIK::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UAnimComponentFootIK, BoneIKModifierStack) == 0x0000F8, "Member 'UAnimComponentFootIK::BoneIKModifierStack' has a wrong offset!");
static_assert(offsetof(UAnimComponentFootIK, NumStepTraces) == 0x000148, "Member 'UAnimComponentFootIK::NumStepTraces' has a wrong offset!");
static_assert(offsetof(UAnimComponentFootIK, StepLengthCurveName) == 0x00014C, "Member 'UAnimComponentFootIK::StepLengthCurveName' has a wrong offset!");
static_assert(offsetof(UAnimComponentFootIK, FootRadius) == 0x000154, "Member 'UAnimComponentFootIK::FootRadius' has a wrong offset!");

// Class ObsidianFox.InGameUIWidget
// 0x0018 (0x0278 - 0x0260)
class UInGameUIWidget : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnPlayerHUDVisibilityChanged;                      // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x8];                                      // 0x0270(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideShowUI();
	void HUDVisibilityChanged(bool bNewHUDVisbility);
	void PlayerHUDVisibilitySignature__DelegateSignature(bool bNewHUDVisibility);

	bool GetIsVisibilityAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameUIWidget">();
	}
	static class UInGameUIWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameUIWidget>();
	}
};
static_assert(alignof(UInGameUIWidget) == 0x000008, "Wrong alignment on UInGameUIWidget");
static_assert(sizeof(UInGameUIWidget) == 0x000278, "Wrong size on UInGameUIWidget");
static_assert(offsetof(UInGameUIWidget, OnPlayerHUDVisibilityChanged) == 0x000260, "Member 'UInGameUIWidget::OnPlayerHUDVisibilityChanged' has a wrong offset!");

// Class ObsidianFox.OF_HUDCrosshair
// 0x0020 (0x0298 - 0x0278)
class UOF_HUDCrosshair : public UInGameUIWidget
{
public:
	struct FGameplayTag                           HasAimTargetTag;                                   // 0x0278(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AimingStatusTag;                                   // 0x0280(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AHitscanWeaponActor>     TrackedWeapon;                                     // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAimingTrackedWeapon;                              // 0x0290(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHasTargetChanged(bool SetHasTarget);
	void OnTrackedWeaponHitHandler(const struct FGameplayEventData& EventPayload);
	void OnTrackedWeaponSet(class AHitscanWeaponActor* InTrackedWeapon);
	void OnWeaponAimStateChanged(bool IsAimingWeapon);
	void OnWeaponHit(const struct FGameplayEventData& EventPayload, int32 Hits);
	void SetTrackedWeapon(class AHitscanWeaponActor* WeaponToTrack);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OF_HUDCrosshair">();
	}
	static class UOF_HUDCrosshair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOF_HUDCrosshair>();
	}
};
static_assert(alignof(UOF_HUDCrosshair) == 0x000008, "Wrong alignment on UOF_HUDCrosshair");
static_assert(sizeof(UOF_HUDCrosshair) == 0x000298, "Wrong size on UOF_HUDCrosshair");
static_assert(offsetof(UOF_HUDCrosshair, HasAimTargetTag) == 0x000278, "Member 'UOF_HUDCrosshair::HasAimTargetTag' has a wrong offset!");
static_assert(offsetof(UOF_HUDCrosshair, AimingStatusTag) == 0x000280, "Member 'UOF_HUDCrosshair::AimingStatusTag' has a wrong offset!");
static_assert(offsetof(UOF_HUDCrosshair, TrackedWeapon) == 0x000288, "Member 'UOF_HUDCrosshair::TrackedWeapon' has a wrong offset!");
static_assert(offsetof(UOF_HUDCrosshair, bAimingTrackedWeapon) == 0x000290, "Member 'UOF_HUDCrosshair::bAimingTrackedWeapon' has a wrong offset!");

// Class ObsidianFox.AnimationLockedTurnInPlaceInterface
// 0x0000 (0x0028 - 0x0028)
class IAnimationLockedTurnInPlaceInterface final : public IInterface
{
public:
	void RequestManualLockedTurnInPlace(float AngleDegrees);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationLockedTurnInPlaceInterface">();
	}
	static class IAnimationLockedTurnInPlaceInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimationLockedTurnInPlaceInterface>();
	}
};
static_assert(alignof(IAnimationLockedTurnInPlaceInterface) == 0x000008, "Wrong alignment on IAnimationLockedTurnInPlaceInterface");
static_assert(sizeof(IAnimationLockedTurnInPlaceInterface) == 0x000028, "Wrong size on IAnimationLockedTurnInPlaceInterface");

// Class ObsidianFox.AnimComponentLockedTurnInPlace
// 0x0030 (0x0080 - 0x0050)
class UAnimComponentLockedTurnInPlace final : public UAnimComponent
{
public:
	float                                         FastTurnAngle;                                     // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsFastTurn : 1;                                   // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsAnimationPlaying : 1;                           // 0x0054(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateData                   TurnInPlaceState;                                  // 0x0058(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0xC];                                       // 0x0074(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceUpdateFastTurnAngle();
	void OnTurnInPlaceEnded();
	void OnTurnInPlaceStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimComponentLockedTurnInPlace">();
	}
	static class UAnimComponentLockedTurnInPlace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimComponentLockedTurnInPlace>();
	}
};
static_assert(alignof(UAnimComponentLockedTurnInPlace) == 0x000008, "Wrong alignment on UAnimComponentLockedTurnInPlace");
static_assert(sizeof(UAnimComponentLockedTurnInPlace) == 0x000080, "Wrong size on UAnimComponentLockedTurnInPlace");
static_assert(offsetof(UAnimComponentLockedTurnInPlace, FastTurnAngle) == 0x000050, "Member 'UAnimComponentLockedTurnInPlace::FastTurnAngle' has a wrong offset!");
static_assert(offsetof(UAnimComponentLockedTurnInPlace, TurnInPlaceState) == 0x000058, "Member 'UAnimComponentLockedTurnInPlace::TurnInPlaceState' has a wrong offset!");

// Class ObsidianFox.OFSaveGameWorld
// 0x0010 (0x00E0 - 0x00D0)
class UOFSaveGameWorld final : public UPiecesSaveGameWorld
{
public:
	EPlayerCharacterType                          PlayerCharacterType;                               // 0x00D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           Progression;                                       // 0x00D4(0x0008)(BlueprintVisible, BlueprintReadOnly, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDifficulty                                   Difficulty;                                        // 0x00DC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerGuidanceLevel                          PlayerGuidanceLevel;                               // 0x00DD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DE[0x2];                                       // 0x00DE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFSaveGameWorld">();
	}
	static class UOFSaveGameWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFSaveGameWorld>();
	}
};
static_assert(alignof(UOFSaveGameWorld) == 0x000010, "Wrong alignment on UOFSaveGameWorld");
static_assert(sizeof(UOFSaveGameWorld) == 0x0000E0, "Wrong size on UOFSaveGameWorld");
static_assert(offsetof(UOFSaveGameWorld, PlayerCharacterType) == 0x0000D0, "Member 'UOFSaveGameWorld::PlayerCharacterType' has a wrong offset!");
static_assert(offsetof(UOFSaveGameWorld, Progression) == 0x0000D4, "Member 'UOFSaveGameWorld::Progression' has a wrong offset!");
static_assert(offsetof(UOFSaveGameWorld, Difficulty) == 0x0000DC, "Member 'UOFSaveGameWorld::Difficulty' has a wrong offset!");
static_assert(offsetof(UOFSaveGameWorld, PlayerGuidanceLevel) == 0x0000DD, "Member 'UOFSaveGameWorld::PlayerGuidanceLevel' has a wrong offset!");

// Class ObsidianFox.RagdollSession
// 0x0030 (0x0058 - 0x0028)
class URagdollSession : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RagdollSession">();
	}
	static class URagdollSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<URagdollSession>();
	}
};
static_assert(alignof(URagdollSession) == 0x000008, "Wrong alignment on URagdollSession");
static_assert(sizeof(URagdollSession) == 0x000058, "Wrong size on URagdollSession");

// Class ObsidianFox.BodyVelocityBlendOutRagdollSession
// 0x00D8 (0x0130 - 0x0058)
class UBodyVelocityBlendOutRagdollSession final : public URagdollSession
{
public:
	uint8                                         Pad_58[0xD8];                                      // 0x0058(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BodyVelocityBlendOutRagdollSession">();
	}
	static class UBodyVelocityBlendOutRagdollSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBodyVelocityBlendOutRagdollSession>();
	}
};
static_assert(alignof(UBodyVelocityBlendOutRagdollSession) == 0x000008, "Wrong alignment on UBodyVelocityBlendOutRagdollSession");
static_assert(sizeof(UBodyVelocityBlendOutRagdollSession) == 0x000130, "Wrong size on UBodyVelocityBlendOutRagdollSession");

// Class ObsidianFox.ParticleEffectSpawnerVolume
// 0x00A0 (0x02D8 - 0x0238)
class AParticleEffectSpawnerVolume final : public AActor
{
public:
	class UBoxComponent*                          Volume;                                            // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        SpawnLocationComponent;                            // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODAudioComponent*                    AudioComponent;                                    // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPersistenceComponent*                  PersistenceComponent;                              // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActivationType                               SpawnerType;                                       // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDelayParticleSpawn;                               // 0x0259(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A[0x2];                                      // 0x025A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSpawnDelayDuration;                             // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSpawnDelayDuration;                             // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnRandomParticleEffect;                        // 0x0264(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265[0x3];                                      // 0x0265(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                EffectsSpawnScale;                                 // 0x0268(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseVolumeActorInsteadOfComponent;                 // 0x0274(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_275[0x3];                                      // 0x0275(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 VolumeActor;                                       // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDelaySound;                                       // 0x0280(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSoundDelayDuration;                             // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSoundDelayDuration;                             // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UNiagaraSystem>>  ParticleEffects;                                   // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCollisionProfileName                  CollisionProfile;                                  // 0x02B0(0x0008)(Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	bool                                          bForceSyncLoadIfNotLoaded;                         // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           SpawnTimerHandle;                                  // 0x02C0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           SoundTimerHandle;                                  // 0x02C8(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasSpawned;                                       // 0x02D0(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x7];                                      // 0x02D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ComponentBeginOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bFromSweep, const struct FHitResult& InSweepResult);
	void ComponentEndOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex);
	void SpawnParticleEffect(const class UWorld* WorldContext, const TSoftObjectPtr<class UNiagaraSystem>& ParticleSystem);
	void SpawnParticleEffects();
	void VolumeActorBeginOverlap(class AActor* OverlappedActor, class AActor* InOtherActor);
	void VolumeActorEndOverlap(class AActor* OverlappedActor, class AActor* InOtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleEffectSpawnerVolume">();
	}
	static class AParticleEffectSpawnerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AParticleEffectSpawnerVolume>();
	}
};
static_assert(alignof(AParticleEffectSpawnerVolume) == 0x000008, "Wrong alignment on AParticleEffectSpawnerVolume");
static_assert(sizeof(AParticleEffectSpawnerVolume) == 0x0002D8, "Wrong size on AParticleEffectSpawnerVolume");
static_assert(offsetof(AParticleEffectSpawnerVolume, Volume) == 0x000238, "Member 'AParticleEffectSpawnerVolume::Volume' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, SpawnLocationComponent) == 0x000240, "Member 'AParticleEffectSpawnerVolume::SpawnLocationComponent' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, AudioComponent) == 0x000248, "Member 'AParticleEffectSpawnerVolume::AudioComponent' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, PersistenceComponent) == 0x000250, "Member 'AParticleEffectSpawnerVolume::PersistenceComponent' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, SpawnerType) == 0x000258, "Member 'AParticleEffectSpawnerVolume::SpawnerType' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, bDelayParticleSpawn) == 0x000259, "Member 'AParticleEffectSpawnerVolume::bDelayParticleSpawn' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, MinSpawnDelayDuration) == 0x00025C, "Member 'AParticleEffectSpawnerVolume::MinSpawnDelayDuration' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, MaxSpawnDelayDuration) == 0x000260, "Member 'AParticleEffectSpawnerVolume::MaxSpawnDelayDuration' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, bSpawnRandomParticleEffect) == 0x000264, "Member 'AParticleEffectSpawnerVolume::bSpawnRandomParticleEffect' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, EffectsSpawnScale) == 0x000268, "Member 'AParticleEffectSpawnerVolume::EffectsSpawnScale' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, bUseVolumeActorInsteadOfComponent) == 0x000274, "Member 'AParticleEffectSpawnerVolume::bUseVolumeActorInsteadOfComponent' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, VolumeActor) == 0x000278, "Member 'AParticleEffectSpawnerVolume::VolumeActor' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, bDelaySound) == 0x000280, "Member 'AParticleEffectSpawnerVolume::bDelaySound' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, MinSoundDelayDuration) == 0x000284, "Member 'AParticleEffectSpawnerVolume::MinSoundDelayDuration' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, MaxSoundDelayDuration) == 0x000288, "Member 'AParticleEffectSpawnerVolume::MaxSoundDelayDuration' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, ParticleEffects) == 0x000290, "Member 'AParticleEffectSpawnerVolume::ParticleEffects' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, CollisionProfile) == 0x0002B0, "Member 'AParticleEffectSpawnerVolume::CollisionProfile' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, bForceSyncLoadIfNotLoaded) == 0x0002B8, "Member 'AParticleEffectSpawnerVolume::bForceSyncLoadIfNotLoaded' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, SpawnTimerHandle) == 0x0002C0, "Member 'AParticleEffectSpawnerVolume::SpawnTimerHandle' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, SoundTimerHandle) == 0x0002C8, "Member 'AParticleEffectSpawnerVolume::SoundTimerHandle' has a wrong offset!");
static_assert(offsetof(AParticleEffectSpawnerVolume, bHasSpawned) == 0x0002D0, "Member 'AParticleEffectSpawnerVolume::bHasSpawned' has a wrong offset!");

// Class ObsidianFox.AnimComponentRagdoll
// 0x0120 (0x0170 - 0x0050)
class alignas(0x10) UAnimComponentRagdoll final : public UAnimComponent
{
public:
	FMulticastInlineDelegateProperty_             OnPoseSnapshotSaved;                               // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	ERagdollState                                 RagdollState;                                      // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultPoseSnapshotName;                           // 0x006C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPoseSnapshot                          SavedPoseSnapshot;                                 // 0x0078(0x0038)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bHasSnapshot;                                      // 0x00B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultBlendInTime;                                // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          StopSimulationOnSaveLoaded;                        // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URagdollSession*>                SessionStack;                                      // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D0[0xA0];                                      // 0x00D0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimComponentRagdoll">();
	}
	static class UAnimComponentRagdoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimComponentRagdoll>();
	}
};
static_assert(alignof(UAnimComponentRagdoll) == 0x000010, "Wrong alignment on UAnimComponentRagdoll");
static_assert(sizeof(UAnimComponentRagdoll) == 0x000170, "Wrong size on UAnimComponentRagdoll");
static_assert(offsetof(UAnimComponentRagdoll, OnPoseSnapshotSaved) == 0x000050, "Member 'UAnimComponentRagdoll::OnPoseSnapshotSaved' has a wrong offset!");
static_assert(offsetof(UAnimComponentRagdoll, RagdollState) == 0x000068, "Member 'UAnimComponentRagdoll::RagdollState' has a wrong offset!");
static_assert(offsetof(UAnimComponentRagdoll, DefaultPoseSnapshotName) == 0x00006C, "Member 'UAnimComponentRagdoll::DefaultPoseSnapshotName' has a wrong offset!");
static_assert(offsetof(UAnimComponentRagdoll, SavedPoseSnapshot) == 0x000078, "Member 'UAnimComponentRagdoll::SavedPoseSnapshot' has a wrong offset!");
static_assert(offsetof(UAnimComponentRagdoll, bHasSnapshot) == 0x0000B0, "Member 'UAnimComponentRagdoll::bHasSnapshot' has a wrong offset!");
static_assert(offsetof(UAnimComponentRagdoll, DefaultBlendInTime) == 0x0000B4, "Member 'UAnimComponentRagdoll::DefaultBlendInTime' has a wrong offset!");
static_assert(offsetof(UAnimComponentRagdoll, StopSimulationOnSaveLoaded) == 0x0000B8, "Member 'UAnimComponentRagdoll::StopSimulationOnSaveLoaded' has a wrong offset!");
static_assert(offsetof(UAnimComponentRagdoll, SessionStack) == 0x0000C0, "Member 'UAnimComponentRagdoll::SessionStack' has a wrong offset!");

// Class ObsidianFox.AnimComponentRailingFinder
// 0x0140 (0x0190 - 0x0050)
class alignas(0x10) UAnimComponentRailingFinder final : public UAnimComponent
{
public:
	uint8                                         bEnabled : 1;                                      // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MontageEndSectionName;                             // 0x0054(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SearchDistance;                                    // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkingSearchOffset;                               // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MaxHeightJointName;                                // 0x0064(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SweepLength;                                       // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SweepRadius;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bCustomRotation : 1;                               // 0x0074(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTime;                                         // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InstantBlockBlendOutTime;                          // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmReachExtraDistance;                             // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                EffectorLocationInterpolationSpeed;                // 0x0084(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EffectorRotationInterpolationSpeed;                // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmReachExtraDistanceForActiveSession;             // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCachedAnimStateArray                  RailingBlockedAnimStates;                          // 0x0098(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRailingSearchSettings>         RailingFindSettings;                               // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x50];                                      // 0x00C0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UOFCharacterMovementComponent*          CharacterMovementComponent;                        // 0x0110(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHumanoidAnimInstance*                  HumanoidAnimInstance;                              // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_120[0x70];                                     // 0x0120(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartIKMontage(const class FName Bone, bool bInstant);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimComponentRailingFinder">();
	}
	static class UAnimComponentRailingFinder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimComponentRailingFinder>();
	}
};
static_assert(alignof(UAnimComponentRailingFinder) == 0x000010, "Wrong alignment on UAnimComponentRailingFinder");
static_assert(sizeof(UAnimComponentRailingFinder) == 0x000190, "Wrong size on UAnimComponentRailingFinder");
static_assert(offsetof(UAnimComponentRailingFinder, MontageEndSectionName) == 0x000054, "Member 'UAnimComponentRailingFinder::MontageEndSectionName' has a wrong offset!");
static_assert(offsetof(UAnimComponentRailingFinder, SearchDistance) == 0x00005C, "Member 'UAnimComponentRailingFinder::SearchDistance' has a wrong offset!");
static_assert(offsetof(UAnimComponentRailingFinder, WalkingSearchOffset) == 0x000060, "Member 'UAnimComponentRailingFinder::WalkingSearchOffset' has a wrong offset!");
static_assert(offsetof(UAnimComponentRailingFinder, MaxHeightJointName) == 0x000064, "Member 'UAnimComponentRailingFinder::MaxHeightJointName' has a wrong offset!");
static_assert(offsetof(UAnimComponentRailingFinder, SweepLength) == 0x00006C, "Member 'UAnimComponentRailingFinder::SweepLength' has a wrong offset!");
static_assert(offsetof(UAnimComponentRailingFinder, SweepRadius) == 0x000070, "Member 'UAnimComponentRailingFinder::SweepRadius' has a wrong offset!");
static_assert(offsetof(UAnimComponentRailingFinder, StartTime) == 0x000078, "Member 'UAnimComponentRailingFinder::StartTime' has a wrong offset!");
static_assert(offsetof(UAnimComponentRailingFinder, InstantBlockBlendOutTime) == 0x00007C, "Member 'UAnimComponentRailingFinder::InstantBlockBlendOutTime' has a wrong offset!");
static_assert(offsetof(UAnimComponentRailingFinder, ArmReachExtraDistance) == 0x000080, "Member 'UAnimComponentRailingFinder::ArmReachExtraDistance' has a wrong offset!");
static_assert(offsetof(UAnimComponentRailingFinder, EffectorLocationInterpolationSpeed) == 0x000084, "Member 'UAnimComponentRailingFinder::EffectorLocationInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UAnimComponentRailingFinder, EffectorRotationInterpolationSpeed) == 0x000090, "Member 'UAnimComponentRailingFinder::EffectorRotationInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UAnimComponentRailingFinder, ArmReachExtraDistanceForActiveSession) == 0x000094, "Member 'UAnimComponentRailingFinder::ArmReachExtraDistanceForActiveSession' has a wrong offset!");
static_assert(offsetof(UAnimComponentRailingFinder, RailingBlockedAnimStates) == 0x000098, "Member 'UAnimComponentRailingFinder::RailingBlockedAnimStates' has a wrong offset!");
static_assert(offsetof(UAnimComponentRailingFinder, RailingFindSettings) == 0x0000B0, "Member 'UAnimComponentRailingFinder::RailingFindSettings' has a wrong offset!");
static_assert(offsetof(UAnimComponentRailingFinder, CharacterMovementComponent) == 0x000110, "Member 'UAnimComponentRailingFinder::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UAnimComponentRailingFinder, HumanoidAnimInstance) == 0x000118, "Member 'UAnimComponentRailingFinder::HumanoidAnimInstance' has a wrong offset!");

// Class ObsidianFox.PlayerCharactersEngineSubsystem
// 0x0038 (0x0068 - 0x0030)
class UPlayerCharactersEngineSubsystem final : public UEngineSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnCharacterUnPossessed;                            // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterPosessed;                               // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CacheCurrentPlayerCharacters(class AController* InController);
	EPlayerCharacterType GetPlayerCharacterType(const class UObject* WorldContextObject);
	void OnCharacterPosessed__DelegateSignature(const class AOFPlayerCharacter* Character);
	class AOFPlayerCharacter* PossessPlayerCharacter(class AController* InController, EPlayerCharacterType PlayerCharacterType, bool bDisableCurrentCharacter);
	void SetCharacterToUse(EPlayerCharacterType PlayerCharacterType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCharactersEngineSubsystem">();
	}
	static class UPlayerCharactersEngineSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCharactersEngineSubsystem>();
	}
};
static_assert(alignof(UPlayerCharactersEngineSubsystem) == 0x000008, "Wrong alignment on UPlayerCharactersEngineSubsystem");
static_assert(sizeof(UPlayerCharactersEngineSubsystem) == 0x000068, "Wrong size on UPlayerCharactersEngineSubsystem");
static_assert(offsetof(UPlayerCharactersEngineSubsystem, OnCharacterUnPossessed) == 0x000030, "Member 'UPlayerCharactersEngineSubsystem::OnCharacterUnPossessed' has a wrong offset!");
static_assert(offsetof(UPlayerCharactersEngineSubsystem, OnCharacterPosessed) == 0x000040, "Member 'UPlayerCharactersEngineSubsystem::OnCharacterPosessed' has a wrong offset!");

// Class ObsidianFox.AnimComponentThreatDetection
// 0x0040 (0x0090 - 0x0050)
class UAnimComponentThreatDetection final : public UAnimComponent
{
public:
	class FName                                   BlackBoardKey;                                     // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlackBoardAlertThreshold;                          // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlackBoardAggroThreshold;                          // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumberOfAlertVariations;                           // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCachedAnimStateData                   AlertStartState;                                   // 0x0064(0x001C)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EAnimAlertState                               AlertState;                                        // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AlertVariant;                                      // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimComponentThreatDetection">();
	}
	static class UAnimComponentThreatDetection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimComponentThreatDetection>();
	}
};
static_assert(alignof(UAnimComponentThreatDetection) == 0x000008, "Wrong alignment on UAnimComponentThreatDetection");
static_assert(sizeof(UAnimComponentThreatDetection) == 0x000090, "Wrong size on UAnimComponentThreatDetection");
static_assert(offsetof(UAnimComponentThreatDetection, BlackBoardKey) == 0x000050, "Member 'UAnimComponentThreatDetection::BlackBoardKey' has a wrong offset!");
static_assert(offsetof(UAnimComponentThreatDetection, BlackBoardAlertThreshold) == 0x000058, "Member 'UAnimComponentThreatDetection::BlackBoardAlertThreshold' has a wrong offset!");
static_assert(offsetof(UAnimComponentThreatDetection, BlackBoardAggroThreshold) == 0x00005C, "Member 'UAnimComponentThreatDetection::BlackBoardAggroThreshold' has a wrong offset!");
static_assert(offsetof(UAnimComponentThreatDetection, NumberOfAlertVariations) == 0x000060, "Member 'UAnimComponentThreatDetection::NumberOfAlertVariations' has a wrong offset!");
static_assert(offsetof(UAnimComponentThreatDetection, AlertStartState) == 0x000064, "Member 'UAnimComponentThreatDetection::AlertStartState' has a wrong offset!");
static_assert(offsetof(UAnimComponentThreatDetection, AlertState) == 0x000080, "Member 'UAnimComponentThreatDetection::AlertState' has a wrong offset!");
static_assert(offsetof(UAnimComponentThreatDetection, AlertVariant) == 0x000084, "Member 'UAnimComponentThreatDetection::AlertVariant' has a wrong offset!");

// Class ObsidianFox.AnimInterface
// 0x0000 (0x0028 - 0x0028)
class IAnimInterface final : public IInterface
{
public:
	void DisableAnimationFeature(const struct FGameplayTag& Feature);
	void DisableBodyFocus(const class UObject* LockReference, float ResetSpeed);
	void DisableFootIK(const class UObject* CallerReference, bool KeepHipOffsetEnabled);
	void EnableAnimationFeature(const struct FGameplayTag& Feature);
	void EnableBodyFocus(const class UObject* LockReference);
	void EnableFootIK(const class UObject* CallerReference);
	void EndContextualTraverse();
	EAnimationLocomotionState GetCurrentLocomotionState();
	struct FVector GetFocusPointOnCharacter();
	void OnFootStepEvent(EFootType FootStepType, const class FName& BoneName);
	void OnFootUpEvent(EFootType FootStepType, const class FName& BoneName);
	void OnWeaponAttackHit(float HitStrength, float HitForce, bool CharacterIsDead, const struct FVector& HitDirection, ECardinalDirection HitQuadrant, const struct FHitResult& HitInfo, const struct FHitReactionData& HitReactionData, const struct FGameplayEventData& EventData);
	void PlayHitReactionMontage(class UAnimMontage* Montage, const struct FVector& HitDirection, const class FName& HitBoneName);
	void QueueArmIKData(const class UObject* SessionOwner, const struct FVector& TargetLocation, float InterpToSpeed, float InterpFromSpeed, const struct FIKHandParameters& HandParameters, EOFTransformSpace LocationSpace);
	void RagdollMeshAtHit(class FName BoneName, const struct FVector& HitDirection, float HitImpactStrength, float HitForce, float SimulationDuration, float InitialBlendWeight);
	void ReleaseHoldWalkState();
	void RequestHoldWalkState();
	void RequestMoveToStopState();
	void RootMotionEnd(const class UObject* LockOwner);
	void RootMotionStart(const class UObject* LockOwner, bool ApplyTranslation, bool ApplyRotation, bool IsRotationAbsolute);
	void SetArmIKData(const class UObject* SessionOwner, class FName BoneName, const struct FVector& TargetLocation, float InterpToSpeed, float InterpFromSpeed, const struct FIKHandParameters& HandParameters, EOFTransformSpace LocationSpace);
	void SetFootIKInterpolationMultiplier(const class FName BoneName, const float Multiplier);
	void StartArmIK(const class UObject* SessionOwner, class FName BoneName, const struct FArmIKReferenceTarget& TargetReference, const struct FArmIKCompensationData& LocationCompensationData, const class FName WeightCurveName);
	void StartContextualTraverse(const struct FGameplayTag& TraverseTag);
	void StopArmIK(const class UObject* SessionOwner, class FName BoneName, const class FName WeightCurveName);
	void TrySetBlockFlagForRailingFinderForBone(const class UObject* CallerReference, class FName BoneName, bool bShouldBeBlocked, bool bInstantBlock);
	void WholebodyRagdoll(bool Activate, float Duration);

	float GetDynamicsAlpha(const struct FGameplayTag& Key) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimInterface">();
	}
	static class IAnimInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimInterface>();
	}
};
static_assert(alignof(IAnimInterface) == 0x000008, "Wrong alignment on IAnimInterface");
static_assert(sizeof(IAnimInterface) == 0x000028, "Wrong size on IAnimInterface");

// Class ObsidianFox.PlatformSpecificKeyWidget
// 0x0030 (0x0290 - 0x0260)
class UPlatformSpecificKeyWidget : public UUserWidget
{
public:
	class UImage*                                 KeyImage;                                          // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             KeyText;                                           // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               SizeBoxButton;                                     // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       HoldAnimation;                                     // 0x0278(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       PressAnimation;                                    // 0x0280(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       TapAnimation;                                      // 0x0288(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetInputAction(class UInputAction* InInputAction);
	void SetInputMappingContext(class UPiecesInputMappingContext* InInputMappingContext);
	void SetKeyImageAndText(class UTexture2D* Texture, const class FText& KeyString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlatformSpecificKeyWidget">();
	}
	static class UPlatformSpecificKeyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlatformSpecificKeyWidget>();
	}
};
static_assert(alignof(UPlatformSpecificKeyWidget) == 0x000008, "Wrong alignment on UPlatformSpecificKeyWidget");
static_assert(sizeof(UPlatformSpecificKeyWidget) == 0x000290, "Wrong size on UPlatformSpecificKeyWidget");
static_assert(offsetof(UPlatformSpecificKeyWidget, KeyImage) == 0x000260, "Member 'UPlatformSpecificKeyWidget::KeyImage' has a wrong offset!");
static_assert(offsetof(UPlatformSpecificKeyWidget, KeyText) == 0x000268, "Member 'UPlatformSpecificKeyWidget::KeyText' has a wrong offset!");
static_assert(offsetof(UPlatformSpecificKeyWidget, SizeBoxButton) == 0x000270, "Member 'UPlatformSpecificKeyWidget::SizeBoxButton' has a wrong offset!");
static_assert(offsetof(UPlatformSpecificKeyWidget, HoldAnimation) == 0x000278, "Member 'UPlatformSpecificKeyWidget::HoldAnimation' has a wrong offset!");
static_assert(offsetof(UPlatformSpecificKeyWidget, PressAnimation) == 0x000280, "Member 'UPlatformSpecificKeyWidget::PressAnimation' has a wrong offset!");
static_assert(offsetof(UPlatformSpecificKeyWidget, TapAnimation) == 0x000288, "Member 'UPlatformSpecificKeyWidget::TapAnimation' has a wrong offset!");

// Class ObsidianFox.AnimNotifyState_DisableAnimFeature
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_DisableAnimFeature final : public UAnimNotifyState
{
public:
	struct FGameplayTag                           FeatureToDisable;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DisableAnimFeature">();
	}
	static class UAnimNotifyState_DisableAnimFeature* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DisableAnimFeature>();
	}
};
static_assert(alignof(UAnimNotifyState_DisableAnimFeature) == 0x000008, "Wrong alignment on UAnimNotifyState_DisableAnimFeature");
static_assert(sizeof(UAnimNotifyState_DisableAnimFeature) == 0x000038, "Wrong size on UAnimNotifyState_DisableAnimFeature");
static_assert(offsetof(UAnimNotifyState_DisableAnimFeature, FeatureToDisable) == 0x000030, "Member 'UAnimNotifyState_DisableAnimFeature::FeatureToDisable' has a wrong offset!");

// Class ObsidianFox.AnimNotifyState_DisableEmotes
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_DisableEmotes final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DisableEmotes">();
	}
	static class UAnimNotifyState_DisableEmotes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DisableEmotes>();
	}
};
static_assert(alignof(UAnimNotifyState_DisableEmotes) == 0x000008, "Wrong alignment on UAnimNotifyState_DisableEmotes");
static_assert(sizeof(UAnimNotifyState_DisableEmotes) == 0x000030, "Wrong size on UAnimNotifyState_DisableEmotes");

// Class ObsidianFox.OptionsControlsPT
// 0x0550 (0x07B0 - 0x0260)
class UOptionsControlsPT final : public UUserWidget
{
public:
	float                                         ValueToIncreseSensitivity;                         // 0x0260(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_264[0xC];                                      // 0x0264(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UButton*                                DecreaseAimSensitiveButton;                        // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                IncreaseAimSensitiveButton;                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ControllSensitiveText;                             // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCheckBox*                              InvertedCheckBox;                                  // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ControllerSensitivity;                             // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Inverted;                                          // 0x0298(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FButtonStyle                           ButtonNormal;                                      // 0x02A0(0x0278)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FButtonStyle                           ButtonHovered;                                     // 0x0518(0x0278)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_790[0x20];                                     // 0x0790(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BackToStartScreen();
	void CancelButtonPressed();
	void ChangeActiveButton();
	void ControllerSensitivityHoveredCallback();
	void DecreaseAimSensitiveButtonPressedCallback();
	void IncreaseAimSensitiveButtonPressedCallback();
	void InteractButtonPressed();
	void InvertedCheckBoxPressed(bool bInvertedValue);
	void InvertedHoveredCallback();
	void LeftStickX(float Val);
	void LeftStickY(float Val);
	void OnInitalize();
	void SelectDownPressed();
	void SelectNextPressed();
	void SelectPreviousPressed();
	void SelectUpPressed();
	void SetCanMoveWithLeftStickXToTrue();
	void SetCanMoveWithLeftStickYToTrue();
	void SetupInput();
	void WidgetSetActive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OptionsControlsPT">();
	}
	static class UOptionsControlsPT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOptionsControlsPT>();
	}
};
static_assert(alignof(UOptionsControlsPT) == 0x000008, "Wrong alignment on UOptionsControlsPT");
static_assert(sizeof(UOptionsControlsPT) == 0x0007B0, "Wrong size on UOptionsControlsPT");
static_assert(offsetof(UOptionsControlsPT, ValueToIncreseSensitivity) == 0x000260, "Member 'UOptionsControlsPT::ValueToIncreseSensitivity' has a wrong offset!");
static_assert(offsetof(UOptionsControlsPT, DecreaseAimSensitiveButton) == 0x000270, "Member 'UOptionsControlsPT::DecreaseAimSensitiveButton' has a wrong offset!");
static_assert(offsetof(UOptionsControlsPT, IncreaseAimSensitiveButton) == 0x000278, "Member 'UOptionsControlsPT::IncreaseAimSensitiveButton' has a wrong offset!");
static_assert(offsetof(UOptionsControlsPT, ControllSensitiveText) == 0x000280, "Member 'UOptionsControlsPT::ControllSensitiveText' has a wrong offset!");
static_assert(offsetof(UOptionsControlsPT, InvertedCheckBox) == 0x000288, "Member 'UOptionsControlsPT::InvertedCheckBox' has a wrong offset!");
static_assert(offsetof(UOptionsControlsPT, ControllerSensitivity) == 0x000290, "Member 'UOptionsControlsPT::ControllerSensitivity' has a wrong offset!");
static_assert(offsetof(UOptionsControlsPT, Inverted) == 0x000298, "Member 'UOptionsControlsPT::Inverted' has a wrong offset!");
static_assert(offsetof(UOptionsControlsPT, ButtonNormal) == 0x0002A0, "Member 'UOptionsControlsPT::ButtonNormal' has a wrong offset!");
static_assert(offsetof(UOptionsControlsPT, ButtonHovered) == 0x000518, "Member 'UOptionsControlsPT::ButtonHovered' has a wrong offset!");

// Class ObsidianFox.AnimNotifyState_DisableFootIK
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_DisableFootIK final : public UAnimNotifyState
{
public:
	uint8                                         bKeepHipOffsetEnabled : 1;                         // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNotifyDisabled : 1;                               // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DisableFootIK">();
	}
	static class UAnimNotifyState_DisableFootIK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DisableFootIK>();
	}
};
static_assert(alignof(UAnimNotifyState_DisableFootIK) == 0x000008, "Wrong alignment on UAnimNotifyState_DisableFootIK");
static_assert(sizeof(UAnimNotifyState_DisableFootIK) == 0x000038, "Wrong size on UAnimNotifyState_DisableFootIK");

// Class ObsidianFox.AnimNotifyState_DisableInput
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_DisableInput final : public UAnimNotifyState
{
public:
	uint8                                         bFreezeMovementInput : 1;                          // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableMovementInput : 1;                         // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableCameraInput : 1;                           // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableGameplayInput : 1;                         // 0x0030(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DisableInput">();
	}
	static class UAnimNotifyState_DisableInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DisableInput>();
	}
};
static_assert(alignof(UAnimNotifyState_DisableInput) == 0x000008, "Wrong alignment on UAnimNotifyState_DisableInput");
static_assert(sizeof(UAnimNotifyState_DisableInput) == 0x000038, "Wrong size on UAnimNotifyState_DisableInput");

// Class ObsidianFox.PlayerCharacterAnimInterface
// 0x0000 (0x0028 - 0x0028)
class IPlayerCharacterAnimInterface final : public IInterface
{
public:
	void ForceCombatState();
	void ReleaseForceCombatState();
	void SetLowAttack(bool bIsLowAttack);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCharacterAnimInterface">();
	}
	static class IPlayerCharacterAnimInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPlayerCharacterAnimInterface>();
	}
};
static_assert(alignof(IPlayerCharacterAnimInterface) == 0x000008, "Wrong alignment on IPlayerCharacterAnimInterface");
static_assert(sizeof(IPlayerCharacterAnimInterface) == 0x000028, "Wrong size on IPlayerCharacterAnimInterface");

// Class ObsidianFox.AnimNotifyState_DisableTurnRate
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_DisableTurnRate final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DisableTurnRate">();
	}
	static class UAnimNotifyState_DisableTurnRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DisableTurnRate>();
	}
};
static_assert(alignof(UAnimNotifyState_DisableTurnRate) == 0x000008, "Wrong alignment on UAnimNotifyState_DisableTurnRate");
static_assert(sizeof(UAnimNotifyState_DisableTurnRate) == 0x000030, "Wrong size on UAnimNotifyState_DisableTurnRate");

// Class ObsidianFox.AnimNotifyState_DistanceRotation
// 0x0050 (0x0080 - 0x0030)
class UAnimNotifyState_DistanceRotation final : public UAnimNotifyState
{
public:
	uint8                                         bShouldRotateActor : 1;                            // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bNormalizeDistanceRotationCurve : 1;               // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_31[0xF];                                       // 0x0031(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  StartRotation;                                     // 0x0040(0x0010)(BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	float                                         TargetAngle;                                       // 0x0050(0x0004)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bFullyBlended : 1;                                 // 0x0054(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintReadOnly, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCompressedRichCurve                   DistanceRotationCurve;                             // 0x0058(0x0018)(BlueprintReadOnly, NativeAccessSpecifierPrivate)
	bool                                          bHasDistanceCurveData;                             // 0x0070(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0xF];                                       // 0x0071(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DistanceRotation">();
	}
	static class UAnimNotifyState_DistanceRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DistanceRotation>();
	}
};
static_assert(alignof(UAnimNotifyState_DistanceRotation) == 0x000010, "Wrong alignment on UAnimNotifyState_DistanceRotation");
static_assert(sizeof(UAnimNotifyState_DistanceRotation) == 0x000080, "Wrong size on UAnimNotifyState_DistanceRotation");
static_assert(offsetof(UAnimNotifyState_DistanceRotation, StartRotation) == 0x000040, "Member 'UAnimNotifyState_DistanceRotation::StartRotation' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_DistanceRotation, TargetAngle) == 0x000050, "Member 'UAnimNotifyState_DistanceRotation::TargetAngle' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_DistanceRotation, DistanceRotationCurve) == 0x000058, "Member 'UAnimNotifyState_DistanceRotation::DistanceRotationCurve' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_DistanceRotation, bHasDistanceCurveData) == 0x000070, "Member 'UAnimNotifyState_DistanceRotation::bHasDistanceCurveData' has a wrong offset!");

// Class ObsidianFox.AnimNotifyState_FreezeTurnAngle
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_FreezeTurnAngle final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_FreezeTurnAngle">();
	}
	static class UAnimNotifyState_FreezeTurnAngle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_FreezeTurnAngle>();
	}
};
static_assert(alignof(UAnimNotifyState_FreezeTurnAngle) == 0x000008, "Wrong alignment on UAnimNotifyState_FreezeTurnAngle");
static_assert(sizeof(UAnimNotifyState_FreezeTurnAngle) == 0x000030, "Wrong size on UAnimNotifyState_FreezeTurnAngle");

// Class ObsidianFox.AnimNotifyState_GameplayEffect
// 0x0010 (0x0040 - 0x0030)
class UAnimNotifyState_GameplayEffect final : public UAnimNotifyState
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffectToAdd;                               // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FActiveGameplayEffectHandle            ActiveEffectHandle;                                // 0x0038(0x0008)(BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_GameplayEffect">();
	}
	static class UAnimNotifyState_GameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_GameplayEffect>();
	}
};
static_assert(alignof(UAnimNotifyState_GameplayEffect) == 0x000008, "Wrong alignment on UAnimNotifyState_GameplayEffect");
static_assert(sizeof(UAnimNotifyState_GameplayEffect) == 0x000040, "Wrong size on UAnimNotifyState_GameplayEffect");
static_assert(offsetof(UAnimNotifyState_GameplayEffect, GameplayEffectToAdd) == 0x000030, "Member 'UAnimNotifyState_GameplayEffect::GameplayEffectToAdd' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_GameplayEffect, ActiveEffectHandle) == 0x000038, "Member 'UAnimNotifyState_GameplayEffect::ActiveEffectHandle' has a wrong offset!");

// Class ObsidianFox.AnimNotifyState_HideWeapon
// 0x00A8 (0x00D8 - 0x0030)
class UAnimNotifyState_HideWeapon final : public UAnimNotifyState
{
public:
	uint8                                         bShowWeaponWhenNotActive : 1;                      // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         HideAllEquippedWeapons : 1;                        // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBaseVisibilityOnSocketBlockage : 1;               // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             SocketsToBaseVisibilityOn;                         // 0x0038(0x0050)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_88[0x50];                                      // 0x0088(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_HideWeapon">();
	}
	static class UAnimNotifyState_HideWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_HideWeapon>();
	}
};
static_assert(alignof(UAnimNotifyState_HideWeapon) == 0x000008, "Wrong alignment on UAnimNotifyState_HideWeapon");
static_assert(sizeof(UAnimNotifyState_HideWeapon) == 0x0000D8, "Wrong size on UAnimNotifyState_HideWeapon");
static_assert(offsetof(UAnimNotifyState_HideWeapon, SocketsToBaseVisibilityOn) == 0x000038, "Member 'UAnimNotifyState_HideWeapon::SocketsToBaseVisibilityOn' has a wrong offset!");

// Class ObsidianFox.AnimNotifyState_IKInterpolationSpeedModifier
// 0x0010 (0x0040 - 0x0030)
class UAnimNotifyState_IKInterpolationSpeedModifier final : public UAnimNotifyState
{
public:
	class FName                                   BoneName;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multiplier;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_IKInterpolationSpeedModifier">();
	}
	static class UAnimNotifyState_IKInterpolationSpeedModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_IKInterpolationSpeedModifier>();
	}
};
static_assert(alignof(UAnimNotifyState_IKInterpolationSpeedModifier) == 0x000008, "Wrong alignment on UAnimNotifyState_IKInterpolationSpeedModifier");
static_assert(sizeof(UAnimNotifyState_IKInterpolationSpeedModifier) == 0x000040, "Wrong size on UAnimNotifyState_IKInterpolationSpeedModifier");
static_assert(offsetof(UAnimNotifyState_IKInterpolationSpeedModifier, BoneName) == 0x000030, "Member 'UAnimNotifyState_IKInterpolationSpeedModifier::BoneName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_IKInterpolationSpeedModifier, Multiplier) == 0x000038, "Member 'UAnimNotifyState_IKInterpolationSpeedModifier::Multiplier' has a wrong offset!");

// Class ObsidianFox.PlayerAsyncTaskBlueprintProxy
// 0x0048 (0x0070 - 0x0028)
class UPlayerAsyncTaskBlueprintProxy final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFail;                                            // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x28];                                      // 0x0048(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortMovement(bool ResetInputVectors);
	void OnMoveCompleted(const struct FAIRequestID& RequestID, EPathFollowingResult MovementResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAsyncTaskBlueprintProxy">();
	}
	static class UPlayerAsyncTaskBlueprintProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAsyncTaskBlueprintProxy>();
	}
};
static_assert(alignof(UPlayerAsyncTaskBlueprintProxy) == 0x000008, "Wrong alignment on UPlayerAsyncTaskBlueprintProxy");
static_assert(sizeof(UPlayerAsyncTaskBlueprintProxy) == 0x000070, "Wrong size on UPlayerAsyncTaskBlueprintProxy");
static_assert(offsetof(UPlayerAsyncTaskBlueprintProxy, OnSuccess) == 0x000028, "Member 'UPlayerAsyncTaskBlueprintProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UPlayerAsyncTaskBlueprintProxy, OnFail) == 0x000038, "Member 'UPlayerAsyncTaskBlueprintProxy::OnFail' has a wrong offset!");

// Class ObsidianFox.AnimNotifyState_Ragdoll
// 0x0030 (0x0060 - 0x0030)
class UAnimNotifyState_Ragdoll final : public UAnimNotifyState
{
public:
	class FName                                   RagdollRootBone;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RagdollProfile;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WeightCurveName;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PhysicalAnimationStrengthName;                     // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SnapshotName;                                      // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bKeepRagdollEnabledAfterNotifyEnd : 1;             // 0x0058(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_Ragdoll">();
	}
	static class UAnimNotifyState_Ragdoll* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_Ragdoll>();
	}
};
static_assert(alignof(UAnimNotifyState_Ragdoll) == 0x000008, "Wrong alignment on UAnimNotifyState_Ragdoll");
static_assert(sizeof(UAnimNotifyState_Ragdoll) == 0x000060, "Wrong size on UAnimNotifyState_Ragdoll");
static_assert(offsetof(UAnimNotifyState_Ragdoll, RagdollRootBone) == 0x000030, "Member 'UAnimNotifyState_Ragdoll::RagdollRootBone' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_Ragdoll, RagdollProfile) == 0x000038, "Member 'UAnimNotifyState_Ragdoll::RagdollProfile' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_Ragdoll, WeightCurveName) == 0x000040, "Member 'UAnimNotifyState_Ragdoll::WeightCurveName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_Ragdoll, PhysicalAnimationStrengthName) == 0x000048, "Member 'UAnimNotifyState_Ragdoll::PhysicalAnimationStrengthName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_Ragdoll, SnapshotName) == 0x000050, "Member 'UAnimNotifyState_Ragdoll::SnapshotName' has a wrong offset!");

// Class ObsidianFox.AnimNotify_FastTurnEnd
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_FastTurnEnd final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_FastTurnEnd">();
	}
	static class UAnimNotify_FastTurnEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_FastTurnEnd>();
	}
};
static_assert(alignof(UAnimNotify_FastTurnEnd) == 0x000008, "Wrong alignment on UAnimNotify_FastTurnEnd");
static_assert(sizeof(UAnimNotify_FastTurnEnd) == 0x000038, "Wrong size on UAnimNotify_FastTurnEnd");

// Class ObsidianFox.AnimNotify_TurnInPlaceEndTranslationRM
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_TurnInPlaceEndTranslationRM final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_TurnInPlaceEndTranslationRM">();
	}
	static class UAnimNotify_TurnInPlaceEndTranslationRM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_TurnInPlaceEndTranslationRM>();
	}
};
static_assert(alignof(UAnimNotify_TurnInPlaceEndTranslationRM) == 0x000008, "Wrong alignment on UAnimNotify_TurnInPlaceEndTranslationRM");
static_assert(sizeof(UAnimNotify_TurnInPlaceEndTranslationRM) == 0x000038, "Wrong size on UAnimNotify_TurnInPlaceEndTranslationRM");

// Class ObsidianFox.PreStreamTexturesWorldSubsystem
// 0x0018 (0x0048 - 0x0030)
class UPreStreamTexturesWorldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPreStreamTexturesJob(const TDelegate<void()>& OnPreStreamTextureDone, const class FName InTag, const bool bInForceTextureLoad);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreStreamTexturesWorldSubsystem">();
	}
	static class UPreStreamTexturesWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreStreamTexturesWorldSubsystem>();
	}
};
static_assert(alignof(UPreStreamTexturesWorldSubsystem) == 0x000008, "Wrong alignment on UPreStreamTexturesWorldSubsystem");
static_assert(sizeof(UPreStreamTexturesWorldSubsystem) == 0x000048, "Wrong size on UPreStreamTexturesWorldSubsystem");

// Class ObsidianFox.AnimNotify_TurnInPlaceBranch
// 0x0000 (0x0038 - 0x0038)
class UAnimNotify_TurnInPlaceBranch final : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_TurnInPlaceBranch">();
	}
	static class UAnimNotify_TurnInPlaceBranch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_TurnInPlaceBranch>();
	}
};
static_assert(alignof(UAnimNotify_TurnInPlaceBranch) == 0x000008, "Wrong alignment on UAnimNotify_TurnInPlaceBranch");
static_assert(sizeof(UAnimNotify_TurnInPlaceBranch) == 0x000038, "Wrong size on UAnimNotify_TurnInPlaceBranch");

// Class ObsidianFox.ArchiveButton
// 0x0018 (0x0278 - 0x0260)
class UArchiveButton : public UUserWidget
{
public:
	struct FGameplayTag                           ChapterTag;                                        // 0x0260(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 LockIcon;                                          // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOFButtonUserWidget*                    OFButton;                                          // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetStatus(bool bEnabled);
	void UpdateStatus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArchiveButton">();
	}
	static class UArchiveButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArchiveButton>();
	}
};
static_assert(alignof(UArchiveButton) == 0x000008, "Wrong alignment on UArchiveButton");
static_assert(sizeof(UArchiveButton) == 0x000278, "Wrong size on UArchiveButton");
static_assert(offsetof(UArchiveButton, ChapterTag) == 0x000260, "Member 'UArchiveButton::ChapterTag' has a wrong offset!");
static_assert(offsetof(UArchiveButton, LockIcon) == 0x000268, "Member 'UArchiveButton::LockIcon' has a wrong offset!");
static_assert(offsetof(UArchiveButton, OFButton) == 0x000270, "Member 'UArchiveButton::OFButton' has a wrong offset!");

// Class ObsidianFox.OFButtonUserWidget
// 0x0168 (0x03C8 - 0x0260)
class UOFButtonUserWidget : public UUserWidget
{
public:
	class UOFButton*                              OFButton;                                          // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             OFButtonTextBlock;                                 // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWidgetHover;                                     // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   TextDescription;                                   // 0x0280(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FFontSettings                          FontSettingsHover;                                 // 0x0298(0x0098)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FFontSettings                          FontSettingsNormal;                                // 0x0330(0x0098)(NativeAccessSpecifierPrivate)

public:
	void OnButtonHovered();
	void OnButtonUnHovered(class UButton* Button);
	void OnWidgetHover__DelegateSignature(class UWidget* Widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFButtonUserWidget">();
	}
	static class UOFButtonUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFButtonUserWidget>();
	}
};
static_assert(alignof(UOFButtonUserWidget) == 0x000008, "Wrong alignment on UOFButtonUserWidget");
static_assert(sizeof(UOFButtonUserWidget) == 0x0003C8, "Wrong size on UOFButtonUserWidget");
static_assert(offsetof(UOFButtonUserWidget, OFButton) == 0x000260, "Member 'UOFButtonUserWidget::OFButton' has a wrong offset!");
static_assert(offsetof(UOFButtonUserWidget, OFButtonTextBlock) == 0x000268, "Member 'UOFButtonUserWidget::OFButtonTextBlock' has a wrong offset!");
static_assert(offsetof(UOFButtonUserWidget, OnWidgetHover) == 0x000270, "Member 'UOFButtonUserWidget::OnWidgetHover' has a wrong offset!");
static_assert(offsetof(UOFButtonUserWidget, TextDescription) == 0x000280, "Member 'UOFButtonUserWidget::TextDescription' has a wrong offset!");
static_assert(offsetof(UOFButtonUserWidget, FontSettingsHover) == 0x000298, "Member 'UOFButtonUserWidget::FontSettingsHover' has a wrong offset!");
static_assert(offsetof(UOFButtonUserWidget, FontSettingsNormal) == 0x000330, "Member 'UOFButtonUserWidget::FontSettingsNormal' has a wrong offset!");

// Class ObsidianFox.RebindKeyWidget
// 0x00E8 (0x04B0 - 0x03C8)
class URebindKeyWidget : public UOFButtonUserWidget
{
public:
	class UOFButton*                              PrimaryBindingButton;                              // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOFButton*                              SecondaryBindingButton;                            // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UKeyBindingTextureDataAsset> CtrlButtonDataAsset;                               // 0x03D8(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionName;                                        // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsGamepadKey;                                     // 0x0408(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_409[0x7];                                      // 0x0409(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0410(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   Description;                                       // 0x0428(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UOFConfirmationPopupWidget> ConfirmationPopupClass;                            // 0x0440(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              FailedToBindSound;                                 // 0x0448(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x40];                                     // 0x0470(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangePrimaryKey(const struct FKey& InKey);
	void ChangeSecondaryKey(const struct FKey& InKey);
	void ConfirmationPopupOnSuccessHandler(bool bChange);
	void HandlePrimaryKeyPressed();
	void HandlePrimaryKeySelected(const struct FKey& InKey);
	void HandleSecondaryKeyPressed();
	void HandleSecondaryKeySelected(const struct FKey& InKey);
	void PostBindingUpdated();
	void PreBindingUpdated();
	void SetupWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RebindKeyWidget">();
	}
	static class URebindKeyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<URebindKeyWidget>();
	}
};
static_assert(alignof(URebindKeyWidget) == 0x000008, "Wrong alignment on URebindKeyWidget");
static_assert(sizeof(URebindKeyWidget) == 0x0004B0, "Wrong size on URebindKeyWidget");
static_assert(offsetof(URebindKeyWidget, PrimaryBindingButton) == 0x0003C8, "Member 'URebindKeyWidget::PrimaryBindingButton' has a wrong offset!");
static_assert(offsetof(URebindKeyWidget, SecondaryBindingButton) == 0x0003D0, "Member 'URebindKeyWidget::SecondaryBindingButton' has a wrong offset!");
static_assert(offsetof(URebindKeyWidget, CtrlButtonDataAsset) == 0x0003D8, "Member 'URebindKeyWidget::CtrlButtonDataAsset' has a wrong offset!");
static_assert(offsetof(URebindKeyWidget, ActionName) == 0x000400, "Member 'URebindKeyWidget::ActionName' has a wrong offset!");
static_assert(offsetof(URebindKeyWidget, bIsGamepadKey) == 0x000408, "Member 'URebindKeyWidget::bIsGamepadKey' has a wrong offset!");
static_assert(offsetof(URebindKeyWidget, Title) == 0x000410, "Member 'URebindKeyWidget::Title' has a wrong offset!");
static_assert(offsetof(URebindKeyWidget, Description) == 0x000428, "Member 'URebindKeyWidget::Description' has a wrong offset!");
static_assert(offsetof(URebindKeyWidget, ConfirmationPopupClass) == 0x000440, "Member 'URebindKeyWidget::ConfirmationPopupClass' has a wrong offset!");
static_assert(offsetof(URebindKeyWidget, FailedToBindSound) == 0x000448, "Member 'URebindKeyWidget::FailedToBindSound' has a wrong offset!");

// Class ObsidianFox.ASyncActionCommitSave
// 0x0028 (0x0058 - 0x0030)
class UASyncActionCommitSave final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             SaveDone;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 WorldContextObject;                                // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UASyncActionCommitSave* AsyncCommitSave(class UObject* WorldContextObject_0);

	void OnSaveDone(bool Success);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ASyncActionCommitSave">();
	}
	static class UASyncActionCommitSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UASyncActionCommitSave>();
	}
};
static_assert(alignof(UASyncActionCommitSave) == 0x000008, "Wrong alignment on UASyncActionCommitSave");
static_assert(sizeof(UASyncActionCommitSave) == 0x000058, "Wrong size on UASyncActionCommitSave");
static_assert(offsetof(UASyncActionCommitSave, SaveDone) == 0x000030, "Member 'UASyncActionCommitSave::SaveDone' has a wrong offset!");
static_assert(offsetof(UASyncActionCommitSave, WorldContextObject) == 0x000040, "Member 'UASyncActionCommitSave::WorldContextObject' has a wrong offset!");

// Class ObsidianFox.AbilityTask_PlayMontageAndWaitForEvent
// 0x00C0 (0x0140 - 0x0080)
class UAbilityTask_PlayMontageAndWaitForEvent final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnCompleted;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlendOut;                                        // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInterrupted;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelled;                                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventReceived;                                     // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageToPlay;                                     // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  EventTags;                                         // 0x00D8(0x0020)(NativeAccessSpecifierPrivate)
	float                                         Rate;                                              // 0x00F8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StartSection;                                      // 0x00FC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimRootMotionTranslationScale;                    // 0x0104(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopWhenAbilityEnds;                              // 0x0108(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_109[0x37];                                     // 0x0109(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_PlayMontageAndWaitForEvent* PlayMontageAndWaitForEvent(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* MontageToPlay_0, const struct FGameplayTagContainer& EventTags_0, float Rate_0, class FName StartSection_0, bool bStopWhenAbilityEnds_0, float AnimRootMotionTranslationScale_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_PlayMontageAndWaitForEvent">();
	}
	static class UAbilityTask_PlayMontageAndWaitForEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_PlayMontageAndWaitForEvent>();
	}
};
static_assert(alignof(UAbilityTask_PlayMontageAndWaitForEvent) == 0x000008, "Wrong alignment on UAbilityTask_PlayMontageAndWaitForEvent");
static_assert(sizeof(UAbilityTask_PlayMontageAndWaitForEvent) == 0x000140, "Wrong size on UAbilityTask_PlayMontageAndWaitForEvent");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitForEvent, OnCompleted) == 0x000080, "Member 'UAbilityTask_PlayMontageAndWaitForEvent::OnCompleted' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitForEvent, OnBlendOut) == 0x000090, "Member 'UAbilityTask_PlayMontageAndWaitForEvent::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitForEvent, OnInterrupted) == 0x0000A0, "Member 'UAbilityTask_PlayMontageAndWaitForEvent::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitForEvent, OnCancelled) == 0x0000B0, "Member 'UAbilityTask_PlayMontageAndWaitForEvent::OnCancelled' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitForEvent, EventReceived) == 0x0000C0, "Member 'UAbilityTask_PlayMontageAndWaitForEvent::EventReceived' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitForEvent, MontageToPlay) == 0x0000D0, "Member 'UAbilityTask_PlayMontageAndWaitForEvent::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitForEvent, EventTags) == 0x0000D8, "Member 'UAbilityTask_PlayMontageAndWaitForEvent::EventTags' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitForEvent, Rate) == 0x0000F8, "Member 'UAbilityTask_PlayMontageAndWaitForEvent::Rate' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitForEvent, StartSection) == 0x0000FC, "Member 'UAbilityTask_PlayMontageAndWaitForEvent::StartSection' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitForEvent, AnimRootMotionTranslationScale) == 0x000104, "Member 'UAbilityTask_PlayMontageAndWaitForEvent::AnimRootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PlayMontageAndWaitForEvent, bStopWhenAbilityEnds) == 0x000108, "Member 'UAbilityTask_PlayMontageAndWaitForEvent::bStopWhenAbilityEnds' has a wrong offset!");

// Class ObsidianFox.ProjectileLibrary
// 0x0000 (0x0028 - 0x0028)
class UProjectileLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float CalculateBallisticRange(float Speed, float InitialHeight, float Gravity);
	static bool SuggestProjectileVelocityByProfile(const class UObject* WorldContextObject, struct FVector* TossVelocity, const struct FVector& StartLocation, const struct FVector& EndLocation, float LaunchSpeed, float OverrideGravityZ, const struct FCollisionProfileName& TraceProfile, ESuggestProjVelocityTraceOption TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug, const TArray<class AActor*>& ActorsToIgnore);
	static bool SuggestProjectileVelocityFiltered(const class UObject* WorldContextObject, struct FVector* TossVelocity, const struct FVector& StartLocation, const struct FVector& EndLocation, float LaunchSpeed, float OverrideGravityZ, ESuggestProjVelocityTraceOption TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug, const TArray<class AActor*>& ActorsToIgnore);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectileLibrary">();
	}
	static class UProjectileLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectileLibrary>();
	}
};
static_assert(alignof(UProjectileLibrary) == 0x000008, "Wrong alignment on UProjectileLibrary");
static_assert(sizeof(UProjectileLibrary) == 0x000028, "Wrong size on UProjectileLibrary");

// Class ObsidianFox.BFL_PlayerMovement
// 0x0000 (0x0028 - 0x0028)
class UBFL_PlayerMovement final : public UBlueprintFunctionLibrary
{
public:
	static class UPlayerAsyncTaskBlueprintProxy* CreateMoveToProxyObject(class UObject* WorldContextObject, class APawn* Pawn, const struct FVector& Destination, class AActor* TargetActor, float AcceptanceRadius, bool bStopOnOverlap, bool bDisableInput, bool bIgnoreLookInput);
	static void SimpleMoveToLocation(const struct FLatentActionInfo& LatentInfo, EPlayerMoveToLocationAsyncMode* AsyncMode, class AOFPlayerController* Controller, const struct FVector& GoalLocation, const bool bInDisableInput, const bool bInIgnoreLookInput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFL_PlayerMovement">();
	}
	static class UBFL_PlayerMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFL_PlayerMovement>();
	}
};
static_assert(alignof(UBFL_PlayerMovement) == 0x000008, "Wrong alignment on UBFL_PlayerMovement");
static_assert(sizeof(UBFL_PlayerMovement) == 0x000028, "Wrong size on UBFL_PlayerMovement");

// Class ObsidianFox.BPAsyncAction_ChunkInstallWaitPopup
// 0x0070 (0x00A0 - 0x0030)
class UBPAsyncAction_ChunkInstallWaitPopup final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UOFChunkInstallPopupWidget> ConfirmationPopupWidgetClass;                      // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 WorldContextObject;                                // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ConfirmationTitle;                                 // 0x0060(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   ConfirmationDescription;                           // 0x0078(0x0018)(NativeAccessSpecifierPublic)
	class UOFChunkInstallPopupWidget*             ConfirmationPopupWidget;                           // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PopupZOrder;                                       // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChunkIndex;                                        // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UBPAsyncAction_ChunkInstallWaitPopup* DisplayChunkInstallWaitPopup(const class UObject* WorldContextObject_0, const class FText& Title, const class FText& Description, int32 ChunkIndex_0, TSubclassOf<class UOFChunkInstallPopupWidget> ConfirmationPopupClass);

	void OnConfirmationEndEvent__DelegateSignature();
	void OnConfirmationResultEnded(bool bResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPAsyncAction_ChunkInstallWaitPopup">();
	}
	static class UBPAsyncAction_ChunkInstallWaitPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPAsyncAction_ChunkInstallWaitPopup>();
	}
};
static_assert(alignof(UBPAsyncAction_ChunkInstallWaitPopup) == 0x000008, "Wrong alignment on UBPAsyncAction_ChunkInstallWaitPopup");
static_assert(sizeof(UBPAsyncAction_ChunkInstallWaitPopup) == 0x0000A0, "Wrong size on UBPAsyncAction_ChunkInstallWaitPopup");
static_assert(offsetof(UBPAsyncAction_ChunkInstallWaitPopup, OnSuccess) == 0x000030, "Member 'UBPAsyncAction_ChunkInstallWaitPopup::OnSuccess' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_ChunkInstallWaitPopup, OnFailed) == 0x000040, "Member 'UBPAsyncAction_ChunkInstallWaitPopup::OnFailed' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_ChunkInstallWaitPopup, ConfirmationPopupWidgetClass) == 0x000050, "Member 'UBPAsyncAction_ChunkInstallWaitPopup::ConfirmationPopupWidgetClass' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_ChunkInstallWaitPopup, WorldContextObject) == 0x000058, "Member 'UBPAsyncAction_ChunkInstallWaitPopup::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_ChunkInstallWaitPopup, ConfirmationTitle) == 0x000060, "Member 'UBPAsyncAction_ChunkInstallWaitPopup::ConfirmationTitle' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_ChunkInstallWaitPopup, ConfirmationDescription) == 0x000078, "Member 'UBPAsyncAction_ChunkInstallWaitPopup::ConfirmationDescription' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_ChunkInstallWaitPopup, ConfirmationPopupWidget) == 0x000090, "Member 'UBPAsyncAction_ChunkInstallWaitPopup::ConfirmationPopupWidget' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_ChunkInstallWaitPopup, PopupZOrder) == 0x000098, "Member 'UBPAsyncAction_ChunkInstallWaitPopup::PopupZOrder' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_ChunkInstallWaitPopup, ChunkIndex) == 0x00009C, "Member 'UBPAsyncAction_ChunkInstallWaitPopup::ChunkIndex' has a wrong offset!");

// Class ObsidianFox.PreloadLevelsActor
// 0x0018 (0x0250 - 0x0238)
class APreloadLevelsActor final : public AActor
{
public:
	TArray<TSoftObjectPtr<class UWorld>>          LevelsToPreload;                                   // 0x0238(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          BoxComponent;                                      // 0x0248(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreloadLevelsActor">();
	}
	static class APreloadLevelsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APreloadLevelsActor>();
	}
};
static_assert(alignof(APreloadLevelsActor) == 0x000008, "Wrong alignment on APreloadLevelsActor");
static_assert(sizeof(APreloadLevelsActor) == 0x000250, "Wrong size on APreloadLevelsActor");
static_assert(offsetof(APreloadLevelsActor, LevelsToPreload) == 0x000238, "Member 'APreloadLevelsActor::LevelsToPreload' has a wrong offset!");
static_assert(offsetof(APreloadLevelsActor, BoxComponent) == 0x000248, "Member 'APreloadLevelsActor::BoxComponent' has a wrong offset!");

// Class ObsidianFox.BPAsyncAction_ConfirmationPopup
// 0x0070 (0x00A0 - 0x0030)
class UBPAsyncAction_ConfirmationPopup final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UOFConfirmationPopupWidget> ConfirmationPopupWidgetClass;                      // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 WorldContextObject;                                // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ConfirmationTitle;                                 // 0x0060(0x0018)(NativeAccessSpecifierPublic)
	class FText                                   ConfirmationDescription;                           // 0x0078(0x0018)(NativeAccessSpecifierPublic)
	class UOFConfirmationPopupWidget*             ConfirmationPopupWidget;                           // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PopupZOrder;                                       // 0x0098(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBPAsyncAction_ConfirmationPopup* DisplayConfirmationPopup(const class UObject* WorldContextObject_0, const class FText& Title, const class FText& Description, TSubclassOf<class UOFConfirmationPopupWidget> ConfirmationPopupClass);

	void OnConfirmationEndEvent__DelegateSignature();
	void OnConfirmationResultEnded(bool bResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPAsyncAction_ConfirmationPopup">();
	}
	static class UBPAsyncAction_ConfirmationPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPAsyncAction_ConfirmationPopup>();
	}
};
static_assert(alignof(UBPAsyncAction_ConfirmationPopup) == 0x000008, "Wrong alignment on UBPAsyncAction_ConfirmationPopup");
static_assert(sizeof(UBPAsyncAction_ConfirmationPopup) == 0x0000A0, "Wrong size on UBPAsyncAction_ConfirmationPopup");
static_assert(offsetof(UBPAsyncAction_ConfirmationPopup, OnSuccess) == 0x000030, "Member 'UBPAsyncAction_ConfirmationPopup::OnSuccess' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_ConfirmationPopup, OnFailed) == 0x000040, "Member 'UBPAsyncAction_ConfirmationPopup::OnFailed' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_ConfirmationPopup, ConfirmationPopupWidgetClass) == 0x000050, "Member 'UBPAsyncAction_ConfirmationPopup::ConfirmationPopupWidgetClass' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_ConfirmationPopup, WorldContextObject) == 0x000058, "Member 'UBPAsyncAction_ConfirmationPopup::WorldContextObject' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_ConfirmationPopup, ConfirmationTitle) == 0x000060, "Member 'UBPAsyncAction_ConfirmationPopup::ConfirmationTitle' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_ConfirmationPopup, ConfirmationDescription) == 0x000078, "Member 'UBPAsyncAction_ConfirmationPopup::ConfirmationDescription' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_ConfirmationPopup, ConfirmationPopupWidget) == 0x000090, "Member 'UBPAsyncAction_ConfirmationPopup::ConfirmationPopupWidget' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_ConfirmationPopup, PopupZOrder) == 0x000098, "Member 'UBPAsyncAction_ConfirmationPopup::PopupZOrder' has a wrong offset!");

// Class ObsidianFox.BPAsyncAction_GetMontageByTag
// 0x0050 (0x0080 - 0x0030)
class UBPAsyncAction_GetMontageByTag final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             Completed;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             Failed;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMeshComponent>  SkeletalMeshComponent;                             // 0x0050(0x0028)(ExportObject, InstancedReference, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           MontageTag;                                        // 0x0078(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UBPAsyncAction_GetMontageByTag* GetMontageByTag(const class USkeletalMeshComponent* SkeletalMeshComp, const struct FGameplayTag& MontageTag_0);

	void GetAnimationMontageAsyncBaseSignature__DelegateSignature(class UAnimMontage* Montage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPAsyncAction_GetMontageByTag">();
	}
	static class UBPAsyncAction_GetMontageByTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPAsyncAction_GetMontageByTag>();
	}
};
static_assert(alignof(UBPAsyncAction_GetMontageByTag) == 0x000008, "Wrong alignment on UBPAsyncAction_GetMontageByTag");
static_assert(sizeof(UBPAsyncAction_GetMontageByTag) == 0x000080, "Wrong size on UBPAsyncAction_GetMontageByTag");
static_assert(offsetof(UBPAsyncAction_GetMontageByTag, Completed) == 0x000030, "Member 'UBPAsyncAction_GetMontageByTag::Completed' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_GetMontageByTag, Failed) == 0x000040, "Member 'UBPAsyncAction_GetMontageByTag::Failed' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_GetMontageByTag, SkeletalMeshComponent) == 0x000050, "Member 'UBPAsyncAction_GetMontageByTag::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_GetMontageByTag, MontageTag) == 0x000078, "Member 'UBPAsyncAction_GetMontageByTag::MontageTag' has a wrong offset!");

// Class ObsidianFox.PuzzleHelperHud
// 0x0000 (0x0260 - 0x0260)
class UPuzzleHelperHud final : public UUserWidget
{
public:
	void SetupInput();
	void ShowHideText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PuzzleHelperHud">();
	}
	static class UPuzzleHelperHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPuzzleHelperHud>();
	}
};
static_assert(alignof(UPuzzleHelperHud) == 0x000008, "Wrong alignment on UPuzzleHelperHud");
static_assert(sizeof(UPuzzleHelperHud) == 0x000260, "Wrong size on UPuzzleHelperHud");

// Class ObsidianFox.BPAsyncAction_GetTextureAssociatedWithInputAction
// 0x0028 (0x0058 - 0x0030)
class UBPAsyncAction_GetTextureAssociatedWithInputAction final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnCompleted;                                       // 0x0030(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UInputAction*                           InputAction;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 OurWorld;                                          // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPiecesInputMappingContext*             InputMappingContext;                               // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UBPAsyncAction_GetTextureAssociatedWithInputAction* GetTextureAssociatedWithInputAction(const class UObject* WorldContextObject, const class UInputAction* InInputAction, const class UPiecesInputMappingContext* InInputMappingContext);

	void OnAsyncActionCompletePin__DelegateSignature(class UTexture2D* Texture, const class FText& KeyString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPAsyncAction_GetTextureAssociatedWithInputAction">();
	}
	static class UBPAsyncAction_GetTextureAssociatedWithInputAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPAsyncAction_GetTextureAssociatedWithInputAction>();
	}
};
static_assert(alignof(UBPAsyncAction_GetTextureAssociatedWithInputAction) == 0x000008, "Wrong alignment on UBPAsyncAction_GetTextureAssociatedWithInputAction");
static_assert(sizeof(UBPAsyncAction_GetTextureAssociatedWithInputAction) == 0x000058, "Wrong size on UBPAsyncAction_GetTextureAssociatedWithInputAction");
static_assert(offsetof(UBPAsyncAction_GetTextureAssociatedWithInputAction, OnCompleted) == 0x000030, "Member 'UBPAsyncAction_GetTextureAssociatedWithInputAction::OnCompleted' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_GetTextureAssociatedWithInputAction, InputAction) == 0x000040, "Member 'UBPAsyncAction_GetTextureAssociatedWithInputAction::InputAction' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_GetTextureAssociatedWithInputAction, OurWorld) == 0x000048, "Member 'UBPAsyncAction_GetTextureAssociatedWithInputAction::OurWorld' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_GetTextureAssociatedWithInputAction, InputMappingContext) == 0x000050, "Member 'UBPAsyncAction_GetTextureAssociatedWithInputAction::InputMappingContext' has a wrong offset!");

// Class ObsidianFox.BPAsyncAction_PlayIKMontage
// 0x0010 (0x0120 - 0x0110)
class UBPAsyncAction_PlayIKMontage final : public UBPAsyncAction_PlayMontageBase
{
public:
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBPAsyncAction_PlayIKMontage* PlayIKMontage(class USkeletalMeshComponent* InSkeletalMesh, class UAnimMontage* MontageToPlay, const TArray<struct FIKParameters>& IKParameters, float PlayRate, float StartingPosition, const class FName StartingSection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPAsyncAction_PlayIKMontage">();
	}
	static class UBPAsyncAction_PlayIKMontage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPAsyncAction_PlayIKMontage>();
	}
};
static_assert(alignof(UBPAsyncAction_PlayIKMontage) == 0x000008, "Wrong alignment on UBPAsyncAction_PlayIKMontage");
static_assert(sizeof(UBPAsyncAction_PlayIKMontage) == 0x000120, "Wrong size on UBPAsyncAction_PlayIKMontage");

// Class ObsidianFox.SaveSlotWidget
// 0x0140 (0x0508 - 0x03C8)
class USaveSlotWidget : public UOFButtonUserWidget
{
public:
	TSubclassOf<class UOFSaveConfirmationPopupWidget> ConfirmationPopupClass;                            // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_AutoSave;                                     // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Slot;                                         // 0x03D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Name;                                         // 0x03E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Date;                                         // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_Empty;                                        // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Image_CharacterIcon;                               // 0x03F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x0408(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasAutoSave;                                      // 0x040C(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40D[0x3];                                      // 0x040D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UOFSaveConfirmationPopupWidget*         SaveConfirmationPopup;                             // 0x0410(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLoadGame;                                       // 0x0418(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLoadSaveGameUIData                    LoadSaveGameUIData;                                // 0x0420(0x0098)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B8[0x10];                                     // 0x04B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStartDelayedUpdate;                               // 0x04C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCurrentlySaving;                                  // 0x04C9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4CA[0x2];                                      // 0x04CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CurrentDelayTimer;                                 // 0x04CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DelayedUpdateTimer;                                // 0x04D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D4[0xC];                                      // 0x04D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   AutoSaveText;                                      // 0x04E0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FMargin                                AutoSaveTextPadding;                               // 0x04F8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void LoadGame();
	void OnLoadLevelPressed();
	void OnLoadSaveButtonPressed();
	void OnSaveConfirmationDone(bool bAccepted);
	void OnSaveFinished(bool Success);
	void OnSaveUpdateCompleted();
	void SaveGameInSlot(int32 SaveGameSlot);

	struct FGameplayTag GetProgression() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveSlotWidget">();
	}
	static class USaveSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveSlotWidget>();
	}
};
static_assert(alignof(USaveSlotWidget) == 0x000008, "Wrong alignment on USaveSlotWidget");
static_assert(sizeof(USaveSlotWidget) == 0x000508, "Wrong size on USaveSlotWidget");
static_assert(offsetof(USaveSlotWidget, ConfirmationPopupClass) == 0x0003C8, "Member 'USaveSlotWidget::ConfirmationPopupClass' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, Text_AutoSave) == 0x0003D0, "Member 'USaveSlotWidget::Text_AutoSave' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, Text_Slot) == 0x0003D8, "Member 'USaveSlotWidget::Text_Slot' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, Text_Name) == 0x0003E0, "Member 'USaveSlotWidget::Text_Name' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, Text_Date) == 0x0003E8, "Member 'USaveSlotWidget::Text_Date' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, Text_Empty) == 0x0003F0, "Member 'USaveSlotWidget::Text_Empty' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, Image_CharacterIcon) == 0x0003F8, "Member 'USaveSlotWidget::Image_CharacterIcon' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, SlotIndex) == 0x000408, "Member 'USaveSlotWidget::SlotIndex' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, bHasAutoSave) == 0x00040C, "Member 'USaveSlotWidget::bHasAutoSave' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, SaveConfirmationPopup) == 0x000410, "Member 'USaveSlotWidget::SaveConfirmationPopup' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, bIsLoadGame) == 0x000418, "Member 'USaveSlotWidget::bIsLoadGame' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, LoadSaveGameUIData) == 0x000420, "Member 'USaveSlotWidget::LoadSaveGameUIData' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, bStartDelayedUpdate) == 0x0004C8, "Member 'USaveSlotWidget::bStartDelayedUpdate' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, bCurrentlySaving) == 0x0004C9, "Member 'USaveSlotWidget::bCurrentlySaving' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, CurrentDelayTimer) == 0x0004CC, "Member 'USaveSlotWidget::CurrentDelayTimer' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, DelayedUpdateTimer) == 0x0004D0, "Member 'USaveSlotWidget::DelayedUpdateTimer' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, AutoSaveText) == 0x0004E0, "Member 'USaveSlotWidget::AutoSaveText' has a wrong offset!");
static_assert(offsetof(USaveSlotWidget, AutoSaveTextPadding) == 0x0004F8, "Member 'USaveSlotWidget::AutoSaveTextPadding' has a wrong offset!");

// Class ObsidianFox.BPAsyncAction_PlayNearestSectionMontage
// 0x0010 (0x0120 - 0x0110)
class UBPAsyncAction_PlayNearestSectionMontage final : public UBPAsyncAction_PlayMontageBase
{
public:
	uint8                                         Pad_110[0x10];                                     // 0x0110(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBPAsyncAction_PlayNearestSectionMontage* PlayNearestSectionMontage(class USkeletalMeshComponent* InSkeletalMesh, const struct FVector& GoalLocation, class UAnimMontage* MontageToPlay, bool SetGoalLocationAsIKTarget, float PlayRate, bool IgnoreXY);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPAsyncAction_PlayNearestSectionMontage">();
	}
	static class UBPAsyncAction_PlayNearestSectionMontage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPAsyncAction_PlayNearestSectionMontage>();
	}
};
static_assert(alignof(UBPAsyncAction_PlayNearestSectionMontage) == 0x000008, "Wrong alignment on UBPAsyncAction_PlayNearestSectionMontage");
static_assert(sizeof(UBPAsyncAction_PlayNearestSectionMontage) == 0x000120, "Wrong size on UBPAsyncAction_PlayNearestSectionMontage");

// Class ObsidianFox.BPAsyncAction_RepositionAndReorient
// 0x0090 (0x00C0 - 0x0030)
class UBPAsyncAction_RepositionAndReorient final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnCompleted;                                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCloseEnough;                                     // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInterrupted;                                     // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          LerpAsFallback;                                    // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RepositionBeforeReorientation;                     // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreZ;                                           // 0x0062(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x1];                                       // 0x0063(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveCloseEnough;                                   // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleCloseEnough;                                  // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TravelTime;                                        // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           YoinkTimer;                                        // 0x0070(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x40];                                      // 0x0078(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UActorTransformComponent*               CurrentTransformComponent;                         // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UBPAsyncAction_RepositionAndReorient* RepositionAndReorient(class ACharacter* Character, ERepositionMethod RepositionMethod, EReorientMethod ReorientMethod, class USceneComponent* SceneComponentTransformGoal, class UBPAsyncAction_RepositionAndReorient** OutActionProxy, ETransformCalculationMethod TransformBehaviour, bool LerpAsFallback_0, bool RepositionBeforeReorientation_0, bool IgnoreZ_0, float MoveCloseEnough_0, float TravelTime_0, EEasingFunc EasingFunction, float EasingExponent, float AngleCloseEnough_0);

	void CharacterMoveToCompleted(EPathFollowingResult MovementResult, const struct FAIRequestID& RequestID);
	void CharacterMoveToFailed(EPathFollowingResult MovementResult, const struct FAIRequestID& RequestID);
	void CharacterTurnInPlaceCompleted(class ACharacter* Character, bool bIsBlendOutToWalk);
	void CharacterTurnInPlaceFailedAngleTooSmall(class ACharacter* Character);
	void LerpDoneFailure(class AActor* TransformedActor, class UActorTransformComponent* TransformingComponent);
	void LerpDoneSuccess(class AActor* TransformedActor, class UActorTransformComponent* TransformingComponent);
	void LerpOnCloseEnough(class AActor* TransformedActor, class UActorTransformComponent* TransformingComponent);
	void OnAsyncActionCompletePin__DelegateSignature(class ACharacter* TransformedCharacter);

	void ForceStopTransform(bool SnapCharacterToTargetLocation) const;
	void ForceStopTransformLocation(bool SnapCharacterToTargetLocation) const;
	void ForceStopTransformRotation(bool SnapCharacterToTargetRotation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPAsyncAction_RepositionAndReorient">();
	}
	static class UBPAsyncAction_RepositionAndReorient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPAsyncAction_RepositionAndReorient>();
	}
};
static_assert(alignof(UBPAsyncAction_RepositionAndReorient) == 0x000008, "Wrong alignment on UBPAsyncAction_RepositionAndReorient");
static_assert(sizeof(UBPAsyncAction_RepositionAndReorient) == 0x0000C0, "Wrong size on UBPAsyncAction_RepositionAndReorient");
static_assert(offsetof(UBPAsyncAction_RepositionAndReorient, OnCompleted) == 0x000030, "Member 'UBPAsyncAction_RepositionAndReorient::OnCompleted' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_RepositionAndReorient, OnCloseEnough) == 0x000040, "Member 'UBPAsyncAction_RepositionAndReorient::OnCloseEnough' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_RepositionAndReorient, OnInterrupted) == 0x000050, "Member 'UBPAsyncAction_RepositionAndReorient::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_RepositionAndReorient, LerpAsFallback) == 0x000060, "Member 'UBPAsyncAction_RepositionAndReorient::LerpAsFallback' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_RepositionAndReorient, RepositionBeforeReorientation) == 0x000061, "Member 'UBPAsyncAction_RepositionAndReorient::RepositionBeforeReorientation' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_RepositionAndReorient, IgnoreZ) == 0x000062, "Member 'UBPAsyncAction_RepositionAndReorient::IgnoreZ' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_RepositionAndReorient, MoveCloseEnough) == 0x000064, "Member 'UBPAsyncAction_RepositionAndReorient::MoveCloseEnough' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_RepositionAndReorient, AngleCloseEnough) == 0x000068, "Member 'UBPAsyncAction_RepositionAndReorient::AngleCloseEnough' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_RepositionAndReorient, TravelTime) == 0x00006C, "Member 'UBPAsyncAction_RepositionAndReorient::TravelTime' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_RepositionAndReorient, YoinkTimer) == 0x000070, "Member 'UBPAsyncAction_RepositionAndReorient::YoinkTimer' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_RepositionAndReorient, CurrentTransformComponent) == 0x0000B8, "Member 'UBPAsyncAction_RepositionAndReorient::CurrentTransformComponent' has a wrong offset!");

// Class ObsidianFox.BPAsyncAction_SpawnEnemy
// 0x0018 (0x0048 - 0x0030)
class UBPAsyncAction_SpawnEnemy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnEnemySpawned;                                    // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBPAsyncAction_SpawnEnemy* SpawnEnemy(class AEnemySpawner* EnemySpawner);

	void OnAsyncSpawnCompletePin__DelegateSignature(class AOFEnemyCharacter* SpawnedEnemy, class AAIController* SpawnedAICOntroller, class AEnemySpawner* Spawner);
	void OnSpawnerComplete(class AOFEnemyCharacter* SpawnedEnemy, class AAIController* SpawnedAICOntroller, class AEnemySpawner* Spawner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPAsyncAction_SpawnEnemy">();
	}
	static class UBPAsyncAction_SpawnEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPAsyncAction_SpawnEnemy>();
	}
};
static_assert(alignof(UBPAsyncAction_SpawnEnemy) == 0x000008, "Wrong alignment on UBPAsyncAction_SpawnEnemy");
static_assert(sizeof(UBPAsyncAction_SpawnEnemy) == 0x000048, "Wrong size on UBPAsyncAction_SpawnEnemy");
static_assert(offsetof(UBPAsyncAction_SpawnEnemy, OnEnemySpawned) == 0x000030, "Member 'UBPAsyncAction_SpawnEnemy::OnEnemySpawned' has a wrong offset!");

// Class ObsidianFox.BPAsyncAction_SpawnEnemies
// 0x0020 (0x0050 - 0x0030)
class UBPAsyncAction_SpawnEnemies final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnEnemySpawned;                                    // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBPAsyncAction_SpawnEnemies* SpawnEnemies(const TArray<class AEnemySpawner*>& EnemySpawners);

	void OnAsyncSpawnCompletePin__DelegateSignature(class AOFEnemyCharacter* SpawnedEnemy, class AAIController* SpawnedAICOntroller, class AEnemySpawner* Spawner);
	void OnSpawnerComplete(class AOFEnemyCharacter* SpawnedEnemy, class AAIController* SpawnedAICOntroller, class AEnemySpawner* Spawner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPAsyncAction_SpawnEnemies">();
	}
	static class UBPAsyncAction_SpawnEnemies* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPAsyncAction_SpawnEnemies>();
	}
};
static_assert(alignof(UBPAsyncAction_SpawnEnemies) == 0x000008, "Wrong alignment on UBPAsyncAction_SpawnEnemies");
static_assert(sizeof(UBPAsyncAction_SpawnEnemies) == 0x000050, "Wrong size on UBPAsyncAction_SpawnEnemies");
static_assert(offsetof(UBPAsyncAction_SpawnEnemies, OnEnemySpawned) == 0x000030, "Member 'UBPAsyncAction_SpawnEnemies::OnEnemySpawned' has a wrong offset!");

// Class ObsidianFox.BPAsyncAction_SplineMove
// 0x0018 (0x0048 - 0x0030)
class UBPAsyncAction_SplineMove final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnCompleted;                                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBPAsyncAction_SplineMove* MoveDirectionOnSpline(class USplineMovementComponent* MovementComponent, ESplineMovementDirection MovementDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPAsyncAction_SplineMove">();
	}
	static class UBPAsyncAction_SplineMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPAsyncAction_SplineMove>();
	}
};
static_assert(alignof(UBPAsyncAction_SplineMove) == 0x000008, "Wrong alignment on UBPAsyncAction_SplineMove");
static_assert(sizeof(UBPAsyncAction_SplineMove) == 0x000048, "Wrong size on UBPAsyncAction_SplineMove");
static_assert(offsetof(UBPAsyncAction_SplineMove, OnCompleted) == 0x000030, "Member 'UBPAsyncAction_SplineMove::OnCompleted' has a wrong offset!");

// Class ObsidianFox.BPFL_PlayState
// 0x0000 (0x0028 - 0x0028)
class UBPFL_PlayState final : public UBlueprintFunctionLibrary
{
public:
	static bool GetIsInCombat(const class UObject* WorldContextObject);
	static EGameMainState GetMainState(const class UObject* WorldContextObject);
	static EPlayerHealthState GetPlayerHealthState(const class UObject* WorldContextObject);
	static void PopMainState(const class UObject* WorldContextObject, const class UObject* StateOwner);
	static void PushMainSate(const class UObject* WorldContextObject, const class UObject* StateOwner, EGameMainState NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPFL_PlayState">();
	}
	static class UBPFL_PlayState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPFL_PlayState>();
	}
};
static_assert(alignof(UBPFL_PlayState) == 0x000008, "Wrong alignment on UBPFL_PlayState");
static_assert(sizeof(UBPFL_PlayState) == 0x000028, "Wrong size on UBPFL_PlayState");

// Class ObsidianFox.BTDecorator_PercentChance
// 0x0000 (0x0068 - 0x0068)
class UBTDecorator_PercentChance final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTDecorator_PercentChance">();
	}
	static class UBTDecorator_PercentChance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTDecorator_PercentChance>();
	}
};
static_assert(alignof(UBTDecorator_PercentChance) == 0x000008, "Wrong alignment on UBTDecorator_PercentChance");
static_assert(sizeof(UBTDecorator_PercentChance) == 0x000068, "Wrong size on UBTDecorator_PercentChance");

// Class ObsidianFox.OFPropAnimInstance
// 0x0050 (0x0320 - 0x02D0)
class UOFPropAnimInstance final : public UAnimInstance
{
public:
	bool                                          bVisibleForCertainCharacters;                      // 0x02C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<EPlayerCharacterType>                    VisibleForCharacters;                              // 0x02D0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnCharacterPossessed(const class AOFPlayerCharacter* NewCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFPropAnimInstance">();
	}
	static class UOFPropAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFPropAnimInstance>();
	}
};
static_assert(alignof(UOFPropAnimInstance) == 0x000010, "Wrong alignment on UOFPropAnimInstance");
static_assert(sizeof(UOFPropAnimInstance) == 0x000320, "Wrong size on UOFPropAnimInstance");
static_assert(offsetof(UOFPropAnimInstance, bVisibleForCertainCharacters) == 0x0002C8, "Member 'UOFPropAnimInstance::bVisibleForCertainCharacters' has a wrong offset!");
static_assert(offsetof(UOFPropAnimInstance, VisibleForCharacters) == 0x0002D0, "Member 'UOFPropAnimInstance::VisibleForCharacters' has a wrong offset!");

// Class ObsidianFox.BTD_RandomCooldown
// 0x0008 (0x0070 - 0x0068)
class UBTD_RandomCooldown final : public UBTDecorator
{
public:
	float                                         CoolDownTime;                                      // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownDurationDeviation;                         // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_RandomCooldown">();
	}
	static class UBTD_RandomCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_RandomCooldown>();
	}
};
static_assert(alignof(UBTD_RandomCooldown) == 0x000008, "Wrong alignment on UBTD_RandomCooldown");
static_assert(sizeof(UBTD_RandomCooldown) == 0x000070, "Wrong size on UBTD_RandomCooldown");
static_assert(offsetof(UBTD_RandomCooldown, CoolDownTime) == 0x000068, "Member 'UBTD_RandomCooldown::CoolDownTime' has a wrong offset!");
static_assert(offsetof(UBTD_RandomCooldown, CooldownDurationDeviation) == 0x00006C, "Member 'UBTD_RandomCooldown::CooldownDurationDeviation' has a wrong offset!");

// Class ObsidianFox.BTD_SetTagRandomCooldown
// 0x0018 (0x0080 - 0x0068)
class UBTD_SetTagRandomCooldown final : public UBTDecorator
{
public:
	struct FGameplayTag                           CooldownTag;                                       // 0x0068(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownDuration;                                  // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownDurationDeviation;                         // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToExistingDuration;                            // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_SetTagRandomCooldown">();
	}
	static class UBTD_SetTagRandomCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_SetTagRandomCooldown>();
	}
};
static_assert(alignof(UBTD_SetTagRandomCooldown) == 0x000008, "Wrong alignment on UBTD_SetTagRandomCooldown");
static_assert(sizeof(UBTD_SetTagRandomCooldown) == 0x000080, "Wrong size on UBTD_SetTagRandomCooldown");
static_assert(offsetof(UBTD_SetTagRandomCooldown, CooldownTag) == 0x000068, "Member 'UBTD_SetTagRandomCooldown::CooldownTag' has a wrong offset!");
static_assert(offsetof(UBTD_SetTagRandomCooldown, CooldownDuration) == 0x000070, "Member 'UBTD_SetTagRandomCooldown::CooldownDuration' has a wrong offset!");
static_assert(offsetof(UBTD_SetTagRandomCooldown, CooldownDurationDeviation) == 0x000074, "Member 'UBTD_SetTagRandomCooldown::CooldownDurationDeviation' has a wrong offset!");
static_assert(offsetof(UBTD_SetTagRandomCooldown, bAddToExistingDuration) == 0x000078, "Member 'UBTD_SetTagRandomCooldown::bAddToExistingDuration' has a wrong offset!");

// Class ObsidianFox.SkeletonPuzzleActor
// 0x0008 (0x0240 - 0x0238)
class ASkeletonPuzzleActor final : public AActor
{
public:
	class UPersistenceComponent*                  PersistenceComponent;                              // 0x0238(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void RotateBonePitch(class UStaticMeshComponent* Bone, float Value);
	void RotateBoneYaw(class USceneComponent* Bone, float Value);
	void SkeletonPuzzleBeginPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkeletonPuzzleActor">();
	}
	static class ASkeletonPuzzleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASkeletonPuzzleActor>();
	}
};
static_assert(alignof(ASkeletonPuzzleActor) == 0x000008, "Wrong alignment on ASkeletonPuzzleActor");
static_assert(sizeof(ASkeletonPuzzleActor) == 0x000240, "Wrong size on ASkeletonPuzzleActor");
static_assert(offsetof(ASkeletonPuzzleActor, PersistenceComponent) == 0x000238, "Member 'ASkeletonPuzzleActor::PersistenceComponent' has a wrong offset!");

// Class ObsidianFox.BTD_TagRandomCooldown
// 0x0018 (0x0080 - 0x0068)
class UBTD_TagRandomCooldown final : public UBTDecorator
{
public:
	struct FGameplayTag                           CooldownTag;                                       // 0x0068(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownDuration;                                  // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownDurationDeviation;                         // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToExistingDuration;                            // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActivatesCooldown;                                // 0x0079(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTD_TagRandomCooldown">();
	}
	static class UBTD_TagRandomCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTD_TagRandomCooldown>();
	}
};
static_assert(alignof(UBTD_TagRandomCooldown) == 0x000008, "Wrong alignment on UBTD_TagRandomCooldown");
static_assert(sizeof(UBTD_TagRandomCooldown) == 0x000080, "Wrong size on UBTD_TagRandomCooldown");
static_assert(offsetof(UBTD_TagRandomCooldown, CooldownTag) == 0x000068, "Member 'UBTD_TagRandomCooldown::CooldownTag' has a wrong offset!");
static_assert(offsetof(UBTD_TagRandomCooldown, CooldownDuration) == 0x000070, "Member 'UBTD_TagRandomCooldown::CooldownDuration' has a wrong offset!");
static_assert(offsetof(UBTD_TagRandomCooldown, CooldownDurationDeviation) == 0x000074, "Member 'UBTD_TagRandomCooldown::CooldownDurationDeviation' has a wrong offset!");
static_assert(offsetof(UBTD_TagRandomCooldown, bAddToExistingDuration) == 0x000078, "Member 'UBTD_TagRandomCooldown::bAddToExistingDuration' has a wrong offset!");
static_assert(offsetof(UBTD_TagRandomCooldown, bActivatesCooldown) == 0x000079, "Member 'UBTD_TagRandomCooldown::bActivatesCooldown' has a wrong offset!");

// Class ObsidianFox.BTService_GameplayFocus
// 0x0000 (0x00A0 - 0x00A0)
class UBTService_GameplayFocus final : public UBTService_DefaultFocus
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_GameplayFocus">();
	}
	static class UBTService_GameplayFocus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_GameplayFocus>();
	}
};
static_assert(alignof(UBTService_GameplayFocus) == 0x000008, "Wrong alignment on UBTService_GameplayFocus");
static_assert(sizeof(UBTService_GameplayFocus) == 0x0000A0, "Wrong size on UBTService_GameplayFocus");

// Class ObsidianFox.BTTask_ActivateAbility
// 0x0038 (0x00B0 - 0x0078)
class UBTTask_ActivateAbility final : public UBTTask_GameplayTaskBase
{
public:
	TSubclassOf<class UGameplayAbility>           InAbilityToActivate;                               // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTreeComponent*                 OwningBT;                                          // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAbilitySpecHandle             InAbilitySpecHandle;                               // 0x0090(0x0004)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94[0xC];                                       // 0x0094(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAbilityEndedData                      EndingData;                                        // 0x00A0(0x0010)(NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_ActivateAbility">();
	}
	static class UBTTask_ActivateAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_ActivateAbility>();
	}
};
static_assert(alignof(UBTTask_ActivateAbility) == 0x000008, "Wrong alignment on UBTTask_ActivateAbility");
static_assert(sizeof(UBTTask_ActivateAbility) == 0x0000B0, "Wrong size on UBTTask_ActivateAbility");
static_assert(offsetof(UBTTask_ActivateAbility, InAbilityToActivate) == 0x000078, "Member 'UBTTask_ActivateAbility::InAbilityToActivate' has a wrong offset!");
static_assert(offsetof(UBTTask_ActivateAbility, OwningBT) == 0x000080, "Member 'UBTTask_ActivateAbility::OwningBT' has a wrong offset!");
static_assert(offsetof(UBTTask_ActivateAbility, AbilitySystemComponent) == 0x000088, "Member 'UBTTask_ActivateAbility::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(UBTTask_ActivateAbility, InAbilitySpecHandle) == 0x000090, "Member 'UBTTask_ActivateAbility::InAbilitySpecHandle' has a wrong offset!");
static_assert(offsetof(UBTTask_ActivateAbility, EndingData) == 0x0000A0, "Member 'UBTTask_ActivateAbility::EndingData' has a wrong offset!");

// Class ObsidianFox.GameSubsystem_DarkMan
// 0x00C0 (0x00F0 - 0x0030)
class UGameSubsystem_DarkMan final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           DarkManMPC;                                        // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x88];                                      // 0x0068(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeInAreaEffects(float FadeDuration);
	void FadeOutAreaEffects(float FadeDuration);
	void OverrideCameraEffectsAllowed(const bool bCameraEffectsDisabled);
	bool SetActiveDarkMan(class ACharacter* NewActiveDarkMan);

	class ACharacter* GetActiveDarkMan() const;
	EOFObsessionStage GetCurrentObsessionStage() const;
	float GetObsession() const;
	float GetObsessionDecayMin() const;
	float GetObsessionDecayMultiplier() const;
	float GetObsessionRaw() const;
	float GetObsessionStage2Threshold() const;
	float GetObsessionStage3Threshold() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSubsystem_DarkMan">();
	}
	static class UGameSubsystem_DarkMan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSubsystem_DarkMan>();
	}
};
static_assert(alignof(UGameSubsystem_DarkMan) == 0x000008, "Wrong alignment on UGameSubsystem_DarkMan");
static_assert(sizeof(UGameSubsystem_DarkMan) == 0x0000F0, "Wrong size on UGameSubsystem_DarkMan");
static_assert(offsetof(UGameSubsystem_DarkMan, DarkManMPC) == 0x000060, "Member 'UGameSubsystem_DarkMan::DarkManMPC' has a wrong offset!");

// Class ObsidianFox.BTTask_SetTagRandomCooldown
// 0x0018 (0x0088 - 0x0070)
class UBTTask_SetTagRandomCooldown final : public UBTTaskNode
{
public:
	struct FGameplayTag                           CooldownTag;                                       // 0x0070(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToExistingDuration;                            // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CooldownDuration;                                  // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CooldownDurationDeviation;                         // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_SetTagRandomCooldown">();
	}
	static class UBTTask_SetTagRandomCooldown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_SetTagRandomCooldown>();
	}
};
static_assert(alignof(UBTTask_SetTagRandomCooldown) == 0x000008, "Wrong alignment on UBTTask_SetTagRandomCooldown");
static_assert(sizeof(UBTTask_SetTagRandomCooldown) == 0x000088, "Wrong size on UBTTask_SetTagRandomCooldown");
static_assert(offsetof(UBTTask_SetTagRandomCooldown, CooldownTag) == 0x000070, "Member 'UBTTask_SetTagRandomCooldown::CooldownTag' has a wrong offset!");
static_assert(offsetof(UBTTask_SetTagRandomCooldown, bAddToExistingDuration) == 0x000078, "Member 'UBTTask_SetTagRandomCooldown::bAddToExistingDuration' has a wrong offset!");
static_assert(offsetof(UBTTask_SetTagRandomCooldown, CooldownDuration) == 0x00007C, "Member 'UBTTask_SetTagRandomCooldown::CooldownDuration' has a wrong offset!");
static_assert(offsetof(UBTTask_SetTagRandomCooldown, CooldownDurationDeviation) == 0x000080, "Member 'UBTTask_SetTagRandomCooldown::CooldownDurationDeviation' has a wrong offset!");

// Class ObsidianFox.BTT_CombatPointsWalkToPlayer
// 0x0050 (0x00C0 - 0x0070)
class UBTT_CombatPointsWalkToPlayer final : public UBTTaskNode
{
public:
	float                                         StrafePointDistanceThreshold;                      // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickNewPointPlayerDistThreshold;                   // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrafePropability;                                 // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AcceptableDistance;                                // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x40];                                      // 0x0080(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTT_CombatPointsWalkToPlayer">();
	}
	static class UBTT_CombatPointsWalkToPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTT_CombatPointsWalkToPlayer>();
	}
};
static_assert(alignof(UBTT_CombatPointsWalkToPlayer) == 0x000008, "Wrong alignment on UBTT_CombatPointsWalkToPlayer");
static_assert(sizeof(UBTT_CombatPointsWalkToPlayer) == 0x0000C0, "Wrong size on UBTT_CombatPointsWalkToPlayer");
static_assert(offsetof(UBTT_CombatPointsWalkToPlayer, StrafePointDistanceThreshold) == 0x000070, "Member 'UBTT_CombatPointsWalkToPlayer::StrafePointDistanceThreshold' has a wrong offset!");
static_assert(offsetof(UBTT_CombatPointsWalkToPlayer, PickNewPointPlayerDistThreshold) == 0x000074, "Member 'UBTT_CombatPointsWalkToPlayer::PickNewPointPlayerDistThreshold' has a wrong offset!");
static_assert(offsetof(UBTT_CombatPointsWalkToPlayer, StrafePropability) == 0x000078, "Member 'UBTT_CombatPointsWalkToPlayer::StrafePropability' has a wrong offset!");
static_assert(offsetof(UBTT_CombatPointsWalkToPlayer, AcceptableDistance) == 0x00007C, "Member 'UBTT_CombatPointsWalkToPlayer::AcceptableDistance' has a wrong offset!");

// Class ObsidianFox.OFAnimInstance
// 0x0D90 (0x11C0 - 0x0430)
class UOFAnimInstance : public UPiecesAnimInstance
{
public:
	uint8                                         Pad_430[0x60];                                     // 0x0430(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnFootStepDelegate;                                // 0x0490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFootUpDelegate;                                  // 0x04A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPoseMatchingCacheAsset*                PoseMatchingCacheAsset;                            // 0x04B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RelativeInputDirection;                            // 0x04B8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLegIKActive;                                     // 0x04C4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C5[0x63];                                     // 0x04C5(0x0063)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMultiBool                             LegIKDisableOverrideKeepHipOffsetEnabled;          // 0x0528(0x0060)(BlueprintVisible, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AObsidianFoxCharacter*                  OwnerChar;                                         // 0x0588(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 OwnerComponent;                                    // 0x0590(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOFCharacterMovementComponent*          CharacterMovementComponent;                        // 0x0598(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWaterLevelComponent*                   WaterLevelComponent;                               // 0x05A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveSpeed;                                         // 0x05A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StopMoveSpeed;                                     // 0x05AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MoveDirection;                                     // 0x05B0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeightShift_Forward;                               // 0x05BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeightShift_Right;                                 // 0x05C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeightShiftSpeed_Forward;                          // 0x05C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WeightShiftSpeed_Right;                            // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsSprinting : 1;                                  // 0x05CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_5CD[0x3];                                      // 0x05CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RelativeMovementDir;                               // 0x05D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Acceleration;                                      // 0x05DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDead;                                            // 0x05E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDeadOnLoad;                                      // 0x05E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          PlayDeathAnimation;                                // 0x05E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInAir;                                           // 0x05E3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                GroundNormal;                                      // 0x05E4(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundAngle;                                       // 0x05F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BankAngle;                                         // 0x05F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RMCurveName_Speed;                                 // 0x05F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RMCurveName_Forward;                               // 0x0600(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RMCurveName_Right;                                 // 0x0608(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RMCurveName_Up;                                    // 0x0610(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RMCurveName_Yaw;                                   // 0x0618(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDebuggingMain;                                   // 0x0620(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_621[0x7];                                      // 0x0621(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFocusPointsVariables                  FocusPoints;                                       // 0x0628(0x0190)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRagdollGroup>                  RagdollGroups;                                     // 0x07B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            HitRecoveryCurve;                                  // 0x07C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERagdollState                                 RagdollState;                                      // 0x07D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7D1[0x3];                                      // 0x07D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CapsuleFollowSpeed;                                // 0x07D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bRagdollSetsActorRotation : 1;                     // 0x07D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_7D9[0x3];                                      // 0x07D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PhysicsBodiesRootBone;                             // 0x07DC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PhysAnimationRootBone;                             // 0x07E4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PhysicsProfile_Default;                            // 0x07EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PhysicsProfile_Falling;                            // 0x07F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RecoveryPoseName;                                  // 0x07FC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FreezePoseName;                                    // 0x0804(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RagdollRecoveryRotTolerance;                       // 0x080C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRecoveryDelayTime;                              // 0x0810(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_814[0x4];                                      // 0x0814(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RagdollRotMisMatchDelay;                           // 0x0818(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_81C[0xC];                                      // 0x081C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class UFMODEvent*                             FootStepAudioEventWalk;                            // 0x0828(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             FootStepAudioEventRun;                             // 0x0830(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FootStepAudioSurfaceTypeParameterName;             // 0x0838(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FootStepAudioSpeedParameterName;                   // 0x0840(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FootStepAudioWaterLevelParameterName;              // 0x0848(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UContextualTraverseData*                ContextTraverseDataAsset;                          // 0x0850(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UContextualTraverseAnimInstance> LinkedContextualTraverseClass;                     // 0x0858(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CurrentEmoteAnimation;                             // 0x0860(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UActorMoodComponent*                    CharacterStateComponent;                           // 0x0868(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimComponentDistanceRotation*         DistanceRotationComponent;                         // 0x0870(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimComponentRagdoll*                  RagdollComponent;                                  // 0x0878(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAnimComponent*>                 DynamicAnimComponents;                             // 0x0880(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UAnimComponentDismemberment*            DismembermentComponent;                            // 0x0890(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FrozenTurnAngle;                                   // 0x0898(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_89C[0x54];                                     // 0x089C(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CinematicSlotName;                                 // 0x08F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CinematicRefPoseBlend;                             // 0x08F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BaseRecordedPoseName;                              // 0x08FC(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_904[0x4];                                      // 0x0904(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  OwnerCharacterGameplayTags;                        // 0x0908(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_928[0xB0];                                     // 0x0928(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DynamicsAlpha;                                     // 0x09D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bHasBegunPlay : 1;                                 // 0x09DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_9DD[0x3];                                      // 0x09DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBarkPlaybackData                      CurrentPlayingBark;                                // 0x09E0(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UFocusPointSearchHandle*                FocusPointSearchHandle;                            // 0x09F0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9F8[0x58];                                     // 0x09F8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOFAnimInstanceProxy                   Proxy;                                             // 0x0A50(0x0770)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPrivate)

public:
	struct FHitResult AverageLinetraceByChannel(const struct FVector& Start, const struct FVector& End, float Radius, int32 ExtraTraces, ECollisionChannel TraceChannel, bool DrawDebug);
	void ChangeIKState(EIKState* StateToUpdate, EIKState NewState);
	void CheckSaveDataChanges();
	class UAnimComponent* CreateAnimationComponent(TSubclassOf<class UAnimComponent> Class_0);
	void DebugLinetrace(const struct FHitResult& HitResult, float LineThickness, float Lifetime);
	void DebugLocationInterpolation(const struct FVector& TargetLocation, const struct FVector& ChasingLocation, float WantedProximity);
	void FreezeRagdollPosition();
	void FreezeTurnAngle(class UObject* LockOwner);
	struct FVector GetFocusPointOnCharacter();
	ERagdollState GetRagdollState();
	float GetStateMachineStateWeight(const class FName& StateMachineName, const class FName& StateName);
	struct FHitResult LinetraceByChannelWDebug(const struct FVector& Start, const struct FVector& End, ECollisionChannel TraceChannel, bool DrawDebug, float LineThickness, float DebugLifetime);
	void OnDeath(const struct FGameplayTagContainer& EventTags);
	void OnFootStep__DelegateSignature(const struct FVector& StepLocation, EFootType FootStepType, const class FName& BoneName);
	void PlayFootStepAudio(const class FName& BoneName);
	struct FMovePrediction PredictStopLocation();
	void RagdollEndRecovery();
	void UnfreezeTurnAngle(class UObject* LockOwner);
	void WholebodyRagdoll(bool Activate, float Duration);

	bool BoneIsParent(class FName ParentBone, class FName ChildBone, int32* Distance) const;
	bool CheckFocusPointValidity(const struct FFocusPointData& FocusPoint) const;
	void ForceStopRootMotion() const;
	class UAnimComponent* GetAnimationComponent(TSubclassOf<class UAnimComponent> ClassType) const;
	float GetCurveValueForBlueprint(class FName CurveName, bool* bCurveExists) const;
	float GetLimbReach(class FName BoneName, int32 HeirarchyLength) const;
	class FName GetParentBoneName(class FName BoneName, int32 HeirarchyHeight) const;
	bool HasAnyGameplayTags(const struct FGameplayTagContainer& Container) const;
	bool IsIKTargetWithinReach(const struct FVector& Target, float ReachLength, class FName BoneName, int32 HeirarchyLength) const;
	bool IsPreviewWorld() const;
	bool IsWithinVisionCone(const struct FVector& PointToCheck, float VisionConeDegrees) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFAnimInstance">();
	}
	static class UOFAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFAnimInstance>();
	}
};
static_assert(alignof(UOFAnimInstance) == 0x000010, "Wrong alignment on UOFAnimInstance");
static_assert(sizeof(UOFAnimInstance) == 0x0011C0, "Wrong size on UOFAnimInstance");
static_assert(offsetof(UOFAnimInstance, OnFootStepDelegate) == 0x000490, "Member 'UOFAnimInstance::OnFootStepDelegate' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, OnFootUpDelegate) == 0x0004A0, "Member 'UOFAnimInstance::OnFootUpDelegate' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, PoseMatchingCacheAsset) == 0x0004B0, "Member 'UOFAnimInstance::PoseMatchingCacheAsset' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, RelativeInputDirection) == 0x0004B8, "Member 'UOFAnimInstance::RelativeInputDirection' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, IsLegIKActive) == 0x0004C4, "Member 'UOFAnimInstance::IsLegIKActive' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, LegIKDisableOverrideKeepHipOffsetEnabled) == 0x000528, "Member 'UOFAnimInstance::LegIKDisableOverrideKeepHipOffsetEnabled' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, OwnerChar) == 0x000588, "Member 'UOFAnimInstance::OwnerChar' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, OwnerComponent) == 0x000590, "Member 'UOFAnimInstance::OwnerComponent' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, CharacterMovementComponent) == 0x000598, "Member 'UOFAnimInstance::CharacterMovementComponent' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, WaterLevelComponent) == 0x0005A0, "Member 'UOFAnimInstance::WaterLevelComponent' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, MoveSpeed) == 0x0005A8, "Member 'UOFAnimInstance::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, StopMoveSpeed) == 0x0005AC, "Member 'UOFAnimInstance::StopMoveSpeed' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, MoveDirection) == 0x0005B0, "Member 'UOFAnimInstance::MoveDirection' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, WeightShift_Forward) == 0x0005BC, "Member 'UOFAnimInstance::WeightShift_Forward' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, WeightShift_Right) == 0x0005C0, "Member 'UOFAnimInstance::WeightShift_Right' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, WeightShiftSpeed_Forward) == 0x0005C4, "Member 'UOFAnimInstance::WeightShiftSpeed_Forward' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, WeightShiftSpeed_Right) == 0x0005C8, "Member 'UOFAnimInstance::WeightShiftSpeed_Right' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, RelativeMovementDir) == 0x0005D0, "Member 'UOFAnimInstance::RelativeMovementDir' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, Acceleration) == 0x0005DC, "Member 'UOFAnimInstance::Acceleration' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, IsDead) == 0x0005E0, "Member 'UOFAnimInstance::IsDead' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, IsDeadOnLoad) == 0x0005E1, "Member 'UOFAnimInstance::IsDeadOnLoad' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, PlayDeathAnimation) == 0x0005E2, "Member 'UOFAnimInstance::PlayDeathAnimation' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, IsInAir) == 0x0005E3, "Member 'UOFAnimInstance::IsInAir' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, GroundNormal) == 0x0005E4, "Member 'UOFAnimInstance::GroundNormal' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, GroundAngle) == 0x0005F0, "Member 'UOFAnimInstance::GroundAngle' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, BankAngle) == 0x0005F4, "Member 'UOFAnimInstance::BankAngle' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, RMCurveName_Speed) == 0x0005F8, "Member 'UOFAnimInstance::RMCurveName_Speed' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, RMCurveName_Forward) == 0x000600, "Member 'UOFAnimInstance::RMCurveName_Forward' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, RMCurveName_Right) == 0x000608, "Member 'UOFAnimInstance::RMCurveName_Right' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, RMCurveName_Up) == 0x000610, "Member 'UOFAnimInstance::RMCurveName_Up' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, RMCurveName_Yaw) == 0x000618, "Member 'UOFAnimInstance::RMCurveName_Yaw' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, IsDebuggingMain) == 0x000620, "Member 'UOFAnimInstance::IsDebuggingMain' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, FocusPoints) == 0x000628, "Member 'UOFAnimInstance::FocusPoints' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, RagdollGroups) == 0x0007B8, "Member 'UOFAnimInstance::RagdollGroups' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, HitRecoveryCurve) == 0x0007C8, "Member 'UOFAnimInstance::HitRecoveryCurve' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, RagdollState) == 0x0007D0, "Member 'UOFAnimInstance::RagdollState' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, CapsuleFollowSpeed) == 0x0007D4, "Member 'UOFAnimInstance::CapsuleFollowSpeed' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, PhysicsBodiesRootBone) == 0x0007DC, "Member 'UOFAnimInstance::PhysicsBodiesRootBone' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, PhysAnimationRootBone) == 0x0007E4, "Member 'UOFAnimInstance::PhysAnimationRootBone' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, PhysicsProfile_Default) == 0x0007EC, "Member 'UOFAnimInstance::PhysicsProfile_Default' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, PhysicsProfile_Falling) == 0x0007F4, "Member 'UOFAnimInstance::PhysicsProfile_Falling' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, RecoveryPoseName) == 0x0007FC, "Member 'UOFAnimInstance::RecoveryPoseName' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, FreezePoseName) == 0x000804, "Member 'UOFAnimInstance::FreezePoseName' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, RagdollRecoveryRotTolerance) == 0x00080C, "Member 'UOFAnimInstance::RagdollRecoveryRotTolerance' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, MaxRecoveryDelayTime) == 0x000810, "Member 'UOFAnimInstance::MaxRecoveryDelayTime' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, RagdollRotMisMatchDelay) == 0x000818, "Member 'UOFAnimInstance::RagdollRotMisMatchDelay' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, FootStepAudioEventWalk) == 0x000828, "Member 'UOFAnimInstance::FootStepAudioEventWalk' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, FootStepAudioEventRun) == 0x000830, "Member 'UOFAnimInstance::FootStepAudioEventRun' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, FootStepAudioSurfaceTypeParameterName) == 0x000838, "Member 'UOFAnimInstance::FootStepAudioSurfaceTypeParameterName' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, FootStepAudioSpeedParameterName) == 0x000840, "Member 'UOFAnimInstance::FootStepAudioSpeedParameterName' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, FootStepAudioWaterLevelParameterName) == 0x000848, "Member 'UOFAnimInstance::FootStepAudioWaterLevelParameterName' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, ContextTraverseDataAsset) == 0x000850, "Member 'UOFAnimInstance::ContextTraverseDataAsset' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, LinkedContextualTraverseClass) == 0x000858, "Member 'UOFAnimInstance::LinkedContextualTraverseClass' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, CurrentEmoteAnimation) == 0x000860, "Member 'UOFAnimInstance::CurrentEmoteAnimation' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, CharacterStateComponent) == 0x000868, "Member 'UOFAnimInstance::CharacterStateComponent' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, DistanceRotationComponent) == 0x000870, "Member 'UOFAnimInstance::DistanceRotationComponent' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, RagdollComponent) == 0x000878, "Member 'UOFAnimInstance::RagdollComponent' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, DynamicAnimComponents) == 0x000880, "Member 'UOFAnimInstance::DynamicAnimComponents' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, DismembermentComponent) == 0x000890, "Member 'UOFAnimInstance::DismembermentComponent' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, FrozenTurnAngle) == 0x000898, "Member 'UOFAnimInstance::FrozenTurnAngle' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, CinematicSlotName) == 0x0008F0, "Member 'UOFAnimInstance::CinematicSlotName' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, CinematicRefPoseBlend) == 0x0008F8, "Member 'UOFAnimInstance::CinematicRefPoseBlend' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, BaseRecordedPoseName) == 0x0008FC, "Member 'UOFAnimInstance::BaseRecordedPoseName' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, OwnerCharacterGameplayTags) == 0x000908, "Member 'UOFAnimInstance::OwnerCharacterGameplayTags' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, DynamicsAlpha) == 0x0009D8, "Member 'UOFAnimInstance::DynamicsAlpha' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, CurrentPlayingBark) == 0x0009E0, "Member 'UOFAnimInstance::CurrentPlayingBark' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, FocusPointSearchHandle) == 0x0009F0, "Member 'UOFAnimInstance::FocusPointSearchHandle' has a wrong offset!");
static_assert(offsetof(UOFAnimInstance, Proxy) == 0x000A50, "Member 'UOFAnimInstance::Proxy' has a wrong offset!");

// Class ObsidianFox.PuzzleActor
// 0x0188 (0x03C0 - 0x0238)
class APuzzleActor : public AActor
{
public:
	class USceneComponent*                        PuzzleRoot;                                        // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractionFlowComponent*              InteractionComponentFlow;                          // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHidePlayer : 1;                                   // 0x0248(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableInteractionOnLoadIfSolved : 1;             // 0x0248(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PuzzleUIClass;                                     // 0x0250(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCtrlButtonWidget*                      PuzzleUI;                                          // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOFPlayerController*                    InteractingPController;                            // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraAbductorComponent*               CameraAbductor;                                    // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartAsSolvable;                                  // 0x0290(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequiresMultipleConditions;                       // 0x0291(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bManualSolvableCondition;                          // 0x0292(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_293[0x5];                                      // 0x0293(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UItemData*>                        RequiredItems;                                     // 0x0298(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<class UItemData*>                        AcquiredItems;                                     // 0x02E8(0x0050)(SaveGame, Protected, NativeAccessSpecifierProtected)
	bool                                          bPuzzleIsSolvable;                                 // 0x0338(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_339[0x3];                                      // 0x0339(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ChapterSelectFactTag_Solved;                       // 0x033C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsSolved : 1;                                     // 0x0344(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_345[0x3];                                      // 0x0345(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPuzzleEnter;                                     // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPuzzleExit;                                      // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPuzzleSolved;                                    // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPuzzleSolvableStateUpdated;                      // 0x0378(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPersistenceComponent*                  PersistenceComponent;                              // 0x0388(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapMarkerPuzzleComponent*              MapMarker;                                         // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFlowComponent*                         FlowComponent;                                     // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PuzzleEnterFlowTag;                                // 0x03A0(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PuzzleExitFlowTag;                                 // 0x03A8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PuzzleSolvableFlowTag;                             // 0x03B0(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PuzzleSolvedFlowTag;                               // 0x03B8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CancelExitsPuzzle();
	void EnteringPuzzle(class ACharacter* InteractingCharacter);
	void EnterPuzzle(class ACharacter* InteractingCharacter);
	void ExitingPuzzle(class AOFPlayerController* InteractingPlayerController);
	void ExitPuzzle();
	TSet<class UItemData*> GetRequiredItems();
	void ItemAddedHandler(const class UItemData* ItemData);
	void PuzzleBeginPlay();
	void PuzzleEnter__DelegateSignature(class APuzzleActor* PuzzleActor, class ACharacter* InteractingCharacter);
	void PuzzleExit__DelegateSignature(class APuzzleActor* PuzzleActor, class AOFPlayerController* InteractingController);
	void PuzzleSolve__DelegateSignature(class APuzzleActor* PuzzleActor, class AOFPlayerController* InteractingController);
	void PuzzleUpdateSolvableState__DelegateSignature(bool bSolvable);
	void RestoringFromChapterSelect();
	void SetManualSolvableCondition(const bool bSolvable);
	void SetPuzzleIsSolvableRaw(const bool bSolvable);
	class UCtrlButtonWidget* ShowPuzzleUI(int32 ZOrder);
	void SolvePuzzle();
	void SolvingPuzzle(class AOFPlayerController* InteractingPlayerController);

	bool GetIsSolvable() const;
	bool GetIsSolved() const;
	void RemovePuzzleUI() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PuzzleActor">();
	}
	static class APuzzleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APuzzleActor>();
	}
};
static_assert(alignof(APuzzleActor) == 0x000008, "Wrong alignment on APuzzleActor");
static_assert(sizeof(APuzzleActor) == 0x0003C0, "Wrong size on APuzzleActor");
static_assert(offsetof(APuzzleActor, PuzzleRoot) == 0x000238, "Member 'APuzzleActor::PuzzleRoot' has a wrong offset!");
static_assert(offsetof(APuzzleActor, InteractionComponentFlow) == 0x000240, "Member 'APuzzleActor::InteractionComponentFlow' has a wrong offset!");
static_assert(offsetof(APuzzleActor, PuzzleUIClass) == 0x000250, "Member 'APuzzleActor::PuzzleUIClass' has a wrong offset!");
static_assert(offsetof(APuzzleActor, PuzzleUI) == 0x000278, "Member 'APuzzleActor::PuzzleUI' has a wrong offset!");
static_assert(offsetof(APuzzleActor, InteractingPController) == 0x000280, "Member 'APuzzleActor::InteractingPController' has a wrong offset!");
static_assert(offsetof(APuzzleActor, CameraAbductor) == 0x000288, "Member 'APuzzleActor::CameraAbductor' has a wrong offset!");
static_assert(offsetof(APuzzleActor, bStartAsSolvable) == 0x000290, "Member 'APuzzleActor::bStartAsSolvable' has a wrong offset!");
static_assert(offsetof(APuzzleActor, bRequiresMultipleConditions) == 0x000291, "Member 'APuzzleActor::bRequiresMultipleConditions' has a wrong offset!");
static_assert(offsetof(APuzzleActor, bManualSolvableCondition) == 0x000292, "Member 'APuzzleActor::bManualSolvableCondition' has a wrong offset!");
static_assert(offsetof(APuzzleActor, RequiredItems) == 0x000298, "Member 'APuzzleActor::RequiredItems' has a wrong offset!");
static_assert(offsetof(APuzzleActor, AcquiredItems) == 0x0002E8, "Member 'APuzzleActor::AcquiredItems' has a wrong offset!");
static_assert(offsetof(APuzzleActor, bPuzzleIsSolvable) == 0x000338, "Member 'APuzzleActor::bPuzzleIsSolvable' has a wrong offset!");
static_assert(offsetof(APuzzleActor, ChapterSelectFactTag_Solved) == 0x00033C, "Member 'APuzzleActor::ChapterSelectFactTag_Solved' has a wrong offset!");
static_assert(offsetof(APuzzleActor, OnPuzzleEnter) == 0x000348, "Member 'APuzzleActor::OnPuzzleEnter' has a wrong offset!");
static_assert(offsetof(APuzzleActor, OnPuzzleExit) == 0x000358, "Member 'APuzzleActor::OnPuzzleExit' has a wrong offset!");
static_assert(offsetof(APuzzleActor, OnPuzzleSolved) == 0x000368, "Member 'APuzzleActor::OnPuzzleSolved' has a wrong offset!");
static_assert(offsetof(APuzzleActor, OnPuzzleSolvableStateUpdated) == 0x000378, "Member 'APuzzleActor::OnPuzzleSolvableStateUpdated' has a wrong offset!");
static_assert(offsetof(APuzzleActor, PersistenceComponent) == 0x000388, "Member 'APuzzleActor::PersistenceComponent' has a wrong offset!");
static_assert(offsetof(APuzzleActor, MapMarker) == 0x000390, "Member 'APuzzleActor::MapMarker' has a wrong offset!");
static_assert(offsetof(APuzzleActor, FlowComponent) == 0x000398, "Member 'APuzzleActor::FlowComponent' has a wrong offset!");
static_assert(offsetof(APuzzleActor, PuzzleEnterFlowTag) == 0x0003A0, "Member 'APuzzleActor::PuzzleEnterFlowTag' has a wrong offset!");
static_assert(offsetof(APuzzleActor, PuzzleExitFlowTag) == 0x0003A8, "Member 'APuzzleActor::PuzzleExitFlowTag' has a wrong offset!");
static_assert(offsetof(APuzzleActor, PuzzleSolvableFlowTag) == 0x0003B0, "Member 'APuzzleActor::PuzzleSolvableFlowTag' has a wrong offset!");
static_assert(offsetof(APuzzleActor, PuzzleSolvedFlowTag) == 0x0003B8, "Member 'APuzzleActor::PuzzleSolvedFlowTag' has a wrong offset!");

// Class ObsidianFox.InventoryPuzzle
// 0x0038 (0x03F8 - 0x03C0)
class AInventoryPuzzle final : public APuzzleActor
{
public:
	class USceneComponent*                        RotationComponent;                                 // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        CameraStandIn;                                     // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                CameraWorldPosition;                               // 0x03D0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               CameraWorldRotation;                               // 0x03DC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	float                                         SelectionRadius;                                   // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BasePitchRate;                                     // 0x03EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseYawRate;                                       // 0x03F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanRotate;                                        // 0x03F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F5[0x3];                                      // 0x03F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class USceneComponent* SelectionTrace(struct FHitResult* OutHit, bool* bBlockingHit, float Distance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryPuzzle">();
	}
	static class AInventoryPuzzle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AInventoryPuzzle>();
	}
};
static_assert(alignof(AInventoryPuzzle) == 0x000008, "Wrong alignment on AInventoryPuzzle");
static_assert(sizeof(AInventoryPuzzle) == 0x0003F8, "Wrong size on AInventoryPuzzle");
static_assert(offsetof(AInventoryPuzzle, RotationComponent) == 0x0003C0, "Member 'AInventoryPuzzle::RotationComponent' has a wrong offset!");
static_assert(offsetof(AInventoryPuzzle, CameraStandIn) == 0x0003C8, "Member 'AInventoryPuzzle::CameraStandIn' has a wrong offset!");
static_assert(offsetof(AInventoryPuzzle, CameraWorldPosition) == 0x0003D0, "Member 'AInventoryPuzzle::CameraWorldPosition' has a wrong offset!");
static_assert(offsetof(AInventoryPuzzle, CameraWorldRotation) == 0x0003DC, "Member 'AInventoryPuzzle::CameraWorldRotation' has a wrong offset!");
static_assert(offsetof(AInventoryPuzzle, SelectionRadius) == 0x0003E8, "Member 'AInventoryPuzzle::SelectionRadius' has a wrong offset!");
static_assert(offsetof(AInventoryPuzzle, BasePitchRate) == 0x0003EC, "Member 'AInventoryPuzzle::BasePitchRate' has a wrong offset!");
static_assert(offsetof(AInventoryPuzzle, BaseYawRate) == 0x0003F0, "Member 'AInventoryPuzzle::BaseYawRate' has a wrong offset!");
static_assert(offsetof(AInventoryPuzzle, bCanRotate) == 0x0003F4, "Member 'AInventoryPuzzle::bCanRotate' has a wrong offset!");

// Class ObsidianFox.EnemyAnimInstance
// 0x0050 (0x1210 - 0x11C0)
class UEnemyAnimInstance : public UOFAnimInstance
{
public:
	uint8                                         Pad_11C0[0x20];                                    // 0x11C0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimComponentFootIK*                   FootIK;                                            // 0x11E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimComponentAIFocus*                  FocusComponent;                                    // 0x11E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimComponentLockedTurnInPlace*        TurnInPlace;                                       // 0x11F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimComponentThreatDetection*          ThreatDetection;                                   // 0x11F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SleepVariant;                                      // 0x1200(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumberOfSleepVariants;                             // 0x1204(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bRandomizeIdleStartPosition : 1;                   // 0x1208(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsInCombat : 1;                                   // 0x1208(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1209[0x7];                                     // 0x1209(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAnimInstance">();
	}
	static class UEnemyAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyAnimInstance>();
	}
};
static_assert(alignof(UEnemyAnimInstance) == 0x000010, "Wrong alignment on UEnemyAnimInstance");
static_assert(sizeof(UEnemyAnimInstance) == 0x001210, "Wrong size on UEnemyAnimInstance");
static_assert(offsetof(UEnemyAnimInstance, FootIK) == 0x0011E0, "Member 'UEnemyAnimInstance::FootIK' has a wrong offset!");
static_assert(offsetof(UEnemyAnimInstance, FocusComponent) == 0x0011E8, "Member 'UEnemyAnimInstance::FocusComponent' has a wrong offset!");
static_assert(offsetof(UEnemyAnimInstance, TurnInPlace) == 0x0011F0, "Member 'UEnemyAnimInstance::TurnInPlace' has a wrong offset!");
static_assert(offsetof(UEnemyAnimInstance, ThreatDetection) == 0x0011F8, "Member 'UEnemyAnimInstance::ThreatDetection' has a wrong offset!");
static_assert(offsetof(UEnemyAnimInstance, SleepVariant) == 0x001200, "Member 'UEnemyAnimInstance::SleepVariant' has a wrong offset!");
static_assert(offsetof(UEnemyAnimInstance, NumberOfSleepVariants) == 0x001204, "Member 'UEnemyAnimInstance::NumberOfSleepVariants' has a wrong offset!");

// Class ObsidianFox.BurrowerAnimInstance
// 0x0060 (0x1270 - 0x1210)
class UBurrowerAnimInstance final : public UEnemyAnimInstance
{
public:
	uint8                                         Pad_1210[0x60];                                    // 0x1210(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAirMultiBoolChanged(bool bNewState);
	void OnAirStateChanged(bool bNewState);
	void SetIsInAir(class UObject* CallerReference, bool bRequestedState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BurrowerAnimInstance">();
	}
	static class UBurrowerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBurrowerAnimInstance>();
	}
};
static_assert(alignof(UBurrowerAnimInstance) == 0x000010, "Wrong alignment on UBurrowerAnimInstance");
static_assert(sizeof(UBurrowerAnimInstance) == 0x001270, "Wrong size on UBurrowerAnimInstance");

// Class ObsidianFox.GameSubsystem_ChapterSelect
// 0x0010 (0x0040 - 0x0030)
class UGameSubsystem_ChapterSelect final : public UGameInstanceSubsystem
{
public:
	class UChapterSelectDataAsset*                ChapterSelectDataAsset;                            // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelLoaded(class ULevel* InLevel, class UWorld* InWorld);
	void OpenLevel(const class UChapterSelectDataAsset* InChapterSelectDataAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSubsystem_ChapterSelect">();
	}
	static class UGameSubsystem_ChapterSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSubsystem_ChapterSelect>();
	}
};
static_assert(alignof(UGameSubsystem_ChapterSelect) == 0x000008, "Wrong alignment on UGameSubsystem_ChapterSelect");
static_assert(sizeof(UGameSubsystem_ChapterSelect) == 0x000040, "Wrong size on UGameSubsystem_ChapterSelect");
static_assert(offsetof(UGameSubsystem_ChapterSelect, ChapterSelectDataAsset) == 0x000030, "Member 'UGameSubsystem_ChapterSelect::ChapterSelectDataAsset' has a wrong offset!");

// Class ObsidianFox.CameraAbductorComponent
// 0x00B0 (0x0168 - 0x00B8)
class UCameraAbductorComponent final : public UActorComponent
{
public:
	uint8                                         bHidePlayer : 1;                                   // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBindInteractionComponent : 1;                     // 0x00B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBindCancelToExit : 1;                             // 0x00B8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDisableCameraModifiersImmediately : 1;            // 0x00B8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bForceViewTargetExit : 1;                          // 0x00B8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UCameraModifier>>    DisabledCameraModifiers;                           // 0x00C0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UCameraModifier>>    AddedCameraModifiers;                              // 0x00D0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         RemovalTimerLength;                                // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            CameraStartParams;                                 // 0x00E4(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            CameraEndParams;                                   // 0x00F4(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInputMappingContext*>           AddedInputMappingContexts;                         // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnterActor;                                      // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExitActor;                                       // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x30];                                     // 0x0138(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyCameraEffects();
	void CameraAbductionDelegate__DelegateSignature(class AActor* AbductingActor, class APlayerController* InteractingController);
	void CleanUpCameraModifiers();
	void EnterActor(class APlayerController* InteractingCharacter);
	void EnteringActor(class APlayerController* InteractingCharacter);
	void ExitActor();
	void ExitingActor(class APlayerController* InteractingPlayerController);
	void InteractionEnter(class ACharacter* InteractingCharacter);
	void RemoveCameraEffects();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraAbductorComponent">();
	}
	static class UCameraAbductorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraAbductorComponent>();
	}
};
static_assert(alignof(UCameraAbductorComponent) == 0x000008, "Wrong alignment on UCameraAbductorComponent");
static_assert(sizeof(UCameraAbductorComponent) == 0x000168, "Wrong size on UCameraAbductorComponent");
static_assert(offsetof(UCameraAbductorComponent, DisabledCameraModifiers) == 0x0000C0, "Member 'UCameraAbductorComponent::DisabledCameraModifiers' has a wrong offset!");
static_assert(offsetof(UCameraAbductorComponent, AddedCameraModifiers) == 0x0000D0, "Member 'UCameraAbductorComponent::AddedCameraModifiers' has a wrong offset!");
static_assert(offsetof(UCameraAbductorComponent, RemovalTimerLength) == 0x0000E0, "Member 'UCameraAbductorComponent::RemovalTimerLength' has a wrong offset!");
static_assert(offsetof(UCameraAbductorComponent, CameraStartParams) == 0x0000E4, "Member 'UCameraAbductorComponent::CameraStartParams' has a wrong offset!");
static_assert(offsetof(UCameraAbductorComponent, CameraEndParams) == 0x0000F4, "Member 'UCameraAbductorComponent::CameraEndParams' has a wrong offset!");
static_assert(offsetof(UCameraAbductorComponent, AddedInputMappingContexts) == 0x000108, "Member 'UCameraAbductorComponent::AddedInputMappingContexts' has a wrong offset!");
static_assert(offsetof(UCameraAbductorComponent, OnEnterActor) == 0x000118, "Member 'UCameraAbductorComponent::OnEnterActor' has a wrong offset!");
static_assert(offsetof(UCameraAbductorComponent, OnExitActor) == 0x000128, "Member 'UCameraAbductorComponent::OnExitActor' has a wrong offset!");

// Class ObsidianFox.GameSubSystem_MenuHud
// 0x00A0 (0x00D0 - 0x0030)
class UGameSubSystem_MenuHud final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowStart;                                        // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnemeyHealthBarHud*                    EnemyHealthBar;                                    // 0x0040(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInteractInfoTextHud*                   InteractionInfoWidget;                             // 0x0048(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHelpTextHud*                           HelpTextHud;                                       // 0x0050(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowEnemyHealthBar;                               // 0x0058(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanFadeAway;                                       // 0x0059(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLoadingScreen;                                // 0x005A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowGameOverScreen;                               // 0x005B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewGameText;                                      // 0x005C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectives                                   ObjectiveText;                                     // 0x005D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EHelptText>                            HelpTextDone;                                      // 0x0060(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHaveDercetoMap;                                   // 0x0070(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlackLoadingScreen;                               // 0x0071(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnemyHealthBarFade;                               // 0x0072(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_73[0x5D];                                      // 0x0073(0x005D)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CanFadeAwayAll();
	void FadeEnemyBar50Percent();
	bool IsInGameUIHidden();
	bool IsObjectiveDone(EObjectives Objective);
	bool NewHelpText(EHelptText HelpText);
	void SetInGameUIVisibility(const ESlateVisibility NewState);
	void UpdateEnemyHealthbar(class AObsidianFoxCharacter* Enemy);
	void UpdateInteractWidget(const class FText& InfoText, TSoftObjectPtr<class UTexture2D> InfoImage);
	void UpdateObjective(EObjectives NewObjective);
	bool UpdateObjectiveFromCurrent(EObjectives OldObjective, EObjectives NewObjective);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSubSystem_MenuHud">();
	}
	static class UGameSubSystem_MenuHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSubSystem_MenuHud>();
	}
};
static_assert(alignof(UGameSubSystem_MenuHud) == 0x000008, "Wrong alignment on UGameSubSystem_MenuHud");
static_assert(sizeof(UGameSubSystem_MenuHud) == 0x0000D0, "Wrong size on UGameSubSystem_MenuHud");
static_assert(offsetof(UGameSubSystem_MenuHud, bShowStart) == 0x000038, "Member 'UGameSubSystem_MenuHud::bShowStart' has a wrong offset!");
static_assert(offsetof(UGameSubSystem_MenuHud, EnemyHealthBar) == 0x000040, "Member 'UGameSubSystem_MenuHud::EnemyHealthBar' has a wrong offset!");
static_assert(offsetof(UGameSubSystem_MenuHud, InteractionInfoWidget) == 0x000048, "Member 'UGameSubSystem_MenuHud::InteractionInfoWidget' has a wrong offset!");
static_assert(offsetof(UGameSubSystem_MenuHud, HelpTextHud) == 0x000050, "Member 'UGameSubSystem_MenuHud::HelpTextHud' has a wrong offset!");
static_assert(offsetof(UGameSubSystem_MenuHud, bShowEnemyHealthBar) == 0x000058, "Member 'UGameSubSystem_MenuHud::bShowEnemyHealthBar' has a wrong offset!");
static_assert(offsetof(UGameSubSystem_MenuHud, CanFadeAway) == 0x000059, "Member 'UGameSubSystem_MenuHud::CanFadeAway' has a wrong offset!");
static_assert(offsetof(UGameSubSystem_MenuHud, bShowLoadingScreen) == 0x00005A, "Member 'UGameSubSystem_MenuHud::bShowLoadingScreen' has a wrong offset!");
static_assert(offsetof(UGameSubSystem_MenuHud, bShowGameOverScreen) == 0x00005B, "Member 'UGameSubSystem_MenuHud::bShowGameOverScreen' has a wrong offset!");
static_assert(offsetof(UGameSubSystem_MenuHud, bNewGameText) == 0x00005C, "Member 'UGameSubSystem_MenuHud::bNewGameText' has a wrong offset!");
static_assert(offsetof(UGameSubSystem_MenuHud, ObjectiveText) == 0x00005D, "Member 'UGameSubSystem_MenuHud::ObjectiveText' has a wrong offset!");
static_assert(offsetof(UGameSubSystem_MenuHud, HelpTextDone) == 0x000060, "Member 'UGameSubSystem_MenuHud::HelpTextDone' has a wrong offset!");
static_assert(offsetof(UGameSubSystem_MenuHud, bHaveDercetoMap) == 0x000070, "Member 'UGameSubSystem_MenuHud::bHaveDercetoMap' has a wrong offset!");
static_assert(offsetof(UGameSubSystem_MenuHud, bBlackLoadingScreen) == 0x000071, "Member 'UGameSubSystem_MenuHud::bBlackLoadingScreen' has a wrong offset!");
static_assert(offsetof(UGameSubSystem_MenuHud, bEnemyHealthBarFade) == 0x000072, "Member 'UGameSubSystem_MenuHud::bEnemyHealthBarFade' has a wrong offset!");

// Class ObsidianFox.CameraModifier_HipTracker
// 0x0000 (0x0548 - 0x0548)
class UCameraModifier_HipTracker final : public UThirdPersonCameraModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModifier_HipTracker">();
	}
	static class UCameraModifier_HipTracker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModifier_HipTracker>();
	}
};
static_assert(alignof(UCameraModifier_HipTracker) == 0x000008, "Wrong alignment on UCameraModifier_HipTracker");
static_assert(sizeof(UCameraModifier_HipTracker) == 0x000548, "Wrong size on UCameraModifier_HipTracker");

// Class ObsidianFox.CemetaryCreatureAnimInstance
// 0x0030 (0x1240 - 0x1210)
class UCemetaryCreatureAnimInstance : public UEnemyAnimInstance
{
public:
	float                                         UpperBodyTiltTarget;                               // 0x1210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentUpperBodyTilt;                              // 0x1214(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpperBodyTiltBlendSpeed;                           // 0x1218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SleepingTag;                                       // 0x121C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSleeping;                                        // 0x1224(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1225[0x3];                                     // 0x1225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputDirectionSizeSquared;                         // 0x1228(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Alert;                                             // 0x122C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_122D[0x3];                                     // 0x122D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AlertVariant;                                      // 0x1230(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1234[0xC];                                     // 0x1234(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetUpperBodyTiltEnabled(bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CemetaryCreatureAnimInstance">();
	}
	static class UCemetaryCreatureAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCemetaryCreatureAnimInstance>();
	}
};
static_assert(alignof(UCemetaryCreatureAnimInstance) == 0x000010, "Wrong alignment on UCemetaryCreatureAnimInstance");
static_assert(sizeof(UCemetaryCreatureAnimInstance) == 0x001240, "Wrong size on UCemetaryCreatureAnimInstance");
static_assert(offsetof(UCemetaryCreatureAnimInstance, UpperBodyTiltTarget) == 0x001210, "Member 'UCemetaryCreatureAnimInstance::UpperBodyTiltTarget' has a wrong offset!");
static_assert(offsetof(UCemetaryCreatureAnimInstance, CurrentUpperBodyTilt) == 0x001214, "Member 'UCemetaryCreatureAnimInstance::CurrentUpperBodyTilt' has a wrong offset!");
static_assert(offsetof(UCemetaryCreatureAnimInstance, UpperBodyTiltBlendSpeed) == 0x001218, "Member 'UCemetaryCreatureAnimInstance::UpperBodyTiltBlendSpeed' has a wrong offset!");
static_assert(offsetof(UCemetaryCreatureAnimInstance, SleepingTag) == 0x00121C, "Member 'UCemetaryCreatureAnimInstance::SleepingTag' has a wrong offset!");
static_assert(offsetof(UCemetaryCreatureAnimInstance, IsSleeping) == 0x001224, "Member 'UCemetaryCreatureAnimInstance::IsSleeping' has a wrong offset!");
static_assert(offsetof(UCemetaryCreatureAnimInstance, InputDirectionSizeSquared) == 0x001228, "Member 'UCemetaryCreatureAnimInstance::InputDirectionSizeSquared' has a wrong offset!");
static_assert(offsetof(UCemetaryCreatureAnimInstance, Alert) == 0x00122C, "Member 'UCemetaryCreatureAnimInstance::Alert' has a wrong offset!");
static_assert(offsetof(UCemetaryCreatureAnimInstance, AlertVariant) == 0x001230, "Member 'UCemetaryCreatureAnimInstance::AlertVariant' has a wrong offset!");

// Class ObsidianFox.GameSubsystem_AnimationAssetManager
// 0x0050 (0x0080 - 0x0030)
class UGameSubsystem_AnimationAssetManager final : public UGameInstanceSubsystem
{
public:
	TMap<TSoftObjectPtr<class USkeleton>, class UAnimationLookupTable*> TableCache;                                        // 0x0030(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void GetAllLookupEntriesForTag(const class ACharacter* Character, const struct FGameplayTag& MontageTag, TArray<struct FAnimationLookupTableEntry>* OutEntries, EAnimationLookupTableLookupMethod LookupMethod);
	void GetAllLookupEntriesForTagSkeleton(class USkeletalMeshComponent* SkeletalMeshComponent, const struct FGameplayTag& MontageTag, TArray<struct FAnimationLookupTableEntry>* OutEntries, EAnimationLookupTableLookupMethod LookupMethod);
	TSoftObjectPtr<class UAnimMontage> GetMontageForCharacter(const class ACharacter* Character, const struct FGameplayTag& MontageTag, bool bStartAsyncLoad);
	class UAnimMontage* GetMontageForCharacterBlockingLoad(class ACharacter* Character, const struct FGameplayTag& MontageTag);
	TSoftObjectPtr<class UAnimMontage> GetMontageForSkeleton(class USkeletalMeshComponent* SkeletalMeshComponent, const struct FGameplayTag& MontageTag, bool bStartAsyncLoad);
	class UAnimMontage* GetMontageForSkeletonBlockingLoad(class USkeletalMeshComponent* SkeletalMeshComponent, const struct FGameplayTag& MontageTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSubsystem_AnimationAssetManager">();
	}
	static class UGameSubsystem_AnimationAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSubsystem_AnimationAssetManager>();
	}
};
static_assert(alignof(UGameSubsystem_AnimationAssetManager) == 0x000008, "Wrong alignment on UGameSubsystem_AnimationAssetManager");
static_assert(sizeof(UGameSubsystem_AnimationAssetManager) == 0x000080, "Wrong size on UGameSubsystem_AnimationAssetManager");
static_assert(offsetof(UGameSubsystem_AnimationAssetManager, TableCache) == 0x000030, "Member 'UGameSubsystem_AnimationAssetManager::TableCache' has a wrong offset!");

// Class ObsidianFox.ChapterSelectButtonWidget
// 0x0018 (0x0278 - 0x0260)
class UChapterSelectButtonWidget final : public UUserWidget
{
public:
	class UOFButton*                              ChapterSelectButton;                               // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWidgetHover;                                     // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnButtonHovered();
	void OnWidgetHover__DelegateSignature(class UWidget* Widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChapterSelectButtonWidget">();
	}
	static class UChapterSelectButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChapterSelectButtonWidget>();
	}
};
static_assert(alignof(UChapterSelectButtonWidget) == 0x000008, "Wrong alignment on UChapterSelectButtonWidget");
static_assert(sizeof(UChapterSelectButtonWidget) == 0x000278, "Wrong size on UChapterSelectButtonWidget");
static_assert(offsetof(UChapterSelectButtonWidget, ChapterSelectButton) == 0x000260, "Member 'UChapterSelectButtonWidget::ChapterSelectButton' has a wrong offset!");
static_assert(offsetof(UChapterSelectButtonWidget, OnWidgetHover) == 0x000268, "Member 'UChapterSelectButtonWidget::OnWidgetHover' has a wrong offset!");

// Class ObsidianFox.ChapterSelectDataAsset
// 0x00F8 (0x0128 - 0x0030)
class UChapterSelectDataAsset final : public UDataAsset
{
public:
	class FText                                   ChapterName;                                       // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  Level;                                             // 0x0048(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TeleportPosition;                                  // 0x0070(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UItemData>>       ItemsToAdd;                                        // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UObjectivesData>> Objectives;                                        // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, int32>              FactsDBSettings;                                   // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCompositeCurveTable>    FactsDBCompositeTable;                             // 0x00F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ProgressionTag;                                    // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCharacterType                          CharacterType;                                     // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChapterSelectDataAsset">();
	}
	static class UChapterSelectDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChapterSelectDataAsset>();
	}
};
static_assert(alignof(UChapterSelectDataAsset) == 0x000008, "Wrong alignment on UChapterSelectDataAsset");
static_assert(sizeof(UChapterSelectDataAsset) == 0x000128, "Wrong size on UChapterSelectDataAsset");
static_assert(offsetof(UChapterSelectDataAsset, ChapterName) == 0x000030, "Member 'UChapterSelectDataAsset::ChapterName' has a wrong offset!");
static_assert(offsetof(UChapterSelectDataAsset, Level) == 0x000048, "Member 'UChapterSelectDataAsset::Level' has a wrong offset!");
static_assert(offsetof(UChapterSelectDataAsset, TeleportPosition) == 0x000070, "Member 'UChapterSelectDataAsset::TeleportPosition' has a wrong offset!");
static_assert(offsetof(UChapterSelectDataAsset, ItemsToAdd) == 0x000080, "Member 'UChapterSelectDataAsset::ItemsToAdd' has a wrong offset!");
static_assert(offsetof(UChapterSelectDataAsset, Objectives) == 0x000090, "Member 'UChapterSelectDataAsset::Objectives' has a wrong offset!");
static_assert(offsetof(UChapterSelectDataAsset, FactsDBSettings) == 0x0000A0, "Member 'UChapterSelectDataAsset::FactsDBSettings' has a wrong offset!");
static_assert(offsetof(UChapterSelectDataAsset, FactsDBCompositeTable) == 0x0000F0, "Member 'UChapterSelectDataAsset::FactsDBCompositeTable' has a wrong offset!");
static_assert(offsetof(UChapterSelectDataAsset, ProgressionTag) == 0x000118, "Member 'UChapterSelectDataAsset::ProgressionTag' has a wrong offset!");
static_assert(offsetof(UChapterSelectDataAsset, CharacterType) == 0x000120, "Member 'UChapterSelectDataAsset::CharacterType' has a wrong offset!");

// Class ObsidianFox.GuantletPerformenceSampler
// 0x0020 (0x0258 - 0x0238)
class AGuantletPerformenceSampler : public AActor
{
public:
	class UCameraComponent*                       Camera;                                            // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraAbductorComponent*               CameraAbductor;                                    // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 SamplerId;                                         // 0x0248(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnSampleEnd();
	void OnSampleStart();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuantletPerformenceSampler">();
	}
	static class AGuantletPerformenceSampler* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGuantletPerformenceSampler>();
	}
};
static_assert(alignof(AGuantletPerformenceSampler) == 0x000008, "Wrong alignment on AGuantletPerformenceSampler");
static_assert(sizeof(AGuantletPerformenceSampler) == 0x000258, "Wrong size on AGuantletPerformenceSampler");
static_assert(offsetof(AGuantletPerformenceSampler, Camera) == 0x000238, "Member 'AGuantletPerformenceSampler::Camera' has a wrong offset!");
static_assert(offsetof(AGuantletPerformenceSampler, CameraAbductor) == 0x000240, "Member 'AGuantletPerformenceSampler::CameraAbductor' has a wrong offset!");
static_assert(offsetof(AGuantletPerformenceSampler, SamplerId) == 0x000248, "Member 'AGuantletPerformenceSampler::SamplerId' has a wrong offset!");

// Class ObsidianFox.CharacterMeshInterpolationComponent
// 0x0088 (0x0140 - 0x00B8)
class UCharacterMeshInterpolationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x60];                                      // 0x00B8(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseMeshInterpolation : 1;                         // 0x0118(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, Interp, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_119[0x3];                                      // 0x0119(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MeshOffset;                                        // 0x011C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOFPlayerCharacter*                     OwnerCharacter;                                    // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinInterpolationSpeed;                             // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxInterpolationSpeed;                             // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DisableMeshInterpolation(const class UObject* LockReference);
	void OnOwnerCinematicModeChange(bool EnteredCinematicMode);
	void RestoreMeshInterpolation(const class UObject* LockReference);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterMeshInterpolationComponent">();
	}
	static class UCharacterMeshInterpolationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterMeshInterpolationComponent>();
	}
};
static_assert(alignof(UCharacterMeshInterpolationComponent) == 0x000008, "Wrong alignment on UCharacterMeshInterpolationComponent");
static_assert(sizeof(UCharacterMeshInterpolationComponent) == 0x000140, "Wrong size on UCharacterMeshInterpolationComponent");
static_assert(offsetof(UCharacterMeshInterpolationComponent, MeshOffset) == 0x00011C, "Member 'UCharacterMeshInterpolationComponent::MeshOffset' has a wrong offset!");
static_assert(offsetof(UCharacterMeshInterpolationComponent, OwnerCharacter) == 0x000120, "Member 'UCharacterMeshInterpolationComponent::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UCharacterMeshInterpolationComponent, MinInterpolationSpeed) == 0x000138, "Member 'UCharacterMeshInterpolationComponent::MinInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UCharacterMeshInterpolationComponent, MaxInterpolationSpeed) == 0x00013C, "Member 'UCharacterMeshInterpolationComponent::MaxInterpolationSpeed' has a wrong offset!");

// Class ObsidianFox.CharacterSelect
// 0x00B8 (0x02F0 - 0x0238)
class ACharacterSelect final : public AActor
{
public:
	TMap<EPlayerCharacterType, class FName>       CharacterLightsTags;                               // 0x0238(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_288[0x50];                                     // 0x0288(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UPersistenceComponent*                  PersistenceComponent;                              // 0x02D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLevelAddedToWorld(class ULevel* Level, class UWorld* World);
	void RefreshCharacterSelectLights();
	void SetAlphaForAllCharacterLights(float Alpha);
	void SetAlphaForCharacterLight(EPlayerCharacterType Character, float Alpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSelect">();
	}
	static class ACharacterSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterSelect>();
	}
};
static_assert(alignof(ACharacterSelect) == 0x000008, "Wrong alignment on ACharacterSelect");
static_assert(sizeof(ACharacterSelect) == 0x0002F0, "Wrong size on ACharacterSelect");
static_assert(offsetof(ACharacterSelect, CharacterLightsTags) == 0x000238, "Member 'ACharacterSelect::CharacterLightsTags' has a wrong offset!");
static_assert(offsetof(ACharacterSelect, PersistenceComponent) == 0x0002D8, "Member 'ACharacterSelect::PersistenceComponent' has a wrong offset!");

// Class ObsidianFox.HiddenOptionsPT
// 0x05A0 (0x0800 - 0x0260)
class UHiddenOptionsPT final : public UUserWidget
{
public:
	class UIncreaseDecreaseOption*                GammaSetting;                                      // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIncreaseDecreaseOption*                SFXVolumeSetting;                                  // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIncreaseDecreaseOption*                MusicVolumeSetting;                                // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIncreaseDecreaseOption*                MasterVolumeSetting;                               // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIncreaseDecreaseOption*                ScreenResolutionWidget;                            // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIncreaseDecreaseOption*                WindowTypeWidget;                                  // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UIncreaseDecreaseOption*                VSyncWidget;                                       // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                RestartButton;                                     // 0x0298(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                QuitButton;                                        // 0x02A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FButtonStyle                           ButtonNormalStyle;                                 // 0x02A8(0x0278)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FButtonStyle                           ButtonHoveredStyle;                                // 0x0520(0x0278)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_798[0x48];                                     // 0x0798(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           WindowTypesText;                                   // 0x07E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class FText>                           OnOffText;                                         // 0x07F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void ButtonHovered();
	void ButtonUnHovered();
	void CancelButtonPressed();
	void DecreaseOption();
	void IncreaseOption();
	void InteractButtonPressed();
	void LeftStickX(float Val);
	void LeftStickY(float Val);
	void QuitGame();
	void RestartGame();
	void SelectDownPressed();
	void SelectNextPressed();
	void SelectPreviousPressed();
	void SelectUpPressed();
	void SetCanMoveWithLeftStickXToTrue();
	void SetCanMoveWithLeftStickYToTrue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HiddenOptionsPT">();
	}
	static class UHiddenOptionsPT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHiddenOptionsPT>();
	}
};
static_assert(alignof(UHiddenOptionsPT) == 0x000008, "Wrong alignment on UHiddenOptionsPT");
static_assert(sizeof(UHiddenOptionsPT) == 0x000800, "Wrong size on UHiddenOptionsPT");
static_assert(offsetof(UHiddenOptionsPT, GammaSetting) == 0x000260, "Member 'UHiddenOptionsPT::GammaSetting' has a wrong offset!");
static_assert(offsetof(UHiddenOptionsPT, SFXVolumeSetting) == 0x000268, "Member 'UHiddenOptionsPT::SFXVolumeSetting' has a wrong offset!");
static_assert(offsetof(UHiddenOptionsPT, MusicVolumeSetting) == 0x000270, "Member 'UHiddenOptionsPT::MusicVolumeSetting' has a wrong offset!");
static_assert(offsetof(UHiddenOptionsPT, MasterVolumeSetting) == 0x000278, "Member 'UHiddenOptionsPT::MasterVolumeSetting' has a wrong offset!");
static_assert(offsetof(UHiddenOptionsPT, ScreenResolutionWidget) == 0x000280, "Member 'UHiddenOptionsPT::ScreenResolutionWidget' has a wrong offset!");
static_assert(offsetof(UHiddenOptionsPT, WindowTypeWidget) == 0x000288, "Member 'UHiddenOptionsPT::WindowTypeWidget' has a wrong offset!");
static_assert(offsetof(UHiddenOptionsPT, VSyncWidget) == 0x000290, "Member 'UHiddenOptionsPT::VSyncWidget' has a wrong offset!");
static_assert(offsetof(UHiddenOptionsPT, RestartButton) == 0x000298, "Member 'UHiddenOptionsPT::RestartButton' has a wrong offset!");
static_assert(offsetof(UHiddenOptionsPT, QuitButton) == 0x0002A0, "Member 'UHiddenOptionsPT::QuitButton' has a wrong offset!");
static_assert(offsetof(UHiddenOptionsPT, ButtonNormalStyle) == 0x0002A8, "Member 'UHiddenOptionsPT::ButtonNormalStyle' has a wrong offset!");
static_assert(offsetof(UHiddenOptionsPT, ButtonHoveredStyle) == 0x000520, "Member 'UHiddenOptionsPT::ButtonHoveredStyle' has a wrong offset!");
static_assert(offsetof(UHiddenOptionsPT, WindowTypesText) == 0x0007E0, "Member 'UHiddenOptionsPT::WindowTypesText' has a wrong offset!");
static_assert(offsetof(UHiddenOptionsPT, OnOffText) == 0x0007F0, "Member 'UHiddenOptionsPT::OnOffText' has a wrong offset!");

// Class ObsidianFox.CharacterStateAnimInterface
// 0x0000 (0x0028 - 0x0028)
class ICharacterStateAnimInterface final : public IInterface
{
public:
	void OnEnterGauntlet(bool bIsFirstTime);
	void OnExitGauntlet(bool bIsFirstTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterStateAnimInterface">();
	}
	static class ICharacterStateAnimInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ICharacterStateAnimInterface>();
	}
};
static_assert(alignof(ICharacterStateAnimInterface) == 0x000008, "Wrong alignment on ICharacterStateAnimInterface");
static_assert(sizeof(ICharacterStateAnimInterface) == 0x000028, "Wrong size on ICharacterStateAnimInterface");

// Class ObsidianFox.ChargeTask
// 0x0000 (0x0080 - 0x0080)
class UChargeTask final : public UAbilityTask
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeTask">();
	}
	static class UChargeTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChargeTask>();
	}
};
static_assert(alignof(UChargeTask) == 0x000008, "Wrong alignment on UChargeTask");
static_assert(sizeof(UChargeTask) == 0x000080, "Wrong size on UChargeTask");

// Class ObsidianFox.GunAnimInterface
// 0x0000 (0x0028 - 0x0028)
class IGunAnimInterface final : public IInterface
{
public:
	void OnReloadEvent(const struct FGameplayTag& EventTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunAnimInterface">();
	}
	static class IGunAnimInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGunAnimInterface>();
	}
};
static_assert(alignof(IGunAnimInterface) == 0x000008, "Wrong alignment on IGunAnimInterface");
static_assert(sizeof(IGunAnimInterface) == 0x000028, "Wrong size on IGunAnimInterface");

// Class ObsidianFox.CheckGroundedAtStartupAC
// 0x00C0 (0x0178 - 0x00B8)
class UCheckGroundedAtStartupAC final : public UActorComponent
{
public:
	float                                         DistanceToTestForGrounded;                         // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnabled;                                          // 0x00BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReturnToPositionBeforeRestoringGravity;           // 0x00BD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableGravityAtEndPlay;                          // 0x00BE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BF[0x1];                                       // 0x00BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           PlayerTagThatAllowsFalling;                        // 0x00C0(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0xB0];                                      // 0x00C8(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAllowFallingMultiBoolValueChanged(bool bNewValue);
	void OnCharacterGameplayTagChanged(const struct FGameplayTag& Tag, int32 EventType);
	void OnCharacterMovementModeChanged(EMovementMode PreviousMovementMode, EMovementMode NewMovementMode);
	void OnOwnerCinematicModeChanged(bool NewState);
	void ResetRestoringPositionAndStartTracing();
	void SetAllowFalling(const class UObject* LockReference, bool bValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckGroundedAtStartupAC">();
	}
	static class UCheckGroundedAtStartupAC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheckGroundedAtStartupAC>();
	}
};
static_assert(alignof(UCheckGroundedAtStartupAC) == 0x000008, "Wrong alignment on UCheckGroundedAtStartupAC");
static_assert(sizeof(UCheckGroundedAtStartupAC) == 0x000178, "Wrong size on UCheckGroundedAtStartupAC");
static_assert(offsetof(UCheckGroundedAtStartupAC, DistanceToTestForGrounded) == 0x0000B8, "Member 'UCheckGroundedAtStartupAC::DistanceToTestForGrounded' has a wrong offset!");
static_assert(offsetof(UCheckGroundedAtStartupAC, bEnabled) == 0x0000BC, "Member 'UCheckGroundedAtStartupAC::bEnabled' has a wrong offset!");
static_assert(offsetof(UCheckGroundedAtStartupAC, bReturnToPositionBeforeRestoringGravity) == 0x0000BD, "Member 'UCheckGroundedAtStartupAC::bReturnToPositionBeforeRestoringGravity' has a wrong offset!");
static_assert(offsetof(UCheckGroundedAtStartupAC, bDisableGravityAtEndPlay) == 0x0000BE, "Member 'UCheckGroundedAtStartupAC::bDisableGravityAtEndPlay' has a wrong offset!");
static_assert(offsetof(UCheckGroundedAtStartupAC, PlayerTagThatAllowsFalling) == 0x0000C0, "Member 'UCheckGroundedAtStartupAC::PlayerTagThatAllowsFalling' has a wrong offset!");

// Class ObsidianFox.HelpButtonHud
// 0x0088 (0x02E8 - 0x0260)
class UHelpButtonHud final : public UUserWidget
{
public:
	class UImage*                                 BackButtonImage;                                   // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             BackButtonText;                                    // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           ButtonCanvas;                                      // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwningActor;                                       // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetPosition;                                      // 0x0280(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x67];                                     // 0x0281(0x0067)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearButtons();
	void CreateNewHelpButton(const TSoftObjectPtr<class UTexture2D> buttonTexture, const class FText& ButtonText, const EFButtonType Type);
	void PositionButtons();
	void SetDefaultButtonPosition();
	void SetInactive(EFButtonType Type, bool Value);
	void SetNewName(EFButtonType Type, const class FText& NewText);
	void SetVisibilityOnAll(ESlateVisibility Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelpButtonHud">();
	}
	static class UHelpButtonHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelpButtonHud>();
	}
};
static_assert(alignof(UHelpButtonHud) == 0x000008, "Wrong alignment on UHelpButtonHud");
static_assert(sizeof(UHelpButtonHud) == 0x0002E8, "Wrong size on UHelpButtonHud");
static_assert(offsetof(UHelpButtonHud, BackButtonImage) == 0x000260, "Member 'UHelpButtonHud::BackButtonImage' has a wrong offset!");
static_assert(offsetof(UHelpButtonHud, BackButtonText) == 0x000268, "Member 'UHelpButtonHud::BackButtonText' has a wrong offset!");
static_assert(offsetof(UHelpButtonHud, ButtonCanvas) == 0x000270, "Member 'UHelpButtonHud::ButtonCanvas' has a wrong offset!");
static_assert(offsetof(UHelpButtonHud, OwningActor) == 0x000278, "Member 'UHelpButtonHud::OwningActor' has a wrong offset!");
static_assert(offsetof(UHelpButtonHud, bSetPosition) == 0x000280, "Member 'UHelpButtonHud::bSetPosition' has a wrong offset!");

// Class ObsidianFox.CheckpointSubsystem
// 0x0010 (0x0040 - 0x0030)
class UCheckpointSubsystem final : public UGameplaySessionSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CurrentCheckpoint;                                 // 0x0038(0x0008)(SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetCheckpointTag(const struct FGameplayTag& CheckpointTag);

	struct FGameplayTag GetCurrentCheckpoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheckpointSubsystem">();
	}
	static class UCheckpointSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheckpointSubsystem>();
	}
};
static_assert(alignof(UCheckpointSubsystem) == 0x000008, "Wrong alignment on UCheckpointSubsystem");
static_assert(sizeof(UCheckpointSubsystem) == 0x000040, "Wrong size on UCheckpointSubsystem");
static_assert(offsetof(UCheckpointSubsystem, CurrentCheckpoint) == 0x000038, "Member 'UCheckpointSubsystem::CurrentCheckpoint' has a wrong offset!");

// Class ObsidianFox.BPAsyncAction_HitReaction
// 0x0130 (0x0160 - 0x0030)
class UBPAsyncAction_HitReaction final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnFailed;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReactionBegin;                                   // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCompleted;                                       // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInterrupted;                                     // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UHitReactionComponent*                  HitReactionComponent;                              // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0xE8];                                      // 0x0078(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBPAsyncAction_HitReaction* PlayHitReaction(class UHitReactionComponent* HitReactionComponent_0, const struct FHitReactionData& HitReactionData, EHitReactionType HitReactionType, bool bOverrideDirection, ECardinalDirection DirectionToPlay);

	void OnHitReactionFinished__DelegateSignature(EHitReactionType HitReactionType);
	void OnInteractionBegin(EHitReactionType HitReactionType);
	void OnInteractionDone(EHitReactionType HitReactionType, bool bFailed, bool bWasInterrupted);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPAsyncAction_HitReaction">();
	}
	static class UBPAsyncAction_HitReaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPAsyncAction_HitReaction>();
	}
};
static_assert(alignof(UBPAsyncAction_HitReaction) == 0x000008, "Wrong alignment on UBPAsyncAction_HitReaction");
static_assert(sizeof(UBPAsyncAction_HitReaction) == 0x000160, "Wrong size on UBPAsyncAction_HitReaction");
static_assert(offsetof(UBPAsyncAction_HitReaction, OnFailed) == 0x000030, "Member 'UBPAsyncAction_HitReaction::OnFailed' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_HitReaction, OnReactionBegin) == 0x000040, "Member 'UBPAsyncAction_HitReaction::OnReactionBegin' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_HitReaction, OnCompleted) == 0x000050, "Member 'UBPAsyncAction_HitReaction::OnCompleted' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_HitReaction, OnInterrupted) == 0x000060, "Member 'UBPAsyncAction_HitReaction::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_HitReaction, HitReactionComponent) == 0x000070, "Member 'UBPAsyncAction_HitReaction::HitReactionComponent' has a wrong offset!");

// Class ObsidianFox.CircuitBreaker
// 0x0020 (0x03E0 - 0x03C0)
class ACircuitBreaker final : public APuzzleActor
{
public:
	TArray<struct FPuzzleBreaker>                 Breakers;                                          // 0x03C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<uint8>                                 BreakerDefaultOnOffState;                          // 0x03D0(0x0010)(ZeroConstructor, SaveGame, Protected, NativeAccessSpecifierProtected)

public:
	void ResetBreakerState();
	void SetBreakerLeverComponent(int32 Index_0, class USceneComponent* LeverComponent);
	void StoreDefaultBreakerState();
	void ToggleBreakerByLever(const class USceneComponent* LeverComponent);
	bool UpdateSolvedState();

	TArray<struct FPuzzleBreaker> GetAffectedBreakersByLever(const class USceneComponent* LeverComponent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CircuitBreaker">();
	}
	static class ACircuitBreaker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACircuitBreaker>();
	}
};
static_assert(alignof(ACircuitBreaker) == 0x000008, "Wrong alignment on ACircuitBreaker");
static_assert(sizeof(ACircuitBreaker) == 0x0003E0, "Wrong size on ACircuitBreaker");
static_assert(offsetof(ACircuitBreaker, Breakers) == 0x0003C0, "Member 'ACircuitBreaker::Breakers' has a wrong offset!");
static_assert(offsetof(ACircuitBreaker, BreakerDefaultOnOffState) == 0x0003D0, "Member 'ACircuitBreaker::BreakerDefaultOnOffState' has a wrong offset!");

// Class ObsidianFox.ExaminationViewBaseWidget
// 0x0090 (0x02F0 - 0x0260)
class UExaminationViewBaseWidget : public UUserWidget
{
public:
	class UInputAction*                           PlayVOInputAction;                                 // 0x0260(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrlButtonWidget*                      InputActions;                                      // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   PlayVOText;                                        // 0x0270(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   StopVOText;                                        // 0x0288(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFMODEvent>              VOFmodEvent;                                       // 0x02B0(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x18];                                     // 0x02D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlaySound_Internal();
	void StopSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ExaminationViewBaseWidget">();
	}
	static class UExaminationViewBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UExaminationViewBaseWidget>();
	}
};
static_assert(alignof(UExaminationViewBaseWidget) == 0x000008, "Wrong alignment on UExaminationViewBaseWidget");
static_assert(sizeof(UExaminationViewBaseWidget) == 0x0002F0, "Wrong size on UExaminationViewBaseWidget");
static_assert(offsetof(UExaminationViewBaseWidget, PlayVOInputAction) == 0x000260, "Member 'UExaminationViewBaseWidget::PlayVOInputAction' has a wrong offset!");
static_assert(offsetof(UExaminationViewBaseWidget, InputActions) == 0x000268, "Member 'UExaminationViewBaseWidget::InputActions' has a wrong offset!");
static_assert(offsetof(UExaminationViewBaseWidget, PlayVOText) == 0x000270, "Member 'UExaminationViewBaseWidget::PlayVOText' has a wrong offset!");
static_assert(offsetof(UExaminationViewBaseWidget, StopVOText) == 0x000288, "Member 'UExaminationViewBaseWidget::StopVOText' has a wrong offset!");
static_assert(offsetof(UExaminationViewBaseWidget, VOFmodEvent) == 0x0002B0, "Member 'UExaminationViewBaseWidget::VOFmodEvent' has a wrong offset!");

// Class ObsidianFox.AnimNotifyState_HipOffsetInterpolationSpeed
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_HipOffsetInterpolationSpeed final : public UAnimNotifyState
{
public:
	float                                         InterpolationSpeed;                                // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_HipOffsetInterpolationSpeed">();
	}
	static class UAnimNotifyState_HipOffsetInterpolationSpeed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_HipOffsetInterpolationSpeed>();
	}
};
static_assert(alignof(UAnimNotifyState_HipOffsetInterpolationSpeed) == 0x000008, "Wrong alignment on UAnimNotifyState_HipOffsetInterpolationSpeed");
static_assert(sizeof(UAnimNotifyState_HipOffsetInterpolationSpeed) == 0x000038, "Wrong size on UAnimNotifyState_HipOffsetInterpolationSpeed");
static_assert(offsetof(UAnimNotifyState_HipOffsetInterpolationSpeed, InterpolationSpeed) == 0x000030, "Member 'UAnimNotifyState_HipOffsetInterpolationSpeed::InterpolationSpeed' has a wrong offset!");

// Class ObsidianFox.CollectibleLoreTextExamination
// 0x0048 (0x0338 - 0x02F0)
class UCollectibleLoreTextExamination : public UExaminationViewBaseWidget
{
public:
	class UTextBlock*                             Label;                                             // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         LoreText;                                          // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             LoreTextScrollBox;                                 // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MultiplyValueToMoveInScrollBox;                    // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           CloseDownInputAction;                              // 0x0310(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           MoveScrollBoxInputAction;                          // 0x0318(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           CloseDownWidgetInputAction;                        // 0x0320(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVOStructInfo>                  CollectibleVOS;                                    // 0x0328(0x0010)(BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void MoveScrollBoxInputHandler(const struct FInputActionValue& InputActionValue);
	void OnCloseDownWidgetPressedHandler();
	void OnClosePressedHandler();
	void OnPlayVOHandler();
	void SetupInput();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectibleLoreTextExamination">();
	}
	static class UCollectibleLoreTextExamination* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectibleLoreTextExamination>();
	}
};
static_assert(alignof(UCollectibleLoreTextExamination) == 0x000008, "Wrong alignment on UCollectibleLoreTextExamination");
static_assert(sizeof(UCollectibleLoreTextExamination) == 0x000338, "Wrong size on UCollectibleLoreTextExamination");
static_assert(offsetof(UCollectibleLoreTextExamination, Label) == 0x0002F0, "Member 'UCollectibleLoreTextExamination::Label' has a wrong offset!");
static_assert(offsetof(UCollectibleLoreTextExamination, LoreText) == 0x0002F8, "Member 'UCollectibleLoreTextExamination::LoreText' has a wrong offset!");
static_assert(offsetof(UCollectibleLoreTextExamination, LoreTextScrollBox) == 0x000300, "Member 'UCollectibleLoreTextExamination::LoreTextScrollBox' has a wrong offset!");
static_assert(offsetof(UCollectibleLoreTextExamination, MultiplyValueToMoveInScrollBox) == 0x000308, "Member 'UCollectibleLoreTextExamination::MultiplyValueToMoveInScrollBox' has a wrong offset!");
static_assert(offsetof(UCollectibleLoreTextExamination, CloseDownInputAction) == 0x000310, "Member 'UCollectibleLoreTextExamination::CloseDownInputAction' has a wrong offset!");
static_assert(offsetof(UCollectibleLoreTextExamination, MoveScrollBoxInputAction) == 0x000318, "Member 'UCollectibleLoreTextExamination::MoveScrollBoxInputAction' has a wrong offset!");
static_assert(offsetof(UCollectibleLoreTextExamination, CloseDownWidgetInputAction) == 0x000320, "Member 'UCollectibleLoreTextExamination::CloseDownWidgetInputAction' has a wrong offset!");
static_assert(offsetof(UCollectibleLoreTextExamination, CollectibleVOS) == 0x000328, "Member 'UCollectibleLoreTextExamination::CollectibleVOS' has a wrong offset!");

// Class ObsidianFox.CollectibleManager
// 0x00E0 (0x0108 - 0x0028)
class UCollectibleManager final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnAllCollectiblesLoaded;                           // 0x0028(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAllCollectiblesCompleted;                        // 0x0038(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UCollectibleSet*>                CollectibleSets;                                   // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSet<TWeakObjectPtr<class UCollectibleSet>>   CompletedCollectibleSets;                          // 0x0058(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x58];                                      // 0x00A8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventory*                             OwnerInventory;                                    // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void CollectibleSetCompletedHandler(const class UCollectibleSet* CollectibleSet);

	bool GetAllCollectiblesLoaded() const;
	const class UCollectibleSet* GetCollectibleSet(TSoftObjectPtr<class UCollectiblesDataAsset> InCollectiblesDataAsset) const;
	const TArray<class UCollectibleSet*> GetCollectibleSets() const;
	bool HaveGatheredItem(const TSoftObjectPtr<class UCollectiblesDataAsset>& InCollectiblesDataAsset, const TSoftObjectPtr<class UItemData>& InItemData) const;
	bool HaveGatheredItemInAnySet(const TSoftObjectPtr<class UItemData>& InItemData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectibleManager">();
	}
	static class UCollectibleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectibleManager>();
	}
};
static_assert(alignof(UCollectibleManager) == 0x000008, "Wrong alignment on UCollectibleManager");
static_assert(sizeof(UCollectibleManager) == 0x000108, "Wrong size on UCollectibleManager");
static_assert(offsetof(UCollectibleManager, OnAllCollectiblesLoaded) == 0x000028, "Member 'UCollectibleManager::OnAllCollectiblesLoaded' has a wrong offset!");
static_assert(offsetof(UCollectibleManager, OnAllCollectiblesCompleted) == 0x000038, "Member 'UCollectibleManager::OnAllCollectiblesCompleted' has a wrong offset!");
static_assert(offsetof(UCollectibleManager, CollectibleSets) == 0x000048, "Member 'UCollectibleManager::CollectibleSets' has a wrong offset!");
static_assert(offsetof(UCollectibleManager, CompletedCollectibleSets) == 0x000058, "Member 'UCollectibleManager::CompletedCollectibleSets' has a wrong offset!");
static_assert(offsetof(UCollectibleManager, OwnerInventory) == 0x000100, "Member 'UCollectibleManager::OwnerInventory' has a wrong offset!");

// Class ObsidianFox.HealthHistoryComponent
// 0x0038 (0x00F0 - 0x00B8)
class UHealthHistoryComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             HealthHistoryUpdated;                              // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x28];                                      // 0x00C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetHealthDifference(const float SecondsBackInTime);
	void OnHealthChanged(float NewCurrentHealth, float DeltaValue, const struct FGameplayTagContainer& EventTags);

	float GetHealthBackInTime(const float SecondsBackInTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthHistoryComponent">();
	}
	static class UHealthHistoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthHistoryComponent>();
	}
};
static_assert(alignof(UHealthHistoryComponent) == 0x000008, "Wrong alignment on UHealthHistoryComponent");
static_assert(sizeof(UHealthHistoryComponent) == 0x0000F0, "Wrong size on UHealthHistoryComponent");
static_assert(offsetof(UHealthHistoryComponent, HealthHistoryUpdated) == 0x0000B8, "Member 'UHealthHistoryComponent::HealthHistoryUpdated' has a wrong offset!");

// Class ObsidianFox.CollectiblesDataAsset
// 0x0078 (0x00A8 - 0x0030)
class UCollectiblesDataAsset final : public UDataAsset
{
public:
	TArray<TSoftObjectPtr<class UItemData>>       CollectiblesItems;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FText                                   CollectibleLabelText;                              // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CollectibleRewardText;                             // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CollectibleLoreText;                               // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 UniqueName;                                        // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVOStructInfo>                  CollectibleVOS;                                    // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectiblesDataAsset">();
	}
	static class UCollectiblesDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectiblesDataAsset>();
	}
};
static_assert(alignof(UCollectiblesDataAsset) == 0x000008, "Wrong alignment on UCollectiblesDataAsset");
static_assert(sizeof(UCollectiblesDataAsset) == 0x0000A8, "Wrong size on UCollectiblesDataAsset");
static_assert(offsetof(UCollectiblesDataAsset, CollectiblesItems) == 0x000030, "Member 'UCollectiblesDataAsset::CollectiblesItems' has a wrong offset!");
static_assert(offsetof(UCollectiblesDataAsset, CollectibleLabelText) == 0x000040, "Member 'UCollectiblesDataAsset::CollectibleLabelText' has a wrong offset!");
static_assert(offsetof(UCollectiblesDataAsset, CollectibleRewardText) == 0x000058, "Member 'UCollectiblesDataAsset::CollectibleRewardText' has a wrong offset!");
static_assert(offsetof(UCollectiblesDataAsset, CollectibleLoreText) == 0x000070, "Member 'UCollectiblesDataAsset::CollectibleLoreText' has a wrong offset!");
static_assert(offsetof(UCollectiblesDataAsset, UniqueName) == 0x000088, "Member 'UCollectiblesDataAsset::UniqueName' has a wrong offset!");
static_assert(offsetof(UCollectiblesDataAsset, CollectibleVOS) == 0x000098, "Member 'UCollectiblesDataAsset::CollectibleVOS' has a wrong offset!");

// Class ObsidianFox.CollectibleSet
// 0x0068 (0x0090 - 0x0028)
class UCollectibleSet final : public UObject
{
public:
	TArray<TSoftObjectPtr<class UItemData>>       GatheredItems;                                     // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCollectiblesDataAsset>  CollectibleAsset;                                  // 0x0038(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSetCompleted;                                    // 0x0070(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemGathered;                                    // 0x0080(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool IsCompleted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectibleSet">();
	}
	static class UCollectibleSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectibleSet>();
	}
};
static_assert(alignof(UCollectibleSet) == 0x000008, "Wrong alignment on UCollectibleSet");
static_assert(sizeof(UCollectibleSet) == 0x000090, "Wrong size on UCollectibleSet");
static_assert(offsetof(UCollectibleSet, GatheredItems) == 0x000028, "Member 'UCollectibleSet::GatheredItems' has a wrong offset!");
static_assert(offsetof(UCollectibleSet, CollectibleAsset) == 0x000038, "Member 'UCollectibleSet::CollectibleAsset' has a wrong offset!");
static_assert(offsetof(UCollectibleSet, OnSetCompleted) == 0x000070, "Member 'UCollectibleSet::OnSetCompleted' has a wrong offset!");
static_assert(offsetof(UCollectibleSet, OnItemGathered) == 0x000080, "Member 'UCollectibleSet::OnItemGathered' has a wrong offset!");

// Class ObsidianFox.WidgetInputHandlingBase
// 0x0030 (0x02A0 - 0x0270)
class UWidgetInputHandlingBase : public UPiecesUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnNewWidgetHovered;                                // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelPressed;                                   // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWidget*                                SelectedWidget;                                    // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGamepad;                                          // 0x0298(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelPressed();
	void CategoryNextHandler();
	void CategoryPreviousHandler();
	void GetWidgets(TArray<class UWidget*>* Widgets);
	void HoverNewWidget(class UWidget* Widget);
	void MoveWidgetInputActionTriggeredHandler(const struct FInputActionValue& InputActionValue);
	void OnAcceptPressed();
	void OnButtonWidgetHovered(class UButton* ButtonWidget);
	void OnCancelPressed__DelegateSignature(class UWidget* Widget);
	void OnCultureChanged();
	void OnInteractPressedHandler();
	void OnNewWidgetHovered__DelegateSignature(class UWidget* NewWidget);
	void OnResetPressed();
	void OnWidgetHovered(class UWidget* NewWidget);
	void OpenMenuPressedHandler();
	void OpenPauseMenuPressed();
	void SelectNextPressed();
	void SelectNextPressed_Implementation();
	void SelectPreviousPressed();
	void SelectPreviousPressed_Implementation();
	void SetupInput();
	void SetUpWidgets();

	bool HasBeenSetup() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetInputHandlingBase">();
	}
	static class UWidgetInputHandlingBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetInputHandlingBase>();
	}
};
static_assert(alignof(UWidgetInputHandlingBase) == 0x000008, "Wrong alignment on UWidgetInputHandlingBase");
static_assert(sizeof(UWidgetInputHandlingBase) == 0x0002A0, "Wrong size on UWidgetInputHandlingBase");
static_assert(offsetof(UWidgetInputHandlingBase, OnNewWidgetHovered) == 0x000270, "Member 'UWidgetInputHandlingBase::OnNewWidgetHovered' has a wrong offset!");
static_assert(offsetof(UWidgetInputHandlingBase, OnCancelPressed) == 0x000280, "Member 'UWidgetInputHandlingBase::OnCancelPressed' has a wrong offset!");
static_assert(offsetof(UWidgetInputHandlingBase, SelectedWidget) == 0x000290, "Member 'UWidgetInputHandlingBase::SelectedWidget' has a wrong offset!");
static_assert(offsetof(UWidgetInputHandlingBase, bGamepad) == 0x000298, "Member 'UWidgetInputHandlingBase::bGamepad' has a wrong offset!");

// Class ObsidianFox.CollectiblesListWidget
// 0x0008 (0x02A8 - 0x02A0)
class UCollectiblesListWidget : public UWidgetInputHandlingBase
{
public:
	bool                                          CollectiblesSelected;                              // 0x02A0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MoveBetweenCollectiblesVertical(const bool bUp);
	void OnCollectibleItemSlotPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectiblesListWidget">();
	}
	static class UCollectiblesListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectiblesListWidget>();
	}
};
static_assert(alignof(UCollectiblesListWidget) == 0x000008, "Wrong alignment on UCollectiblesListWidget");
static_assert(sizeof(UCollectiblesListWidget) == 0x0002A8, "Wrong size on UCollectiblesListWidget");
static_assert(offsetof(UCollectiblesListWidget, CollectiblesSelected) == 0x0002A0, "Member 'UCollectiblesListWidget::CollectiblesSelected' has a wrong offset!");

// Class ObsidianFox.CollectiblesSlotButtonWidget
// 0x0010 (0x0270 - 0x0260)
class UCollectiblesSlotButtonWidget : public UUserWidget
{
public:
	class UImage*                                 ItemImage;                                         // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ItemName;                                          // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetImageAndItemName(TSoftObjectPtr<class UItemData> ItemData);
	void UpdateCollectibleItemImageMaterial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectiblesSlotButtonWidget">();
	}
	static class UCollectiblesSlotButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectiblesSlotButtonWidget>();
	}
};
static_assert(alignof(UCollectiblesSlotButtonWidget) == 0x000008, "Wrong alignment on UCollectiblesSlotButtonWidget");
static_assert(sizeof(UCollectiblesSlotButtonWidget) == 0x000270, "Wrong size on UCollectiblesSlotButtonWidget");
static_assert(offsetof(UCollectiblesSlotButtonWidget, ItemImage) == 0x000260, "Member 'UCollectiblesSlotButtonWidget::ItemImage' has a wrong offset!");
static_assert(offsetof(UCollectiblesSlotButtonWidget, ItemName) == 0x000268, "Member 'UCollectiblesSlotButtonWidget::ItemName' has a wrong offset!");

// Class ObsidianFox.CollectiblesWidget
// 0x0030 (0x0290 - 0x0260)
class UCollectiblesWidget final : public UUserWidget
{
public:
	class UUniformGridPanel*                      SlotPanel;                                         // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelSlot*                             ActiveSlot;                                        // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNumberOddColumn;                                // 0x0270(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNumberEvenColumn;                               // 0x0274(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SlotsPerRow;                                       // 0x0278(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLastColumnBigRow;                                 // 0x027C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27D[0x3];                                      // 0x027D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UScrollBox*                             ScrollBoxCollectibles;                             // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           MoveInputAction;                                   // 0x0288(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CancelPressedHandler();
	void MoveWidgetInputActionTriggeredHandler(const struct FInputActionValue& InputActionValue);
	void OnInteractPressedHandler();
	void OpenMenuPressedHandlerHandler();
	void OpenPauseMenuPressedHandler();
	void SetupInput();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollectiblesWidget">();
	}
	static class UCollectiblesWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCollectiblesWidget>();
	}
};
static_assert(alignof(UCollectiblesWidget) == 0x000008, "Wrong alignment on UCollectiblesWidget");
static_assert(sizeof(UCollectiblesWidget) == 0x000290, "Wrong size on UCollectiblesWidget");
static_assert(offsetof(UCollectiblesWidget, SlotPanel) == 0x000260, "Member 'UCollectiblesWidget::SlotPanel' has a wrong offset!");
static_assert(offsetof(UCollectiblesWidget, ActiveSlot) == 0x000268, "Member 'UCollectiblesWidget::ActiveSlot' has a wrong offset!");
static_assert(offsetof(UCollectiblesWidget, MaxNumberOddColumn) == 0x000270, "Member 'UCollectiblesWidget::MaxNumberOddColumn' has a wrong offset!");
static_assert(offsetof(UCollectiblesWidget, MaxNumberEvenColumn) == 0x000274, "Member 'UCollectiblesWidget::MaxNumberEvenColumn' has a wrong offset!");
static_assert(offsetof(UCollectiblesWidget, SlotsPerRow) == 0x000278, "Member 'UCollectiblesWidget::SlotsPerRow' has a wrong offset!");
static_assert(offsetof(UCollectiblesWidget, bLastColumnBigRow) == 0x00027C, "Member 'UCollectiblesWidget::bLastColumnBigRow' has a wrong offset!");
static_assert(offsetof(UCollectiblesWidget, ScrollBoxCollectibles) == 0x000280, "Member 'UCollectiblesWidget::ScrollBoxCollectibles' has a wrong offset!");
static_assert(offsetof(UCollectiblesWidget, MoveInputAction) == 0x000288, "Member 'UCollectiblesWidget::MoveInputAction' has a wrong offset!");

// Class ObsidianFox.PlayerSubGraphAnimInstance
// 0x07A0 (0x0BD0 - 0x0430)
class UPlayerSubGraphAnimInstance : public UPiecesAnimInstance
{
public:
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         Initialized : 1;                                   // 0x0438(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_439[0x7];                                      // 0x0439(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerAnimInstance*                    Owner;                                             // 0x0440(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AObsidianFoxCharacter*                  OwnerChar;                                         // 0x0448(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPlayerSubGraphAnimInstanceProxy       SubGraphProxy;                                     // 0x0450(0x0780)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPrivate)

public:
	class UPlayerAnimInstance* GetLinkedOwner() const;
	bool HasAnyGameplayTags(const struct FGameplayTagContainer& Container) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerSubGraphAnimInstance">();
	}
	static class UPlayerSubGraphAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerSubGraphAnimInstance>();
	}
};
static_assert(alignof(UPlayerSubGraphAnimInstance) == 0x000010, "Wrong alignment on UPlayerSubGraphAnimInstance");
static_assert(sizeof(UPlayerSubGraphAnimInstance) == 0x000BD0, "Wrong size on UPlayerSubGraphAnimInstance");
static_assert(offsetof(UPlayerSubGraphAnimInstance, Owner) == 0x000440, "Member 'UPlayerSubGraphAnimInstance::Owner' has a wrong offset!");
static_assert(offsetof(UPlayerSubGraphAnimInstance, OwnerChar) == 0x000448, "Member 'UPlayerSubGraphAnimInstance::OwnerChar' has a wrong offset!");
static_assert(offsetof(UPlayerSubGraphAnimInstance, SubGraphProxy) == 0x000450, "Member 'UPlayerSubGraphAnimInstance::SubGraphProxy' has a wrong offset!");

// Class ObsidianFox.ContextualTraverseAnimInstance
// 0x07E0 (0x13B0 - 0x0BD0)
class UContextualTraverseAnimInstance : public UPlayerSubGraphAnimInstance
{
public:
	uint8                                         Pad_BD0[0x8];                                      // 0x0BD0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateData                   DefaultBlendState;                                 // 0x0BD8(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bShouldBlendOutOfEntryState : 1;                   // 0x0BF4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_BF5[0xB];                                      // 0x0BF5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FContextualTraverseAnimInstanceProxy   Proxy;                                             // 0x0C00(0x07B0)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPrivate)

public:
	bool GetInputTriggeredEarlyBlendOut(int32 MachineIndex, int32 TransitionIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualTraverseAnimInstance">();
	}
	static class UContextualTraverseAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualTraverseAnimInstance>();
	}
};
static_assert(alignof(UContextualTraverseAnimInstance) == 0x000010, "Wrong alignment on UContextualTraverseAnimInstance");
static_assert(sizeof(UContextualTraverseAnimInstance) == 0x0013B0, "Wrong size on UContextualTraverseAnimInstance");
static_assert(offsetof(UContextualTraverseAnimInstance, DefaultBlendState) == 0x000BD8, "Member 'UContextualTraverseAnimInstance::DefaultBlendState' has a wrong offset!");
static_assert(offsetof(UContextualTraverseAnimInstance, Proxy) == 0x000C00, "Member 'UContextualTraverseAnimInstance::Proxy' has a wrong offset!");

// Class ObsidianFox.HumanoidAnimInterface
// 0x0000 (0x0028 - 0x0028)
class IHumanoidAnimInterface final : public IInterface
{
public:
	class FName GetHandBoneName(bool bIsRightHand);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanoidAnimInterface">();
	}
	static class IHumanoidAnimInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHumanoidAnimInterface>();
	}
};
static_assert(alignof(IHumanoidAnimInterface) == 0x000008, "Wrong alignment on IHumanoidAnimInterface");
static_assert(sizeof(IHumanoidAnimInterface) == 0x000028, "Wrong size on IHumanoidAnimInterface");

// Class ObsidianFox.ContextualTraverseAnimInterface
// 0x0000 (0x0028 - 0x0028)
class IContextualTraverseAnimInterface final : public IInterface
{
public:
	void OnRestart();
	void ResetShouldBlendOutOfEntryState();
	void SetShouldBlendOutOfEntryState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualTraverseAnimInterface">();
	}
	static class IContextualTraverseAnimInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IContextualTraverseAnimInterface>();
	}
};
static_assert(alignof(IContextualTraverseAnimInterface) == 0x000008, "Wrong alignment on IContextualTraverseAnimInterface");
static_assert(sizeof(IContextualTraverseAnimInterface) == 0x000028, "Wrong size on IContextualTraverseAnimInterface");

// Class ObsidianFox.ContextualTraverseData
// 0x0050 (0x0080 - 0x0030)
class UContextualTraverseData final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, TSubclassOf<class UContextualTraverseAnimInstance>> AnimBlueprintTagMapping;                           // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualTraverseData">();
	}
	static class UContextualTraverseData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualTraverseData>();
	}
};
static_assert(alignof(UContextualTraverseData) == 0x000008, "Wrong alignment on UContextualTraverseData");
static_assert(sizeof(UContextualTraverseData) == 0x000080, "Wrong size on UContextualTraverseData");
static_assert(offsetof(UContextualTraverseData, AnimBlueprintTagMapping) == 0x000030, "Member 'UContextualTraverseData::AnimBlueprintTagMapping' has a wrong offset!");

// Class ObsidianFox.FocusPointComponent
// 0x0020 (0x04B0 - 0x0490)
class UFocusPointComponent : public UBoxComponent
{
public:
	int32                                         Priority;                                          // 0x0488(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinGlancePriority;                                 // 0x048C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsStartle : 1;                                    // 0x0490(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_491[0x3];                                      // 0x0491(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartleRadius;                                     // 0x0494(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsEnabled : 1;                                    // 0x0498(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPermanentFocus : 1;                               // 0x0498(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasCustomRadius : 1;                              // 0x0498(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCustomInterestTime : 1;                           // 0x0498(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_499[0x3];                                      // 0x0499(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomInterestTimeBaseValue;                       // 0x049C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CustomInterestTimeDeviation;                       // 0x04A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CustomRadius;                                      // 0x04A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFocusPointType                               FocusPointType;                                    // 0x04A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFocusPointCategory                           FocusPointCategory;                                // 0x04A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AA[0x6];                                      // 0x04AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateStartle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FocusPointComponent">();
	}
	static class UFocusPointComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFocusPointComponent>();
	}
};
static_assert(alignof(UFocusPointComponent) == 0x000010, "Wrong alignment on UFocusPointComponent");
static_assert(sizeof(UFocusPointComponent) == 0x0004B0, "Wrong size on UFocusPointComponent");
static_assert(offsetof(UFocusPointComponent, Priority) == 0x000488, "Member 'UFocusPointComponent::Priority' has a wrong offset!");
static_assert(offsetof(UFocusPointComponent, MinGlancePriority) == 0x00048C, "Member 'UFocusPointComponent::MinGlancePriority' has a wrong offset!");
static_assert(offsetof(UFocusPointComponent, StartleRadius) == 0x000494, "Member 'UFocusPointComponent::StartleRadius' has a wrong offset!");
static_assert(offsetof(UFocusPointComponent, CustomInterestTimeBaseValue) == 0x00049C, "Member 'UFocusPointComponent::CustomInterestTimeBaseValue' has a wrong offset!");
static_assert(offsetof(UFocusPointComponent, CustomInterestTimeDeviation) == 0x0004A0, "Member 'UFocusPointComponent::CustomInterestTimeDeviation' has a wrong offset!");
static_assert(offsetof(UFocusPointComponent, CustomRadius) == 0x0004A4, "Member 'UFocusPointComponent::CustomRadius' has a wrong offset!");
static_assert(offsetof(UFocusPointComponent, FocusPointType) == 0x0004A8, "Member 'UFocusPointComponent::FocusPointType' has a wrong offset!");
static_assert(offsetof(UFocusPointComponent, FocusPointCategory) == 0x0004A9, "Member 'UFocusPointComponent::FocusPointCategory' has a wrong offset!");

// Class ObsidianFox.InteractionComponentBase
// 0x0080 (0x0530 - 0x04B0)
class UInteractionComponentBase : public UFocusPointComponent
{
public:
	EInteractionSelectionShape                    DiscoveryShape;                                    // 0x04B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B1[0x3];                                      // 0x04B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DiscoveryRange;                                    // 0x04B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiscoveryAngle;                                    // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiscoveryNearPlane;                                // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InteractionSelectionRange;                         // 0x04C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bExclusiveForParent : 1;                           // 0x04C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bHolsterWeapon : 1;                                // 0x04C4(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EInteractionType                              InteractionType;                                   // 0x04C5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C6[0x2];                                      // 0x04C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              SelectionIcon;                                     // 0x04C8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              SelectionExtraIcon;                                // 0x04F0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShowSelectionExtraIconStatusChangedDone;         // 0x0518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         bShowSelectionExtraIcon : 1;                       // 0x0528(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_529[0x7];                                      // 0x0529(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitiateInteraction(class ACharacter* InteractingCharacter);
	void OnShowSelectionExtraIconStatusChangedDone__DelegateSignature(bool bShowSelectionExtraIcon_0);
	void SetBeginActivated(bool Val);
	void SetShowSelectionExtraIcon(const bool bInShowSelectionExtraIcon);

	bool CurrentlyInteracting() const;
	class ACharacter* GetInteractingChar() const;
	const struct FVector GetInteractionIconWorldLocation() const;
	bool GetShowSelectionExtraIcon() const;
	const struct FGameplayTagContainer GetTagsUserShouldHave() const;
	const struct FGameplayTagContainer GetTagsUserShouldNotHave() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionComponentBase">();
	}
	static class UInteractionComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionComponentBase>();
	}
};
static_assert(alignof(UInteractionComponentBase) == 0x000010, "Wrong alignment on UInteractionComponentBase");
static_assert(sizeof(UInteractionComponentBase) == 0x000530, "Wrong size on UInteractionComponentBase");
static_assert(offsetof(UInteractionComponentBase, DiscoveryShape) == 0x0004B0, "Member 'UInteractionComponentBase::DiscoveryShape' has a wrong offset!");
static_assert(offsetof(UInteractionComponentBase, DiscoveryRange) == 0x0004B4, "Member 'UInteractionComponentBase::DiscoveryRange' has a wrong offset!");
static_assert(offsetof(UInteractionComponentBase, DiscoveryAngle) == 0x0004B8, "Member 'UInteractionComponentBase::DiscoveryAngle' has a wrong offset!");
static_assert(offsetof(UInteractionComponentBase, DiscoveryNearPlane) == 0x0004BC, "Member 'UInteractionComponentBase::DiscoveryNearPlane' has a wrong offset!");
static_assert(offsetof(UInteractionComponentBase, InteractionSelectionRange) == 0x0004C0, "Member 'UInteractionComponentBase::InteractionSelectionRange' has a wrong offset!");
static_assert(offsetof(UInteractionComponentBase, InteractionType) == 0x0004C5, "Member 'UInteractionComponentBase::InteractionType' has a wrong offset!");
static_assert(offsetof(UInteractionComponentBase, SelectionIcon) == 0x0004C8, "Member 'UInteractionComponentBase::SelectionIcon' has a wrong offset!");
static_assert(offsetof(UInteractionComponentBase, SelectionExtraIcon) == 0x0004F0, "Member 'UInteractionComponentBase::SelectionExtraIcon' has a wrong offset!");
static_assert(offsetof(UInteractionComponentBase, OnShowSelectionExtraIconStatusChangedDone) == 0x000518, "Member 'UInteractionComponentBase::OnShowSelectionExtraIconStatusChangedDone' has a wrong offset!");

// Class ObsidianFox.CtrlButtonWidget
// 0x0120 (0x0380 - 0x0260)
class UCtrlButtonWidget : public UUserWidget
{
public:
	TWeakObjectPtr<class AActor>                  OwningActor;                                       // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         HorizontalBoxCtrlButton;                           // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UPiecesInputMappingContext> PiecesInputMapping;                                // 0x0270(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UKeyBindingTextureDataAsset> CtrlButtonDataAsset;                               // 0x0298(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                TextPadding;                                       // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         FontInfo;                                          // 0x02D0(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          TextHorizontalAlignment;                           // 0x0328(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            TextVerticalAlignment;                             // 0x0329(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32A[0x6];                                      // 0x032A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            TextColorAndOpacity;                               // 0x0330(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x10];                                     // 0x0358(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCtrlButtonInfo>                CtrlButtonInfos;                                   // 0x0368(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCtrlButton(const class UInputAction* InputAction, const class FText& Description, const bool Enabled, const bool Shown);
	void ChangeTextOnCtrlButton(const class UInputAction* InputAction, const class FText& Description);
	void ClearCtrlButtons();
	void EnableAction(const class UInputAction* InputAction, bool bEnabled);
	void HideInputAction(const class UInputAction* InputAction);
	void InputTypeChangedHandler(bool IsGamepad);
	void ShowInputAction(const class UInputAction* InputAction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CtrlButtonWidget">();
	}
	static class UCtrlButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrlButtonWidget>();
	}
};
static_assert(alignof(UCtrlButtonWidget) == 0x000008, "Wrong alignment on UCtrlButtonWidget");
static_assert(sizeof(UCtrlButtonWidget) == 0x000380, "Wrong size on UCtrlButtonWidget");
static_assert(offsetof(UCtrlButtonWidget, OwningActor) == 0x000260, "Member 'UCtrlButtonWidget::OwningActor' has a wrong offset!");
static_assert(offsetof(UCtrlButtonWidget, HorizontalBoxCtrlButton) == 0x000268, "Member 'UCtrlButtonWidget::HorizontalBoxCtrlButton' has a wrong offset!");
static_assert(offsetof(UCtrlButtonWidget, PiecesInputMapping) == 0x000270, "Member 'UCtrlButtonWidget::PiecesInputMapping' has a wrong offset!");
static_assert(offsetof(UCtrlButtonWidget, CtrlButtonDataAsset) == 0x000298, "Member 'UCtrlButtonWidget::CtrlButtonDataAsset' has a wrong offset!");
static_assert(offsetof(UCtrlButtonWidget, TextPadding) == 0x0002C0, "Member 'UCtrlButtonWidget::TextPadding' has a wrong offset!");
static_assert(offsetof(UCtrlButtonWidget, FontInfo) == 0x0002D0, "Member 'UCtrlButtonWidget::FontInfo' has a wrong offset!");
static_assert(offsetof(UCtrlButtonWidget, TextHorizontalAlignment) == 0x000328, "Member 'UCtrlButtonWidget::TextHorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UCtrlButtonWidget, TextVerticalAlignment) == 0x000329, "Member 'UCtrlButtonWidget::TextVerticalAlignment' has a wrong offset!");
static_assert(offsetof(UCtrlButtonWidget, TextColorAndOpacity) == 0x000330, "Member 'UCtrlButtonWidget::TextColorAndOpacity' has a wrong offset!");
static_assert(offsetof(UCtrlButtonWidget, CtrlButtonInfos) == 0x000368, "Member 'UCtrlButtonWidget::CtrlButtonInfos' has a wrong offset!");

// Class ObsidianFox.IncreaseDecreaseOption
// 0x0028 (0x03F0 - 0x03C8)
class UIncreaseDecreaseOption : public UOFButtonUserWidget
{
public:
	class UButton*                                IncreaseButton;                                    // 0x03C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                DecreaseButton;                                    // 0x03D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             OptionText;                                        // 0x03D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueToIncrese;                                    // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwapInputToRightLeft;                             // 0x03EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3ED[0x3];                                      // 0x03ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float CalculateNewValue(const float CurrentValue, const bool bAdding);
	void SetButtonText(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncreaseDecreaseOption">();
	}
	static class UIncreaseDecreaseOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIncreaseDecreaseOption>();
	}
};
static_assert(alignof(UIncreaseDecreaseOption) == 0x000008, "Wrong alignment on UIncreaseDecreaseOption");
static_assert(sizeof(UIncreaseDecreaseOption) == 0x0003F0, "Wrong size on UIncreaseDecreaseOption");
static_assert(offsetof(UIncreaseDecreaseOption, IncreaseButton) == 0x0003C8, "Member 'UIncreaseDecreaseOption::IncreaseButton' has a wrong offset!");
static_assert(offsetof(UIncreaseDecreaseOption, DecreaseButton) == 0x0003D0, "Member 'UIncreaseDecreaseOption::DecreaseButton' has a wrong offset!");
static_assert(offsetof(UIncreaseDecreaseOption, OptionText) == 0x0003D8, "Member 'UIncreaseDecreaseOption::OptionText' has a wrong offset!");
static_assert(offsetof(UIncreaseDecreaseOption, MaxValue) == 0x0003E0, "Member 'UIncreaseDecreaseOption::MaxValue' has a wrong offset!");
static_assert(offsetof(UIncreaseDecreaseOption, MinValue) == 0x0003E4, "Member 'UIncreaseDecreaseOption::MinValue' has a wrong offset!");
static_assert(offsetof(UIncreaseDecreaseOption, ValueToIncrese) == 0x0003E8, "Member 'UIncreaseDecreaseOption::ValueToIncrese' has a wrong offset!");
static_assert(offsetof(UIncreaseDecreaseOption, bSwapInputToRightLeft) == 0x0003EC, "Member 'UIncreaseDecreaseOption::bSwapInputToRightLeft' has a wrong offset!");

// Class ObsidianFox.IncreaseDecreaseCustomTextOption
// 0x0058 (0x0448 - 0x03F0)
class UIncreaseDecreaseCustomTextOption : public UIncreaseDecreaseOption
{
public:
	TMap<int32, class FText>                      TextSettings;                                      // 0x03F0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         Value;                                             // 0x0440(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FText GetTextfromValue(const float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncreaseDecreaseCustomTextOption">();
	}
	static class UIncreaseDecreaseCustomTextOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIncreaseDecreaseCustomTextOption>();
	}
};
static_assert(alignof(UIncreaseDecreaseCustomTextOption) == 0x000008, "Wrong alignment on UIncreaseDecreaseCustomTextOption");
static_assert(sizeof(UIncreaseDecreaseCustomTextOption) == 0x000448, "Wrong size on UIncreaseDecreaseCustomTextOption");
static_assert(offsetof(UIncreaseDecreaseCustomTextOption, TextSettings) == 0x0003F0, "Member 'UIncreaseDecreaseCustomTextOption::TextSettings' has a wrong offset!");
static_assert(offsetof(UIncreaseDecreaseCustomTextOption, Value) == 0x000440, "Member 'UIncreaseDecreaseCustomTextOption::Value' has a wrong offset!");

// Class ObsidianFox.DamagePoint
// 0x0080 (0x0500 - 0x0480)
class UDamagePoint final : public USphereComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDamagePointDestroyed;                            // 0x0480(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDamagePointTakeDamage;                           // 0x0490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   DamagePointName;                                   // 0x04A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDebugDraw : 1;                                    // 0x04A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCanBeHit : 1;                                     // 0x04A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseDamagePointSequence : 1;                       // 0x04A8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bReviveAfterDestroy : 1;                           // 0x04A8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_4A9[0x3];                                      // 0x04A9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NumberOfMeleeHitsUntilDestruction;                 // 0x04AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NumberOfRangedHitsUntilDestruction;                // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         OrderSequenceNumber;                               // 0x04B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x04B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UGameplayEffect>>    GameplayEffectToBeAppliedWhenDestroyed;            // 0x04D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         ReviveWaitTimerDuration;                           // 0x04E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4EC[0x14];                                     // 0x04EC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckIfHit(const struct FVector& LineOrigin, const struct FVector& LineDirection);
	bool OnHit(const struct FGameplayTagContainer& DamageTags, float WeakPointsDamage);
	void Reset();
	void ReviveDamagePoint();
	void SetCanBeHit(const bool InCanBeHit);

	bool CanBeHit() const;
	class FName GetDamagePointName() const;
	TArray<TSubclassOf<class UGameplayEffect>> GetGamePlayEffectsWhenDestroyed() const;
	const struct FGameplayTagContainer GetGameplayTags() const;
	int32 GetOrderSequenceNumber() const;
	bool IsDamagePointDestroyed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamagePoint">();
	}
	static class UDamagePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamagePoint>();
	}
};
static_assert(alignof(UDamagePoint) == 0x000010, "Wrong alignment on UDamagePoint");
static_assert(sizeof(UDamagePoint) == 0x000500, "Wrong size on UDamagePoint");
static_assert(offsetof(UDamagePoint, OnDamagePointDestroyed) == 0x000480, "Member 'UDamagePoint::OnDamagePointDestroyed' has a wrong offset!");
static_assert(offsetof(UDamagePoint, OnDamagePointTakeDamage) == 0x000490, "Member 'UDamagePoint::OnDamagePointTakeDamage' has a wrong offset!");
static_assert(offsetof(UDamagePoint, DamagePointName) == 0x0004A0, "Member 'UDamagePoint::DamagePointName' has a wrong offset!");
static_assert(offsetof(UDamagePoint, NumberOfMeleeHitsUntilDestruction) == 0x0004AC, "Member 'UDamagePoint::NumberOfMeleeHitsUntilDestruction' has a wrong offset!");
static_assert(offsetof(UDamagePoint, NumberOfRangedHitsUntilDestruction) == 0x0004B0, "Member 'UDamagePoint::NumberOfRangedHitsUntilDestruction' has a wrong offset!");
static_assert(offsetof(UDamagePoint, OrderSequenceNumber) == 0x0004B4, "Member 'UDamagePoint::OrderSequenceNumber' has a wrong offset!");
static_assert(offsetof(UDamagePoint, GameplayTags) == 0x0004B8, "Member 'UDamagePoint::GameplayTags' has a wrong offset!");
static_assert(offsetof(UDamagePoint, GameplayEffectToBeAppliedWhenDestroyed) == 0x0004D8, "Member 'UDamagePoint::GameplayEffectToBeAppliedWhenDestroyed' has a wrong offset!");
static_assert(offsetof(UDamagePoint, ReviveWaitTimerDuration) == 0x0004E8, "Member 'UDamagePoint::ReviveWaitTimerDuration' has a wrong offset!");

// Class ObsidianFox.HomeRangeActor
// 0x0010 (0x0248 - 0x0238)
class AHomeRangeActor final : public AActor
{
public:
	class USphereComponent*                       HomeRangeSphere;                                   // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        HomeRangePosition;                                 // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HomeRangeActor">();
	}
	static class AHomeRangeActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHomeRangeActor>();
	}
};
static_assert(alignof(AHomeRangeActor) == 0x000008, "Wrong alignment on AHomeRangeActor");
static_assert(sizeof(AHomeRangeActor) == 0x000248, "Wrong size on AHomeRangeActor");
static_assert(offsetof(AHomeRangeActor, HomeRangeSphere) == 0x000238, "Member 'AHomeRangeActor::HomeRangeSphere' has a wrong offset!");
static_assert(offsetof(AHomeRangeActor, HomeRangePosition) == 0x000240, "Member 'AHomeRangeActor::HomeRangePosition' has a wrong offset!");

// Class ObsidianFox.DamagePointHighlight
// 0x0000 (0x04F0 - 0x04F0)
class UDamagePointHighlight final : public UStaticMeshComponent
{
public:
	void OnParentActivation(class UActorComponent* Component, bool bReset);
	void OnParentDeactivation(class UActorComponent* Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamagePointHighlight">();
	}
	static class UDamagePointHighlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamagePointHighlight>();
	}
};
static_assert(alignof(UDamagePointHighlight) == 0x000010, "Wrong alignment on UDamagePointHighlight");
static_assert(sizeof(UDamagePointHighlight) == 0x0004F0, "Wrong size on UDamagePointHighlight");

// Class ObsidianFox.DamagePointSequence
// 0x0050 (0x0108 - 0x00B8)
class UDamagePointSequence final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnDamagePointSequenceIsDone;                       // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDamagePointInSequenceTakeDamage;                 // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnDamagePointInSequenceDestroyed;                  // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DamagePointTag;                                    // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x4];                                      // 0x0100(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VisableDistance;                                   // 0x0104(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DamagePointInSequenceDestroyed__DelegateSignature(class FName Name_0, bool bSequenceComplete);
	void DamagePointSequenceIsDone__DelegateSignature();
	class UDamagePoint* GetActiveDamagePointLine(const struct FVector& Start, const struct FVector& End);
	void OnDamagePointDestroyed();
	void OnDamagePointTakeDamage(class FName Name_0, float AmountOfDamage, bool bGotDestroyed, const struct FGameplayTagContainer& DamageTags);
	void ResetSequence();

	class UDamagePoint* GetActiveDamagePoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DamagePointSequence">();
	}
	static class UDamagePointSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamagePointSequence>();
	}
};
static_assert(alignof(UDamagePointSequence) == 0x000008, "Wrong alignment on UDamagePointSequence");
static_assert(sizeof(UDamagePointSequence) == 0x000108, "Wrong size on UDamagePointSequence");
static_assert(offsetof(UDamagePointSequence, OnDamagePointSequenceIsDone) == 0x0000B8, "Member 'UDamagePointSequence::OnDamagePointSequenceIsDone' has a wrong offset!");
static_assert(offsetof(UDamagePointSequence, OnDamagePointInSequenceTakeDamage) == 0x0000C8, "Member 'UDamagePointSequence::OnDamagePointInSequenceTakeDamage' has a wrong offset!");
static_assert(offsetof(UDamagePointSequence, OnDamagePointInSequenceDestroyed) == 0x0000D8, "Member 'UDamagePointSequence::OnDamagePointInSequenceDestroyed' has a wrong offset!");
static_assert(offsetof(UDamagePointSequence, DamagePointTag) == 0x0000F8, "Member 'UDamagePointSequence::DamagePointTag' has a wrong offset!");
static_assert(offsetof(UDamagePointSequence, VisableDistance) == 0x000104, "Member 'UDamagePointSequence::VisableDistance' has a wrong offset!");

// Class ObsidianFox.InGameUIWidget_QuickSlotWidget
// 0x0288 (0x0500 - 0x0278)
class UInGameUIWidget_QuickSlotWidget : public UInGameUIWidget
{
public:
	class UEquipmentManager*                      EquipmentManager;                                  // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInventory*                             Inventory;                                         // 0x0280(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOFPlayerController*                    PlayerController;                                  // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOFPlayerCharacter*                     PlayerCharacter;                                   // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpacityOn_NoAmmo;                                  // 0x0298(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpacityOn_HaveAmmo;                                // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WhiskeyCount;                                      // 0x02A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AmmoCount_Pistol;                                  // 0x02A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AmmoCount_Shotgun;                                 // 0x02A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AmmoCount_TommyGun;                                // 0x02AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AmmoCount_FlareGun;                                // 0x02B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemData*                              ItemData_Whiskey;                                  // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemData*                              ItemData_Revolver;                                 // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemData*                              ItemData_Remington;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemData*                              ItemData_Shotgun;                                  // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemData*                              ItemData_TommyGun;                                 // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemData*                              ItemData_FlareGun;                                 // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           ItemWhiskeyPanelWidget;                            // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           ItemShotgunPanelWidget;                            // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           ItemPistolPanelWidget;                             // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           ItemTommyGunPanelWidget;                           // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           ItemFlaregunPanelWidget;                           // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemPistolActiveWidget;                            // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemShotgunActiveWidget;                           // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemTommyGunActiveWidget;                          // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PistolIcon;                                        // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 WhiskeyIcon;                                       // 0x0330(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             PistolIcon_Edward;                                 // 0x0338(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             WhiskeyIcon_Edward;                                // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             PistolIcon_Emily;                                  // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             WhiskeyIcon_Emily;                                 // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_WhiskeyCount;                                 // 0x0358(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_PistolAmmoCount;                              // 0x0360(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_ShotgunAmmoCount;                             // 0x0368(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_TommyGunAmmoCount;                            // 0x0370(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_FlareGunAmmoCount;                            // 0x0378(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            AmmoColor_NoAmmo;                                  // 0x0380(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            AmmoColor_Default;                                 // 0x03A8(0x0028)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CanvasPickupIncrementInfo;                         // 0x03D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UOFPickupIncrementWidget>   PickupIncrementWidgetClass;                        // 0x03D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PickupIncrementWidgetLifeTime;                     // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PickupIncrementWidgetFadingTime;                   // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ItemPickupsAnchorPivot;                            // 0x03E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ItemPickupsAnchorOffset;                           // 0x03F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ItemPickupsAnchorFadingTarget;                     // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Button;                                            // 0x0400(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     ButtonIdle;                                        // 0x0408(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     ButtonUp;                                          // 0x0418(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     ButtonDown;                                        // 0x0428(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     ButtonRight;                                       // 0x0438(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UTexture2D*>                     ButtonLeft;                                        // 0x0448(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UInputAction*                           HealthInputAction;                                 // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           PistolInputAction;                                 // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           ShotgunInputAction;                                // 0x0468(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           TommyGunInputAction;                               // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       RangedWeaponSwap;                                  // 0x0478(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   FullText;                                          // 0x0480(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              TryingPickUpMaxStackSound;                         // 0x0498(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsCharacterEdward;                                // 0x04C0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C1[0x7];                                      // 0x04C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWeaponInfo                            CurrentWeapon;                                     // 0x04C8(0x0010)(Transient, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FPickupIncrementInfo>           PickupIncrementWidgetCollection;                   // 0x04D8(0x0010)(ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E8[0x18];                                     // 0x04E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAmmoChanged(int32 CurrentAmmo, int32 MaxAmmo);
	void OnAmmoUpdated(class UPanelWidget* PanelWidget, class UTextBlock* AmmoText, int32 AmmoCount);
	void OnEquipmentChanged(const struct FWeaponInfo& EquippedWeapon, const struct FWeaponInfo& UnequippedWeapon);
	void OnPistolSlotChanged(class UItemData_Equippable* NewWeapon, class UItemData_Equippable* OldWeapon);
	void OnPlayerEquipmentUpdated(const struct FWeaponInfo& EquippedWeapon, const struct FWeaponInfo& UnequippedWeapon);
	void OnPlayerLootItem(const class UItemData* ItemData);
	void OnPlayerLootItemUpdated(const class UItemData* ItemData);
	void OnShowItemIncrement(const class UItemData* ItemData, const struct FItemDisplayInfo& ItemInfo, int32 Amount);
	void TryingToPickUpMaxStackItemHandler(const class UItemData* ItemData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameUIWidget_QuickSlotWidget">();
	}
	static class UInGameUIWidget_QuickSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameUIWidget_QuickSlotWidget>();
	}
};
static_assert(alignof(UInGameUIWidget_QuickSlotWidget) == 0x000008, "Wrong alignment on UInGameUIWidget_QuickSlotWidget");
static_assert(sizeof(UInGameUIWidget_QuickSlotWidget) == 0x000500, "Wrong size on UInGameUIWidget_QuickSlotWidget");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, EquipmentManager) == 0x000278, "Member 'UInGameUIWidget_QuickSlotWidget::EquipmentManager' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, Inventory) == 0x000280, "Member 'UInGameUIWidget_QuickSlotWidget::Inventory' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, PlayerController) == 0x000288, "Member 'UInGameUIWidget_QuickSlotWidget::PlayerController' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, PlayerCharacter) == 0x000290, "Member 'UInGameUIWidget_QuickSlotWidget::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, OpacityOn_NoAmmo) == 0x000298, "Member 'UInGameUIWidget_QuickSlotWidget::OpacityOn_NoAmmo' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, OpacityOn_HaveAmmo) == 0x00029C, "Member 'UInGameUIWidget_QuickSlotWidget::OpacityOn_HaveAmmo' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, WhiskeyCount) == 0x0002A0, "Member 'UInGameUIWidget_QuickSlotWidget::WhiskeyCount' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, AmmoCount_Pistol) == 0x0002A4, "Member 'UInGameUIWidget_QuickSlotWidget::AmmoCount_Pistol' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, AmmoCount_Shotgun) == 0x0002A8, "Member 'UInGameUIWidget_QuickSlotWidget::AmmoCount_Shotgun' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, AmmoCount_TommyGun) == 0x0002AC, "Member 'UInGameUIWidget_QuickSlotWidget::AmmoCount_TommyGun' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, AmmoCount_FlareGun) == 0x0002B0, "Member 'UInGameUIWidget_QuickSlotWidget::AmmoCount_FlareGun' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemData_Whiskey) == 0x0002B8, "Member 'UInGameUIWidget_QuickSlotWidget::ItemData_Whiskey' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemData_Revolver) == 0x0002C0, "Member 'UInGameUIWidget_QuickSlotWidget::ItemData_Revolver' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemData_Remington) == 0x0002C8, "Member 'UInGameUIWidget_QuickSlotWidget::ItemData_Remington' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemData_Shotgun) == 0x0002D0, "Member 'UInGameUIWidget_QuickSlotWidget::ItemData_Shotgun' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemData_TommyGun) == 0x0002D8, "Member 'UInGameUIWidget_QuickSlotWidget::ItemData_TommyGun' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemData_FlareGun) == 0x0002E0, "Member 'UInGameUIWidget_QuickSlotWidget::ItemData_FlareGun' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemWhiskeyPanelWidget) == 0x0002E8, "Member 'UInGameUIWidget_QuickSlotWidget::ItemWhiskeyPanelWidget' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemShotgunPanelWidget) == 0x0002F0, "Member 'UInGameUIWidget_QuickSlotWidget::ItemShotgunPanelWidget' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemPistolPanelWidget) == 0x0002F8, "Member 'UInGameUIWidget_QuickSlotWidget::ItemPistolPanelWidget' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemTommyGunPanelWidget) == 0x000300, "Member 'UInGameUIWidget_QuickSlotWidget::ItemTommyGunPanelWidget' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemFlaregunPanelWidget) == 0x000308, "Member 'UInGameUIWidget_QuickSlotWidget::ItemFlaregunPanelWidget' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemPistolActiveWidget) == 0x000310, "Member 'UInGameUIWidget_QuickSlotWidget::ItemPistolActiveWidget' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemShotgunActiveWidget) == 0x000318, "Member 'UInGameUIWidget_QuickSlotWidget::ItemShotgunActiveWidget' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemTommyGunActiveWidget) == 0x000320, "Member 'UInGameUIWidget_QuickSlotWidget::ItemTommyGunActiveWidget' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, PistolIcon) == 0x000328, "Member 'UInGameUIWidget_QuickSlotWidget::PistolIcon' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, WhiskeyIcon) == 0x000330, "Member 'UInGameUIWidget_QuickSlotWidget::WhiskeyIcon' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, PistolIcon_Edward) == 0x000338, "Member 'UInGameUIWidget_QuickSlotWidget::PistolIcon_Edward' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, WhiskeyIcon_Edward) == 0x000340, "Member 'UInGameUIWidget_QuickSlotWidget::WhiskeyIcon_Edward' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, PistolIcon_Emily) == 0x000348, "Member 'UInGameUIWidget_QuickSlotWidget::PistolIcon_Emily' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, WhiskeyIcon_Emily) == 0x000350, "Member 'UInGameUIWidget_QuickSlotWidget::WhiskeyIcon_Emily' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, Text_WhiskeyCount) == 0x000358, "Member 'UInGameUIWidget_QuickSlotWidget::Text_WhiskeyCount' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, Text_PistolAmmoCount) == 0x000360, "Member 'UInGameUIWidget_QuickSlotWidget::Text_PistolAmmoCount' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, Text_ShotgunAmmoCount) == 0x000368, "Member 'UInGameUIWidget_QuickSlotWidget::Text_ShotgunAmmoCount' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, Text_TommyGunAmmoCount) == 0x000370, "Member 'UInGameUIWidget_QuickSlotWidget::Text_TommyGunAmmoCount' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, Text_FlareGunAmmoCount) == 0x000378, "Member 'UInGameUIWidget_QuickSlotWidget::Text_FlareGunAmmoCount' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, AmmoColor_NoAmmo) == 0x000380, "Member 'UInGameUIWidget_QuickSlotWidget::AmmoColor_NoAmmo' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, AmmoColor_Default) == 0x0003A8, "Member 'UInGameUIWidget_QuickSlotWidget::AmmoColor_Default' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, CanvasPickupIncrementInfo) == 0x0003D0, "Member 'UInGameUIWidget_QuickSlotWidget::CanvasPickupIncrementInfo' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, PickupIncrementWidgetClass) == 0x0003D8, "Member 'UInGameUIWidget_QuickSlotWidget::PickupIncrementWidgetClass' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, PickupIncrementWidgetLifeTime) == 0x0003E0, "Member 'UInGameUIWidget_QuickSlotWidget::PickupIncrementWidgetLifeTime' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, PickupIncrementWidgetFadingTime) == 0x0003E4, "Member 'UInGameUIWidget_QuickSlotWidget::PickupIncrementWidgetFadingTime' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemPickupsAnchorPivot) == 0x0003E8, "Member 'UInGameUIWidget_QuickSlotWidget::ItemPickupsAnchorPivot' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemPickupsAnchorOffset) == 0x0003F0, "Member 'UInGameUIWidget_QuickSlotWidget::ItemPickupsAnchorOffset' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ItemPickupsAnchorFadingTarget) == 0x0003F8, "Member 'UInGameUIWidget_QuickSlotWidget::ItemPickupsAnchorFadingTarget' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, Button) == 0x000400, "Member 'UInGameUIWidget_QuickSlotWidget::Button' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ButtonIdle) == 0x000408, "Member 'UInGameUIWidget_QuickSlotWidget::ButtonIdle' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ButtonUp) == 0x000418, "Member 'UInGameUIWidget_QuickSlotWidget::ButtonUp' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ButtonDown) == 0x000428, "Member 'UInGameUIWidget_QuickSlotWidget::ButtonDown' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ButtonRight) == 0x000438, "Member 'UInGameUIWidget_QuickSlotWidget::ButtonRight' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ButtonLeft) == 0x000448, "Member 'UInGameUIWidget_QuickSlotWidget::ButtonLeft' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, HealthInputAction) == 0x000458, "Member 'UInGameUIWidget_QuickSlotWidget::HealthInputAction' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, PistolInputAction) == 0x000460, "Member 'UInGameUIWidget_QuickSlotWidget::PistolInputAction' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, ShotgunInputAction) == 0x000468, "Member 'UInGameUIWidget_QuickSlotWidget::ShotgunInputAction' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, TommyGunInputAction) == 0x000470, "Member 'UInGameUIWidget_QuickSlotWidget::TommyGunInputAction' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, RangedWeaponSwap) == 0x000478, "Member 'UInGameUIWidget_QuickSlotWidget::RangedWeaponSwap' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, FullText) == 0x000480, "Member 'UInGameUIWidget_QuickSlotWidget::FullText' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, TryingPickUpMaxStackSound) == 0x000498, "Member 'UInGameUIWidget_QuickSlotWidget::TryingPickUpMaxStackSound' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, bIsCharacterEdward) == 0x0004C0, "Member 'UInGameUIWidget_QuickSlotWidget::bIsCharacterEdward' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, CurrentWeapon) == 0x0004C8, "Member 'UInGameUIWidget_QuickSlotWidget::CurrentWeapon' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_QuickSlotWidget, PickupIncrementWidgetCollection) == 0x0004D8, "Member 'UInGameUIWidget_QuickSlotWidget::PickupIncrementWidgetCollection' has a wrong offset!");

// Class ObsidianFox.HumanoidAnimInstance
// 0x05E0 (0x17A0 - 0x11C0)
class UHumanoidAnimInstance : public UOFAnimInstance
{
public:
	uint8                                         Pad_11C0[0x10];                                    // 0x11C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnFootDown;                                        // 0x11D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         bIsChestUpward : 1;                                // 0x11E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_11E1[0x3];                                     // 0x11E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RelativeMoveYaw;                                   // 0x11E4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputModifier;                                     // 0x11E8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AccelerationDiff;                                  // 0x11EC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsRightLastFootDown;                               // 0x11F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11F1[0x7];                                     // 0x11F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      ActiveStopAnimation;                               // 0x11F8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopTime;                                          // 0x1200(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopMoveAngle;                                     // 0x1204(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsInteracting : 1;                                 // 0x1208(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1209[0x7];                                     // 0x1209(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           InteractionTimer;                                  // 0x1210(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsStartWalkRight : 1;                              // 0x1218(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1219[0x3];                                     // 0x1219(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BodyFocusPercent;                                  // 0x121C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsArmIKActive;                                     // 0x1220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1221[0x7];                                     // 0x1221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UAnimSequenceBase*, struct FArmIKData> MontageArmIKDataMap;                               // 0x1228(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FArmIKData                             RArmIKData;                                        // 0x1278(0x0084)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FArmIKData                             LArmIKData;                                        // 0x12FC(0x0084)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                RArmIKPoleTarget;                                  // 0x1380(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LArmIKPoleTarget;                                  // 0x138C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RSkinningHandBoneName;                             // 0x1398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LSkinningHandBoneName;                             // 0x13A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RIKHandBoneName;                                   // 0x13A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LIKHandBoneName;                                   // 0x13B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RArmPoleTargetBoneName;                            // 0x13B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LArmPoleTargetBoneName;                            // 0x13C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RightPalmName;                                     // 0x13C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LeftPalmName;                                      // 0x13D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmIKBaseInterpSpeed;                              // 0x13D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmIKReachRelaxAmount;                             // 0x13DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ArmReach;                                          // 0x13E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RootBoneName;                                      // 0x13E4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RSkinningFootBoneName;                             // 0x13EC(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LSkinningFootBoneName;                             // 0x13F4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LegIKFootHeight;                                   // 0x13FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1400[0x8];                                     // 0x1400(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HipsOffset;                                        // 0x1408(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_140C[0xC];                                     // 0x140C(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PositiveHipsInterpSpeed;                           // 0x1418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NegativeHipsInterpSpeed;                           // 0x141C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HipsOffsetMax;                                     // 0x1420(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1424[0x64];                                    // 0x1424(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bHipOffsetDisabled : 1;                            // 0x1488(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1489[0x3];                                     // 0x1489(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ManualHipsOffsetInterpolationSpeed;                // 0x148C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsBodyFocusActive;                                 // 0x1490(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1491[0x67];                                    // 0x1491(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FocusPoint;                                        // 0x14F8(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1504[0xC];                                     // 0x1504(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	EBodyFocusMode                                BodyFocusMode;                                     // 0x1510(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1511[0x3];                                     // 0x1511(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               FocusRotation;                                     // 0x1514(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         AimOffsetVertical;                                 // 0x1520(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1524[0xC];                                     // 0x1524(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BodyFocusInterpSpeed;                              // 0x1530(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               HeadRotation;                                      // 0x1534(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               StartleOutOfSightHeadClamp;                        // 0x1540(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               StartleOutOfSightBodyClamp;                        // 0x154C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1558[0x3C];                                    // 0x1558(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HeadRotationAlpha;                                 // 0x1594(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BodyRotationAlpha;                                 // 0x1598(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_159C[0x4];                                     // 0x159C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkTwist;                                         // 0x15A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkTwistInterpolationSpeed;                       // 0x15A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkTwistInterpolationSpeedDecreasing;             // 0x15A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15AC[0x4];                                     // 0x15AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateArray                  WalkTwistStates;                                   // 0x15B0(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         WalkTwistLimit;                                    // 0x15C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkTwistFactor;                                   // 0x15CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintTwist;                                       // 0x15D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUpperBodyTurnTwist;                               // 0x15D4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15D5[0x3];                                     // 0x15D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpperBodyTwistInterpolationSpeed;                  // 0x15D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkTwistHeadLimit;                                // 0x15DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15E0[0x4];                                     // 0x15E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartleUpperBodyMultiplier;                        // 0x15E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CharacterAimingTags;                               // 0x15E8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsAiming;                                         // 0x1608(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1609[0x3];                                     // 0x1609(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HeadBoneName;                                      // 0x160C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ChestBoneName;                                     // 0x1614(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusYawRotMax;                                    // 0x161C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusRollRotMaxDown;                               // 0x1620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusRollRotMaxUp;                                 // 0x1624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusPitchRotMax;                                  // 0x1628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusPitchDeadZone;                                // 0x162C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusHoldRotation;                                 // 0x1630(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusInterpSpeedLooking;                           // 0x1634(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusInterpSpeedAiming;                            // 0x1638(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusInterpSpeedFocusPoint;                        // 0x163C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusInterpSpeedTurning;                           // 0x1640(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bUseLocomotionFocus : 1;                           // 0x1644(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1645[0x3];                                     // 0x1645(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocusInterpSpeedWalking;                           // 0x1648(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusInterpSpeedReset;                             // 0x164C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BodyRotationTangent;                               // 0x1650(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusInterpSpeedOutOfBounds;                       // 0x1654(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusSpeedInitialChestReactionReset;               // 0x1658(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_165C[0x4];                                     // 0x165C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocusUpdateDelay;                                  // 0x1660(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusUpdateDelayCurrent;                           // 0x1664(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PassiveFocusTime;                                  // 0x1668(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PassiveFocusMinChange;                             // 0x166C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PassiveFocusTimeCurrent;                           // 0x1670(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               LastPassiveFocusRotation;                          // 0x1674(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1680[0x4];                                     // 0x1680(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFocusRotationInProgress;                          // 0x1684(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1685[0x3];                                     // 0x1685(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               StartFocusRotation;                                // 0x1688(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               TargetFocusRotation;                               // 0x1694(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_16A0[0x4];                                     // 0x16A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HeadForwardReferenceUpperBone;                     // 0x16A4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HeadForwardReferenceLowerBone;                     // 0x16AC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               HeadForwardReferenceOffset;                        // 0x16B4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         AnimationSprintSpeedTarget;                        // 0x16C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimationWalkSpeedTarget;                          // 0x16C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDebuggingArmIK;                                  // 0x16C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsDebuggingLegIK;                                  // 0x16C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16CA[0xE];                                     // 0x16CA(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HipTwistCurveName;                                 // 0x16D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HipTwistBoneName;                                  // 0x16E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HipTwistAmount;                                    // 0x16E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHipTwistEnabled;                                  // 0x16EC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16ED[0x3];                                     // 0x16ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWallTwistSettings                     WallTwistSettings;                                 // 0x16F0(0x0020)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         WallTwistAmount;                                   // 0x1710(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1714[0x4];                                     // 0x1714(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallTwistMaxValue;                                 // 0x1718(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bWallTwistIgnoreMovable : 1;                       // 0x171C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_171D[0x3];                                     // 0x171D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDuckLeanSettings                      DuckLeanSettings;                                  // 0x1720(0x0018)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         DuckLeanAmount;                                    // 0x1738(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_173C[0x4];                                     // 0x173C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimComponentRailingFinder*            RailingFinder;                                     // 0x1740(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KeepFootPlantedCurveName;                          // 0x1748(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ManualKeepFootPlanted;                             // 0x1750(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KeepFootPlanted;                                   // 0x1754(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimComponentFootIK*                   FootIK;                                            // 0x1758(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimComponentArmIK*                    ArmIK;                                             // 0x1760(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLimitLegIKReach : 1;                              // 0x1768(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bHasActiveWeapon : 1;                              // 0x1768(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1769[0x37];                                    // 0x1769(0x0037)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ArmIKEnd(bool IsRightSide);
	void ArmIKStart(bool IsRightSide, const class FName IKTargetCompensationBoneName, const class FName WeightCurveName);
	void DebugWantedLookAt(const struct FVector& Origin, const struct FVector& LookAtLocation, const struct FVector& CurrentForward, float Lifetime);
	void FootStepDelegate__DelegateSignature(bool bRunning);
	EBodyFocusMode GetBodyFocusMode();
	void OnBodyFocusMultiBoolValueChanged(bool bNewValue);
	void RailingIKBlocked(class FName IKBoneName, bool* bOutIsBlocked, bool* bOutIsInstantBlock);
	void ResetArmIKData(struct FArmIKData* ArmIKData);
	void SetManualHipOffsetInterpolationSpeed(float Value);
	void UpdateArmIK(float DeltaTimeX);
	void UpdateArmIKState(struct FArmIKData* ArmIKData);
	void UpdateHandIKRotation(float DeltaTimeX, struct FArmIKData* ArmIKData);
	void UpdateHipsIK(float DeltaTimeX);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanoidAnimInstance">();
	}
	static class UHumanoidAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHumanoidAnimInstance>();
	}
};
static_assert(alignof(UHumanoidAnimInstance) == 0x000010, "Wrong alignment on UHumanoidAnimInstance");
static_assert(sizeof(UHumanoidAnimInstance) == 0x0017A0, "Wrong size on UHumanoidAnimInstance");
static_assert(offsetof(UHumanoidAnimInstance, OnFootDown) == 0x0011D0, "Member 'UHumanoidAnimInstance::OnFootDown' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, RelativeMoveYaw) == 0x0011E4, "Member 'UHumanoidAnimInstance::RelativeMoveYaw' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, InputModifier) == 0x0011E8, "Member 'UHumanoidAnimInstance::InputModifier' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, AccelerationDiff) == 0x0011EC, "Member 'UHumanoidAnimInstance::AccelerationDiff' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, IsRightLastFootDown) == 0x0011F0, "Member 'UHumanoidAnimInstance::IsRightLastFootDown' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, ActiveStopAnimation) == 0x0011F8, "Member 'UHumanoidAnimInstance::ActiveStopAnimation' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, StopTime) == 0x001200, "Member 'UHumanoidAnimInstance::StopTime' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, StopMoveAngle) == 0x001204, "Member 'UHumanoidAnimInstance::StopMoveAngle' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, InteractionTimer) == 0x001210, "Member 'UHumanoidAnimInstance::InteractionTimer' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, BodyFocusPercent) == 0x00121C, "Member 'UHumanoidAnimInstance::BodyFocusPercent' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, IsArmIKActive) == 0x001220, "Member 'UHumanoidAnimInstance::IsArmIKActive' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, MontageArmIKDataMap) == 0x001228, "Member 'UHumanoidAnimInstance::MontageArmIKDataMap' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, RArmIKData) == 0x001278, "Member 'UHumanoidAnimInstance::RArmIKData' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, LArmIKData) == 0x0012FC, "Member 'UHumanoidAnimInstance::LArmIKData' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, RArmIKPoleTarget) == 0x001380, "Member 'UHumanoidAnimInstance::RArmIKPoleTarget' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, LArmIKPoleTarget) == 0x00138C, "Member 'UHumanoidAnimInstance::LArmIKPoleTarget' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, RSkinningHandBoneName) == 0x001398, "Member 'UHumanoidAnimInstance::RSkinningHandBoneName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, LSkinningHandBoneName) == 0x0013A0, "Member 'UHumanoidAnimInstance::LSkinningHandBoneName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, RIKHandBoneName) == 0x0013A8, "Member 'UHumanoidAnimInstance::RIKHandBoneName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, LIKHandBoneName) == 0x0013B0, "Member 'UHumanoidAnimInstance::LIKHandBoneName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, RArmPoleTargetBoneName) == 0x0013B8, "Member 'UHumanoidAnimInstance::RArmPoleTargetBoneName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, LArmPoleTargetBoneName) == 0x0013C0, "Member 'UHumanoidAnimInstance::LArmPoleTargetBoneName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, RightPalmName) == 0x0013C8, "Member 'UHumanoidAnimInstance::RightPalmName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, LeftPalmName) == 0x0013D0, "Member 'UHumanoidAnimInstance::LeftPalmName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, ArmIKBaseInterpSpeed) == 0x0013D8, "Member 'UHumanoidAnimInstance::ArmIKBaseInterpSpeed' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, ArmIKReachRelaxAmount) == 0x0013DC, "Member 'UHumanoidAnimInstance::ArmIKReachRelaxAmount' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, ArmReach) == 0x0013E0, "Member 'UHumanoidAnimInstance::ArmReach' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, RootBoneName) == 0x0013E4, "Member 'UHumanoidAnimInstance::RootBoneName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, RSkinningFootBoneName) == 0x0013EC, "Member 'UHumanoidAnimInstance::RSkinningFootBoneName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, LSkinningFootBoneName) == 0x0013F4, "Member 'UHumanoidAnimInstance::LSkinningFootBoneName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, LegIKFootHeight) == 0x0013FC, "Member 'UHumanoidAnimInstance::LegIKFootHeight' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, HipsOffset) == 0x001408, "Member 'UHumanoidAnimInstance::HipsOffset' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, PositiveHipsInterpSpeed) == 0x001418, "Member 'UHumanoidAnimInstance::PositiveHipsInterpSpeed' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, NegativeHipsInterpSpeed) == 0x00141C, "Member 'UHumanoidAnimInstance::NegativeHipsInterpSpeed' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, HipsOffsetMax) == 0x001420, "Member 'UHumanoidAnimInstance::HipsOffsetMax' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, ManualHipsOffsetInterpolationSpeed) == 0x00148C, "Member 'UHumanoidAnimInstance::ManualHipsOffsetInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, IsBodyFocusActive) == 0x001490, "Member 'UHumanoidAnimInstance::IsBodyFocusActive' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusPoint) == 0x0014F8, "Member 'UHumanoidAnimInstance::FocusPoint' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, BodyFocusMode) == 0x001510, "Member 'UHumanoidAnimInstance::BodyFocusMode' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusRotation) == 0x001514, "Member 'UHumanoidAnimInstance::FocusRotation' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, AimOffsetVertical) == 0x001520, "Member 'UHumanoidAnimInstance::AimOffsetVertical' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, BodyFocusInterpSpeed) == 0x001530, "Member 'UHumanoidAnimInstance::BodyFocusInterpSpeed' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, HeadRotation) == 0x001534, "Member 'UHumanoidAnimInstance::HeadRotation' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, StartleOutOfSightHeadClamp) == 0x001540, "Member 'UHumanoidAnimInstance::StartleOutOfSightHeadClamp' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, StartleOutOfSightBodyClamp) == 0x00154C, "Member 'UHumanoidAnimInstance::StartleOutOfSightBodyClamp' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, HeadRotationAlpha) == 0x001594, "Member 'UHumanoidAnimInstance::HeadRotationAlpha' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, BodyRotationAlpha) == 0x001598, "Member 'UHumanoidAnimInstance::BodyRotationAlpha' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, WalkTwist) == 0x0015A0, "Member 'UHumanoidAnimInstance::WalkTwist' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, WalkTwistInterpolationSpeed) == 0x0015A4, "Member 'UHumanoidAnimInstance::WalkTwistInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, WalkTwistInterpolationSpeedDecreasing) == 0x0015A8, "Member 'UHumanoidAnimInstance::WalkTwistInterpolationSpeedDecreasing' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, WalkTwistStates) == 0x0015B0, "Member 'UHumanoidAnimInstance::WalkTwistStates' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, WalkTwistLimit) == 0x0015C8, "Member 'UHumanoidAnimInstance::WalkTwistLimit' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, WalkTwistFactor) == 0x0015CC, "Member 'UHumanoidAnimInstance::WalkTwistFactor' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, SprintTwist) == 0x0015D0, "Member 'UHumanoidAnimInstance::SprintTwist' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, bUpperBodyTurnTwist) == 0x0015D4, "Member 'UHumanoidAnimInstance::bUpperBodyTurnTwist' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, UpperBodyTwistInterpolationSpeed) == 0x0015D8, "Member 'UHumanoidAnimInstance::UpperBodyTwistInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, WalkTwistHeadLimit) == 0x0015DC, "Member 'UHumanoidAnimInstance::WalkTwistHeadLimit' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, StartleUpperBodyMultiplier) == 0x0015E4, "Member 'UHumanoidAnimInstance::StartleUpperBodyMultiplier' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, CharacterAimingTags) == 0x0015E8, "Member 'UHumanoidAnimInstance::CharacterAimingTags' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, bIsAiming) == 0x001608, "Member 'UHumanoidAnimInstance::bIsAiming' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, HeadBoneName) == 0x00160C, "Member 'UHumanoidAnimInstance::HeadBoneName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, ChestBoneName) == 0x001614, "Member 'UHumanoidAnimInstance::ChestBoneName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusYawRotMax) == 0x00161C, "Member 'UHumanoidAnimInstance::FocusYawRotMax' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusRollRotMaxDown) == 0x001620, "Member 'UHumanoidAnimInstance::FocusRollRotMaxDown' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusRollRotMaxUp) == 0x001624, "Member 'UHumanoidAnimInstance::FocusRollRotMaxUp' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusPitchRotMax) == 0x001628, "Member 'UHumanoidAnimInstance::FocusPitchRotMax' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusPitchDeadZone) == 0x00162C, "Member 'UHumanoidAnimInstance::FocusPitchDeadZone' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusHoldRotation) == 0x001630, "Member 'UHumanoidAnimInstance::FocusHoldRotation' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusInterpSpeedLooking) == 0x001634, "Member 'UHumanoidAnimInstance::FocusInterpSpeedLooking' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusInterpSpeedAiming) == 0x001638, "Member 'UHumanoidAnimInstance::FocusInterpSpeedAiming' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusInterpSpeedFocusPoint) == 0x00163C, "Member 'UHumanoidAnimInstance::FocusInterpSpeedFocusPoint' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusInterpSpeedTurning) == 0x001640, "Member 'UHumanoidAnimInstance::FocusInterpSpeedTurning' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusInterpSpeedWalking) == 0x001648, "Member 'UHumanoidAnimInstance::FocusInterpSpeedWalking' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusInterpSpeedReset) == 0x00164C, "Member 'UHumanoidAnimInstance::FocusInterpSpeedReset' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, BodyRotationTangent) == 0x001650, "Member 'UHumanoidAnimInstance::BodyRotationTangent' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusInterpSpeedOutOfBounds) == 0x001654, "Member 'UHumanoidAnimInstance::FocusInterpSpeedOutOfBounds' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusSpeedInitialChestReactionReset) == 0x001658, "Member 'UHumanoidAnimInstance::FocusSpeedInitialChestReactionReset' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusUpdateDelay) == 0x001660, "Member 'UHumanoidAnimInstance::FocusUpdateDelay' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FocusUpdateDelayCurrent) == 0x001664, "Member 'UHumanoidAnimInstance::FocusUpdateDelayCurrent' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, PassiveFocusTime) == 0x001668, "Member 'UHumanoidAnimInstance::PassiveFocusTime' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, PassiveFocusMinChange) == 0x00166C, "Member 'UHumanoidAnimInstance::PassiveFocusMinChange' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, PassiveFocusTimeCurrent) == 0x001670, "Member 'UHumanoidAnimInstance::PassiveFocusTimeCurrent' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, LastPassiveFocusRotation) == 0x001674, "Member 'UHumanoidAnimInstance::LastPassiveFocusRotation' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, bFocusRotationInProgress) == 0x001684, "Member 'UHumanoidAnimInstance::bFocusRotationInProgress' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, StartFocusRotation) == 0x001688, "Member 'UHumanoidAnimInstance::StartFocusRotation' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, TargetFocusRotation) == 0x001694, "Member 'UHumanoidAnimInstance::TargetFocusRotation' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, HeadForwardReferenceUpperBone) == 0x0016A4, "Member 'UHumanoidAnimInstance::HeadForwardReferenceUpperBone' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, HeadForwardReferenceLowerBone) == 0x0016AC, "Member 'UHumanoidAnimInstance::HeadForwardReferenceLowerBone' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, HeadForwardReferenceOffset) == 0x0016B4, "Member 'UHumanoidAnimInstance::HeadForwardReferenceOffset' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, AnimationSprintSpeedTarget) == 0x0016C0, "Member 'UHumanoidAnimInstance::AnimationSprintSpeedTarget' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, AnimationWalkSpeedTarget) == 0x0016C4, "Member 'UHumanoidAnimInstance::AnimationWalkSpeedTarget' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, IsDebuggingArmIK) == 0x0016C8, "Member 'UHumanoidAnimInstance::IsDebuggingArmIK' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, IsDebuggingLegIK) == 0x0016C9, "Member 'UHumanoidAnimInstance::IsDebuggingLegIK' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, HipTwistCurveName) == 0x0016D8, "Member 'UHumanoidAnimInstance::HipTwistCurveName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, HipTwistBoneName) == 0x0016E0, "Member 'UHumanoidAnimInstance::HipTwistBoneName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, HipTwistAmount) == 0x0016E8, "Member 'UHumanoidAnimInstance::HipTwistAmount' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, bHipTwistEnabled) == 0x0016EC, "Member 'UHumanoidAnimInstance::bHipTwistEnabled' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, WallTwistSettings) == 0x0016F0, "Member 'UHumanoidAnimInstance::WallTwistSettings' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, WallTwistAmount) == 0x001710, "Member 'UHumanoidAnimInstance::WallTwistAmount' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, WallTwistMaxValue) == 0x001718, "Member 'UHumanoidAnimInstance::WallTwistMaxValue' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, DuckLeanSettings) == 0x001720, "Member 'UHumanoidAnimInstance::DuckLeanSettings' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, DuckLeanAmount) == 0x001738, "Member 'UHumanoidAnimInstance::DuckLeanAmount' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, RailingFinder) == 0x001740, "Member 'UHumanoidAnimInstance::RailingFinder' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, KeepFootPlantedCurveName) == 0x001748, "Member 'UHumanoidAnimInstance::KeepFootPlantedCurveName' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, ManualKeepFootPlanted) == 0x001750, "Member 'UHumanoidAnimInstance::ManualKeepFootPlanted' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, KeepFootPlanted) == 0x001754, "Member 'UHumanoidAnimInstance::KeepFootPlanted' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, FootIK) == 0x001758, "Member 'UHumanoidAnimInstance::FootIK' has a wrong offset!");
static_assert(offsetof(UHumanoidAnimInstance, ArmIK) == 0x001760, "Member 'UHumanoidAnimInstance::ArmIK' has a wrong offset!");

// Class ObsidianFox.EnemyHumanoidAnimInstance
// 0x0040 (0x17E0 - 0x17A0)
class UEnemyHumanoidAnimInstance : public UHumanoidAnimInstance
{
public:
	uint8                                         Pad_17A0[0x18];                                    // 0x17A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimComponentAIFocus*                  FocusComponent;                                    // 0x17B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimComponentLockedTurnInPlace*        TurnInPlace;                                       // 0x17C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimComponentThreatDetection*          ThreatDetection;                                   // 0x17C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bRandomizeIdleStartPosition : 1;                   // 0x17D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsInCombat : 1;                                   // 0x17D0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_17D1[0xF];                                     // 0x17D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyHumanoidAnimInstance">();
	}
	static class UEnemyHumanoidAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemyHumanoidAnimInstance>();
	}
};
static_assert(alignof(UEnemyHumanoidAnimInstance) == 0x000010, "Wrong alignment on UEnemyHumanoidAnimInstance");
static_assert(sizeof(UEnemyHumanoidAnimInstance) == 0x0017E0, "Wrong size on UEnemyHumanoidAnimInstance");
static_assert(offsetof(UEnemyHumanoidAnimInstance, FocusComponent) == 0x0017B8, "Member 'UEnemyHumanoidAnimInstance::FocusComponent' has a wrong offset!");
static_assert(offsetof(UEnemyHumanoidAnimInstance, TurnInPlace) == 0x0017C0, "Member 'UEnemyHumanoidAnimInstance::TurnInPlace' has a wrong offset!");
static_assert(offsetof(UEnemyHumanoidAnimInstance, ThreatDetection) == 0x0017C8, "Member 'UEnemyHumanoidAnimInstance::ThreatDetection' has a wrong offset!");

// Class ObsidianFox.Inventory
// 0x01E8 (0x02A0 - 0x00B8)
class UInventory final : public UActorComponent
{
public:
	TSoftObjectPtr<class UFMODEvent>              FallBackUseSound;                                  // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFMODEvent>              CantUseSound;                                      // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemAdded;                                       // 0x0108(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             TryingToPickUpMaxStackItem;                        // 0x0118(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x20];                                     // 0x0128(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnItemLookedAt;                                    // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemExamined;                                    // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   HighlightItemPickupHudClass;                       // 0x0178(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSoftObjectPtr<class UItemData>, struct FItemInfo> InventoryItems;                                    // 0x01A0(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	TMap<TSoftObjectPtr<class UItemData>, struct FArchivedItemInfo> ArchivedItems;                                     // 0x01F0(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	TSet<TSoftObjectPtr<class UItemData>>         ItemPickedUpHistory;                               // 0x0240(0x0050)(SaveGame, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bHaveArchiveTutorialBeenShown;                     // 0x0290(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCollectibleManager*                    CollectibleManager;                                // 0x0298(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool AddItem(const class UItemData* InItemData, int32 Amount, EFInventoryPopUp PopUp);
	const TMap<TSoftObjectPtr<class UItemData>, struct FItemInfo> GetAllItems();
	TMap<TSoftObjectPtr<class UItemData>, struct FArchivedItemInfo> GetArchivedItems();
	TSet<TSoftObjectPtr<class UItemData>> GetItemPickedUpHistory();
	bool HasItemBeenLookedAt(const TSoftObjectPtr<class UItemData> ItemData);
	void OnProgressionUpdated(const struct FGameplayTag& NewProgressionState, const struct FGameplayTag& OldProgressionState);
	void RemoveAllItems();
	bool RemoveItem(const class UItemData* ItemData, int32 Amount);
	void SetArchiveTutorialShown(bool NewValue);
	void SetItemLookedAt(const TSoftObjectPtr<class UItemData> ItemData, bool bItemLookedAt);
	bool UseItem(const class UItemData* ItemData);

	const class UCollectibleManager* GetCollectibleManager() const;
	int32 GetItemAmount(const class UItemData* ItemData) const;
	bool HasAnyItemNotBeenLookedAt(const TArray<TSoftObjectPtr<class UItemData>>& Items) const;
	bool HaveArchiveTutorialBeenShown() const;
	bool HaveItem(TSoftObjectPtr<class UItemData> ItemData) const;
	bool IsItemInPickupHistory(const TSoftObjectPtr<class UItemData>& ItemData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Inventory">();
	}
	static class UInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventory>();
	}
};
static_assert(alignof(UInventory) == 0x000008, "Wrong alignment on UInventory");
static_assert(sizeof(UInventory) == 0x0002A0, "Wrong size on UInventory");
static_assert(offsetof(UInventory, FallBackUseSound) == 0x0000B8, "Member 'UInventory::FallBackUseSound' has a wrong offset!");
static_assert(offsetof(UInventory, CantUseSound) == 0x0000E0, "Member 'UInventory::CantUseSound' has a wrong offset!");
static_assert(offsetof(UInventory, OnItemAdded) == 0x000108, "Member 'UInventory::OnItemAdded' has a wrong offset!");
static_assert(offsetof(UInventory, TryingToPickUpMaxStackItem) == 0x000118, "Member 'UInventory::TryingToPickUpMaxStackItem' has a wrong offset!");
static_assert(offsetof(UInventory, OnItemLookedAt) == 0x000148, "Member 'UInventory::OnItemLookedAt' has a wrong offset!");
static_assert(offsetof(UInventory, OnItemExamined) == 0x000158, "Member 'UInventory::OnItemExamined' has a wrong offset!");
static_assert(offsetof(UInventory, HighlightItemPickupHudClass) == 0x000178, "Member 'UInventory::HighlightItemPickupHudClass' has a wrong offset!");
static_assert(offsetof(UInventory, InventoryItems) == 0x0001A0, "Member 'UInventory::InventoryItems' has a wrong offset!");
static_assert(offsetof(UInventory, ArchivedItems) == 0x0001F0, "Member 'UInventory::ArchivedItems' has a wrong offset!");
static_assert(offsetof(UInventory, ItemPickedUpHistory) == 0x000240, "Member 'UInventory::ItemPickedUpHistory' has a wrong offset!");
static_assert(offsetof(UInventory, bHaveArchiveTutorialBeenShown) == 0x000290, "Member 'UInventory::bHaveArchiveTutorialBeenShown' has a wrong offset!");
static_assert(offsetof(UInventory, CollectibleManager) == 0x000298, "Member 'UInventory::CollectibleManager' has a wrong offset!");

// Class ObsidianFox.DarkManAnimInstance
// 0x0020 (0x1800 - 0x17E0)
class UDarkManAnimInstance : public UEnemyHumanoidAnimInstance
{
public:
	class UAnimMontage*                           CurrentOneShotEmoteMontage;                        // 0x17E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TDelegate<void()>>                     EmoteDoneListeners;                                // 0x17E8(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_17F8[0x8];                                     // 0x17F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BPEndEmote(class AActor* AlertTargetActor);
	void BPStartEmote(class UDarkManEmoteDataAsset* Emote);
	void MontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnABPEmoteDone();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkManAnimInstance">();
	}
	static class UDarkManAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarkManAnimInstance>();
	}
};
static_assert(alignof(UDarkManAnimInstance) == 0x000010, "Wrong alignment on UDarkManAnimInstance");
static_assert(sizeof(UDarkManAnimInstance) == 0x001800, "Wrong size on UDarkManAnimInstance");
static_assert(offsetof(UDarkManAnimInstance, CurrentOneShotEmoteMontage) == 0x0017E0, "Member 'UDarkManAnimInstance::CurrentOneShotEmoteMontage' has a wrong offset!");
static_assert(offsetof(UDarkManAnimInstance, EmoteDoneListeners) == 0x0017E8, "Member 'UDarkManAnimInstance::EmoteDoneListeners' has a wrong offset!");

// Class ObsidianFox.DarkManEmoteDataAsset
// 0x0030 (0x0060 - 0x0030)
class UDarkManEmoteDataAsset : public UPrimaryDataAsset
{
public:
	uint8                                         bIsOneShotMontage : 1;                             // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimMontage>            OneShotMontage;                                    // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkManEmoteDataAsset">();
	}
	static class UDarkManEmoteDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDarkManEmoteDataAsset>();
	}
};
static_assert(alignof(UDarkManEmoteDataAsset) == 0x000008, "Wrong alignment on UDarkManEmoteDataAsset");
static_assert(sizeof(UDarkManEmoteDataAsset) == 0x000060, "Wrong size on UDarkManEmoteDataAsset");
static_assert(offsetof(UDarkManEmoteDataAsset, OneShotMontage) == 0x000038, "Member 'UDarkManEmoteDataAsset::OneShotMontage' has a wrong offset!");

// Class ObsidianFox.InteractionComponentQuery
// 0x0010 (0x0038 - 0x0028)
class UInteractionComponentQuery : public UObject
{
public:
	class UInteractionComponentQuery*             ParentFilter;                                      // 0x0028(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionComponentQuery">();
	}
	static class UInteractionComponentQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionComponentQuery>();
	}
};
static_assert(alignof(UInteractionComponentQuery) == 0x000008, "Wrong alignment on UInteractionComponentQuery");
static_assert(sizeof(UInteractionComponentQuery) == 0x000038, "Wrong size on UInteractionComponentQuery");
static_assert(offsetof(UInteractionComponentQuery, ParentFilter) == 0x000028, "Member 'UInteractionComponentQuery::ParentFilter' has a wrong offset!");

// Class ObsidianFox.DarkManEmoteInterface
// 0x0000 (0x0028 - 0x0028)
class IDarkManEmoteInterface final : public IInterface
{
public:
	void EndEmote(class AActor* AlertTargetActor);
	void RegisterEmoteDoneListener(TDelegate<void()> Event);
	void StartEmote(class UDarkManEmoteDataAsset* Emote);
	void UnregisterEmoteDoneListener(TDelegate<void()> Event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkManEmoteInterface">();
	}
	static class IDarkManEmoteInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDarkManEmoteInterface>();
	}
};
static_assert(alignof(IDarkManEmoteInterface) == 0x000008, "Wrong alignment on IDarkManEmoteInterface");
static_assert(sizeof(IDarkManEmoteInterface) == 0x000028, "Wrong size on IDarkManEmoteInterface");

// Class ObsidianFox.InGameUIWidget_Equipment
// 0x0088 (0x0300 - 0x0278)
class UInGameUIWidget_Equipment : public UInGameUIWidget
{
public:
	struct FLinearColor                           AmmoCount_DefaultColor;                            // 0x0278(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmmoCount_ReserveEmptyColor;                       // 0x0288(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AmmoCount_MagazineEmptyColor;                      // 0x0298(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOFPlayerController*                    PlayerController;                                  // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOFPlayerCharacter*                     PlayerCharacter;                                   // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEquipmentManager*                      EquipmentManager;                                  // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventory*                             Inventory;                                         // 0x02C0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           MainCanvas;                                        // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_AmmoMagazineCount;                            // 0x02D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Text_AmmoReserveCount;                             // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_RangeWeapon;                                 // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Image_MeleeWeapon;                                 // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               Overlay_MeleeWeapon;                               // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmmoInMagazine;                                    // 0x02F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ReserveAmmo;                                       // 0x02FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnAmmoChanged(int32 CurrentAmmo, int32 MaxAmmo);
	void OnPlayerEquipmentUpdated(const struct FWeaponInfo& EquippedWeapon, const struct FWeaponInfo& UnequippedWeapon);
	void OnPlayerLootItemUpdated(const class UItemData* ItemData);
	void UpdateBreakingImageMeleeWeaponWithNewWeapon(const class AMeleeWeaponActor* NewWeaponActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameUIWidget_Equipment">();
	}
	static class UInGameUIWidget_Equipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameUIWidget_Equipment>();
	}
};
static_assert(alignof(UInGameUIWidget_Equipment) == 0x000008, "Wrong alignment on UInGameUIWidget_Equipment");
static_assert(sizeof(UInGameUIWidget_Equipment) == 0x000300, "Wrong size on UInGameUIWidget_Equipment");
static_assert(offsetof(UInGameUIWidget_Equipment, AmmoCount_DefaultColor) == 0x000278, "Member 'UInGameUIWidget_Equipment::AmmoCount_DefaultColor' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Equipment, AmmoCount_ReserveEmptyColor) == 0x000288, "Member 'UInGameUIWidget_Equipment::AmmoCount_ReserveEmptyColor' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Equipment, AmmoCount_MagazineEmptyColor) == 0x000298, "Member 'UInGameUIWidget_Equipment::AmmoCount_MagazineEmptyColor' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Equipment, PlayerController) == 0x0002A8, "Member 'UInGameUIWidget_Equipment::PlayerController' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Equipment, PlayerCharacter) == 0x0002B0, "Member 'UInGameUIWidget_Equipment::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Equipment, EquipmentManager) == 0x0002B8, "Member 'UInGameUIWidget_Equipment::EquipmentManager' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Equipment, Inventory) == 0x0002C0, "Member 'UInGameUIWidget_Equipment::Inventory' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Equipment, MainCanvas) == 0x0002C8, "Member 'UInGameUIWidget_Equipment::MainCanvas' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Equipment, Text_AmmoMagazineCount) == 0x0002D0, "Member 'UInGameUIWidget_Equipment::Text_AmmoMagazineCount' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Equipment, Text_AmmoReserveCount) == 0x0002D8, "Member 'UInGameUIWidget_Equipment::Text_AmmoReserveCount' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Equipment, Image_RangeWeapon) == 0x0002E0, "Member 'UInGameUIWidget_Equipment::Image_RangeWeapon' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Equipment, Image_MeleeWeapon) == 0x0002E8, "Member 'UInGameUIWidget_Equipment::Image_MeleeWeapon' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Equipment, Overlay_MeleeWeapon) == 0x0002F0, "Member 'UInGameUIWidget_Equipment::Overlay_MeleeWeapon' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Equipment, AmmoInMagazine) == 0x0002F8, "Member 'UInGameUIWidget_Equipment::AmmoInMagazine' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Equipment, ReserveAmmo) == 0x0002FC, "Member 'UInGameUIWidget_Equipment::ReserveAmmo' has a wrong offset!");

// Class ObsidianFox.DebugTextRenderComponent
// 0x0010 (0x04C0 - 0x04B0)
class UDebugTextRenderComponent final : public UTextRenderComponent
{
public:
	uint8                                         DebugRenderEnabled : 1;                            // 0x04B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_4B1[0xF];                                      // 0x04B1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugTextRenderComponent">();
	}
	static class UDebugTextRenderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugTextRenderComponent>();
	}
};
static_assert(alignof(UDebugTextRenderComponent) == 0x000010, "Wrong alignment on UDebugTextRenderComponent");
static_assert(sizeof(UDebugTextRenderComponent) == 0x0004C0, "Wrong size on UDebugTextRenderComponent");

// Class ObsidianFox.DEZInteractionComponent
// 0x00E0 (0x02F0 - 0x0210)
class UDEZInteractionComponent final : public USceneComponent
{
public:
	class UDynamicEnvironmentZoneComponent*       DEZComp;                                           // 0x0208(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PreviousTickLocation;                              // 0x0210(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovedDistance;                                     // 0x021C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldInteractWithFluids;                         // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FluidRippleLifetime;                               // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FluidRippleSize;                                   // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FluidRippleStrength;                               // 0x022C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FluidRippleSpawnIntervalDistance;                  // 0x0230(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234[0x4];                                      // 0x0234(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     FluidCenterBrush;                                  // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FluidCenterSize;                                   // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FluidCenterStrength;                               // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LastFluidEventLocation;                            // 0x0248(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnFluidSplashEffects;                          // 0x0254(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_255[0x3];                                      // 0x0255(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceLength;                                       // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EPhysicalSurface>                      FluidPhysSurfaces;                                 // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UNiagaraSystem>          FluidSplash;                                       // 0x0270(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShouldInteractWithTerrain;                        // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TerrainInteractRange;                              // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TerrainInteractStrength;                           // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TerrainInteractLifetime;                           // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<ETerrainMaterialType>                  NonCompatibleTerrainTypes;                         // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FInteractBrushOverride>         OverrideBrushesForSurfaces;                        // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bShouldTraceForGround;                             // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C9[0x3];                                      // 0x02C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SurfaceCheckTraceLength;                           // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpawnTerrainSplashEffects;                        // 0x02D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinSplashTriggerDistance;                          // 0x02D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTerrainSplashEffects>          TerrainSplashEffects;                              // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bTerrainSplashHasTriggered;                        // 0x02E8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UDynamicEnvironmentZoneComponent* GetDEZReference() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DEZInteractionComponent">();
	}
	static class UDEZInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDEZInteractionComponent>();
	}
};
static_assert(alignof(UDEZInteractionComponent) == 0x000010, "Wrong alignment on UDEZInteractionComponent");
static_assert(sizeof(UDEZInteractionComponent) == 0x0002F0, "Wrong size on UDEZInteractionComponent");
static_assert(offsetof(UDEZInteractionComponent, DEZComp) == 0x000208, "Member 'UDEZInteractionComponent::DEZComp' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, PreviousTickLocation) == 0x000210, "Member 'UDEZInteractionComponent::PreviousTickLocation' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, MovedDistance) == 0x00021C, "Member 'UDEZInteractionComponent::MovedDistance' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, bShouldInteractWithFluids) == 0x000220, "Member 'UDEZInteractionComponent::bShouldInteractWithFluids' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, FluidRippleLifetime) == 0x000224, "Member 'UDEZInteractionComponent::FluidRippleLifetime' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, FluidRippleSize) == 0x000228, "Member 'UDEZInteractionComponent::FluidRippleSize' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, FluidRippleStrength) == 0x00022C, "Member 'UDEZInteractionComponent::FluidRippleStrength' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, FluidRippleSpawnIntervalDistance) == 0x000230, "Member 'UDEZInteractionComponent::FluidRippleSpawnIntervalDistance' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, FluidCenterBrush) == 0x000238, "Member 'UDEZInteractionComponent::FluidCenterBrush' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, FluidCenterSize) == 0x000240, "Member 'UDEZInteractionComponent::FluidCenterSize' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, FluidCenterStrength) == 0x000244, "Member 'UDEZInteractionComponent::FluidCenterStrength' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, LastFluidEventLocation) == 0x000248, "Member 'UDEZInteractionComponent::LastFluidEventLocation' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, bSpawnFluidSplashEffects) == 0x000254, "Member 'UDEZInteractionComponent::bSpawnFluidSplashEffects' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, TraceLength) == 0x000258, "Member 'UDEZInteractionComponent::TraceLength' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, FluidPhysSurfaces) == 0x000260, "Member 'UDEZInteractionComponent::FluidPhysSurfaces' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, FluidSplash) == 0x000270, "Member 'UDEZInteractionComponent::FluidSplash' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, bShouldInteractWithTerrain) == 0x000298, "Member 'UDEZInteractionComponent::bShouldInteractWithTerrain' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, TerrainInteractRange) == 0x00029C, "Member 'UDEZInteractionComponent::TerrainInteractRange' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, TerrainInteractStrength) == 0x0002A0, "Member 'UDEZInteractionComponent::TerrainInteractStrength' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, TerrainInteractLifetime) == 0x0002A4, "Member 'UDEZInteractionComponent::TerrainInteractLifetime' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, NonCompatibleTerrainTypes) == 0x0002A8, "Member 'UDEZInteractionComponent::NonCompatibleTerrainTypes' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, OverrideBrushesForSurfaces) == 0x0002B8, "Member 'UDEZInteractionComponent::OverrideBrushesForSurfaces' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, bShouldTraceForGround) == 0x0002C8, "Member 'UDEZInteractionComponent::bShouldTraceForGround' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, SurfaceCheckTraceLength) == 0x0002CC, "Member 'UDEZInteractionComponent::SurfaceCheckTraceLength' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, bSpawnTerrainSplashEffects) == 0x0002D0, "Member 'UDEZInteractionComponent::bSpawnTerrainSplashEffects' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, MinSplashTriggerDistance) == 0x0002D4, "Member 'UDEZInteractionComponent::MinSplashTriggerDistance' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, TerrainSplashEffects) == 0x0002D8, "Member 'UDEZInteractionComponent::TerrainSplashEffects' has a wrong offset!");
static_assert(offsetof(UDEZInteractionComponent, bTerrainSplashHasTriggered) == 0x0002E8, "Member 'UDEZInteractionComponent::bTerrainSplashHasTriggered' has a wrong offset!");

// Class ObsidianFox.InteractionFlowComponent
// 0x00E0 (0x0610 - 0x0530)
class UInteractionFlowComponent final : public UInteractionComponentBase
{
public:
	FMulticastInlineDelegateProperty_             OnBeginInteract;                                   // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndInteract;                                     // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInterrupt;                                       // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPostEndInteract;                                 // 0x0560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPostInterrupt;                                   // 0x0570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_580[0x1];                                      // 0x0580(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bUseInteractionIconLocation : 1;                   // 0x0581(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_582[0x2];                                      // 0x0582(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InteractionIconLocation;                           // 0x0584(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InteractionIconWorldLocation;                      // 0x0590(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistanceDifferenceBeforeInteract;               // 0x059C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxAngleDifferenceBeforeInteract;                  // 0x05A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A4[0x4];                                      // 0x05A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             InteractingCharacterReference;                     // 0x05A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bLockMovementInputWhileInteracting : 1;            // 0x05B0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockLookInputWhileInteracting : 1;                // 0x05B0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockGameplayInputWhileInteracting : 1;            // 0x05B0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockInteractableWhileInteracting : 1;             // 0x05B0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLockVelocityModifyingAnimationCurvesWhileInteracting : 1; // 0x05B0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBeginActivated : 1;                               // 0x05B0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, SaveGame, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSingleUseOnlySoft : 1;                            // 0x05B0(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSingleUseOnlyHard : 1;                            // 0x05B0(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisableReactivate : 1;                            // 0x05B1(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_5B2[0x2];                                      // 0x05B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxAmountOfInteractions;                           // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TagsUserShouldHave;                                // 0x05B8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TagsUserShouldNotHave;                             // 0x05D8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AmountOfInteractionsWithObject;                    // 0x0600(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_604[0xC];                                      // 0x0604(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndInteraction();
	void InteractionSignature__DelegateSignature(class ACharacter* InteractionCharacter);
	void SetLockDuringInteraction(bool LockMoveInput, bool LockLookInput, bool LockGameplayInput, bool LockInteractable);
	void SetLockGameplayInputDuringInteraction(bool ShouldIgnore);
	void SetLockInteractableDuringInteraction(bool ShouldIgnore);
	void SetLockLookInputDuringInteraction(bool ShouldIgnore);
	void SetLockMovementInputDuringInteraction(bool ShouldIgnore);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionFlowComponent">();
	}
	static class UInteractionFlowComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionFlowComponent>();
	}
};
static_assert(alignof(UInteractionFlowComponent) == 0x000010, "Wrong alignment on UInteractionFlowComponent");
static_assert(sizeof(UInteractionFlowComponent) == 0x000610, "Wrong size on UInteractionFlowComponent");
static_assert(offsetof(UInteractionFlowComponent, OnBeginInteract) == 0x000530, "Member 'UInteractionFlowComponent::OnBeginInteract' has a wrong offset!");
static_assert(offsetof(UInteractionFlowComponent, OnEndInteract) == 0x000540, "Member 'UInteractionFlowComponent::OnEndInteract' has a wrong offset!");
static_assert(offsetof(UInteractionFlowComponent, OnInterrupt) == 0x000550, "Member 'UInteractionFlowComponent::OnInterrupt' has a wrong offset!");
static_assert(offsetof(UInteractionFlowComponent, OnPostEndInteract) == 0x000560, "Member 'UInteractionFlowComponent::OnPostEndInteract' has a wrong offset!");
static_assert(offsetof(UInteractionFlowComponent, OnPostInterrupt) == 0x000570, "Member 'UInteractionFlowComponent::OnPostInterrupt' has a wrong offset!");
static_assert(offsetof(UInteractionFlowComponent, InteractionIconLocation) == 0x000584, "Member 'UInteractionFlowComponent::InteractionIconLocation' has a wrong offset!");
static_assert(offsetof(UInteractionFlowComponent, InteractionIconWorldLocation) == 0x000590, "Member 'UInteractionFlowComponent::InteractionIconWorldLocation' has a wrong offset!");
static_assert(offsetof(UInteractionFlowComponent, MaxDistanceDifferenceBeforeInteract) == 0x00059C, "Member 'UInteractionFlowComponent::MaxDistanceDifferenceBeforeInteract' has a wrong offset!");
static_assert(offsetof(UInteractionFlowComponent, MaxAngleDifferenceBeforeInteract) == 0x0005A0, "Member 'UInteractionFlowComponent::MaxAngleDifferenceBeforeInteract' has a wrong offset!");
static_assert(offsetof(UInteractionFlowComponent, InteractingCharacterReference) == 0x0005A8, "Member 'UInteractionFlowComponent::InteractingCharacterReference' has a wrong offset!");
static_assert(offsetof(UInteractionFlowComponent, MaxAmountOfInteractions) == 0x0005B4, "Member 'UInteractionFlowComponent::MaxAmountOfInteractions' has a wrong offset!");
static_assert(offsetof(UInteractionFlowComponent, TagsUserShouldHave) == 0x0005B8, "Member 'UInteractionFlowComponent::TagsUserShouldHave' has a wrong offset!");
static_assert(offsetof(UInteractionFlowComponent, TagsUserShouldNotHave) == 0x0005D8, "Member 'UInteractionFlowComponent::TagsUserShouldNotHave' has a wrong offset!");
static_assert(offsetof(UInteractionFlowComponent, AmountOfInteractionsWithObject) == 0x000600, "Member 'UInteractionFlowComponent::AmountOfInteractionsWithObject' has a wrong offset!");

// Class ObsidianFox.DifficultyDependantGameplayModMagnitudeCalculation
// 0x0008 (0x0048 - 0x0040)
class UDifficultyDependantGameplayModMagnitudeCalculation : public UGameplayModMagnitudeCalculation
{
public:
	EDifficulty                                   Difficulty;                                        // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DifficultyDependantGameplayModMagnitudeCalculation">();
	}
	static class UDifficultyDependantGameplayModMagnitudeCalculation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDifficultyDependantGameplayModMagnitudeCalculation>();
	}
};
static_assert(alignof(UDifficultyDependantGameplayModMagnitudeCalculation) == 0x000008, "Wrong alignment on UDifficultyDependantGameplayModMagnitudeCalculation");
static_assert(sizeof(UDifficultyDependantGameplayModMagnitudeCalculation) == 0x000048, "Wrong size on UDifficultyDependantGameplayModMagnitudeCalculation");
static_assert(offsetof(UDifficultyDependantGameplayModMagnitudeCalculation, Difficulty) == 0x000040, "Member 'UDifficultyDependantGameplayModMagnitudeCalculation::Difficulty' has a wrong offset!");

// Class ObsidianFox.DifficultyDependantSubsystem
// 0x0000 (0x0030 - 0x0030)
class UDifficultyDependantSubsystem final : public UGameplaySessionSubsystem
{
public:
	void OnDifficultyUpdatedHandler(EDifficulty NewDifficulty);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DifficultyDependantSubsystem">();
	}
	static class UDifficultyDependantSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDifficultyDependantSubsystem>();
	}
};
static_assert(alignof(UDifficultyDependantSubsystem) == 0x000008, "Wrong alignment on UDifficultyDependantSubsystem");
static_assert(sizeof(UDifficultyDependantSubsystem) == 0x000030, "Wrong size on UDifficultyDependantSubsystem");

// Class ObsidianFox.OFGridPanel
// 0x0020 (0x02C0 - 0x02A0)
class UOFGridPanel : public UWidgetInputHandlingBase
{
public:
	class UGridPanel*                             GridPanel;                                         // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOFSlotWidget*                          SelectedSlotWidget;                                // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGridSlot*                              SelectedGridSlot;                                  // 0x02B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x8];                                      // 0x02B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSlotHovered(class UOFSlotWidget* InArchiveSlot);
	void SetFirstSlotAsActive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFGridPanel">();
	}
	static class UOFGridPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFGridPanel>();
	}
};
static_assert(alignof(UOFGridPanel) == 0x000008, "Wrong alignment on UOFGridPanel");
static_assert(sizeof(UOFGridPanel) == 0x0002C0, "Wrong size on UOFGridPanel");
static_assert(offsetof(UOFGridPanel, GridPanel) == 0x0002A0, "Member 'UOFGridPanel::GridPanel' has a wrong offset!");
static_assert(offsetof(UOFGridPanel, SelectedSlotWidget) == 0x0002A8, "Member 'UOFGridPanel::SelectedSlotWidget' has a wrong offset!");
static_assert(offsetof(UOFGridPanel, SelectedGridSlot) == 0x0002B0, "Member 'UOFGridPanel::SelectedGridSlot' has a wrong offset!");

// Class ObsidianFox.InvestigationSelectionWidget
// 0x0030 (0x02F0 - 0x02C0)
class UInvestigationSelectionWidget : public UOFGridPanel
{
public:
	class UOverlay*                               OverlayLabelBox;                                   // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             LabelText;                                         // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             InfoDescription;                                   // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              RelativeLabelPositionInSlot;                       // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionArchive;                                // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OpenArchive();
	void ReloadPressedHandler();
	void UpdateLabelBox();

	class UInvestigationSlotWidget* GetSelectedInvestigationSlotWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvestigationSelectionWidget">();
	}
	static class UInvestigationSelectionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvestigationSelectionWidget>();
	}
};
static_assert(alignof(UInvestigationSelectionWidget) == 0x000008, "Wrong alignment on UInvestigationSelectionWidget");
static_assert(sizeof(UInvestigationSelectionWidget) == 0x0002F0, "Wrong size on UInvestigationSelectionWidget");
static_assert(offsetof(UInvestigationSelectionWidget, OverlayLabelBox) == 0x0002C0, "Member 'UInvestigationSelectionWidget::OverlayLabelBox' has a wrong offset!");
static_assert(offsetof(UInvestigationSelectionWidget, LabelText) == 0x0002C8, "Member 'UInvestigationSelectionWidget::LabelText' has a wrong offset!");
static_assert(offsetof(UInvestigationSelectionWidget, InfoDescription) == 0x0002D0, "Member 'UInvestigationSelectionWidget::InfoDescription' has a wrong offset!");
static_assert(offsetof(UInvestigationSelectionWidget, RelativeLabelPositionInSlot) == 0x0002D8, "Member 'UInvestigationSelectionWidget::RelativeLabelPositionInSlot' has a wrong offset!");
static_assert(offsetof(UInvestigationSelectionWidget, InputActionArchive) == 0x0002E0, "Member 'UInvestigationSelectionWidget::InputActionArchive' has a wrong offset!");

// Class ObsidianFox.DismembermentExtraParameters
// 0x0000 (0x0028 - 0x0028)
class UDismembermentExtraParameters final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DismembermentExtraParameters">();
	}
	static class UDismembermentExtraParameters* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDismembermentExtraParameters>();
	}
};
static_assert(alignof(UDismembermentExtraParameters) == 0x000008, "Wrong alignment on UDismembermentExtraParameters");
static_assert(sizeof(UDismembermentExtraParameters) == 0x000028, "Wrong size on UDismembermentExtraParameters");

// Class ObsidianFox.DismembermentGoreSpawner
// 0x00E8 (0x0320 - 0x0238)
class ADismembermentGoreSpawner : public AActor
{
public:
	class USceneComponent*                        Root;                                              // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyAfterDuration;                             // 0x0240(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241[0x3];                                      // 0x0241(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lifetime;                                          // 0x0244(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDismemberStaticMeshData>       DismemberStaticMeshData;                           // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UStaticMeshComponent*>           StaticMeshComponents;                              // 0x0258(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FDismemberSkeletalMeshData>     DismemberSkeletalMeshData;                         // 0x0268(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class USkeletalMeshComponent*>         SkeletalMeshComponents;                            // 0x0278(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 DismembermentSourceMesh;                           // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitResult                             DismembermentHit;                                  // 0x0290(0x0088)(Edit, BlueprintVisible, EditConst, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class FName                                   DismemberPointBoneName;                            // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DismembermentGoreSpawner">();
	}
	static class ADismembermentGoreSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADismembermentGoreSpawner>();
	}
};
static_assert(alignof(ADismembermentGoreSpawner) == 0x000008, "Wrong alignment on ADismembermentGoreSpawner");
static_assert(sizeof(ADismembermentGoreSpawner) == 0x000320, "Wrong size on ADismembermentGoreSpawner");
static_assert(offsetof(ADismembermentGoreSpawner, Root) == 0x000238, "Member 'ADismembermentGoreSpawner::Root' has a wrong offset!");
static_assert(offsetof(ADismembermentGoreSpawner, bDestroyAfterDuration) == 0x000240, "Member 'ADismembermentGoreSpawner::bDestroyAfterDuration' has a wrong offset!");
static_assert(offsetof(ADismembermentGoreSpawner, Lifetime) == 0x000244, "Member 'ADismembermentGoreSpawner::Lifetime' has a wrong offset!");
static_assert(offsetof(ADismembermentGoreSpawner, DismemberStaticMeshData) == 0x000248, "Member 'ADismembermentGoreSpawner::DismemberStaticMeshData' has a wrong offset!");
static_assert(offsetof(ADismembermentGoreSpawner, StaticMeshComponents) == 0x000258, "Member 'ADismembermentGoreSpawner::StaticMeshComponents' has a wrong offset!");
static_assert(offsetof(ADismembermentGoreSpawner, DismemberSkeletalMeshData) == 0x000268, "Member 'ADismembermentGoreSpawner::DismemberSkeletalMeshData' has a wrong offset!");
static_assert(offsetof(ADismembermentGoreSpawner, SkeletalMeshComponents) == 0x000278, "Member 'ADismembermentGoreSpawner::SkeletalMeshComponents' has a wrong offset!");
static_assert(offsetof(ADismembermentGoreSpawner, DismembermentSourceMesh) == 0x000288, "Member 'ADismembermentGoreSpawner::DismembermentSourceMesh' has a wrong offset!");
static_assert(offsetof(ADismembermentGoreSpawner, DismembermentHit) == 0x000290, "Member 'ADismembermentGoreSpawner::DismembermentHit' has a wrong offset!");
static_assert(offsetof(ADismembermentGoreSpawner, DismemberPointBoneName) == 0x000318, "Member 'ADismembermentGoreSpawner::DismemberPointBoneName' has a wrong offset!");

// Class ObsidianFox.InventoryItemPicker
// 0x0000 (0x0028 - 0x0028)
class IInventoryItemPicker final : public IInterface
{
public:
	bool CheckIfRightItem(class UItemData* ItemData);
	class FText GetTargetName();
	void OnWindowClose();

	struct FGameplayTag GetItemCategoryGameplayTag() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryItemPicker">();
	}
	static class IInventoryItemPicker* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInventoryItemPicker>();
	}
};
static_assert(alignof(IInventoryItemPicker) == 0x000008, "Wrong alignment on IInventoryItemPicker");
static_assert(sizeof(IInventoryItemPicker) == 0x000028, "Wrong size on IInventoryItemPicker");

// Class ObsidianFox.DismembermentInterface
// 0x0000 (0x0028 - 0x0028)
class IDismembermentInterface final : public IInterface
{
public:
	void DismemberAtHit(const struct FHitResult& HitResult, float HitMagnitude, bool IsKillingHit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DismembermentInterface">();
	}
	static class IDismembermentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDismembermentInterface>();
	}
};
static_assert(alignof(IDismembermentInterface) == 0x000008, "Wrong alignment on IDismembermentInterface");
static_assert(sizeof(IDismembermentInterface) == 0x000028, "Wrong size on IDismembermentInterface");

// Class ObsidianFox.DismemberMeshParticleActor
// 0x0090 (0x02C8 - 0x0238)
class ADismemberMeshParticleActor final : public AActor
{
public:
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPhysicalAnimationComponent*            PhysicalAnimationComponent;                        // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPoseSnapshot                          PoseSnapshot;                                      // 0x0250(0x0038)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         bHasPoseSnapshot : 1;                              // 0x0288(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBlendToRefPose : 1;                               // 0x0288(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_289[0x3F];                                     // 0x0289(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAngularImpulseInDegrees(const struct FVector& Impulse, class FName BoneName, bool bSkipQueueIfPhysicsAreDisabled);
	void AddRadialImpulse(const struct FVector& Origin, float Radius, float Strength, bool bSkipQueueIfPhysicsAreDisabled);
	void OnSpawnEvent(class UDismemberSkeletalMeshComponent* SpawningComponent, const class UDismembermentExtraParameters* OptionalObject);

	void DisablePhysics(class FName SimulationRootBone) const;
	void EnablePhysics(class FName SimulationRootBone, class FName PhysicsProfileName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DismemberMeshParticleActor">();
	}
	static class ADismemberMeshParticleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADismemberMeshParticleActor>();
	}
};
static_assert(alignof(ADismemberMeshParticleActor) == 0x000008, "Wrong alignment on ADismemberMeshParticleActor");
static_assert(sizeof(ADismemberMeshParticleActor) == 0x0002C8, "Wrong size on ADismemberMeshParticleActor");
static_assert(offsetof(ADismemberMeshParticleActor, SkeletalMeshComponent) == 0x000240, "Member 'ADismemberMeshParticleActor::SkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(ADismemberMeshParticleActor, PhysicalAnimationComponent) == 0x000248, "Member 'ADismemberMeshParticleActor::PhysicalAnimationComponent' has a wrong offset!");
static_assert(offsetof(ADismemberMeshParticleActor, PoseSnapshot) == 0x000250, "Member 'ADismemberMeshParticleActor::PoseSnapshot' has a wrong offset!");

// Class ObsidianFox.SphereFilterInteractionComponentQuery
// 0x0010 (0x0048 - 0x0038)
class USphereFilterInteractionComponentQuery final : public UInteractionComponentQuery
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SphereFilterInteractionComponentQuery">();
	}
	static class USphereFilterInteractionComponentQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<USphereFilterInteractionComponentQuery>();
	}
};
static_assert(alignof(USphereFilterInteractionComponentQuery) == 0x000008, "Wrong alignment on USphereFilterInteractionComponentQuery");
static_assert(sizeof(USphereFilterInteractionComponentQuery) == 0x000048, "Wrong size on USphereFilterInteractionComponentQuery");

// Class ObsidianFox.DismemberParticleAnimInstance
// 0x0010 (0x02E0 - 0x02D0)
class UDismemberParticleAnimInstance final : public UAnimInstance
{
public:
	class ADismemberMeshParticleActor*            ActorOwner;                                        // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 OriginMasterMeshComponent;                         // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DismemberParticleAnimInstance">();
	}
	static class UDismemberParticleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDismemberParticleAnimInstance>();
	}
};
static_assert(alignof(UDismemberParticleAnimInstance) == 0x000010, "Wrong alignment on UDismemberParticleAnimInstance");
static_assert(sizeof(UDismemberParticleAnimInstance) == 0x0002E0, "Wrong size on UDismemberParticleAnimInstance");
static_assert(offsetof(UDismemberParticleAnimInstance, ActorOwner) == 0x0002C8, "Member 'UDismemberParticleAnimInstance::ActorOwner' has a wrong offset!");
static_assert(offsetof(UDismemberParticleAnimInstance, OriginMasterMeshComponent) == 0x0002D0, "Member 'UDismemberParticleAnimInstance::OriginMasterMeshComponent' has a wrong offset!");

// Class ObsidianFox.VectorFieldInteractionComponent
// 0x0020 (0x0230 - 0x0210)
class UVectorFieldInteractionComponent final : public USceneComponent
{
public:
	class UDynamicVectorFieldManager*             ManagerRef;                                        // 0x0208(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractRadius;                                    // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractStrength;                                  // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInteractOnTick;                                   // 0x0218(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInteractOnlyhWhenMoving;                          // 0x0219(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A[0x2];                                      // 0x021A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinMoveSpeed;                                      // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PreviousTickLocation;                              // 0x0220(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void VectorFieldInteraction(float Radius, float Strength);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VectorFieldInteractionComponent">();
	}
	static class UVectorFieldInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVectorFieldInteractionComponent>();
	}
};
static_assert(alignof(UVectorFieldInteractionComponent) == 0x000010, "Wrong alignment on UVectorFieldInteractionComponent");
static_assert(sizeof(UVectorFieldInteractionComponent) == 0x000230, "Wrong size on UVectorFieldInteractionComponent");
static_assert(offsetof(UVectorFieldInteractionComponent, ManagerRef) == 0x000208, "Member 'UVectorFieldInteractionComponent::ManagerRef' has a wrong offset!");
static_assert(offsetof(UVectorFieldInteractionComponent, InteractRadius) == 0x000210, "Member 'UVectorFieldInteractionComponent::InteractRadius' has a wrong offset!");
static_assert(offsetof(UVectorFieldInteractionComponent, InteractStrength) == 0x000214, "Member 'UVectorFieldInteractionComponent::InteractStrength' has a wrong offset!");
static_assert(offsetof(UVectorFieldInteractionComponent, bInteractOnTick) == 0x000218, "Member 'UVectorFieldInteractionComponent::bInteractOnTick' has a wrong offset!");
static_assert(offsetof(UVectorFieldInteractionComponent, bInteractOnlyhWhenMoving) == 0x000219, "Member 'UVectorFieldInteractionComponent::bInteractOnlyhWhenMoving' has a wrong offset!");
static_assert(offsetof(UVectorFieldInteractionComponent, MinMoveSpeed) == 0x00021C, "Member 'UVectorFieldInteractionComponent::MinMoveSpeed' has a wrong offset!");
static_assert(offsetof(UVectorFieldInteractionComponent, PreviousTickLocation) == 0x000220, "Member 'UVectorFieldInteractionComponent::PreviousTickLocation' has a wrong offset!");

// Class ObsidianFox.DismemberSkeletalMeshComponent
// 0x0050 (0x0F40 - 0x0EF0)
class UDismemberSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	TSubclassOf<class UAnimInstance>              DetachedAnimClass;                                 // 0x0EF0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ADismemberMeshParticleActor> DetachedActorClass;                                // 0x0EF8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bBlendToRefPose : 1;                               // 0x0F00(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_F01[0x3F];                                     // 0x0F01(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ADismemberMeshParticleActor* DetachMesh(class UDismembermentExtraParameters* OptionalObject);
	class ADismemberMeshParticleActor* DetachMeshWithForce(class UDismembermentExtraParameters* OptionalObject, const struct FVector& RadialForceOrigin, float ForceRadius, float ForceStrength, const struct FVector& AngularImpulse, class FName AngularImpulseBone);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DismemberSkeletalMeshComponent">();
	}
	static class UDismemberSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDismemberSkeletalMeshComponent>();
	}
};
static_assert(alignof(UDismemberSkeletalMeshComponent) == 0x000010, "Wrong alignment on UDismemberSkeletalMeshComponent");
static_assert(sizeof(UDismemberSkeletalMeshComponent) == 0x000F40, "Wrong size on UDismemberSkeletalMeshComponent");
static_assert(offsetof(UDismemberSkeletalMeshComponent, DetachedAnimClass) == 0x000EF0, "Member 'UDismemberSkeletalMeshComponent::DetachedAnimClass' has a wrong offset!");
static_assert(offsetof(UDismemberSkeletalMeshComponent, DetachedActorClass) == 0x000EF8, "Member 'UDismemberSkeletalMeshComponent::DetachedActorClass' has a wrong offset!");

// Class ObsidianFox.OFArchiveSelectionWidget
// 0x0070 (0x0310 - 0x02A0)
class UOFArchiveSelectionWidget : public UWidgetInputHandlingBase
{
public:
	class UVerticalBox*                           ChapterButtonVerticalBox;                          // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        WidgetSwitcherArchive;                             // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SelectionWidgetSetUpFinished;                      // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, class UOFArchiveGridWidget*> ArchiveGridWidgets;                                // 0x02C0(0x0050)(ExportObject, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFArchiveSelectionWidget">();
	}
	static class UOFArchiveSelectionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFArchiveSelectionWidget>();
	}
};
static_assert(alignof(UOFArchiveSelectionWidget) == 0x000008, "Wrong alignment on UOFArchiveSelectionWidget");
static_assert(sizeof(UOFArchiveSelectionWidget) == 0x000310, "Wrong size on UOFArchiveSelectionWidget");
static_assert(offsetof(UOFArchiveSelectionWidget, ChapterButtonVerticalBox) == 0x0002A0, "Member 'UOFArchiveSelectionWidget::ChapterButtonVerticalBox' has a wrong offset!");
static_assert(offsetof(UOFArchiveSelectionWidget, WidgetSwitcherArchive) == 0x0002A8, "Member 'UOFArchiveSelectionWidget::WidgetSwitcherArchive' has a wrong offset!");
static_assert(offsetof(UOFArchiveSelectionWidget, SelectionWidgetSetUpFinished) == 0x0002B0, "Member 'UOFArchiveSelectionWidget::SelectionWidgetSetUpFinished' has a wrong offset!");
static_assert(offsetof(UOFArchiveSelectionWidget, ArchiveGridWidgets) == 0x0002C0, "Member 'UOFArchiveSelectionWidget::ArchiveGridWidgets' has a wrong offset!");

// Class ObsidianFox.Door
// 0x11E8 (0x1420 - 0x0238)
#pragma pack(push, 0x1)
class alignas(0x10) ADoor : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnStartDoorOpening;                                // 0x0238(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTackledOpen;                                     // 0x0248(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoorClosing;                                     // 0x0258(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoorClosed;                                      // 0x0268(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractingCharacterReachDoorHandle;             // 0x0278(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoorUnlocked;                                    // 0x0288(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLockStateSet;                                    // 0x0298(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDoorOpened;                                      // 0x02A8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   DoorMesh;                                          // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   DoorKnob;                                          // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   DoorHandle;                                        // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   DoorBolt;                                          // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   DoorBoltLatch;                                     // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        DoorRoot;                                          // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   KeyMesh;                                           // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        KeyArrowLocation;                                  // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        DoorArrowMiddlePoint;                              // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        SprintOpenDirection;                               // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintOpenAngle;                                   // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionFlowComponent*              DoorInteractionComponent;                          // 0x0310(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPersistenceComponent*                  PersistenceComponent;                              // 0x0318(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMapMarkerDoorComponent*                MapMarkerComponent;                                // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoorLockState                                LockState;                                         // 0x0328(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          DoorSprintCheckVolume;                             // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    BoltSpringArmComponent;                            // 0x0338(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       BoltCameraComponent;                               // 0x0340(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpringArmComponent*                    KeySpringArmComponent;                             // 0x0348(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       KeyCameraComponent;                                // 0x0350(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        ClockwiseTravelpoint;                              // 0x0358(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        NotClockwiseTravelpoint;                           // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        ChildClockwiseTravelpoint;                         // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        ChildNotClockwiseTravelpoint;                      // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimationEnvironmentSettings*          AnimationEnvironmentSettings;                      // 0x0378(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EPlayerCharacterType, struct FDoorCurveData> DoorCurveMap;                                      // 0x0380(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EPlayerCharacterType, struct FDoorCurveTagOverrideData> DoorCurveMapTagOverrides;                          // 0x03D0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DoorCloseCurve;                                    // 0x0420(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DoorOpenRunningCurve;                              // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            BoltLatchCurve;                                    // 0x0430(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_438[0x88];                                     // 0x0438(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	EDoorOpenState                                DoorOpenState;                                     // 0x04C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDoorOpenState                                StartDoorOpenState;                                // 0x04C1(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bSaveOpenState : 1;                                // 0x04C2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseClosingTimer : 1;                              // 0x04C2(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDoorOpen : 1;                                     // 0x04C2(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bClockwiseOpening : 1;                             // 0x04C2(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	bool                                          bClockwise_Bolted;                                 // 0x04C3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayFirstTimeOpenCinematic;                       // 0x04C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C5[0x3];                                      // 0x04C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                KeyCameraLocation;                                 // 0x04C8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D4[0x4];                                      // 0x04D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  SprintingTag;                                      // 0x04D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AnimationTagOpen;                                  // 0x04F8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AnimationTagOpenSprint;                            // 0x0500(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AnimationTagLockedCombatClockwise;                 // 0x0508(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AnimationTagLockedCombatCounterClockwise;          // 0x0510(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AnimationTagFirstTimeOpening;                      // 0x0518(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraModifier>            CameraModiferToDisable;                            // 0x0520(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_528[0xA18];                                    // 0x0528(0x0A18)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DoorOpenRightSectionName;                          // 0x0F40(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DoorOpenLeftSectionName;                           // 0x0F48(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DoorFailRightSectionName;                          // 0x0F50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DoorFailLeftSectionName;                           // 0x0F58(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   KeyLocationSocketName;                             // 0x0F60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClockwiseMaxOpenAngel;                             // 0x0F68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NotClockwiseMaxOpenAngel;                          // 0x0F6C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UItemData>               KeyItem;                                           // 0x0F70(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F98[0x8];                                      // 0x0F98(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             InteractingPlayer;                                 // 0x0FA0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FA8[0x8];                                      // 0x0FA8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFMODEvent>              DoorOpenSound;                                     // 0x0FB0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              DoorSprintOpenSound;                               // 0x0FD8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              DoorClosingSound;                                  // 0x1000(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              DoorBoltSound;                                     // 0x1028(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              DoorKeySound;                                      // 0x1050(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              DoorClosedEndSound;                                // 0x1078(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              DoorLockedSound;                                   // 0x10A0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraPlayerToDoorBlendTime;                       // 0x10C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraDoorToPlayerBlendTime;                       // 0x10CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WhereOnTimeLineToPlayClosedSound;                  // 0x10D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseAsTrigger;                                     // 0x10D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10D5[0x23];                                    // 0x10D5(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	class UFlowDoorComponent*                     FlowDoorComponent;                                 // 0x10F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              BoltedExtraInteractionIcon;                        // 0x1100(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ChapterSelectFactTag_LockState;                    // 0x1128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ChapterSelectFactTag_OpenState;                    // 0x1130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AutoCloseMaxDistance;                              // 0x1138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSprintOpenEnabled;                                // 0x113C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldWaitForLevelsToBeLoadedBeforeOpeningDoor;    // 0x113D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_113E[0x21A];                                   // 0x113E(0x021A)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CurrentPlayingOpenMontage;                         // 0x1358(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            SpawnedLoadingThrobberWidget;                      // 0x1360(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1368[0xB0];                                    // 0x1368(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AreLevelsLoaded();
	void BoltDraggingCallbackFunction(float Alpha);
	void CheckDistanceForClosing();
	void CloseDoor(bool bInstantClose);
	void CloseDoorTimelineCallback(float Alpha);
	void DoorHandleCounterClockwiseRotationTimelineCallback(float Alpha);
	void DoorHandleRotationTimelineCallback(float Alpha);
	void DoorRotationTimeLineCallback(float Alpha);
	EDoorOpenState GetDoorOpenState();
	void InteractingWithDoor(class ACharacter* InteractionCharacter);
	bool IsLocked();
	void ItemAddedHandler(const class UItemData* ItemData);
	void MoveToInteraction(class ACharacter* InteractingCharacter, const class USceneComponent* MoveToLocation);
	void MoveToInteractionDone(class ACharacter* InteractingCharacter);
	void OnCharacterPossessed(const class AOFPlayerCharacter* PlayerCharacter);
	void OnCharacterUnPossessed(const class AOFPlayerCharacter* PlayerCharacter);
	void OnDoorCloseFinishedCallBack();
	void OnDoorUnboltFinished();
	void OnInteractingCharacterReachDoorHandleCallback();
	void OnLevelsLoaded_InteractingWithDoor_Handler();
	void OnLevelsLoaded_UnlockDoorAnimation_Handler();
	void OnPreSaveGame(ESaveTypePolicy SaveType);
	void OnUnBoltFinishedCallBack();
	void OpenDoor(const bool bCounterClockwise);
	void OpenItemPicker(class ACharacter* InteractingCharacter);
	void OverrideTimelineCurve(const EDoorTimelineActions InAction, class UCurveFloat* InCurve);
	void PlayerGuidanceSystemUpdatedHandler(EPlayerGuidanceSystem System, bool bState);
	void PlayerOverlappedTriggerBox(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void PlayFirstTimeOpening();
	void PlayMontage(const class USkeletalMeshComponent* InSkeletalMesh, const class UAnimMontage* MontageToPlay, class FName StartingSection);
	void PlayOpenAnimation(const class ACharacter* InteractingCharacter, const struct FGameplayTag& AnimationTagOpen_0);
	void PlayTimeline(EDoorTimelineActions InTimeLineAction);
	void PlayUnboltAnimation();
	void SetAnimationPlayRate(float PlayRate);
	void SetClockWiseOpening(const bool bClockwise);
	void SetCosmeticsForLockState(EDoorLockState InLockState);
	void SetDoorAsCameraOwner();
	void SetDoorBoltSound(TSoftObjectPtr<class UFMODEvent> Value);
	void SetDoorClosedEndSound(TSoftObjectPtr<class UFMODEvent> Value);
	void SetDoorClosingSound(TSoftObjectPtr<class UFMODEvent> Value);
	void SetDoorKeySound(TSoftObjectPtr<class UFMODEvent> Value);
	void SetDoorLockedSound(TSoftObjectPtr<class UFMODEvent> Value);
	void SetDoorOpenSound(TSoftObjectPtr<class UFMODEvent> Value);
	void SetDoorSprintOpenSound(TSoftObjectPtr<class UFMODEvent> Value);
	void SetDoorStartLerpRotationToCurrentRotation();
	void SetEnableSprintOpen(const bool bSprintOpenEnable);
	void SetLockState(EDoorLockState NewLockState);
	void SetLockState_Direct_Deprecated(EDoorLockState NewLockState);
	void SetOpenCurve(const struct FDoorCurveDataPair& NewOpenCurve);
	void SetPlayerCameraOwner();
	void SetSprintOpenCurve(class UCurveFloat* NewSprintOpenCurve);
	void SetupTimelineAction(const EDoorTimelineActions TimelineAction, const class FName InTimelineName, class UCurveFloat* InCurve);
	void SetUseAsTrigger(const bool bInUseAsTrigger);
	void SetUseClosingTimer(const bool bInUseClosingTimer);
	void StartDoorHandleTimeLine(EDoorOpenType OpenType, const class ACharacter* InteractingCharacter, bool bDoorIsLocked);
	void StartLockedDoorTimeline(EDoorOpenType OpenType, const class ACharacter* InteractingCharacter, bool bPlayHandleAnimations);
	void StartOpenDoorTimeLine(EDoorOpenType OpenType, const class ACharacter* InteractingCharacter, bool bPlayHandleAnimations);
	void StartWaitingForLevelsToLoad(float SlowDownTime, TSubclassOf<class UUserWidget> LoadingThrobberWidgetClass);
	void StopDoorTimeline(EDoorTimelineActions TimelineToStop);
	void StopTimeline(EDoorTimelineActions InTimeLineAction);
	void TimeLineFunctionDone();
	void UnBoltDoor(class ACharacter* InteractingCharacter);
	void UnlockDoor();
	void UnlockDoorAnimation();
	void UpdateClockwiseOpening(bool bClockwiseOpeningPosition);
	void UpdateKeyCameraTransform();

	bool IsDoorClosing() const;
	bool IsDoorOpen() const;
	bool IsPlayingTimeline(EDoorTimelineActions InTimeLineAction) const;
	void OnDoorOpenFinishedCallBack() const;
	bool ShouldLevelsBeLoadedBeforeOpeningDoor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Door">();
	}
	static class ADoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoor>();
	}
};
#pragma pack(pop)
static_assert(alignof(ADoor) == 0x000010, "Wrong alignment on ADoor");
static_assert(sizeof(ADoor) == 0x001420, "Wrong size on ADoor");
static_assert(offsetof(ADoor, OnStartDoorOpening) == 0x000238, "Member 'ADoor::OnStartDoorOpening' has a wrong offset!");
static_assert(offsetof(ADoor, OnTackledOpen) == 0x000248, "Member 'ADoor::OnTackledOpen' has a wrong offset!");
static_assert(offsetof(ADoor, OnDoorClosing) == 0x000258, "Member 'ADoor::OnDoorClosing' has a wrong offset!");
static_assert(offsetof(ADoor, OnDoorClosed) == 0x000268, "Member 'ADoor::OnDoorClosed' has a wrong offset!");
static_assert(offsetof(ADoor, OnInteractingCharacterReachDoorHandle) == 0x000278, "Member 'ADoor::OnInteractingCharacterReachDoorHandle' has a wrong offset!");
static_assert(offsetof(ADoor, OnDoorUnlocked) == 0x000288, "Member 'ADoor::OnDoorUnlocked' has a wrong offset!");
static_assert(offsetof(ADoor, OnLockStateSet) == 0x000298, "Member 'ADoor::OnLockStateSet' has a wrong offset!");
static_assert(offsetof(ADoor, OnDoorOpened) == 0x0002A8, "Member 'ADoor::OnDoorOpened' has a wrong offset!");
static_assert(offsetof(ADoor, DoorMesh) == 0x0002B8, "Member 'ADoor::DoorMesh' has a wrong offset!");
static_assert(offsetof(ADoor, DoorKnob) == 0x0002C0, "Member 'ADoor::DoorKnob' has a wrong offset!");
static_assert(offsetof(ADoor, DoorHandle) == 0x0002C8, "Member 'ADoor::DoorHandle' has a wrong offset!");
static_assert(offsetof(ADoor, DoorBolt) == 0x0002D0, "Member 'ADoor::DoorBolt' has a wrong offset!");
static_assert(offsetof(ADoor, DoorBoltLatch) == 0x0002D8, "Member 'ADoor::DoorBoltLatch' has a wrong offset!");
static_assert(offsetof(ADoor, DoorRoot) == 0x0002E0, "Member 'ADoor::DoorRoot' has a wrong offset!");
static_assert(offsetof(ADoor, KeyMesh) == 0x0002E8, "Member 'ADoor::KeyMesh' has a wrong offset!");
static_assert(offsetof(ADoor, KeyArrowLocation) == 0x0002F0, "Member 'ADoor::KeyArrowLocation' has a wrong offset!");
static_assert(offsetof(ADoor, DoorArrowMiddlePoint) == 0x0002F8, "Member 'ADoor::DoorArrowMiddlePoint' has a wrong offset!");
static_assert(offsetof(ADoor, SprintOpenDirection) == 0x000300, "Member 'ADoor::SprintOpenDirection' has a wrong offset!");
static_assert(offsetof(ADoor, SprintOpenAngle) == 0x000308, "Member 'ADoor::SprintOpenAngle' has a wrong offset!");
static_assert(offsetof(ADoor, DoorInteractionComponent) == 0x000310, "Member 'ADoor::DoorInteractionComponent' has a wrong offset!");
static_assert(offsetof(ADoor, PersistenceComponent) == 0x000318, "Member 'ADoor::PersistenceComponent' has a wrong offset!");
static_assert(offsetof(ADoor, MapMarkerComponent) == 0x000320, "Member 'ADoor::MapMarkerComponent' has a wrong offset!");
static_assert(offsetof(ADoor, LockState) == 0x000328, "Member 'ADoor::LockState' has a wrong offset!");
static_assert(offsetof(ADoor, DoorSprintCheckVolume) == 0x000330, "Member 'ADoor::DoorSprintCheckVolume' has a wrong offset!");
static_assert(offsetof(ADoor, BoltSpringArmComponent) == 0x000338, "Member 'ADoor::BoltSpringArmComponent' has a wrong offset!");
static_assert(offsetof(ADoor, BoltCameraComponent) == 0x000340, "Member 'ADoor::BoltCameraComponent' has a wrong offset!");
static_assert(offsetof(ADoor, KeySpringArmComponent) == 0x000348, "Member 'ADoor::KeySpringArmComponent' has a wrong offset!");
static_assert(offsetof(ADoor, KeyCameraComponent) == 0x000350, "Member 'ADoor::KeyCameraComponent' has a wrong offset!");
static_assert(offsetof(ADoor, ClockwiseTravelpoint) == 0x000358, "Member 'ADoor::ClockwiseTravelpoint' has a wrong offset!");
static_assert(offsetof(ADoor, NotClockwiseTravelpoint) == 0x000360, "Member 'ADoor::NotClockwiseTravelpoint' has a wrong offset!");
static_assert(offsetof(ADoor, ChildClockwiseTravelpoint) == 0x000368, "Member 'ADoor::ChildClockwiseTravelpoint' has a wrong offset!");
static_assert(offsetof(ADoor, ChildNotClockwiseTravelpoint) == 0x000370, "Member 'ADoor::ChildNotClockwiseTravelpoint' has a wrong offset!");
static_assert(offsetof(ADoor, AnimationEnvironmentSettings) == 0x000378, "Member 'ADoor::AnimationEnvironmentSettings' has a wrong offset!");
static_assert(offsetof(ADoor, DoorCurveMap) == 0x000380, "Member 'ADoor::DoorCurveMap' has a wrong offset!");
static_assert(offsetof(ADoor, DoorCurveMapTagOverrides) == 0x0003D0, "Member 'ADoor::DoorCurveMapTagOverrides' has a wrong offset!");
static_assert(offsetof(ADoor, DoorCloseCurve) == 0x000420, "Member 'ADoor::DoorCloseCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorOpenRunningCurve) == 0x000428, "Member 'ADoor::DoorOpenRunningCurve' has a wrong offset!");
static_assert(offsetof(ADoor, BoltLatchCurve) == 0x000430, "Member 'ADoor::BoltLatchCurve' has a wrong offset!");
static_assert(offsetof(ADoor, DoorOpenState) == 0x0004C0, "Member 'ADoor::DoorOpenState' has a wrong offset!");
static_assert(offsetof(ADoor, StartDoorOpenState) == 0x0004C1, "Member 'ADoor::StartDoorOpenState' has a wrong offset!");
static_assert(offsetof(ADoor, bClockwise_Bolted) == 0x0004C3, "Member 'ADoor::bClockwise_Bolted' has a wrong offset!");
static_assert(offsetof(ADoor, bPlayFirstTimeOpenCinematic) == 0x0004C4, "Member 'ADoor::bPlayFirstTimeOpenCinematic' has a wrong offset!");
static_assert(offsetof(ADoor, KeyCameraLocation) == 0x0004C8, "Member 'ADoor::KeyCameraLocation' has a wrong offset!");
static_assert(offsetof(ADoor, SprintingTag) == 0x0004D8, "Member 'ADoor::SprintingTag' has a wrong offset!");
static_assert(offsetof(ADoor, AnimationTagOpen) == 0x0004F8, "Member 'ADoor::AnimationTagOpen' has a wrong offset!");
static_assert(offsetof(ADoor, AnimationTagOpenSprint) == 0x000500, "Member 'ADoor::AnimationTagOpenSprint' has a wrong offset!");
static_assert(offsetof(ADoor, AnimationTagLockedCombatClockwise) == 0x000508, "Member 'ADoor::AnimationTagLockedCombatClockwise' has a wrong offset!");
static_assert(offsetof(ADoor, AnimationTagLockedCombatCounterClockwise) == 0x000510, "Member 'ADoor::AnimationTagLockedCombatCounterClockwise' has a wrong offset!");
static_assert(offsetof(ADoor, AnimationTagFirstTimeOpening) == 0x000518, "Member 'ADoor::AnimationTagFirstTimeOpening' has a wrong offset!");
static_assert(offsetof(ADoor, CameraModiferToDisable) == 0x000520, "Member 'ADoor::CameraModiferToDisable' has a wrong offset!");
static_assert(offsetof(ADoor, DoorOpenRightSectionName) == 0x000F40, "Member 'ADoor::DoorOpenRightSectionName' has a wrong offset!");
static_assert(offsetof(ADoor, DoorOpenLeftSectionName) == 0x000F48, "Member 'ADoor::DoorOpenLeftSectionName' has a wrong offset!");
static_assert(offsetof(ADoor, DoorFailRightSectionName) == 0x000F50, "Member 'ADoor::DoorFailRightSectionName' has a wrong offset!");
static_assert(offsetof(ADoor, DoorFailLeftSectionName) == 0x000F58, "Member 'ADoor::DoorFailLeftSectionName' has a wrong offset!");
static_assert(offsetof(ADoor, KeyLocationSocketName) == 0x000F60, "Member 'ADoor::KeyLocationSocketName' has a wrong offset!");
static_assert(offsetof(ADoor, ClockwiseMaxOpenAngel) == 0x000F68, "Member 'ADoor::ClockwiseMaxOpenAngel' has a wrong offset!");
static_assert(offsetof(ADoor, NotClockwiseMaxOpenAngel) == 0x000F6C, "Member 'ADoor::NotClockwiseMaxOpenAngel' has a wrong offset!");
static_assert(offsetof(ADoor, KeyItem) == 0x000F70, "Member 'ADoor::KeyItem' has a wrong offset!");
static_assert(offsetof(ADoor, InteractingPlayer) == 0x000FA0, "Member 'ADoor::InteractingPlayer' has a wrong offset!");
static_assert(offsetof(ADoor, DoorOpenSound) == 0x000FB0, "Member 'ADoor::DoorOpenSound' has a wrong offset!");
static_assert(offsetof(ADoor, DoorSprintOpenSound) == 0x000FD8, "Member 'ADoor::DoorSprintOpenSound' has a wrong offset!");
static_assert(offsetof(ADoor, DoorClosingSound) == 0x001000, "Member 'ADoor::DoorClosingSound' has a wrong offset!");
static_assert(offsetof(ADoor, DoorBoltSound) == 0x001028, "Member 'ADoor::DoorBoltSound' has a wrong offset!");
static_assert(offsetof(ADoor, DoorKeySound) == 0x001050, "Member 'ADoor::DoorKeySound' has a wrong offset!");
static_assert(offsetof(ADoor, DoorClosedEndSound) == 0x001078, "Member 'ADoor::DoorClosedEndSound' has a wrong offset!");
static_assert(offsetof(ADoor, DoorLockedSound) == 0x0010A0, "Member 'ADoor::DoorLockedSound' has a wrong offset!");
static_assert(offsetof(ADoor, CameraPlayerToDoorBlendTime) == 0x0010C8, "Member 'ADoor::CameraPlayerToDoorBlendTime' has a wrong offset!");
static_assert(offsetof(ADoor, CameraDoorToPlayerBlendTime) == 0x0010CC, "Member 'ADoor::CameraDoorToPlayerBlendTime' has a wrong offset!");
static_assert(offsetof(ADoor, WhereOnTimeLineToPlayClosedSound) == 0x0010D0, "Member 'ADoor::WhereOnTimeLineToPlayClosedSound' has a wrong offset!");
static_assert(offsetof(ADoor, bUseAsTrigger) == 0x0010D4, "Member 'ADoor::bUseAsTrigger' has a wrong offset!");
static_assert(offsetof(ADoor, FlowDoorComponent) == 0x0010F8, "Member 'ADoor::FlowDoorComponent' has a wrong offset!");
static_assert(offsetof(ADoor, BoltedExtraInteractionIcon) == 0x001100, "Member 'ADoor::BoltedExtraInteractionIcon' has a wrong offset!");
static_assert(offsetof(ADoor, ChapterSelectFactTag_LockState) == 0x001128, "Member 'ADoor::ChapterSelectFactTag_LockState' has a wrong offset!");
static_assert(offsetof(ADoor, ChapterSelectFactTag_OpenState) == 0x001130, "Member 'ADoor::ChapterSelectFactTag_OpenState' has a wrong offset!");
static_assert(offsetof(ADoor, AutoCloseMaxDistance) == 0x001138, "Member 'ADoor::AutoCloseMaxDistance' has a wrong offset!");
static_assert(offsetof(ADoor, bSprintOpenEnabled) == 0x00113C, "Member 'ADoor::bSprintOpenEnabled' has a wrong offset!");
static_assert(offsetof(ADoor, ShouldWaitForLevelsToBeLoadedBeforeOpeningDoor) == 0x00113D, "Member 'ADoor::ShouldWaitForLevelsToBeLoadedBeforeOpeningDoor' has a wrong offset!");
static_assert(offsetof(ADoor, CurrentPlayingOpenMontage) == 0x001358, "Member 'ADoor::CurrentPlayingOpenMontage' has a wrong offset!");
static_assert(offsetof(ADoor, SpawnedLoadingThrobberWidget) == 0x001360, "Member 'ADoor::SpawnedLoadingThrobberWidget' has a wrong offset!");

// Class ObsidianFox.DoubleDoor
// 0x0030 (0x1450 - 0x1420)
class ADoubleDoor : public ADoor
{
public:
	class UStaticMeshComponent*                   DoubleDoorMesh;                                    // 0x1418(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SecondDoorHandleTag;                               // 0x1420(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, SimpleDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NotClockwiseMaxOpenAngelSecondDoor;                // 0x1428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClockwiseMaxOpenAngelSecondDoor;                   // 0x142C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1430[0x20];                                    // 0x1430(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoubleDoor">();
	}
	static class ADoubleDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoubleDoor>();
	}
};
static_assert(alignof(ADoubleDoor) == 0x000010, "Wrong alignment on ADoubleDoor");
static_assert(sizeof(ADoubleDoor) == 0x001450, "Wrong size on ADoubleDoor");
static_assert(offsetof(ADoubleDoor, DoubleDoorMesh) == 0x001418, "Member 'ADoubleDoor::DoubleDoorMesh' has a wrong offset!");
static_assert(offsetof(ADoubleDoor, SecondDoorHandleTag) == 0x001420, "Member 'ADoubleDoor::SecondDoorHandleTag' has a wrong offset!");
static_assert(offsetof(ADoubleDoor, NotClockwiseMaxOpenAngelSecondDoor) == 0x001428, "Member 'ADoubleDoor::NotClockwiseMaxOpenAngelSecondDoor' has a wrong offset!");
static_assert(offsetof(ADoubleDoor, ClockwiseMaxOpenAngelSecondDoor) == 0x00142C, "Member 'ADoubleDoor::ClockwiseMaxOpenAngelSecondDoor' has a wrong offset!");

// Class ObsidianFox.ItemData
// 0x0140 (0x0170 - 0x0030)
class UItemData : public UDataAsset
{
public:
	TArray<struct FItemDisplayInfo>               ItemDisplayInfos;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             ItemMesh;                                          // 0x0040(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ItemVisualBlueprint;                               // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mesh;                                              // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStackable;                                        // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsImportant;                                      // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxStack;                                          // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFMODEvent>              PickupSound;                                       // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemData*                              ItemToAdd;                                         // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemCategory;                                      // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemDisplayInfoType                          ItemDisplayInfoType;                               // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemType                                     ItemType;                                          // 0x00D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AssociatedChapter;                                 // 0x00DC(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ProgressionLifetime;                               // 0x00E8(0x0020)(Edit, NativeAccessSpecifierPublic)
	bool                                          bShouldNeverArchive;                               // 0x0108(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultDiscoveryRange;                             // 0x010C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultSelectionRange;                             // 0x0110(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPickupAnimation : 1;                              // 0x0114(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	EItemPickupAnimationType                      AnimationType;                                     // 0x0115(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_116[0x2];                                      // 0x0116(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPlayerCharacterType, TSoftObjectPtr<class ULevelSequence>> PickupSequences;                                   // 0x0118(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x8];                                      // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FVector2D GetTextureSizeFromDisplayInfo(const struct FItemDisplayInfo& Info);

	class UStaticMesh* GetMesh();
	class UFMODEvent* GetPickupSoundEvent();

	const struct FItemDisplayInfo GetDisplayInfoAtIndex(const int32 Index_0) const;
	const struct FItemDisplayInfo GetFirstItemDisplayInfo() const;
	int32 GetNextDisplayInfoIndexOfASet(int32 Index_0) const;
	int32 GetNumItemDisplayInfos() const;
	int32 GetPreviousDisplayInfoIndexOfASet(int32 Index_0) const;
	bool IsPartOfItems() const;
	bool IsSetOfItems() const;
	bool LifetimeIncludesProgressionTag(const struct FGameplayTag& ProgressionTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemData">();
	}
	static class UItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemData>();
	}
};
static_assert(alignof(UItemData) == 0x000008, "Wrong alignment on UItemData");
static_assert(sizeof(UItemData) == 0x000170, "Wrong size on UItemData");
static_assert(offsetof(UItemData, ItemDisplayInfos) == 0x000030, "Member 'UItemData::ItemDisplayInfos' has a wrong offset!");
static_assert(offsetof(UItemData, ItemMesh) == 0x000040, "Member 'UItemData::ItemMesh' has a wrong offset!");
static_assert(offsetof(UItemData, ItemVisualBlueprint) == 0x000068, "Member 'UItemData::ItemVisualBlueprint' has a wrong offset!");
static_assert(offsetof(UItemData, Mesh) == 0x000090, "Member 'UItemData::Mesh' has a wrong offset!");
static_assert(offsetof(UItemData, bStackable) == 0x000098, "Member 'UItemData::bStackable' has a wrong offset!");
static_assert(offsetof(UItemData, bIsImportant) == 0x000099, "Member 'UItemData::bIsImportant' has a wrong offset!");
static_assert(offsetof(UItemData, MaxStack) == 0x00009C, "Member 'UItemData::MaxStack' has a wrong offset!");
static_assert(offsetof(UItemData, PickupSound) == 0x0000A0, "Member 'UItemData::PickupSound' has a wrong offset!");
static_assert(offsetof(UItemData, ItemToAdd) == 0x0000C8, "Member 'UItemData::ItemToAdd' has a wrong offset!");
static_assert(offsetof(UItemData, ItemCategory) == 0x0000D0, "Member 'UItemData::ItemCategory' has a wrong offset!");
static_assert(offsetof(UItemData, ItemDisplayInfoType) == 0x0000D8, "Member 'UItemData::ItemDisplayInfoType' has a wrong offset!");
static_assert(offsetof(UItemData, ItemType) == 0x0000D9, "Member 'UItemData::ItemType' has a wrong offset!");
static_assert(offsetof(UItemData, AssociatedChapter) == 0x0000DC, "Member 'UItemData::AssociatedChapter' has a wrong offset!");
static_assert(offsetof(UItemData, ProgressionLifetime) == 0x0000E8, "Member 'UItemData::ProgressionLifetime' has a wrong offset!");
static_assert(offsetof(UItemData, bShouldNeverArchive) == 0x000108, "Member 'UItemData::bShouldNeverArchive' has a wrong offset!");
static_assert(offsetof(UItemData, DefaultDiscoveryRange) == 0x00010C, "Member 'UItemData::DefaultDiscoveryRange' has a wrong offset!");
static_assert(offsetof(UItemData, DefaultSelectionRange) == 0x000110, "Member 'UItemData::DefaultSelectionRange' has a wrong offset!");
static_assert(offsetof(UItemData, AnimationType) == 0x000115, "Member 'UItemData::AnimationType' has a wrong offset!");
static_assert(offsetof(UItemData, PickupSequences) == 0x000118, "Member 'UItemData::PickupSequences' has a wrong offset!");

// Class ObsidianFox.ItemData_Puzzle
// 0x0028 (0x0198 - 0x0170)
class UItemData_Puzzle final : public UItemData
{
public:
	TSoftClassPtr<class UClass>                   PuzzleBlueprint;                                   // 0x0170(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemData_Puzzle">();
	}
	static class UItemData_Puzzle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemData_Puzzle>();
	}
};
static_assert(alignof(UItemData_Puzzle) == 0x000008, "Wrong alignment on UItemData_Puzzle");
static_assert(sizeof(UItemData_Puzzle) == 0x000198, "Wrong size on UItemData_Puzzle");
static_assert(offsetof(UItemData_Puzzle, PuzzleBlueprint) == 0x000170, "Member 'UItemData_Puzzle::PuzzleBlueprint' has a wrong offset!");

// Class ObsidianFox.DynamicConsumableSpawner
// 0x0070 (0x02A8 - 0x0238)
class ADynamicConsumableSpawner : public AActor
{
public:
	uint8                                         Pad_238[0x10];                                     // 0x0238(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bSpawnedInContainer : 1;                           // 0x0248(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	EConsumableType                               ConsumableType;                                    // 0x0249(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24A[0x2];                                      // 0x024A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaximumSpottingRange;                              // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumSpottingRange;                              // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VisibilityCheckHeightOffset;                       // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AItemPickup>                ItemPickupClass;                                   // 0x0258(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseTargetVariation;                               // 0x0260(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UCurveFloat>             WeightCurve;                                       // 0x0268(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AItemPickup*                            ItemPickupRef;                                     // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPersistenceComponent*                  PersistenceComponent;                              // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A0[0x1];                                      // 0x02A0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasBeenPickedUp;                                  // 0x02A1(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A2[0x6];                                      // 0x02A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetAmountOfItems();
	void ItemPickedUp();
	void OnItemSpawned();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicConsumableSpawner">();
	}
	static class ADynamicConsumableSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicConsumableSpawner>();
	}
};
static_assert(alignof(ADynamicConsumableSpawner) == 0x000008, "Wrong alignment on ADynamicConsumableSpawner");
static_assert(sizeof(ADynamicConsumableSpawner) == 0x0002A8, "Wrong size on ADynamicConsumableSpawner");
static_assert(offsetof(ADynamicConsumableSpawner, ConsumableType) == 0x000249, "Member 'ADynamicConsumableSpawner::ConsumableType' has a wrong offset!");
static_assert(offsetof(ADynamicConsumableSpawner, MaximumSpottingRange) == 0x00024C, "Member 'ADynamicConsumableSpawner::MaximumSpottingRange' has a wrong offset!");
static_assert(offsetof(ADynamicConsumableSpawner, MinimumSpottingRange) == 0x000250, "Member 'ADynamicConsumableSpawner::MinimumSpottingRange' has a wrong offset!");
static_assert(offsetof(ADynamicConsumableSpawner, VisibilityCheckHeightOffset) == 0x000254, "Member 'ADynamicConsumableSpawner::VisibilityCheckHeightOffset' has a wrong offset!");
static_assert(offsetof(ADynamicConsumableSpawner, ItemPickupClass) == 0x000258, "Member 'ADynamicConsumableSpawner::ItemPickupClass' has a wrong offset!");
static_assert(offsetof(ADynamicConsumableSpawner, bUseTargetVariation) == 0x000260, "Member 'ADynamicConsumableSpawner::bUseTargetVariation' has a wrong offset!");
static_assert(offsetof(ADynamicConsumableSpawner, WeightCurve) == 0x000268, "Member 'ADynamicConsumableSpawner::WeightCurve' has a wrong offset!");
static_assert(offsetof(ADynamicConsumableSpawner, ItemPickupRef) == 0x000290, "Member 'ADynamicConsumableSpawner::ItemPickupRef' has a wrong offset!");
static_assert(offsetof(ADynamicConsumableSpawner, PersistenceComponent) == 0x000298, "Member 'ADynamicConsumableSpawner::PersistenceComponent' has a wrong offset!");
static_assert(offsetof(ADynamicConsumableSpawner, bHasBeenPickedUp) == 0x0002A1, "Member 'ADynamicConsumableSpawner::bHasBeenPickedUp' has a wrong offset!");

// Class ObsidianFox.DynamicEnvironmentZoneComponent
// 0x0240 (0x02F8 - 0x00B8)
class UDynamicEnvironmentZoneComponent final : public UActorComponent
{
public:
	int32                                         MaxInteractionEvents;                              // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInteractionLayer                      WaterInteractionLayer;                             // 0x00C0(0x00E0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FInteractionLayer                      TerrainInteractionLayer;                           // 0x01A0(0x00E0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           MPC;                                               // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   RadiusParamName;                                   // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AlphaParamName;                                    // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   OriginParamName;                                   // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       MaterialBrushes;                                   // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   ProgressionParamName;                              // 0x02B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WorldLocationParamName;                            // 0x02B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StrengthParamName;                                 // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VelocityParamName;                                 // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HeightAboveGroundParamName;                        // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CacheBrushTextureParamName;                        // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CacheFalloffParamName;                             // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ModeFadeDuration;                                  // 0x02E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentFadeTime;                                   // 0x02EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETerrainMaterialType                          TerrainType;                                       // 0x02F0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F1[0x7];                                      // 0x02F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateInteractionType(const EEnvironmentInteractionType Type);
	void ClearLayerRenderTargets(const struct FInteractionLayer& InteractionLayer);
	void DeactivateInteractionType(const EEnvironmentInteractionType Type);
	void DEZInteraction(const struct FVector& WorldLocation, const EEnvironmentInteractionType& Type, const struct FVector& Velocity, const float Duration, const float Size, const float Strength, const float HeightAboveGround, const class FString& EventTag, const bool DrawPerPixel);
	void DEZInteractionWithCustomMaterial(const struct FVector& WorldLocation, class UMaterialInterface* InteractionMat, const EEnvironmentInteractionType& Type, const struct FVector& Velocity, const float Duration, const float Size, const float Strength, const float HeightAboveGround, const class FString& EventTag, const bool DrawPerPixel);
	void DrawMaterialToCanvas(class UCanvas* Canvas, class UMaterialInterface* Material, const struct FVector2D& RelativeLocation, const struct FVector2D& Size, const float& CanvasWorldSize);
	void OnSwitchPlayerCharacter(const class AOFPlayerCharacter* Character);
	void SetTerrainType(const ETerrainMaterialType NewTerrainType);
	void UpdateInteractionLayerRenderTargets(float DeltaTime, struct FInteractionLayer* InteractionLayer);

	ETerrainMaterialType GetTerrainType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicEnvironmentZoneComponent">();
	}
	static class UDynamicEnvironmentZoneComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicEnvironmentZoneComponent>();
	}
};
static_assert(alignof(UDynamicEnvironmentZoneComponent) == 0x000008, "Wrong alignment on UDynamicEnvironmentZoneComponent");
static_assert(sizeof(UDynamicEnvironmentZoneComponent) == 0x0002F8, "Wrong size on UDynamicEnvironmentZoneComponent");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, MaxInteractionEvents) == 0x0000B8, "Member 'UDynamicEnvironmentZoneComponent::MaxInteractionEvents' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, WaterInteractionLayer) == 0x0000C0, "Member 'UDynamicEnvironmentZoneComponent::WaterInteractionLayer' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, TerrainInteractionLayer) == 0x0001A0, "Member 'UDynamicEnvironmentZoneComponent::TerrainInteractionLayer' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, MPC) == 0x000280, "Member 'UDynamicEnvironmentZoneComponent::MPC' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, RadiusParamName) == 0x000288, "Member 'UDynamicEnvironmentZoneComponent::RadiusParamName' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, AlphaParamName) == 0x000290, "Member 'UDynamicEnvironmentZoneComponent::AlphaParamName' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, OriginParamName) == 0x000298, "Member 'UDynamicEnvironmentZoneComponent::OriginParamName' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, MaterialBrushes) == 0x0002A0, "Member 'UDynamicEnvironmentZoneComponent::MaterialBrushes' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, ProgressionParamName) == 0x0002B0, "Member 'UDynamicEnvironmentZoneComponent::ProgressionParamName' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, WorldLocationParamName) == 0x0002B8, "Member 'UDynamicEnvironmentZoneComponent::WorldLocationParamName' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, StrengthParamName) == 0x0002C0, "Member 'UDynamicEnvironmentZoneComponent::StrengthParamName' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, VelocityParamName) == 0x0002C8, "Member 'UDynamicEnvironmentZoneComponent::VelocityParamName' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, HeightAboveGroundParamName) == 0x0002D0, "Member 'UDynamicEnvironmentZoneComponent::HeightAboveGroundParamName' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, CacheBrushTextureParamName) == 0x0002D8, "Member 'UDynamicEnvironmentZoneComponent::CacheBrushTextureParamName' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, CacheFalloffParamName) == 0x0002E0, "Member 'UDynamicEnvironmentZoneComponent::CacheFalloffParamName' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, ModeFadeDuration) == 0x0002E8, "Member 'UDynamicEnvironmentZoneComponent::ModeFadeDuration' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, CurrentFadeTime) == 0x0002EC, "Member 'UDynamicEnvironmentZoneComponent::CurrentFadeTime' has a wrong offset!");
static_assert(offsetof(UDynamicEnvironmentZoneComponent, TerrainType) == 0x0002F0, "Member 'UDynamicEnvironmentZoneComponent::TerrainType' has a wrong offset!");

// Class ObsidianFox.OFBFL_Abilities
// 0x0000 (0x0028 - 0x0028)
class UOFBFL_Abilities final : public UBlueprintFunctionLibrary
{
public:
	static void AddLooseGameplayTag(class AObsidianFoxCharacter* InOFCharacter, const struct FGameplayTag& InGameplayTag);
	static class UAbilitySystemComponent* GetPlayerAbilitySystemComponent(const struct FGameplayAbilityActorInfo& ActorInfo, const int32 PlayerIndex);
	static void HandleWeakPoints(class AOFEnemyCharacter* EnemyCharacter, const struct FGameplayEffectContextHandle& ContextHandle, float WeakPointDamage, const struct FGameplayTagContainer& SourceTags);
	static void RemoveLooseGameplayTag(class AObsidianFoxCharacter* InOFCharacter, const struct FGameplayTag& InGameplayTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFBFL_Abilities">();
	}
	static class UOFBFL_Abilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFBFL_Abilities>();
	}
};
static_assert(alignof(UOFBFL_Abilities) == 0x000008, "Wrong alignment on UOFBFL_Abilities");
static_assert(sizeof(UOFBFL_Abilities) == 0x000028, "Wrong size on UOFBFL_Abilities");

// Class ObsidianFox.DynamicMaterialEffectsComponent
// 0x0088 (0x0140 - 0x00B8)
class UDynamicMaterialEffectsComponent final : public UActorComponent
{
public:
	TArray<struct FMaterialScalarInterpData>      ScalarInterpData;                                  // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TSet<class UMaterialInstanceDynamic*>         DynamicMaterials;                                  // 0x00C8(0x0050)(Edit, BlueprintVisible, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          bDefineSpecificMaterialElements;                   // 0x0118(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 DynamicMaterialElements;                           // 0x0120(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          InitializeMaterialsAtBeginPlay;                    // 0x0130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyMeshesTag;                                    // 0x0131(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_132[0x2];                                      // 0x0132(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MeshTag;                                           // 0x0134(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeMaterialParameterOverTime(class FName Name_0, float TargetValue, float ChangeDuration);
	void InitializeDynamicMaterials();
	void InterpScalarParameterOnMaterials(const struct FMaterialParameterInfo& ParameterInfo, float TargetValue, float ChangeDuration);
	void SetParameterOnMaterials(class FName Name_0, float Value);
	void SetScalarParameterOnMaterials(const struct FMaterialParameterInfo& ParameterInfo, float Value);
	void SetVectorParameterOnMaterial(class FName Name_0, const struct FLinearColor& Value);
	void SetVectorParameterOnMaterials(const struct FMaterialParameterInfo& ParameterInfo, const struct FLinearColor& Value);
	void StopChangesToParameter(class FName Name_0);
	void StopParameterInterpolation(const struct FMaterialParameterInfo& ParameterInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicMaterialEffectsComponent">();
	}
	static class UDynamicMaterialEffectsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicMaterialEffectsComponent>();
	}
};
static_assert(alignof(UDynamicMaterialEffectsComponent) == 0x000008, "Wrong alignment on UDynamicMaterialEffectsComponent");
static_assert(sizeof(UDynamicMaterialEffectsComponent) == 0x000140, "Wrong size on UDynamicMaterialEffectsComponent");
static_assert(offsetof(UDynamicMaterialEffectsComponent, ScalarInterpData) == 0x0000B8, "Member 'UDynamicMaterialEffectsComponent::ScalarInterpData' has a wrong offset!");
static_assert(offsetof(UDynamicMaterialEffectsComponent, DynamicMaterials) == 0x0000C8, "Member 'UDynamicMaterialEffectsComponent::DynamicMaterials' has a wrong offset!");
static_assert(offsetof(UDynamicMaterialEffectsComponent, bDefineSpecificMaterialElements) == 0x000118, "Member 'UDynamicMaterialEffectsComponent::bDefineSpecificMaterialElements' has a wrong offset!");
static_assert(offsetof(UDynamicMaterialEffectsComponent, DynamicMaterialElements) == 0x000120, "Member 'UDynamicMaterialEffectsComponent::DynamicMaterialElements' has a wrong offset!");
static_assert(offsetof(UDynamicMaterialEffectsComponent, InitializeMaterialsAtBeginPlay) == 0x000130, "Member 'UDynamicMaterialEffectsComponent::InitializeMaterialsAtBeginPlay' has a wrong offset!");
static_assert(offsetof(UDynamicMaterialEffectsComponent, bOnlyMeshesTag) == 0x000131, "Member 'UDynamicMaterialEffectsComponent::bOnlyMeshesTag' has a wrong offset!");
static_assert(offsetof(UDynamicMaterialEffectsComponent, MeshTag) == 0x000134, "Member 'UDynamicMaterialEffectsComponent::MeshTag' has a wrong offset!");

// Class ObsidianFox.DynamicVectorFieldManager
// 0x00D8 (0x0190 - 0x00B8)
class UDynamicVectorFieldManager final : public UActorComponent
{
public:
	class UNiagaraParameterCollection*            NiagaraCollection;                                 // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSystemEnabled;                                  // 0x00C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GridSizeX;                                         // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GridSizeY;                                         // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GridSizeZ;                                         // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GridSpacing;                                       // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                GridCenterOffset;                                  // 0x00D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForceDecaySpeed;                                   // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GridSizeXParamName;                                // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 GridSizeYParamName;                                // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 GridSizeZParamName;                                // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 GridSpacingParamName;                              // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ManagerLocationParamName;                          // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 IsActiveParamName;                                 // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugVectorField;                                 // 0x0148(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugLineLength;                                   // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugSize;                                         // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UNiagaraParameterCollectionInstance*    NiagaraCollectionInstance;                         // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        VectorField;                                       // 0x0160(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        VectorFieldLocations;                              // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FVectorFieldInteraction>        VectorFieldInteractions;                           // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void AddBurstForceToVectorField(const struct FVector& ForceCenter, float Strength, float Radius);

	bool GetIsSystemEnabled() const;
	const TArray<struct FVector> GetVectorField() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicVectorFieldManager">();
	}
	static class UDynamicVectorFieldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDynamicVectorFieldManager>();
	}
};
static_assert(alignof(UDynamicVectorFieldManager) == 0x000008, "Wrong alignment on UDynamicVectorFieldManager");
static_assert(sizeof(UDynamicVectorFieldManager) == 0x000190, "Wrong size on UDynamicVectorFieldManager");
static_assert(offsetof(UDynamicVectorFieldManager, NiagaraCollection) == 0x0000B8, "Member 'UDynamicVectorFieldManager::NiagaraCollection' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, bIsSystemEnabled) == 0x0000C0, "Member 'UDynamicVectorFieldManager::bIsSystemEnabled' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, GridSizeX) == 0x0000C4, "Member 'UDynamicVectorFieldManager::GridSizeX' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, GridSizeY) == 0x0000C8, "Member 'UDynamicVectorFieldManager::GridSizeY' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, GridSizeZ) == 0x0000CC, "Member 'UDynamicVectorFieldManager::GridSizeZ' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, GridSpacing) == 0x0000D0, "Member 'UDynamicVectorFieldManager::GridSpacing' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, GridCenterOffset) == 0x0000D4, "Member 'UDynamicVectorFieldManager::GridCenterOffset' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, ForceDecaySpeed) == 0x0000E0, "Member 'UDynamicVectorFieldManager::ForceDecaySpeed' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, GridSizeXParamName) == 0x0000E8, "Member 'UDynamicVectorFieldManager::GridSizeXParamName' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, GridSizeYParamName) == 0x0000F8, "Member 'UDynamicVectorFieldManager::GridSizeYParamName' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, GridSizeZParamName) == 0x000108, "Member 'UDynamicVectorFieldManager::GridSizeZParamName' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, GridSpacingParamName) == 0x000118, "Member 'UDynamicVectorFieldManager::GridSpacingParamName' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, ManagerLocationParamName) == 0x000128, "Member 'UDynamicVectorFieldManager::ManagerLocationParamName' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, IsActiveParamName) == 0x000138, "Member 'UDynamicVectorFieldManager::IsActiveParamName' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, bDebugVectorField) == 0x000148, "Member 'UDynamicVectorFieldManager::bDebugVectorField' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, DebugLineLength) == 0x00014C, "Member 'UDynamicVectorFieldManager::DebugLineLength' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, DebugSize) == 0x000150, "Member 'UDynamicVectorFieldManager::DebugSize' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, NiagaraCollectionInstance) == 0x000158, "Member 'UDynamicVectorFieldManager::NiagaraCollectionInstance' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, VectorField) == 0x000160, "Member 'UDynamicVectorFieldManager::VectorField' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, VectorFieldLocations) == 0x000170, "Member 'UDynamicVectorFieldManager::VectorFieldLocations' has a wrong offset!");
static_assert(offsetof(UDynamicVectorFieldManager, VectorFieldInteractions) == 0x000180, "Member 'UDynamicVectorFieldManager::VectorFieldInteractions' has a wrong offset!");

// Class ObsidianFox.OFAnimSaveGameDataContainerComponent
// 0x0060 (0x0118 - 0x00B8)
class UOFAnimSaveGameDataContainerComponent : public UActorComponent
{
public:
	TMap<class FName, struct FSaveablePoseSnapshot> SavedSnapshots;                                    // 0x00B8(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	TArray<int32>                                 DismemberedIndices;                                // 0x0108(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFAnimSaveGameDataContainerComponent">();
	}
	static class UOFAnimSaveGameDataContainerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFAnimSaveGameDataContainerComponent>();
	}
};
static_assert(alignof(UOFAnimSaveGameDataContainerComponent) == 0x000008, "Wrong alignment on UOFAnimSaveGameDataContainerComponent");
static_assert(sizeof(UOFAnimSaveGameDataContainerComponent) == 0x000118, "Wrong size on UOFAnimSaveGameDataContainerComponent");
static_assert(offsetof(UOFAnimSaveGameDataContainerComponent, SavedSnapshots) == 0x0000B8, "Member 'UOFAnimSaveGameDataContainerComponent::SavedSnapshots' has a wrong offset!");
static_assert(offsetof(UOFAnimSaveGameDataContainerComponent, DismemberedIndices) == 0x000108, "Member 'UOFAnimSaveGameDataContainerComponent::DismemberedIndices' has a wrong offset!");

// Class ObsidianFox.OFPlayerAnimInstanceSaveGameDataContainerComponent
// 0x0040 (0x0158 - 0x0118)
class UOFPlayerAnimInstanceSaveGameDataContainerComponent final : public UOFAnimSaveGameDataContainerComponent
{
public:
	bool                                          bIsForcedCombatState;                              // 0x0118(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequenceBase*                      FaceAnimationBaseLayerOverride;                    // 0x0120(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FaceAnimationBaseLayerOverrideBlendTime;           // 0x0128(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UObject>                 FaceAnimationLockReference;                        // 0x0130(0x0028)(SaveGame, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFPlayerAnimInstanceSaveGameDataContainerComponent">();
	}
	static class UOFPlayerAnimInstanceSaveGameDataContainerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFPlayerAnimInstanceSaveGameDataContainerComponent>();
	}
};
static_assert(alignof(UOFPlayerAnimInstanceSaveGameDataContainerComponent) == 0x000008, "Wrong alignment on UOFPlayerAnimInstanceSaveGameDataContainerComponent");
static_assert(sizeof(UOFPlayerAnimInstanceSaveGameDataContainerComponent) == 0x000158, "Wrong size on UOFPlayerAnimInstanceSaveGameDataContainerComponent");
static_assert(offsetof(UOFPlayerAnimInstanceSaveGameDataContainerComponent, bIsForcedCombatState) == 0x000118, "Member 'UOFPlayerAnimInstanceSaveGameDataContainerComponent::bIsForcedCombatState' has a wrong offset!");
static_assert(offsetof(UOFPlayerAnimInstanceSaveGameDataContainerComponent, FaceAnimationBaseLayerOverride) == 0x000120, "Member 'UOFPlayerAnimInstanceSaveGameDataContainerComponent::FaceAnimationBaseLayerOverride' has a wrong offset!");
static_assert(offsetof(UOFPlayerAnimInstanceSaveGameDataContainerComponent, FaceAnimationBaseLayerOverrideBlendTime) == 0x000128, "Member 'UOFPlayerAnimInstanceSaveGameDataContainerComponent::FaceAnimationBaseLayerOverrideBlendTime' has a wrong offset!");
static_assert(offsetof(UOFPlayerAnimInstanceSaveGameDataContainerComponent, FaceAnimationLockReference) == 0x000130, "Member 'UOFPlayerAnimInstanceSaveGameDataContainerComponent::FaceAnimationLockReference' has a wrong offset!");

// Class ObsidianFox.DynamicWaterfall
// 0x0000 (0x0238 - 0x0238)
class ADynamicWaterfall final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DynamicWaterfall">();
	}
	static class ADynamicWaterfall* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADynamicWaterfall>();
	}
};
static_assert(alignof(ADynamicWaterfall) == 0x000008, "Wrong alignment on ADynamicWaterfall");
static_assert(sizeof(ADynamicWaterfall) == 0x000238, "Wrong size on ADynamicWaterfall");

// Class ObsidianFox.EmoteComponent
// 0x0068 (0x0120 - 0x00B8)
class UEmoteComponent : public UActorComponent
{
public:
	class AObsidianFoxCharacter*                  Owner;                                             // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDisabled : 1;                                     // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BlockedByTags;                                     // 0x00C8(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         EmoteCooldownTime;                                 // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EmoteChance;                                       // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CurrentEmoteMontage;                               // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCachedAnimStateData                   IdleState;                                         // 0x0100(0x001C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C[0x1];                                      // 0x011C(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EAnimationLocomotionState                     OwnerLocomotionState;                              // 0x011D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11E[0x2];                                      // 0x011E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FEmoteMontageDataParameter AddRandomDecoratorToParameter(const struct FEmoteMontageDataParameter& Parameter);
	static struct FEmoteMontageDataParameter AddSectionDecoratorToParameter(const struct FEmoteMontageDataParameter& Parameter, class FName Section);
	static struct FEmoteMontageDataParameter MakeListEmoteMontageData(const TArray<class UAnimMontage*>& Montages);
	static struct FEmoteMontageDataParameter MakeSingleEmoteMontageData(class UAnimMontage* Montage);

	void EmoteDone();
	struct FEmotePlayData GetEmote();
	bool GetEmoteShouldOnlyPlayWhenIdle();
	void OnEmoteDone();
	void OnMontageBlendingOut(class UAnimMontage* AnimMontage, bool bInterrupted);
	void OnOwnerCinematicModeChanged(bool NewCinematicMode);
	void PlayRandomEmoteFromMontage(class UAnimMontage* AnimMontage);
	void PlayRandomEmoteMontageFromList(const TArray<class UAnimMontage*>& AnimMontages, bool bPickRandomSection);
	void SetDisabled(bool Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EmoteComponent">();
	}
	static class UEmoteComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEmoteComponent>();
	}
};
static_assert(alignof(UEmoteComponent) == 0x000008, "Wrong alignment on UEmoteComponent");
static_assert(sizeof(UEmoteComponent) == 0x000120, "Wrong size on UEmoteComponent");
static_assert(offsetof(UEmoteComponent, Owner) == 0x0000B8, "Member 'UEmoteComponent::Owner' has a wrong offset!");
static_assert(offsetof(UEmoteComponent, BlockedByTags) == 0x0000C8, "Member 'UEmoteComponent::BlockedByTags' has a wrong offset!");
static_assert(offsetof(UEmoteComponent, EmoteCooldownTime) == 0x0000E8, "Member 'UEmoteComponent::EmoteCooldownTime' has a wrong offset!");
static_assert(offsetof(UEmoteComponent, EmoteChance) == 0x0000F0, "Member 'UEmoteComponent::EmoteChance' has a wrong offset!");
static_assert(offsetof(UEmoteComponent, CurrentEmoteMontage) == 0x0000F8, "Member 'UEmoteComponent::CurrentEmoteMontage' has a wrong offset!");
static_assert(offsetof(UEmoteComponent, IdleState) == 0x000100, "Member 'UEmoteComponent::IdleState' has a wrong offset!");
static_assert(offsetof(UEmoteComponent, OwnerLocomotionState) == 0x00011D, "Member 'UEmoteComponent::OwnerLocomotionState' has a wrong offset!");

// Class ObsidianFox.ItemData_Consumable
// 0x0038 (0x01A8 - 0x0170)
class UItemData_Consumable final : public UItemData
{
public:
	TSubclassOf<class UGameplayEffect>            GameplayEffect;                                    // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFMODEvent>              UseSound;                                          // 0x0178(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ProhibitUseWithFullHealth;                         // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemData_Consumable">();
	}
	static class UItemData_Consumable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemData_Consumable>();
	}
};
static_assert(alignof(UItemData_Consumable) == 0x000008, "Wrong alignment on UItemData_Consumable");
static_assert(sizeof(UItemData_Consumable) == 0x0001A8, "Wrong size on UItemData_Consumable");
static_assert(offsetof(UItemData_Consumable, GameplayEffect) == 0x000170, "Member 'UItemData_Consumable::GameplayEffect' has a wrong offset!");
static_assert(offsetof(UItemData_Consumable, UseSound) == 0x000178, "Member 'UItemData_Consumable::UseSound' has a wrong offset!");
static_assert(offsetof(UItemData_Consumable, ProhibitUseWithFullHealth) == 0x0001A0, "Member 'UItemData_Consumable::ProhibitUseWithFullHealth' has a wrong offset!");

// Class ObsidianFox.SubtitleTextWidget
// 0x0010 (0x0270 - 0x0260)
class USubtitleTextWidget : public UUserWidget
{
public:
	class UTextBlock*                             SubtitleText;                                      // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSubtitleDoneHandler();
	void OnSubtitleSizeChanged(ESubtitleSizes NewSubtitleSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitleTextWidget">();
	}
	static class USubtitleTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitleTextWidget>();
	}
};
static_assert(alignof(USubtitleTextWidget) == 0x000008, "Wrong alignment on USubtitleTextWidget");
static_assert(sizeof(USubtitleTextWidget) == 0x000270, "Wrong size on USubtitleTextWidget");
static_assert(offsetof(USubtitleTextWidget, SubtitleText) == 0x000260, "Member 'USubtitleTextWidget::SubtitleText' has a wrong offset!");

// Class ObsidianFox.HealthBarHud
// 0x0008 (0x0280 - 0x0278)
class UHealthBarHud : public UInGameUIWidget
{
public:
	class AObsidianFoxCharacter*                  CharacterRef;                                      // 0x0278(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthBarHud">();
	}
	static class UHealthBarHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthBarHud>();
	}
};
static_assert(alignof(UHealthBarHud) == 0x000008, "Wrong alignment on UHealthBarHud");
static_assert(sizeof(UHealthBarHud) == 0x000280, "Wrong size on UHealthBarHud");
static_assert(offsetof(UHealthBarHud, CharacterRef) == 0x000278, "Member 'UHealthBarHud::CharacterRef' has a wrong offset!");

// Class ObsidianFox.LocationTrackingVolume
// 0x0020 (0x0290 - 0x0270)
class ALocationTrackingVolume final : public AVolume
{
public:
	struct FGameplayTagContainer                  LocationTags;                                      // 0x0270(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void ComponentBeginOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bFromSweep, const struct FHitResult& InSweepResult);
	void ComponentEndOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocationTrackingVolume">();
	}
	static class ALocationTrackingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALocationTrackingVolume>();
	}
};
static_assert(alignof(ALocationTrackingVolume) == 0x000008, "Wrong alignment on ALocationTrackingVolume");
static_assert(sizeof(ALocationTrackingVolume) == 0x000290, "Wrong size on ALocationTrackingVolume");
static_assert(offsetof(ALocationTrackingVolume, LocationTags) == 0x000270, "Member 'ALocationTrackingVolume::LocationTags' has a wrong offset!");

// Class ObsidianFox.EnemeyHealthBarHud
// 0x0018 (0x0298 - 0x0280)
class UEnemeyHealthBarHud final : public UHealthBarHud
{
public:
	bool                                          bShowBar;                                          // 0x0280(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBar50Percent;                                 // 0x0281(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_282[0x16];                                     // 0x0282(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FadeBar50Percent();
	void FadeIn();
	void FadeIn50pPercent();
	void FadeOut();
	void UpdateHealthBar();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemeyHealthBarHud">();
	}
	static class UEnemeyHealthBarHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemeyHealthBarHud>();
	}
};
static_assert(alignof(UEnemeyHealthBarHud) == 0x000008, "Wrong alignment on UEnemeyHealthBarHud");
static_assert(sizeof(UEnemeyHealthBarHud) == 0x000298, "Wrong size on UEnemeyHealthBarHud");
static_assert(offsetof(UEnemeyHealthBarHud, bShowBar) == 0x000280, "Member 'UEnemeyHealthBarHud::bShowBar' has a wrong offset!");
static_assert(offsetof(UEnemeyHealthBarHud, bShowBar50Percent) == 0x000281, "Member 'UEnemeyHealthBarHud::bShowBar50Percent' has a wrong offset!");

// Class ObsidianFox.WorldSubsystem_MusicPlayer
// 0x0008 (0x0038 - 0x0030)
class UWorldSubsystem_MusicPlayer final : public UWorldSubsystem
{
public:
	struct FFMODEventInstance                     EventMusicInstance;                                // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void NewMusic(const TSoftObjectPtr<class UFMODEvent> Music);
	void PauseMusic();
	void PlayerIsInCombat(const bool bInCombat);
	void ResumeMusic();
	void SetParameter(const class FString& ParamterName, const float ParamterValue);
	void StopMusic();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldSubsystem_MusicPlayer">();
	}
	static class UWorldSubsystem_MusicPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldSubsystem_MusicPlayer>();
	}
};
static_assert(alignof(UWorldSubsystem_MusicPlayer) == 0x000008, "Wrong alignment on UWorldSubsystem_MusicPlayer");
static_assert(sizeof(UWorldSubsystem_MusicPlayer) == 0x000038, "Wrong size on UWorldSubsystem_MusicPlayer");
static_assert(offsetof(UWorldSubsystem_MusicPlayer, EventMusicInstance) == 0x000030, "Member 'UWorldSubsystem_MusicPlayer::EventMusicInstance' has a wrong offset!");

// Class ObsidianFox.EnemiesWithinRangeComponent
// 0x0040 (0x00F8 - 0x00B8)
class UEnemiesWithinRangeComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnCombatStatusChanged;                             // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         EnemiesCombatSearchRadius;                         // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x24];                                      // 0x00CC(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasEnemiesWithinRange;                            // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetEnemiesWithinDistance(const float Distance, TArray<class AOFEnemyCharacter*>* OutList);
	void OnCombatStatusChanged__DelegateSignature(bool bEnterCombat);

	class AOFEnemyCharacter* GetClosestEnemyCharacterWithinCombatRange() const;
	const TArray<class AOFEnemyCharacter*> GetEnemiesWithinCombatRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemiesWithinRangeComponent">();
	}
	static class UEnemiesWithinRangeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnemiesWithinRangeComponent>();
	}
};
static_assert(alignof(UEnemiesWithinRangeComponent) == 0x000008, "Wrong alignment on UEnemiesWithinRangeComponent");
static_assert(sizeof(UEnemiesWithinRangeComponent) == 0x0000F8, "Wrong size on UEnemiesWithinRangeComponent");
static_assert(offsetof(UEnemiesWithinRangeComponent, OnCombatStatusChanged) == 0x0000B8, "Member 'UEnemiesWithinRangeComponent::OnCombatStatusChanged' has a wrong offset!");
static_assert(offsetof(UEnemiesWithinRangeComponent, EnemiesCombatSearchRadius) == 0x0000C8, "Member 'UEnemiesWithinRangeComponent::EnemiesCombatSearchRadius' has a wrong offset!");
static_assert(offsetof(UEnemiesWithinRangeComponent, bHasEnemiesWithinRange) == 0x0000F0, "Member 'UEnemiesWithinRangeComponent::bHasEnemiesWithinRange' has a wrong offset!");

// Class ObsidianFox.JointAlignerComponent
// 0x0088 (0x0140 - 0x00B8)
class alignas(0x10) UJointAlignerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x78];                                      // 0x00B8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         BitPad_130_0 : 3;                                  // 0x0130(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bAlign2D : 1;                                      // 0x0130(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         ReferenceMesh;                                     // 0x0138(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JointAlignerComponent">();
	}
	static class UJointAlignerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJointAlignerComponent>();
	}
};
static_assert(alignof(UJointAlignerComponent) == 0x000010, "Wrong alignment on UJointAlignerComponent");
static_assert(sizeof(UJointAlignerComponent) == 0x000140, "Wrong size on UJointAlignerComponent");
static_assert(offsetof(UJointAlignerComponent, ReferenceMesh) == 0x000138, "Member 'UJointAlignerComponent::ReferenceMesh' has a wrong offset!");

// Class ObsidianFox.EnemyAnimInterface
// 0x0000 (0x0028 - 0x0028)
class IEnemyAnimInterface final : public IInterface
{
public:
	void EndEnemyIntro();
	void SkipSpawnAnimation();
	void StartEnemyIntro();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyAnimInterface">();
	}
	static class IEnemyAnimInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IEnemyAnimInterface>();
	}
};
static_assert(alignof(IEnemyAnimInterface) == 0x000008, "Wrong alignment on IEnemyAnimInterface");
static_assert(sizeof(IEnemyAnimInterface) == 0x000028, "Wrong size on IEnemyAnimInterface");

// Class ObsidianFox.EnemySpawner
// 0x0088 (0x02C0 - 0x0238)
class AEnemySpawner : public AActor
{
public:
	TSubclassOf<class AOFEnemyCharacter>          EnemyClass;                                        // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSpawned;                                         // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	class USceneComponent*                        SpawnPoint;                                        // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESpawnMethod                                  SpawnMethod;                                       // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESaveMethod                                   SaveMethod;                                        // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPoolCollisionType                            PoolCollisionType;                                 // 0x0260(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHasDied;                                          // 0x0261(0x0001)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262[0xE];                                      // 0x0262(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DeathTransform;                                    // 0x0270(0x0030)(BlueprintVisible, SaveGame, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UOFAnimSaveGameDataContainerComponent*  AnimationSaveGameDataContainerComponent;           // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPersistenceComponent*                  PersistenceComponent;                              // 0x02A8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   UniqueSaveName;                                    // 0x02B0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AOFEnemyCharacter*                      SpawnedEnemy;                                      // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DespawnManually();
	void OnSpawnCompleted__DelegateSignature(class AOFEnemyCharacter* SpawnedEnemy_0, class AAIController* SpawnedAICOntroller, class AEnemySpawner* Spawner);
	void SpawnEnemy();
	class AOFEnemyCharacter* SpawnManually();

	struct FTransform GetSpawnTransform() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemySpawner">();
	}
	static class AEnemySpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemySpawner>();
	}
};
static_assert(alignof(AEnemySpawner) == 0x000010, "Wrong alignment on AEnemySpawner");
static_assert(sizeof(AEnemySpawner) == 0x0002C0, "Wrong size on AEnemySpawner");
static_assert(offsetof(AEnemySpawner, EnemyClass) == 0x000238, "Member 'AEnemySpawner::EnemyClass' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, OnSpawned) == 0x000240, "Member 'AEnemySpawner::OnSpawned' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, SpawnPoint) == 0x000250, "Member 'AEnemySpawner::SpawnPoint' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, SpawnMethod) == 0x000258, "Member 'AEnemySpawner::SpawnMethod' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, SaveMethod) == 0x00025C, "Member 'AEnemySpawner::SaveMethod' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, PoolCollisionType) == 0x000260, "Member 'AEnemySpawner::PoolCollisionType' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, bHasDied) == 0x000261, "Member 'AEnemySpawner::bHasDied' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, DeathTransform) == 0x000270, "Member 'AEnemySpawner::DeathTransform' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, AnimationSaveGameDataContainerComponent) == 0x0002A0, "Member 'AEnemySpawner::AnimationSaveGameDataContainerComponent' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, PersistenceComponent) == 0x0002A8, "Member 'AEnemySpawner::PersistenceComponent' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, UniqueSaveName) == 0x0002B0, "Member 'AEnemySpawner::UniqueSaveName' has a wrong offset!");
static_assert(offsetof(AEnemySpawner, SpawnedEnemy) == 0x0002B8, "Member 'AEnemySpawner::SpawnedEnemy' has a wrong offset!");

// Class ObsidianFox.WeaponAnimationDataAsset
// 0x0028 (0x0058 - 0x0030)
class UWeaponAnimationDataAsset final : public UDataAsset
{
public:
	struct FGameplayTag                           HolsterMontageTag;                                 // 0x0030(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           UnholsterMontageTag;                               // 0x0038(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SwitchWeaponMontageTag;                            // 0x0040(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           FireMontageTag;                                    // 0x0048(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ReloadMontageTag;                                  // 0x0050(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FWeaponAnimationData GetAnimationDataForCharacter(const class AOFPlayerCharacter* Character, bool bEnsureAnimationsAreLoaded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAnimationDataAsset">();
	}
	static class UWeaponAnimationDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAnimationDataAsset>();
	}
};
static_assert(alignof(UWeaponAnimationDataAsset) == 0x000008, "Wrong alignment on UWeaponAnimationDataAsset");
static_assert(sizeof(UWeaponAnimationDataAsset) == 0x000058, "Wrong size on UWeaponAnimationDataAsset");
static_assert(offsetof(UWeaponAnimationDataAsset, HolsterMontageTag) == 0x000030, "Member 'UWeaponAnimationDataAsset::HolsterMontageTag' has a wrong offset!");
static_assert(offsetof(UWeaponAnimationDataAsset, UnholsterMontageTag) == 0x000038, "Member 'UWeaponAnimationDataAsset::UnholsterMontageTag' has a wrong offset!");
static_assert(offsetof(UWeaponAnimationDataAsset, SwitchWeaponMontageTag) == 0x000040, "Member 'UWeaponAnimationDataAsset::SwitchWeaponMontageTag' has a wrong offset!");
static_assert(offsetof(UWeaponAnimationDataAsset, FireMontageTag) == 0x000048, "Member 'UWeaponAnimationDataAsset::FireMontageTag' has a wrong offset!");
static_assert(offsetof(UWeaponAnimationDataAsset, ReloadMontageTag) == 0x000050, "Member 'UWeaponAnimationDataAsset::ReloadMontageTag' has a wrong offset!");

// Class ObsidianFox.EnemyWeakPoint
// 0x0010 (0x0248 - 0x0238)
class AEnemyWeakPoint final : public AActor
{
public:
	uint8                                         Pad_238[0x10];                                     // 0x0238(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnemyWeakPoint">();
	}
	static class AEnemyWeakPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnemyWeakPoint>();
	}
};
static_assert(alignof(AEnemyWeakPoint) == 0x000008, "Wrong alignment on AEnemyWeakPoint");
static_assert(sizeof(AEnemyWeakPoint) == 0x000248, "Wrong size on AEnemyWeakPoint");

// Class ObsidianFox.WorldSubSystem_FootIKDebugger
// 0x0070 (0x00A0 - 0x0030)
class UWorldSubSystem_FootIKDebugger final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldSubSystem_FootIKDebugger">();
	}
	static class UWorldSubSystem_FootIKDebugger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldSubSystem_FootIKDebugger>();
	}
};
static_assert(alignof(UWorldSubSystem_FootIKDebugger) == 0x000008, "Wrong alignment on UWorldSubSystem_FootIKDebugger");
static_assert(sizeof(UWorldSubSystem_FootIKDebugger) == 0x0000A0, "Wrong size on UWorldSubSystem_FootIKDebugger");

// Class ObsidianFox.EnvironmentAsset
// 0x0010 (0x0040 - 0x0030)
class UEnvironmentAsset final : public UDataAsset
{
public:
	TArray<struct FGameplayTag>                   EnvironmentTag;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentAsset">();
	}
	static class UEnvironmentAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvironmentAsset>();
	}
};
static_assert(alignof(UEnvironmentAsset) == 0x000008, "Wrong alignment on UEnvironmentAsset");
static_assert(sizeof(UEnvironmentAsset) == 0x000040, "Wrong size on UEnvironmentAsset");
static_assert(offsetof(UEnvironmentAsset, EnvironmentTag) == 0x000030, "Member 'UEnvironmentAsset::EnvironmentTag' has a wrong offset!");

// Class ObsidianFox.OFAttributeSet
// 0x0040 (0x0070 - 0x0030)
class UOFAttributeSet : public UAttributeSet
{
public:
	struct FOFGameplayAttributeData               Health;                                            // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	struct FOFGameplayAttributeData               MaxHealth;                                         // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	struct FOFGameplayAttributeData               Damage;                                            // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	struct FOFGameplayAttributeData               MoveSpeed;                                         // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFAttributeSet">();
	}
	static class UOFAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFAttributeSet>();
	}
};
static_assert(alignof(UOFAttributeSet) == 0x000008, "Wrong alignment on UOFAttributeSet");
static_assert(sizeof(UOFAttributeSet) == 0x000070, "Wrong size on UOFAttributeSet");
static_assert(offsetof(UOFAttributeSet, Health) == 0x000030, "Member 'UOFAttributeSet::Health' has a wrong offset!");
static_assert(offsetof(UOFAttributeSet, MaxHealth) == 0x000040, "Member 'UOFAttributeSet::MaxHealth' has a wrong offset!");
static_assert(offsetof(UOFAttributeSet, Damage) == 0x000050, "Member 'UOFAttributeSet::Damage' has a wrong offset!");
static_assert(offsetof(UOFAttributeSet, MoveSpeed) == 0x000060, "Member 'UOFAttributeSet::MoveSpeed' has a wrong offset!");

// Class ObsidianFox.OFEnemyAttributeSet
// 0x0010 (0x0080 - 0x0070)
class UOFEnemyAttributeSet : public UOFAttributeSet
{
public:
	struct FOFGameplayAttributeData               WeakPointsDamage;                                  // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFEnemyAttributeSet">();
	}
	static class UOFEnemyAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFEnemyAttributeSet>();
	}
};
static_assert(alignof(UOFEnemyAttributeSet) == 0x000008, "Wrong alignment on UOFEnemyAttributeSet");
static_assert(sizeof(UOFEnemyAttributeSet) == 0x000080, "Wrong size on UOFEnemyAttributeSet");
static_assert(offsetof(UOFEnemyAttributeSet, WeakPointsDamage) == 0x000070, "Member 'UOFEnemyAttributeSet::WeakPointsDamage' has a wrong offset!");

// Class ObsidianFox.SteamboatCreatureAttributeSet
// 0x0000 (0x0080 - 0x0080)
class USteamboatCreatureAttributeSet final : public UOFEnemyAttributeSet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamboatCreatureAttributeSet">();
	}
	static class USteamboatCreatureAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamboatCreatureAttributeSet>();
	}
};
static_assert(alignof(USteamboatCreatureAttributeSet) == 0x000008, "Wrong alignment on USteamboatCreatureAttributeSet");
static_assert(sizeof(USteamboatCreatureAttributeSet) == 0x000080, "Wrong size on USteamboatCreatureAttributeSet");

// Class ObsidianFox.LoadDeveloperSettingsAssetsEngineSubsystem
// 0x0010 (0x0040 - 0x0030)
class ULoadDeveloperSettingsAssetsEngineSubsystem final : public UEngineSubsystem
{
public:
	TSubclassOf<class UOFChunkInstallPopupWidget> ChunkInstallPopupWidget;                           // 0x0030(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                PlatformSpecificKeyWidget;                         // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadDeveloperSettingsAssetsEngineSubsystem">();
	}
	static class ULoadDeveloperSettingsAssetsEngineSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadDeveloperSettingsAssetsEngineSubsystem>();
	}
};
static_assert(alignof(ULoadDeveloperSettingsAssetsEngineSubsystem) == 0x000008, "Wrong alignment on ULoadDeveloperSettingsAssetsEngineSubsystem");
static_assert(sizeof(ULoadDeveloperSettingsAssetsEngineSubsystem) == 0x000040, "Wrong size on ULoadDeveloperSettingsAssetsEngineSubsystem");
static_assert(offsetof(ULoadDeveloperSettingsAssetsEngineSubsystem, ChunkInstallPopupWidget) == 0x000030, "Member 'ULoadDeveloperSettingsAssetsEngineSubsystem::ChunkInstallPopupWidget' has a wrong offset!");
static_assert(offsetof(ULoadDeveloperSettingsAssetsEngineSubsystem, PlatformSpecificKeyWidget) == 0x000038, "Member 'ULoadDeveloperSettingsAssetsEngineSubsystem::PlatformSpecificKeyWidget' has a wrong offset!");

// Class ObsidianFox.EnvironmentDeveloperSettings
// 0x00F0 (0x0128 - 0x0038)
class UEnvironmentDeveloperSettings final : public UDeveloperSettings
{
public:
	struct FEnvironmentVolumeExponentialHeightFogProperties ExponentialHeightFogProperties;                    // 0x0038(0x0030)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FEnvironmentVolumeDirectionalInscatteringProperties DirectionalInscatteringProperties;                 // 0x0068(0x0018)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	struct FEnvironmentVolumeVolumetricFogProperties VolumetricFogProperties;                           // 0x0080(0x002C)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UMaterialParameterCollection> EnvironmentDefaultMaterialParameterCollection;     // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraParameterCollection> EnvironmentDefaultNiagaraParameterCollection;      // 0x00D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             GustCurve;                                         // 0x0100(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentDeveloperSettings">();
	}
	static class UEnvironmentDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvironmentDeveloperSettings>();
	}
};
static_assert(alignof(UEnvironmentDeveloperSettings) == 0x000008, "Wrong alignment on UEnvironmentDeveloperSettings");
static_assert(sizeof(UEnvironmentDeveloperSettings) == 0x000128, "Wrong size on UEnvironmentDeveloperSettings");
static_assert(offsetof(UEnvironmentDeveloperSettings, ExponentialHeightFogProperties) == 0x000038, "Member 'UEnvironmentDeveloperSettings::ExponentialHeightFogProperties' has a wrong offset!");
static_assert(offsetof(UEnvironmentDeveloperSettings, DirectionalInscatteringProperties) == 0x000068, "Member 'UEnvironmentDeveloperSettings::DirectionalInscatteringProperties' has a wrong offset!");
static_assert(offsetof(UEnvironmentDeveloperSettings, VolumetricFogProperties) == 0x000080, "Member 'UEnvironmentDeveloperSettings::VolumetricFogProperties' has a wrong offset!");
static_assert(offsetof(UEnvironmentDeveloperSettings, EnvironmentDefaultMaterialParameterCollection) == 0x0000B0, "Member 'UEnvironmentDeveloperSettings::EnvironmentDefaultMaterialParameterCollection' has a wrong offset!");
static_assert(offsetof(UEnvironmentDeveloperSettings, EnvironmentDefaultNiagaraParameterCollection) == 0x0000D8, "Member 'UEnvironmentDeveloperSettings::EnvironmentDefaultNiagaraParameterCollection' has a wrong offset!");
static_assert(offsetof(UEnvironmentDeveloperSettings, GustCurve) == 0x000100, "Member 'UEnvironmentDeveloperSettings::GustCurve' has a wrong offset!");

// Class ObsidianFox.EnvironmentGameSubSystem
// 0x0010 (0x0040 - 0x0030)
class UEnvironmentGameSubSystem final : public UGameInstanceSubsystem
{
public:
	TWeakObjectPtr<class UEnvironmentWorldSubSystem> EnvironmentWorldSubSystem;                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CharacterInWater(const class AObsidianFoxCharacter* Character, float Percentage);
	void CharacterNotInWater(const class AObsidianFoxCharacter* Character);
	void SetMaterialParamterCollection(class UMaterialParameterCollection* NewMaterialCollection);
	void SetNiagaraParamterCollection(class UNiagaraParameterCollectionInstance* NewNiagaraCollection);

	float GetDegreeCelsius() const;
	struct FEnvironmentStruct GetWeatherStruct() const;
	struct FGameplayTagContainer GetWeatherTag() const;
	float GetWindSpeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentGameSubSystem">();
	}
	static class UEnvironmentGameSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvironmentGameSubSystem>();
	}
};
static_assert(alignof(UEnvironmentGameSubSystem) == 0x000008, "Wrong alignment on UEnvironmentGameSubSystem");
static_assert(sizeof(UEnvironmentGameSubSystem) == 0x000040, "Wrong size on UEnvironmentGameSubSystem");
static_assert(offsetof(UEnvironmentGameSubSystem, EnvironmentWorldSubSystem) == 0x000030, "Member 'UEnvironmentGameSubSystem::EnvironmentWorldSubSystem' has a wrong offset!");

// Class ObsidianFox.MapMarkerActorComponent
// 0x00A0 (0x0530 - 0x0490)
class UMapMarkerActorComponent : public UBoxComponent
{
public:
	bool                                          bAddMarkerManually;                                // 0x0488(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_489[0x7];                                      // 0x0489(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            MarkerMapImage;                                    // 0x0490(0x0088)(Edit, BlueprintVisible, SaveGame, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RoomTag;                                           // 0x0518(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveOnDestroy;                                  // 0x0520(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRoomMarker;                                    // 0x0521(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddMarkerToMap;                                   // 0x0522(0x0001)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseClassAsID;                                      // 0x0523(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapMarkerUniqueID;                                 // 0x0524(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ResetPositionToZero;                               // 0x052C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52D[0x3];                                      // 0x052D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddComponentToMap();
	void AddOrUpdateComponent();
	void CreateMapMarkerUnqiueID();
	void RemoveFromMap();
	void SetUseRoomMarker(const bool InUseRoomMarker);
	void UpdateMapData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMarkerActorComponent">();
	}
	static class UMapMarkerActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapMarkerActorComponent>();
	}
};
static_assert(alignof(UMapMarkerActorComponent) == 0x000010, "Wrong alignment on UMapMarkerActorComponent");
static_assert(sizeof(UMapMarkerActorComponent) == 0x000530, "Wrong size on UMapMarkerActorComponent");
static_assert(offsetof(UMapMarkerActorComponent, bAddMarkerManually) == 0x000488, "Member 'UMapMarkerActorComponent::bAddMarkerManually' has a wrong offset!");
static_assert(offsetof(UMapMarkerActorComponent, MarkerMapImage) == 0x000490, "Member 'UMapMarkerActorComponent::MarkerMapImage' has a wrong offset!");
static_assert(offsetof(UMapMarkerActorComponent, RoomTag) == 0x000518, "Member 'UMapMarkerActorComponent::RoomTag' has a wrong offset!");
static_assert(offsetof(UMapMarkerActorComponent, bRemoveOnDestroy) == 0x000520, "Member 'UMapMarkerActorComponent::bRemoveOnDestroy' has a wrong offset!");
static_assert(offsetof(UMapMarkerActorComponent, bUseRoomMarker) == 0x000521, "Member 'UMapMarkerActorComponent::bUseRoomMarker' has a wrong offset!");
static_assert(offsetof(UMapMarkerActorComponent, bAddMarkerToMap) == 0x000522, "Member 'UMapMarkerActorComponent::bAddMarkerToMap' has a wrong offset!");
static_assert(offsetof(UMapMarkerActorComponent, UseClassAsID) == 0x000523, "Member 'UMapMarkerActorComponent::UseClassAsID' has a wrong offset!");
static_assert(offsetof(UMapMarkerActorComponent, MapMarkerUniqueID) == 0x000524, "Member 'UMapMarkerActorComponent::MapMarkerUniqueID' has a wrong offset!");
static_assert(offsetof(UMapMarkerActorComponent, ResetPositionToZero) == 0x00052C, "Member 'UMapMarkerActorComponent::ResetPositionToZero' has a wrong offset!");

// Class ObsidianFox.EnvironmentVolume
// 0x01A0 (0x0410 - 0x0270)
class AEnvironmentVolume final : public AVolume
{
public:
	bool                                          bUseForLightBuilds;                                // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_271[0x3];                                      // 0x0271(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Priority;                                          // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bEnabled : 1;                                      // 0x0278(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUnbound : 1;                                      // 0x0278(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, Interp, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEnvironmentStruct                     Settings;                                          // 0x0280(0x0170)(Edit, BlueprintVisible, Interp, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F0[0x20];                                     // 0x03F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentVolume">();
	}
	static class AEnvironmentVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEnvironmentVolume>();
	}
};
static_assert(alignof(AEnvironmentVolume) == 0x000008, "Wrong alignment on AEnvironmentVolume");
static_assert(sizeof(AEnvironmentVolume) == 0x000410, "Wrong size on AEnvironmentVolume");
static_assert(offsetof(AEnvironmentVolume, bUseForLightBuilds) == 0x000270, "Member 'AEnvironmentVolume::bUseForLightBuilds' has a wrong offset!");
static_assert(offsetof(AEnvironmentVolume, Priority) == 0x000274, "Member 'AEnvironmentVolume::Priority' has a wrong offset!");
static_assert(offsetof(AEnvironmentVolume, Settings) == 0x000280, "Member 'AEnvironmentVolume::Settings' has a wrong offset!");

// Class ObsidianFox.EnvironmentWorldSubSystem
// 0x03A8 (0x03D8 - 0x0030)
class UEnvironmentWorldSubSystem final : public UWorldSubsystem
{
public:
	FMulticastInlineDelegateProperty_             EnvironmentChanged;                                // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EnvironmentTagChanged;                             // 0x0040(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           MaterialCollection;                                // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UNiagaraParameterCollectionInstance*    NiagaraCollection;                                 // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AEnvironmentVolume>> EnvironmentVolumesPrioSorted;                      // 0x0060(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x260];                                     // 0x0070(0x0260)(Fixing Size After Last Property [ Dumper-7 ])
	class AExponentialHeightFog*                  FogActor;                                          // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UExponentialHeightFogComponent*         FogComponent;                                      // 0x02D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0xF8];                                     // 0x02E0(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CharacterInWater(const class AObsidianFoxCharacter* Character, float Percentage);
	void CharacterNotInWater(const class AObsidianFoxCharacter* Character);
	void GustEvaluate(float Alpha);
	void OnWorldBeginTearDown(class UWorld* World);
	void SetMaterialParameterCollection(class UMaterialParameterCollection* NewMaterialCollection);
	void SetNiagaraParameterCollection(class UNiagaraParameterCollectionInstance* NewNiagaraCollection);

	float GetDegreeCelsius() const;
	struct FEnvironmentStruct GetEnvironmentSettingAtLocation(const struct FVector& Location) const;
	struct FEnvironmentStruct GetWeatherStruct() const;
	struct FGameplayTagContainer GetWeatherTag() const;
	float GetWindSpeed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentWorldSubSystem">();
	}
	static class UEnvironmentWorldSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvironmentWorldSubSystem>();
	}
};
static_assert(alignof(UEnvironmentWorldSubSystem) == 0x000008, "Wrong alignment on UEnvironmentWorldSubSystem");
static_assert(sizeof(UEnvironmentWorldSubSystem) == 0x0003D8, "Wrong size on UEnvironmentWorldSubSystem");
static_assert(offsetof(UEnvironmentWorldSubSystem, EnvironmentChanged) == 0x000030, "Member 'UEnvironmentWorldSubSystem::EnvironmentChanged' has a wrong offset!");
static_assert(offsetof(UEnvironmentWorldSubSystem, EnvironmentTagChanged) == 0x000040, "Member 'UEnvironmentWorldSubSystem::EnvironmentTagChanged' has a wrong offset!");
static_assert(offsetof(UEnvironmentWorldSubSystem, MaterialCollection) == 0x000050, "Member 'UEnvironmentWorldSubSystem::MaterialCollection' has a wrong offset!");
static_assert(offsetof(UEnvironmentWorldSubSystem, NiagaraCollection) == 0x000058, "Member 'UEnvironmentWorldSubSystem::NiagaraCollection' has a wrong offset!");
static_assert(offsetof(UEnvironmentWorldSubSystem, EnvironmentVolumesPrioSorted) == 0x000060, "Member 'UEnvironmentWorldSubSystem::EnvironmentVolumesPrioSorted' has a wrong offset!");
static_assert(offsetof(UEnvironmentWorldSubSystem, FogActor) == 0x0002D0, "Member 'UEnvironmentWorldSubSystem::FogActor' has a wrong offset!");
static_assert(offsetof(UEnvironmentWorldSubSystem, FogComponent) == 0x0002D8, "Member 'UEnvironmentWorldSubSystem::FogComponent' has a wrong offset!");

// Class ObsidianFox.LocomotionStateAnimComponent
// 0x0010 (0x0060 - 0x0050)
class ULocomotionStateAnimComponent : public UAnimComponent
{
public:
	bool                                          bIsOnStairs;                                       // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnimationLocomotionState                     LocomotionState;                                   // 0x0051(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52[0xE];                                       // 0x0052(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceCombatState();
	void ReleaseForceCombatState();

	bool IsForcedCombatState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocomotionStateAnimComponent">();
	}
	static class ULocomotionStateAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocomotionStateAnimComponent>();
	}
};
static_assert(alignof(ULocomotionStateAnimComponent) == 0x000008, "Wrong alignment on ULocomotionStateAnimComponent");
static_assert(sizeof(ULocomotionStateAnimComponent) == 0x000060, "Wrong size on ULocomotionStateAnimComponent");
static_assert(offsetof(ULocomotionStateAnimComponent, bIsOnStairs) == 0x000050, "Member 'ULocomotionStateAnimComponent::bIsOnStairs' has a wrong offset!");
static_assert(offsetof(ULocomotionStateAnimComponent, LocomotionState) == 0x000051, "Member 'ULocomotionStateAnimComponent::LocomotionState' has a wrong offset!");

// Class ObsidianFox.EnvQueryTest_ActiveEmotePoint
// 0x0000 (0x01F8 - 0x01F8)
class UEnvQueryTest_ActiveEmotePoint final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_ActiveEmotePoint">();
	}
	static class UEnvQueryTest_ActiveEmotePoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_ActiveEmotePoint>();
	}
};
static_assert(alignof(UEnvQueryTest_ActiveEmotePoint) == 0x000008, "Wrong alignment on UEnvQueryTest_ActiveEmotePoint");
static_assert(sizeof(UEnvQueryTest_ActiveEmotePoint) == 0x0001F8, "Wrong size on UEnvQueryTest_ActiveEmotePoint");

// Class ObsidianFox.EnvQueryTest_IsAlive
// 0x0000 (0x01F8 - 0x01F8)
class UEnvQueryTest_IsAlive final : public UEnvQueryTest
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_IsAlive">();
	}
	static class UEnvQueryTest_IsAlive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_IsAlive>();
	}
};
static_assert(alignof(UEnvQueryTest_IsAlive) == 0x000008, "Wrong alignment on UEnvQueryTest_IsAlive");
static_assert(sizeof(UEnvQueryTest_IsAlive) == 0x0001F8, "Wrong size on UEnvQueryTest_IsAlive");

// Class ObsidianFox.Lever
// 0x0038 (0x0270 - 0x0238)
class ALever final : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnLeverFinished;                                   // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class USceneComponent*                        LeverRootComponent;                                // 0x0248(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   LeverMesh;                                         // 0x0250(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionFlowComponent*              InteractionFlowComponent;                          // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        InteractionLocation;                               // 0x0260(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultMontageSectionName;                         // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AttachLeverMesh(class USceneComponent* InParentComponent, class FName InSocketName);
	void LeverFinishedDelegate__DelegateSignature(class ACharacter* InteractingCharacter);
	void OnFlowBeginInteract(class ACharacter* InteractingCharacter);
	void OnLeverBeginInteraction(class ACharacter* InteractingCharacter);
	void OnLeverMoveDone();
	void OnMontageDone(class ACharacter* InteractingCharacter);
	void OnRepositionDone(class ACharacter* InteractingCharacter);
	void StartMontage(class ACharacter* InteractingCharacter, const struct FGameplayTag& MontageTag, class FName Section, const TArray<struct FIKParameters>& IKParameters);
	void StartMoveLever();
	void StartReposition(class ACharacter* InteractingCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Lever">();
	}
	static class ALever* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALever>();
	}
};
static_assert(alignof(ALever) == 0x000008, "Wrong alignment on ALever");
static_assert(sizeof(ALever) == 0x000270, "Wrong size on ALever");
static_assert(offsetof(ALever, OnLeverFinished) == 0x000238, "Member 'ALever::OnLeverFinished' has a wrong offset!");
static_assert(offsetof(ALever, LeverRootComponent) == 0x000248, "Member 'ALever::LeverRootComponent' has a wrong offset!");
static_assert(offsetof(ALever, LeverMesh) == 0x000250, "Member 'ALever::LeverMesh' has a wrong offset!");
static_assert(offsetof(ALever, InteractionFlowComponent) == 0x000258, "Member 'ALever::InteractionFlowComponent' has a wrong offset!");
static_assert(offsetof(ALever, InteractionLocation) == 0x000260, "Member 'ALever::InteractionLocation' has a wrong offset!");
static_assert(offsetof(ALever, DefaultMontageSectionName) == 0x000268, "Member 'ALever::DefaultMontageSectionName' has a wrong offset!");

// Class ObsidianFox.EnvQueryTest_OFPathfinding
// 0x0088 (0x0280 - 0x01F8)
class UEnvQueryTest_OFPathfinding final : public UEnvQueryTest
{
public:
	EEnvTestOFPathfinding                         TestMode;                                          // 0x01F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F9[0x3];                                      // 0x01F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndPointDiffrenceThreshold;                        // 0x01FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               PathFromContext;                                   // 0x0208(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               SkipUnreachable;                                   // 0x0240(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_OFPathfinding">();
	}
	static class UEnvQueryTest_OFPathfinding* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_OFPathfinding>();
	}
};
static_assert(alignof(UEnvQueryTest_OFPathfinding) == 0x000008, "Wrong alignment on UEnvQueryTest_OFPathfinding");
static_assert(sizeof(UEnvQueryTest_OFPathfinding) == 0x000280, "Wrong size on UEnvQueryTest_OFPathfinding");
static_assert(offsetof(UEnvQueryTest_OFPathfinding, TestMode) == 0x0001F8, "Member 'UEnvQueryTest_OFPathfinding::TestMode' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_OFPathfinding, EndPointDiffrenceThreshold) == 0x0001FC, "Member 'UEnvQueryTest_OFPathfinding::EndPointDiffrenceThreshold' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_OFPathfinding, Context) == 0x000200, "Member 'UEnvQueryTest_OFPathfinding::Context' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_OFPathfinding, PathFromContext) == 0x000208, "Member 'UEnvQueryTest_OFPathfinding::PathFromContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_OFPathfinding, SkipUnreachable) == 0x000240, "Member 'UEnvQueryTest_OFPathfinding::SkipUnreachable' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_OFPathfinding, FilterClass) == 0x000278, "Member 'UEnvQueryTest_OFPathfinding::FilterClass' has a wrong offset!");

// Class ObsidianFox.EnvQueryTest_VisionTrace
// 0x00E8 (0x02E0 - 0x01F8)
class UEnvQueryTest_VisionTrace final : public UEnvQueryTest
{
public:
	struct FEnvTraceData                          TraceData;                                         // 0x01F8(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FAIDataProviderBoolValue               TraceFromContext;                                  // 0x0228(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ItemHeightOffset;                                  // 0x0260(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	struct FAIDataProviderFloatValue              ContextHeightOffset;                               // 0x0298(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemRadius;                                        // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryTest_VisionTrace">();
	}
	static class UEnvQueryTest_VisionTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryTest_VisionTrace>();
	}
};
static_assert(alignof(UEnvQueryTest_VisionTrace) == 0x000008, "Wrong alignment on UEnvQueryTest_VisionTrace");
static_assert(sizeof(UEnvQueryTest_VisionTrace) == 0x0002E0, "Wrong size on UEnvQueryTest_VisionTrace");
static_assert(offsetof(UEnvQueryTest_VisionTrace, TraceData) == 0x0001F8, "Member 'UEnvQueryTest_VisionTrace::TraceData' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_VisionTrace, TraceFromContext) == 0x000228, "Member 'UEnvQueryTest_VisionTrace::TraceFromContext' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_VisionTrace, ItemHeightOffset) == 0x000260, "Member 'UEnvQueryTest_VisionTrace::ItemHeightOffset' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_VisionTrace, ContextHeightOffset) == 0x000298, "Member 'UEnvQueryTest_VisionTrace::ContextHeightOffset' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_VisionTrace, Context) == 0x0002D0, "Member 'UEnvQueryTest_VisionTrace::Context' has a wrong offset!");
static_assert(offsetof(UEnvQueryTest_VisionTrace, ItemRadius) == 0x0002D8, "Member 'UEnvQueryTest_VisionTrace::ItemRadius' has a wrong offset!");

// Class ObsidianFox.MenuInventorySectionHud
// 0x0030 (0x0290 - 0x0260)
class UMenuInventorySectionHud final : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             SlotUpdated;                                       // 0x0260(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UUniformGridPanel*                      SlotPanel;                                         // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ActiveSlotIndex;                                   // 0x0278(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelSlot*                             ActiveSlot;                                        // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotsPerRow;                                       // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SlotsPerColumn;                                    // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FindNewActiveSlot(int32 RowNumberToAdd, int32 ColumnNumberToAdd);
	void SetActiveSlot(const int32 IndexNumber);

	class UMenuInventorySelectionSlot* GetActiveMenuSlot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuInventorySectionHud">();
	}
	static class UMenuInventorySectionHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuInventorySectionHud>();
	}
};
static_assert(alignof(UMenuInventorySectionHud) == 0x000008, "Wrong alignment on UMenuInventorySectionHud");
static_assert(sizeof(UMenuInventorySectionHud) == 0x000290, "Wrong size on UMenuInventorySectionHud");
static_assert(offsetof(UMenuInventorySectionHud, SlotUpdated) == 0x000260, "Member 'UMenuInventorySectionHud::SlotUpdated' has a wrong offset!");
static_assert(offsetof(UMenuInventorySectionHud, SlotPanel) == 0x000270, "Member 'UMenuInventorySectionHud::SlotPanel' has a wrong offset!");
static_assert(offsetof(UMenuInventorySectionHud, ActiveSlotIndex) == 0x000278, "Member 'UMenuInventorySectionHud::ActiveSlotIndex' has a wrong offset!");
static_assert(offsetof(UMenuInventorySectionHud, ActiveSlot) == 0x000280, "Member 'UMenuInventorySectionHud::ActiveSlot' has a wrong offset!");
static_assert(offsetof(UMenuInventorySectionHud, SlotsPerRow) == 0x000288, "Member 'UMenuInventorySectionHud::SlotsPerRow' has a wrong offset!");
static_assert(offsetof(UMenuInventorySectionHud, SlotsPerColumn) == 0x00028C, "Member 'UMenuInventorySectionHud::SlotsPerColumn' has a wrong offset!");

// Class ObsidianFox.EQG_NearbyPlayerPoints
// 0x0000 (0x0080 - 0x0080)
class UEQG_NearbyPlayerPoints final : public UEnvQueryGenerator_ProjectedPoints
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EQG_NearbyPlayerPoints">();
	}
	static class UEQG_NearbyPlayerPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEQG_NearbyPlayerPoints>();
	}
};
static_assert(alignof(UEQG_NearbyPlayerPoints) == 0x000008, "Wrong alignment on UEQG_NearbyPlayerPoints");
static_assert(sizeof(UEQG_NearbyPlayerPoints) == 0x000080, "Wrong size on UEQG_NearbyPlayerPoints");

// Class ObsidianFox.EquipmentManager
// 0x0090 (0x0148 - 0x00B8)
class UEquipmentManager final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnWeaponEquip;                                     // 0x00B8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPistolSlotSet;                                   // 0x00C8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FWeaponInfo>                    SpawnedWeapons;                                    // 0x00D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FWeaponInfo                            RangedWeaponSlot;                                  // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FWeaponInfo                            MeleeWeaponSlot;                                   // 0x00F8(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UItemData_Equippable*                   PistolSlot;                                        // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDisableDefaultWeapons : 1;                        // 0x0110(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemData_Equippable*                   DefaultRangedWeapon;                               // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultRangedSocket;                               // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultRangedSocket_Holstered;                     // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultMeleeSocket;                                // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DefaultMeleeSocket_Holstered;                      // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AObsidianFoxCharacter*                  OwningCharacter;                                   // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AttachWeaponToEquipmentSocket(class AOFWeaponActor* Weapon, EEquipmentSocket SocketLocation);
	bool DestroyWeapon(class AOFWeaponActor* WeaponActor);
	struct FWeaponInfo EquipNext(EEquipmentType WeaponType, bool bPrevious);
	struct FWeaponInfo EquipWeapon(class UItemData_Equippable* ItemData);
	TArray<struct FWeaponInfo> GetSpawnedWeapons();
	TMap<class UItemData*, int32> GetTotalAmmoByAmmo();
	TMap<class UItemData_Equippable*, int32> GetTotalAmmoByWeapon();
	bool SetPistolSlot(class UItemData_Equippable* ItemData);
	void WeaponEquipDelegate__DelegateSignature(const struct FWeaponInfo& EquippedWeapon, const struct FWeaponInfo& UnequippedWeapon);
	void WeaponSlotUpdated__DelegateSignature(class UItemData_Equippable* NewWeapon, class UItemData_Equippable* OldWeapon);

	TArray<class UItemData_Equippable*> GetAvailableWeapons(EEquipmentType Equipment) const;
	class AOFWeaponActor* GetCurrentWeaponActor(EEquipmentType WeaponType) const;
	struct FWeaponInfo GetCurrentWeaponInfo(EEquipmentType WeaponType) const;
	class AMeleeWeaponActor* GetMeleeWeapon() const;
	class AHitscanWeaponActor* GetRangedWeapon() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentManager">();
	}
	static class UEquipmentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentManager>();
	}
};
static_assert(alignof(UEquipmentManager) == 0x000008, "Wrong alignment on UEquipmentManager");
static_assert(sizeof(UEquipmentManager) == 0x000148, "Wrong size on UEquipmentManager");
static_assert(offsetof(UEquipmentManager, OnWeaponEquip) == 0x0000B8, "Member 'UEquipmentManager::OnWeaponEquip' has a wrong offset!");
static_assert(offsetof(UEquipmentManager, OnPistolSlotSet) == 0x0000C8, "Member 'UEquipmentManager::OnPistolSlotSet' has a wrong offset!");
static_assert(offsetof(UEquipmentManager, SpawnedWeapons) == 0x0000D8, "Member 'UEquipmentManager::SpawnedWeapons' has a wrong offset!");
static_assert(offsetof(UEquipmentManager, RangedWeaponSlot) == 0x0000E8, "Member 'UEquipmentManager::RangedWeaponSlot' has a wrong offset!");
static_assert(offsetof(UEquipmentManager, MeleeWeaponSlot) == 0x0000F8, "Member 'UEquipmentManager::MeleeWeaponSlot' has a wrong offset!");
static_assert(offsetof(UEquipmentManager, PistolSlot) == 0x000108, "Member 'UEquipmentManager::PistolSlot' has a wrong offset!");
static_assert(offsetof(UEquipmentManager, DefaultRangedWeapon) == 0x000118, "Member 'UEquipmentManager::DefaultRangedWeapon' has a wrong offset!");
static_assert(offsetof(UEquipmentManager, DefaultRangedSocket) == 0x000120, "Member 'UEquipmentManager::DefaultRangedSocket' has a wrong offset!");
static_assert(offsetof(UEquipmentManager, DefaultRangedSocket_Holstered) == 0x000128, "Member 'UEquipmentManager::DefaultRangedSocket_Holstered' has a wrong offset!");
static_assert(offsetof(UEquipmentManager, DefaultMeleeSocket) == 0x000130, "Member 'UEquipmentManager::DefaultMeleeSocket' has a wrong offset!");
static_assert(offsetof(UEquipmentManager, DefaultMeleeSocket_Holstered) == 0x000138, "Member 'UEquipmentManager::DefaultMeleeSocket_Holstered' has a wrong offset!");
static_assert(offsetof(UEquipmentManager, OwningCharacter) == 0x000140, "Member 'UEquipmentManager::OwningCharacter' has a wrong offset!");

// Class ObsidianFox.MansionMap
// 0x0138 (0x0398 - 0x0260)
class UMansionMap : public UUserWidget
{
public:
	class UWidgetSwitcher*                        FloorWidgetSwitcher;                               // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           FloorCanvasMarkers;                                // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             FloorName;                                         // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapMansionFloor*                       GroundFloor;                                       // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapMansionFloor*                       FirstFloor;                                        // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapMansionFloor*                       SecondFloor;                                       // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMapMansionFloor*                       AtticFloor;                                        // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   MapMarkerClass;                                    // 0x0298(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           GroundFloorTag;                                    // 0x02C8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FirstFloorTag;                                     // 0x02D0(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SecondFloorTag;                                    // 0x02D8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           AtticFloorTag;                                     // 0x02E0(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionBack;                                   // 0x02E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionCloseDownWidget;                        // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionSwitchFloor;                            // 0x02F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionShowPlayer;                             // 0x0300(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              ChangeFloorSound;                                  // 0x0308(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x8];                                      // 0x0330(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, TWeakObjectPtr<class UMapMansionFloor>> TagFloorsMap;                                      // 0x0338(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_388[0x10];                                     // 0x0388(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseDown();
	void HighlightPlayerMarker();
	void OnMarkerDataAddedHandler(const struct FMapData& MapDataMaker);
	void OnMarkerDataDeletedHandler(const struct FMapData& MapDataMaker);
	void OnNewRoomExploredHandler(const struct FGameplayTag& NewRoomTag);
	void OpenMenuPressedHandler();
	void SetupInput();
	void ShowMapIsOfNoUseWidget(bool bShowWidget);
	void SwitchFloorHandler(const struct FInputActionValue& InputActionValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MansionMap">();
	}
	static class UMansionMap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMansionMap>();
	}
};
static_assert(alignof(UMansionMap) == 0x000008, "Wrong alignment on UMansionMap");
static_assert(sizeof(UMansionMap) == 0x000398, "Wrong size on UMansionMap");
static_assert(offsetof(UMansionMap, FloorWidgetSwitcher) == 0x000260, "Member 'UMansionMap::FloorWidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UMansionMap, FloorCanvasMarkers) == 0x000268, "Member 'UMansionMap::FloorCanvasMarkers' has a wrong offset!");
static_assert(offsetof(UMansionMap, FloorName) == 0x000270, "Member 'UMansionMap::FloorName' has a wrong offset!");
static_assert(offsetof(UMansionMap, GroundFloor) == 0x000278, "Member 'UMansionMap::GroundFloor' has a wrong offset!");
static_assert(offsetof(UMansionMap, FirstFloor) == 0x000280, "Member 'UMansionMap::FirstFloor' has a wrong offset!");
static_assert(offsetof(UMansionMap, SecondFloor) == 0x000288, "Member 'UMansionMap::SecondFloor' has a wrong offset!");
static_assert(offsetof(UMansionMap, AtticFloor) == 0x000290, "Member 'UMansionMap::AtticFloor' has a wrong offset!");
static_assert(offsetof(UMansionMap, MapMarkerClass) == 0x000298, "Member 'UMansionMap::MapMarkerClass' has a wrong offset!");
static_assert(offsetof(UMansionMap, GroundFloorTag) == 0x0002C8, "Member 'UMansionMap::GroundFloorTag' has a wrong offset!");
static_assert(offsetof(UMansionMap, FirstFloorTag) == 0x0002D0, "Member 'UMansionMap::FirstFloorTag' has a wrong offset!");
static_assert(offsetof(UMansionMap, SecondFloorTag) == 0x0002D8, "Member 'UMansionMap::SecondFloorTag' has a wrong offset!");
static_assert(offsetof(UMansionMap, AtticFloorTag) == 0x0002E0, "Member 'UMansionMap::AtticFloorTag' has a wrong offset!");
static_assert(offsetof(UMansionMap, InputActionBack) == 0x0002E8, "Member 'UMansionMap::InputActionBack' has a wrong offset!");
static_assert(offsetof(UMansionMap, InputActionCloseDownWidget) == 0x0002F0, "Member 'UMansionMap::InputActionCloseDownWidget' has a wrong offset!");
static_assert(offsetof(UMansionMap, InputActionSwitchFloor) == 0x0002F8, "Member 'UMansionMap::InputActionSwitchFloor' has a wrong offset!");
static_assert(offsetof(UMansionMap, InputActionShowPlayer) == 0x000300, "Member 'UMansionMap::InputActionShowPlayer' has a wrong offset!");
static_assert(offsetof(UMansionMap, ChangeFloorSound) == 0x000308, "Member 'UMansionMap::ChangeFloorSound' has a wrong offset!");
static_assert(offsetof(UMansionMap, TagFloorsMap) == 0x000338, "Member 'UMansionMap::TagFloorsMap' has a wrong offset!");

// Class ObsidianFox.EventTrigger
// 0x00D8 (0x0318 - 0x0240)
class AEventTrigger : public ATriggerBox
{
public:
	FMulticastInlineDelegateProperty_             OnEventBegin;                                      // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEventEnd;                                        // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AOFPlayerController>     TriggeringController;                              // 0x0260(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionComponent*                  InteractionComponent;                              // 0x0268(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDisabled : 1;                                     // 0x0270(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseInteractionComponent : 1;                      // 0x0270(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bInteractionComponentStartsActivated : 1;          // 0x0270(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLockPlayerControl : 1;                            // 0x0270(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTakeCameraControl : 1;                            // 0x0270(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPlayAudio : 1;                                    // 0x0270(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPlayMontage : 1;                                  // 0x0270(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPlayMontageRandomSection : 1;                     // 0x0270(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLoadAudioSynchronously : 1;                       // 0x0271(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bMultiUseTrigger : 1;                              // 0x0271(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bLoadAssetsOnBeginPlayAsynchronously : 1;          // 0x0271(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEventUsedUp : 1;                                  // 0x0271(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, SaveGame, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bResetEventUsedUpBeginPlay : 1;                    // 0x0271(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_272[0x6];                                      // 0x0272(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AActor>                  CameraViewTarget;                                  // 0x0278(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FViewTargetTransitionParams            ViewTargetStartParams;                             // 0x02A0(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FViewTargetTransitionParams            ViewTargetEndParams;                               // 0x02B0(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              FMODEvent2D;                                       // 0x02C0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimMontage>            Montage;                                           // 0x02E8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPersistenceComponent*                  LifetimeComponent;                                 // 0x0310(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EndEvent();
	void EventBegin__DelegateSignature(class AEventTrigger* EventTrigger, class APawn* PlayerPawn);
	void EventEnd__DelegateSignature(class AEventTrigger* EventTrigger, class APawn* PlayerPawn);
	void K2_StartEvent();
	void NotifyInteractBegin(class ACharacter* InteractingCharacter);
	void OnMontageEnded(class UAnimMontage* InMontage, bool bInterrupted);
	void SetDisabled(bool bSetDisabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventTrigger">();
	}
	static class AEventTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventTrigger>();
	}
};
static_assert(alignof(AEventTrigger) == 0x000008, "Wrong alignment on AEventTrigger");
static_assert(sizeof(AEventTrigger) == 0x000318, "Wrong size on AEventTrigger");
static_assert(offsetof(AEventTrigger, OnEventBegin) == 0x000240, "Member 'AEventTrigger::OnEventBegin' has a wrong offset!");
static_assert(offsetof(AEventTrigger, OnEventEnd) == 0x000250, "Member 'AEventTrigger::OnEventEnd' has a wrong offset!");
static_assert(offsetof(AEventTrigger, TriggeringController) == 0x000260, "Member 'AEventTrigger::TriggeringController' has a wrong offset!");
static_assert(offsetof(AEventTrigger, InteractionComponent) == 0x000268, "Member 'AEventTrigger::InteractionComponent' has a wrong offset!");
static_assert(offsetof(AEventTrigger, CameraViewTarget) == 0x000278, "Member 'AEventTrigger::CameraViewTarget' has a wrong offset!");
static_assert(offsetof(AEventTrigger, ViewTargetStartParams) == 0x0002A0, "Member 'AEventTrigger::ViewTargetStartParams' has a wrong offset!");
static_assert(offsetof(AEventTrigger, ViewTargetEndParams) == 0x0002B0, "Member 'AEventTrigger::ViewTargetEndParams' has a wrong offset!");
static_assert(offsetof(AEventTrigger, FMODEvent2D) == 0x0002C0, "Member 'AEventTrigger::FMODEvent2D' has a wrong offset!");
static_assert(offsetof(AEventTrigger, Montage) == 0x0002E8, "Member 'AEventTrigger::Montage' has a wrong offset!");
static_assert(offsetof(AEventTrigger, LifetimeComponent) == 0x000310, "Member 'AEventTrigger::LifetimeComponent' has a wrong offset!");

// Class ObsidianFox.FaceAnimInterface
// 0x0000 (0x0028 - 0x0028)
class IFaceAnimInterface final : public IInterface
{
public:
	void ApplyFaceAnimation(const class UObject* Instigator, class UAnimSequenceBase* Animation, float BlendTime);
	void ApplyMouthAnimation(const class UObject* Instigator, class UAnimSequenceBase* Animation, float BlendTime);
	void RemoveFaceAnimation(const class UObject* Instigator, float BlendTime);
	void RemoveMouthAnimation(const class UObject* Instigator, float BlendTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FaceAnimInterface">();
	}
	static class IFaceAnimInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFaceAnimInterface>();
	}
};
static_assert(alignof(IFaceAnimInterface) == 0x000008, "Wrong alignment on IFaceAnimInterface");
static_assert(sizeof(IFaceAnimInterface) == 0x000028, "Wrong size on IFaceAnimInterface");

// Class ObsidianFox.HitReactionHitboxComponent
// 0x0050 (0x04D0 - 0x0480)
class UHitReactionHitboxComponent final : public UCapsuleComponent
{
public:
	struct FReactionMontageContainer              Montages;                                          // 0x0480(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactionHitboxComponent">();
	}
	static class UHitReactionHitboxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactionHitboxComponent>();
	}
};
static_assert(alignof(UHitReactionHitboxComponent) == 0x000010, "Wrong alignment on UHitReactionHitboxComponent");
static_assert(sizeof(UHitReactionHitboxComponent) == 0x0004D0, "Wrong size on UHitReactionHitboxComponent");
static_assert(offsetof(UHitReactionHitboxComponent, Montages) == 0x000480, "Member 'UHitReactionHitboxComponent::Montages' has a wrong offset!");

// Class ObsidianFox.FireSpreadComponent
// 0x0088 (0x0140 - 0x00B8)
class UFireSpreadComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnFireSectionSpread;                               // 0x00B8(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FFireSpreadSection>             FireSpreadSections;                                // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanStartMultipleFires;                            // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFireHasStarted;                                   // 0x00D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DA[0x6];                                       // 0x00DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TimerHandle;                                       // 0x00E0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpreadUpdateFrequency;                             // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UNiagaraSystem>          BurningSectionVFX;                                 // 0x00F0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                FireSpreadSectionsLocationOffset;                  // 0x0118(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               FireSpreadSectionsRotationOffset;                  // 0x0124(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                FireSpreadSectionsScaleMult;                       // 0x0130(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartFireAtLocation(const struct FVector& Location);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireSpreadComponent">();
	}
	static class UFireSpreadComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFireSpreadComponent>();
	}
};
static_assert(alignof(UFireSpreadComponent) == 0x000008, "Wrong alignment on UFireSpreadComponent");
static_assert(sizeof(UFireSpreadComponent) == 0x000140, "Wrong size on UFireSpreadComponent");
static_assert(offsetof(UFireSpreadComponent, OnFireSectionSpread) == 0x0000B8, "Member 'UFireSpreadComponent::OnFireSectionSpread' has a wrong offset!");
static_assert(offsetof(UFireSpreadComponent, FireSpreadSections) == 0x0000C8, "Member 'UFireSpreadComponent::FireSpreadSections' has a wrong offset!");
static_assert(offsetof(UFireSpreadComponent, bCanStartMultipleFires) == 0x0000D8, "Member 'UFireSpreadComponent::bCanStartMultipleFires' has a wrong offset!");
static_assert(offsetof(UFireSpreadComponent, bFireHasStarted) == 0x0000D9, "Member 'UFireSpreadComponent::bFireHasStarted' has a wrong offset!");
static_assert(offsetof(UFireSpreadComponent, TimerHandle) == 0x0000E0, "Member 'UFireSpreadComponent::TimerHandle' has a wrong offset!");
static_assert(offsetof(UFireSpreadComponent, SpreadUpdateFrequency) == 0x0000E8, "Member 'UFireSpreadComponent::SpreadUpdateFrequency' has a wrong offset!");
static_assert(offsetof(UFireSpreadComponent, BurningSectionVFX) == 0x0000F0, "Member 'UFireSpreadComponent::BurningSectionVFX' has a wrong offset!");
static_assert(offsetof(UFireSpreadComponent, FireSpreadSectionsLocationOffset) == 0x000118, "Member 'UFireSpreadComponent::FireSpreadSectionsLocationOffset' has a wrong offset!");
static_assert(offsetof(UFireSpreadComponent, FireSpreadSectionsRotationOffset) == 0x000124, "Member 'UFireSpreadComponent::FireSpreadSectionsRotationOffset' has a wrong offset!");
static_assert(offsetof(UFireSpreadComponent, FireSpreadSectionsScaleMult) == 0x000130, "Member 'UFireSpreadComponent::FireSpreadSectionsScaleMult' has a wrong offset!");

// Class ObsidianFox.FlammableInterface
// 0x0000 (0x0028 - 0x0028)
class IFlammableInterface final : public IInterface
{
public:
	void SimpleIgnite(class APawn* Instigator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlammableInterface">();
	}
	static class IFlammableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFlammableInterface>();
	}
};
static_assert(alignof(IFlammableInterface) == 0x000008, "Wrong alignment on IFlammableInterface");
static_assert(sizeof(IFlammableInterface) == 0x000028, "Wrong size on IFlammableInterface");

// Class ObsidianFox.ObjectiveComponent
// 0x00F0 (0x01A8 - 0x00B8)
class UObjectiveComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             ObjectiveUpdated;                                  // 0x00B8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ObjectiveStarted;                                  // 0x00C8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             NoteAdded;                                         // 0x00D8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             NoteChanged;                                       // 0x00E8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ObjectiveCompleted;                                // 0x00F8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ObjectiveReview;                                   // 0x0128(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ObjectiveNoteOpenTimerFinished;                    // 0x0138(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	float                                         OpenNoteTimer;                                     // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FObjectiveChapter>         CurrentObjectives;                                 // 0x0150(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x8];                                      // 0x01A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddNotes(const class FText& NewNote, const class UObjectivesData* ObjectivesData);
	void CompleteObjective(const class UObjectivesData* Data);
	void CompleteSubObjective(const class UObjectivesData* Data, const EObjectiveParts Part, const struct FGameplayTag& InObjectiveTag);
	bool IsObjectiveActive(const TSoftObjectPtr<class UObjectivesData> ObjectiveData);
	void OnNotePlayed(const class FText& Note, const class UObjectivesData* ObjectivesData);
	void ReviewObjectiveHistory();
	void SetObjectiveUnSeen(bool bUnSeen, TSoftObjectPtr<class UObjectivesData> ObjectiveSoftClassPath);
	void StartNewSubObjective(const class UObjectivesData* Data, EObjectiveParts NewPart, const struct FGameplayTag& InObjectiveTag);
	void StartObjective(const class UObjectivesData* Data, const struct FGameplayTag& InObjectiveTag, const EObjectiveParts NewPart);
	void TimerNoteDoneHandler();
	void UpdateObjective(const class UObjectivesData* Data, EObjectiveParts Part, const struct FGameplayTag& InObjectiveTag);

	bool CheckIfWeHaveObjective(const class UObjectivesData* Data) const;
	const TMap<int32, struct FObjectiveChapter> GetCurrentObjectives() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveComponent">();
	}
	static class UObjectiveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveComponent>();
	}
};
static_assert(alignof(UObjectiveComponent) == 0x000008, "Wrong alignment on UObjectiveComponent");
static_assert(sizeof(UObjectiveComponent) == 0x0001A8, "Wrong size on UObjectiveComponent");
static_assert(offsetof(UObjectiveComponent, ObjectiveUpdated) == 0x0000B8, "Member 'UObjectiveComponent::ObjectiveUpdated' has a wrong offset!");
static_assert(offsetof(UObjectiveComponent, ObjectiveStarted) == 0x0000C8, "Member 'UObjectiveComponent::ObjectiveStarted' has a wrong offset!");
static_assert(offsetof(UObjectiveComponent, NoteAdded) == 0x0000D8, "Member 'UObjectiveComponent::NoteAdded' has a wrong offset!");
static_assert(offsetof(UObjectiveComponent, NoteChanged) == 0x0000E8, "Member 'UObjectiveComponent::NoteChanged' has a wrong offset!");
static_assert(offsetof(UObjectiveComponent, ObjectiveCompleted) == 0x0000F8, "Member 'UObjectiveComponent::ObjectiveCompleted' has a wrong offset!");
static_assert(offsetof(UObjectiveComponent, ObjectiveReview) == 0x000128, "Member 'UObjectiveComponent::ObjectiveReview' has a wrong offset!");
static_assert(offsetof(UObjectiveComponent, ObjectiveNoteOpenTimerFinished) == 0x000138, "Member 'UObjectiveComponent::ObjectiveNoteOpenTimerFinished' has a wrong offset!");
static_assert(offsetof(UObjectiveComponent, OpenNoteTimer) == 0x000148, "Member 'UObjectiveComponent::OpenNoteTimer' has a wrong offset!");
static_assert(offsetof(UObjectiveComponent, CurrentObjectives) == 0x000150, "Member 'UObjectiveComponent::CurrentObjectives' has a wrong offset!");

// Class ObsidianFox.FlowDoorComponent
// 0x0090 (0x0260 - 0x01D0)
class UFlowDoorComponent final : public UFlowComponent
{
public:
	uint8                                         Pad_1D0[0x90];                                     // 0x01D0(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnDoorClosedHandler(bool bWasInstantClose);
	void OnDoorClosingHandler();
	void OnDoorOpenedHandler();
	void OnDoorUnlockedHandler();
	void OnInteractingCharacterReachDoorHandleHandler();
	void OnStartDoorOpeningHandler();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowDoorComponent">();
	}
	static class UFlowDoorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowDoorComponent>();
	}
};
static_assert(alignof(UFlowDoorComponent) == 0x000008, "Wrong alignment on UFlowDoorComponent");
static_assert(sizeof(UFlowDoorComponent) == 0x000260, "Wrong size on UFlowDoorComponent");

// Class ObsidianFox.FlowNode_OpenDoor
// 0x0020 (0x01F0 - 0x01D0)
class UFlowNode_OpenDoor final : public UFlowNode
{
public:
	struct FGameplayTagContainer                  AffectedDoorTags;                                  // 0x01D0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_OpenDoor">();
	}
	static class UFlowNode_OpenDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_OpenDoor>();
	}
};
static_assert(alignof(UFlowNode_OpenDoor) == 0x000008, "Wrong alignment on UFlowNode_OpenDoor");
static_assert(sizeof(UFlowNode_OpenDoor) == 0x0001F0, "Wrong size on UFlowNode_OpenDoor");
static_assert(offsetof(UFlowNode_OpenDoor, AffectedDoorTags) == 0x0001D0, "Member 'UFlowNode_OpenDoor::AffectedDoorTags' has a wrong offset!");

// Class ObsidianFox.OFWeaponActor
// 0x0158 (0x0390 - 0x0238)
class AOFWeaponActor : public AActor
{
public:
	FMulticastInlineDelegateProperty_             OnEquip;                                           // 0x0238(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnequip;                                         // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   EquippedSocketName;                                // 0x0258(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HolsteredSocketName;                               // 0x0260(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               AttachmentRule;                                    // 0x0268(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AttackEventTag;                                    // 0x026C(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           WeaponTag;                                         // 0x0274(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   WeaponUI;                                          // 0x0280(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImpactAdditiveVelocity;                            // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPersistenceComponent*                  PersistenceComponent;                              // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       RootSphere;                                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsEquipped;                                        // 0x02C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class UGameplayAbility>>     GrantedAbilities;                                  // 0x02C8(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UOFGameplayAbilitySet*                  GrantedAbilitySet;                                 // 0x0318(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FGameplayAbilitySpecHandle>     GrantedAbilitySpecHandles;                         // 0x0320(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             SurfaceHitFXDataTable;                             // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DecalSize;                                         // 0x0338(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalLifetime;                                     // 0x0344(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalMinOffsetFromSurface;                         // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalMaxOffsetFromSurface;                         // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitMagnitude;                                      // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponAnimationDataAsset*              Animations;                                        // 0x0358(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_360[0x10];                                     // 0x0360(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWeaponAnimationHandDataAsset*          HandAnimations;                                    // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsHolstered : 1;                                  // 0x0378(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_379[0x17];                                     // 0x0379(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginAttack(const struct FGameplayTag& AttackEvent);
	void EndAttack();
	void EquipSignature__DelegateSignature(class AOFWeaponActor* Weapon);
	TArray<class FName> GetBlockedSockets();
	class USkeletalMeshComponent* GetMesh();
	void NotifyWeaponHit(struct FGameplayEventData* EventData);
	void OnEffectImpact(const struct FHitResult& OutHit);
	void OnInstigatorPossesed(class AController* NewController);
	void PlayHitSoundEffect(class UWorld* WorldContext, const struct FHitResult& Hit, const struct FSurfaceHitFX& HitFX);
	void SetVisibility(bool bNewVisibility);
	void SpawnHitDecal(class UWorld* WorldContext, const struct FHitResult& Hit, const struct FSurfaceHitFX& HitFX);
	void SpawnHitFX(const struct FHitResult& Hit);
	void SpawnHitParticleSystem(class UWorld* WorldContext, const struct FHitResult& Hit, const struct FSurfaceHitFX& HitFX);
	void StartLoadingWeaponAnimationsAsync();

	class UWeaponAnimationDataAsset* GetAnimations() const;
	class UWeaponAnimationHandDataAsset* GetHandAnimations() const;
	TSoftClassPtr<class UClass> GetWeaponUI() const;
	bool IsUnholstered() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFWeaponActor">();
	}
	static class AOFWeaponActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOFWeaponActor>();
	}
};
static_assert(alignof(AOFWeaponActor) == 0x000008, "Wrong alignment on AOFWeaponActor");
static_assert(sizeof(AOFWeaponActor) == 0x000390, "Wrong size on AOFWeaponActor");
static_assert(offsetof(AOFWeaponActor, OnEquip) == 0x000238, "Member 'AOFWeaponActor::OnEquip' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, OnUnequip) == 0x000248, "Member 'AOFWeaponActor::OnUnequip' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, EquippedSocketName) == 0x000258, "Member 'AOFWeaponActor::EquippedSocketName' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, HolsteredSocketName) == 0x000260, "Member 'AOFWeaponActor::HolsteredSocketName' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, AttachmentRule) == 0x000268, "Member 'AOFWeaponActor::AttachmentRule' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, AttackEventTag) == 0x00026C, "Member 'AOFWeaponActor::AttackEventTag' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, WeaponTag) == 0x000274, "Member 'AOFWeaponActor::WeaponTag' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, WeaponUI) == 0x000280, "Member 'AOFWeaponActor::WeaponUI' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, ImpactAdditiveVelocity) == 0x0002A8, "Member 'AOFWeaponActor::ImpactAdditiveVelocity' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, PersistenceComponent) == 0x0002B0, "Member 'AOFWeaponActor::PersistenceComponent' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, RootSphere) == 0x0002B8, "Member 'AOFWeaponActor::RootSphere' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, IsEquipped) == 0x0002C0, "Member 'AOFWeaponActor::IsEquipped' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, GrantedAbilities) == 0x0002C8, "Member 'AOFWeaponActor::GrantedAbilities' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, GrantedAbilitySet) == 0x000318, "Member 'AOFWeaponActor::GrantedAbilitySet' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, GrantedAbilitySpecHandles) == 0x000320, "Member 'AOFWeaponActor::GrantedAbilitySpecHandles' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, SurfaceHitFXDataTable) == 0x000330, "Member 'AOFWeaponActor::SurfaceHitFXDataTable' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, DecalSize) == 0x000338, "Member 'AOFWeaponActor::DecalSize' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, DecalLifetime) == 0x000344, "Member 'AOFWeaponActor::DecalLifetime' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, DecalMinOffsetFromSurface) == 0x000348, "Member 'AOFWeaponActor::DecalMinOffsetFromSurface' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, DecalMaxOffsetFromSurface) == 0x00034C, "Member 'AOFWeaponActor::DecalMaxOffsetFromSurface' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, HitMagnitude) == 0x000350, "Member 'AOFWeaponActor::HitMagnitude' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, Animations) == 0x000358, "Member 'AOFWeaponActor::Animations' has a wrong offset!");
static_assert(offsetof(AOFWeaponActor, HandAnimations) == 0x000370, "Member 'AOFWeaponActor::HandAnimations' has a wrong offset!");

// Class ObsidianFox.HitscanWeaponActor
// 0x0140 (0x04D0 - 0x0390)
class AHitscanWeaponActor : public AOFWeaponActor
{
public:
	FMulticastInlineDelegateProperty_             OnAmmoChanged;                                     // 0x0390(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBeginReload;                                     // 0x03A0(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndReload;                                       // 0x03B0(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFire;                                            // 0x03C0(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnWeaponHit;                                       // 0x03D0(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFireFailedDueToImmunity;                         // 0x03E0(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UItemData*                              AmmoType;                                          // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               HitTraceChannel;                                   // 0x03F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F9[0x3];                                      // 0x03F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxAmmo;                                           // 0x03FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentAmmo;                                       // 0x0400(0x0004)(Edit, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ClipSize;                                          // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PelletsPerShot;                                    // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40C[0x6];                                      // 0x040C(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bMakeNoise : 1;                                    // 0x0412(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_413[0x1];                                      // 0x0413(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoiseMaxRange;                                     // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NoiseLoudness;                                     // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCurveTableRowHandle                   MaxAimAssistDistance;                              // 0x0420(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCurveTableRowHandle                   MinAimAssistDistance;                              // 0x0430(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketName;                                        // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHitScanWeaponRecoilSettings           RecoilSettings;                                    // 0x0448(0x0018)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UControllerTriggerEffectData*           AimTriggerEffect;                                  // 0x0460(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UControllerTriggerEffectData*           ShootTriggerEffect;                                // 0x0468(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ShrapnelDirParamName;                              // 0x0470(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ImmunityTags;                                      // 0x0478(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   CrosshairClass;                                    // 0x0498(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C0[0x10];                                     // 0x04C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateAimAssist();
	void AmmoChanged__DelegateSignature(int32 CurrentAmmo_0, int32 MaxAmmo_0);
	void ApplyRecoil();
	bool CanUseAimAssist();
	void DeactivatedAimAssist();
	void LoadAmmo();
	void OnEffectFire();
	void OnFire__DelegateSignature();
	void OnFireFailed__DelegateSignature(class AActor* ImmuneActor);
	void OnWeaponHit__DelegateSignature(const struct FGameplayEventData& EventPayload);
	void SetCurrentAmmo(int32 Value);
	void SetMaxAmmo(int32 Value);
	void SetUseAimAssist(bool bValue);
	void TriggerWeaponShootVFX();

	bool AnyAmmoLeft() const;
	bool CanReload() const;
	class UControllerTriggerEffectData* GetAimTriggerEffect() const;
	int32 GetCurrentAmmo() const;
	int32 GetMaxAmmo() const;
	class UControllerTriggerEffectData* GetShootTriggerEffect() const;
	struct FVector GetTraceEnd() const;
	struct FVector GetTraceStart() const;
	bool IsFullyLoaded() const;
	bool TraceForTarget(TArray<struct FHitResult>* OutHit) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitscanWeaponActor">();
	}
	static class AHitscanWeaponActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHitscanWeaponActor>();
	}
};
static_assert(alignof(AHitscanWeaponActor) == 0x000008, "Wrong alignment on AHitscanWeaponActor");
static_assert(sizeof(AHitscanWeaponActor) == 0x0004D0, "Wrong size on AHitscanWeaponActor");
static_assert(offsetof(AHitscanWeaponActor, OnAmmoChanged) == 0x000390, "Member 'AHitscanWeaponActor::OnAmmoChanged' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, OnBeginReload) == 0x0003A0, "Member 'AHitscanWeaponActor::OnBeginReload' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, OnEndReload) == 0x0003B0, "Member 'AHitscanWeaponActor::OnEndReload' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, OnFire) == 0x0003C0, "Member 'AHitscanWeaponActor::OnFire' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, OnWeaponHit) == 0x0003D0, "Member 'AHitscanWeaponActor::OnWeaponHit' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, OnFireFailedDueToImmunity) == 0x0003E0, "Member 'AHitscanWeaponActor::OnFireFailedDueToImmunity' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, AmmoType) == 0x0003F0, "Member 'AHitscanWeaponActor::AmmoType' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, HitTraceChannel) == 0x0003F8, "Member 'AHitscanWeaponActor::HitTraceChannel' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, MaxAmmo) == 0x0003FC, "Member 'AHitscanWeaponActor::MaxAmmo' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, CurrentAmmo) == 0x000400, "Member 'AHitscanWeaponActor::CurrentAmmo' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, ClipSize) == 0x000404, "Member 'AHitscanWeaponActor::ClipSize' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, PelletsPerShot) == 0x000408, "Member 'AHitscanWeaponActor::PelletsPerShot' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, NoiseMaxRange) == 0x000414, "Member 'AHitscanWeaponActor::NoiseMaxRange' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, NoiseLoudness) == 0x000418, "Member 'AHitscanWeaponActor::NoiseLoudness' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, MaxAimAssistDistance) == 0x000420, "Member 'AHitscanWeaponActor::MaxAimAssistDistance' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, MinAimAssistDistance) == 0x000430, "Member 'AHitscanWeaponActor::MinAimAssistDistance' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, SocketName) == 0x000440, "Member 'AHitscanWeaponActor::SocketName' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, RecoilSettings) == 0x000448, "Member 'AHitscanWeaponActor::RecoilSettings' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, AimTriggerEffect) == 0x000460, "Member 'AHitscanWeaponActor::AimTriggerEffect' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, ShootTriggerEffect) == 0x000468, "Member 'AHitscanWeaponActor::ShootTriggerEffect' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, ShrapnelDirParamName) == 0x000470, "Member 'AHitscanWeaponActor::ShrapnelDirParamName' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, ImmunityTags) == 0x000478, "Member 'AHitscanWeaponActor::ImmunityTags' has a wrong offset!");
static_assert(offsetof(AHitscanWeaponActor, CrosshairClass) == 0x000498, "Member 'AHitscanWeaponActor::CrosshairClass' has a wrong offset!");

// Class ObsidianFox.FlowNode_CloseDoor
// 0x0028 (0x01F8 - 0x01D0)
class UFlowNode_CloseDoor final : public UFlowNode
{
public:
	struct FGameplayTagContainer                  AffectedDoorTags;                                  // 0x01D0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          bInstantClose;                                     // 0x01F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F1[0x7];                                      // 0x01F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_CloseDoor">();
	}
	static class UFlowNode_CloseDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_CloseDoor>();
	}
};
static_assert(alignof(UFlowNode_CloseDoor) == 0x000008, "Wrong alignment on UFlowNode_CloseDoor");
static_assert(sizeof(UFlowNode_CloseDoor) == 0x0001F8, "Wrong size on UFlowNode_CloseDoor");
static_assert(offsetof(UFlowNode_CloseDoor, AffectedDoorTags) == 0x0001D0, "Member 'UFlowNode_CloseDoor::AffectedDoorTags' has a wrong offset!");
static_assert(offsetof(UFlowNode_CloseDoor, bInstantClose) == 0x0001F0, "Member 'UFlowNode_CloseDoor::bInstantClose' has a wrong offset!");

// Class ObsidianFox.FlowNode_EnableSprintOpenDoor
// 0x0028 (0x01F8 - 0x01D0)
class UFlowNode_EnableSprintOpenDoor final : public UFlowNode
{
public:
	bool                                          bSprintOpenEnabled;                                // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AffectedDoorTags;                                  // 0x01D8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_EnableSprintOpenDoor">();
	}
	static class UFlowNode_EnableSprintOpenDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_EnableSprintOpenDoor>();
	}
};
static_assert(alignof(UFlowNode_EnableSprintOpenDoor) == 0x000008, "Wrong alignment on UFlowNode_EnableSprintOpenDoor");
static_assert(sizeof(UFlowNode_EnableSprintOpenDoor) == 0x0001F8, "Wrong size on UFlowNode_EnableSprintOpenDoor");
static_assert(offsetof(UFlowNode_EnableSprintOpenDoor, bSprintOpenEnabled) == 0x0001D0, "Member 'UFlowNode_EnableSprintOpenDoor::bSprintOpenEnabled' has a wrong offset!");
static_assert(offsetof(UFlowNode_EnableSprintOpenDoor, AffectedDoorTags) == 0x0001D8, "Member 'UFlowNode_EnableSprintOpenDoor::AffectedDoorTags' has a wrong offset!");

// Class ObsidianFox.HitMeshDecal
// 0x0010 (0x0248 - 0x0238)
class AHitMeshDecal final : public AActor
{
public:
	class UStaticMeshComponent*                   DecalMesh;                                         // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0240(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetDecalMaterial(class UMaterialInterface* Material);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitMeshDecal">();
	}
	static class AHitMeshDecal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHitMeshDecal>();
	}
};
static_assert(alignof(AHitMeshDecal) == 0x000008, "Wrong alignment on AHitMeshDecal");
static_assert(sizeof(AHitMeshDecal) == 0x000248, "Wrong size on AHitMeshDecal");
static_assert(offsetof(AHitMeshDecal, DecalMesh) == 0x000238, "Member 'AHitMeshDecal::DecalMesh' has a wrong offset!");
static_assert(offsetof(AHitMeshDecal, DynamicMaterial) == 0x000240, "Member 'AHitMeshDecal::DynamicMaterial' has a wrong offset!");

// Class ObsidianFox.FlowNode_ChangeDoorOpenCurve
// 0x0040 (0x0210 - 0x01D0)
class UFlowNode_ChangeDoorOpenCurve final : public UFlowNode
{
public:
	struct FDoorCurveDataPair                     DoorOpenCurve;                                     // 0x01D0(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCurveFloat*                            SprintOpenCurve;                                   // 0x01E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EDoorOpenType                                 DoorOpenType;                                      // 0x01E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E9[0x7];                                      // 0x01E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AffectedDoorTags;                                  // 0x01F0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_ChangeDoorOpenCurve">();
	}
	static class UFlowNode_ChangeDoorOpenCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_ChangeDoorOpenCurve>();
	}
};
static_assert(alignof(UFlowNode_ChangeDoorOpenCurve) == 0x000008, "Wrong alignment on UFlowNode_ChangeDoorOpenCurve");
static_assert(sizeof(UFlowNode_ChangeDoorOpenCurve) == 0x000210, "Wrong size on UFlowNode_ChangeDoorOpenCurve");
static_assert(offsetof(UFlowNode_ChangeDoorOpenCurve, DoorOpenCurve) == 0x0001D0, "Member 'UFlowNode_ChangeDoorOpenCurve::DoorOpenCurve' has a wrong offset!");
static_assert(offsetof(UFlowNode_ChangeDoorOpenCurve, SprintOpenCurve) == 0x0001E0, "Member 'UFlowNode_ChangeDoorOpenCurve::SprintOpenCurve' has a wrong offset!");
static_assert(offsetof(UFlowNode_ChangeDoorOpenCurve, DoorOpenType) == 0x0001E8, "Member 'UFlowNode_ChangeDoorOpenCurve::DoorOpenType' has a wrong offset!");
static_assert(offsetof(UFlowNode_ChangeDoorOpenCurve, AffectedDoorTags) == 0x0001F0, "Member 'UFlowNode_ChangeDoorOpenCurve::AffectedDoorTags' has a wrong offset!");

// Class ObsidianFox.FlowNode_UseClosingTimer
// 0x0028 (0x01F8 - 0x01D0)
class UFlowNode_UseClosingTimer final : public UFlowNode
{
public:
	uint8                                         bUseClosingTimer : 1;                              // 0x01D0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AffectedDoorTags;                                  // 0x01D8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_UseClosingTimer">();
	}
	static class UFlowNode_UseClosingTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_UseClosingTimer>();
	}
};
static_assert(alignof(UFlowNode_UseClosingTimer) == 0x000008, "Wrong alignment on UFlowNode_UseClosingTimer");
static_assert(sizeof(UFlowNode_UseClosingTimer) == 0x0001F8, "Wrong size on UFlowNode_UseClosingTimer");
static_assert(offsetof(UFlowNode_UseClosingTimer, AffectedDoorTags) == 0x0001D8, "Member 'UFlowNode_UseClosingTimer::AffectedDoorTags' has a wrong offset!");

// Class ObsidianFox.NestActor
// 0x0030 (0x0268 - 0x0238)
class ANestActor final : public AActor
{
public:
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ANestLocationActor*>             NestLocations;                                     // 0x0240(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   NestActorKey;                                      // 0x0250(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        ArrowComponent;                                    // 0x0258(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PlayerDistanceThreshold;                           // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class ANestLocationActor* PickNewNestLocation();

	class ANestLocationActor* GetCurrentNestLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NestActor">();
	}
	static class ANestActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANestActor>();
	}
};
static_assert(alignof(ANestActor) == 0x000008, "Wrong alignment on ANestActor");
static_assert(sizeof(ANestActor) == 0x000268, "Wrong size on ANestActor");
static_assert(offsetof(ANestActor, NestLocations) == 0x000240, "Member 'ANestActor::NestLocations' has a wrong offset!");
static_assert(offsetof(ANestActor, NestActorKey) == 0x000250, "Member 'ANestActor::NestActorKey' has a wrong offset!");
static_assert(offsetof(ANestActor, ArrowComponent) == 0x000258, "Member 'ANestActor::ArrowComponent' has a wrong offset!");
static_assert(offsetof(ANestActor, PlayerDistanceThreshold) == 0x000260, "Member 'ANestActor::PlayerDistanceThreshold' has a wrong offset!");

// Class ObsidianFox.FlowNode_EventCollectible
// 0x0038 (0x0208 - 0x01D0)
class UFlowNode_EventCollectible final : public UFlowNode
{
public:
	TSoftObjectPtr<class UCollectiblesDataAsset>  CollectiblesDataAsset;                             // 0x01D0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F8[0x10];                                     // 0x01F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Callback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_EventCollectible">();
	}
	static class UFlowNode_EventCollectible* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_EventCollectible>();
	}
};
static_assert(alignof(UFlowNode_EventCollectible) == 0x000008, "Wrong alignment on UFlowNode_EventCollectible");
static_assert(sizeof(UFlowNode_EventCollectible) == 0x000208, "Wrong size on UFlowNode_EventCollectible");
static_assert(offsetof(UFlowNode_EventCollectible, CollectiblesDataAsset) == 0x0001D0, "Member 'UFlowNode_EventCollectible::CollectiblesDataAsset' has a wrong offset!");

// Class ObsidianFox.FlowNode_EventDoor
// 0x0000 (0x0258 - 0x0258)
class UFlowNode_EventDoor final : public UFlowNode_ComponentObserver
{
public:
	void OnDoorClosedEventHandler(class UFlowDoorComponent* FlowDoorComponent);
	void OnDoorClosingEventHandler(class UFlowDoorComponent* FlowDoorComponent);
	void OnDoorOpenedEventHandler(class UFlowDoorComponent* FlowDoorComponent);
	void OnDoorUnlockedEventHandler(class UFlowDoorComponent* FlowDoorComponent);
	void OnInteractingCharacterReachDoorHandleHandler(class UFlowDoorComponent* FlowDoorComponent);
	void OnStartDoorOpeningEventHandler(class UFlowDoorComponent* FlowDoorComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_EventDoor">();
	}
	static class UFlowNode_EventDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_EventDoor>();
	}
};
static_assert(alignof(UFlowNode_EventDoor) == 0x000008, "Wrong alignment on UFlowNode_EventDoor");
static_assert(sizeof(UFlowNode_EventDoor) == 0x000258, "Wrong size on UFlowNode_EventDoor");

// Class ObsidianFox.OFAbilitySystemBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UOFAbilitySystemBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AddTargetDataToEffectContextHandle(const struct FGameplayEffectContextHandle& EffectContextHandle, const struct FGameplayAbilityTargetDataHandle& TargetData);
	static bool CanActivateAbilityByTag(class APawn* Target, const struct FGameplayTagContainer& GameplayTagContainer, bool bAllowRemoteActivation);
	static void EffectContextHandleAddWeakPoint(const struct FGameplayEffectContextHandle& EffectContextHandle, class UDamagePoint* WeakPoint);
	static TArray<struct FHitResult> GetAllHitResultsFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData);
	static struct FGameplayTag GetEnemyDeathReactionTag();
	static struct FGameplayTag GetPlayerDeathReactionTag();
	static struct FGameplayTag GetTagMatchingDeathReactionTag(const struct FGameplayTagContainer& TargetTags, const bool bGetPlayerTags);
	static struct FGameplayAbilityTargetDataHandle GetTargetDataFromEffectContextHandle(const struct FGameplayEffectContextHandle& EffectContextHandle);
	static TArray<class UDamagePoint*> GetWeakPointsFromEffectContextHandle(const struct FGameplayEffectContextHandle& EffectContextHandle);
	static bool IsGamepadLastInputTypeUsed(const struct FGameplayAbilityActorInfo& ActorInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFAbilitySystemBlueprintLibrary">();
	}
	static class UOFAbilitySystemBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFAbilitySystemBlueprintLibrary>();
	}
};
static_assert(alignof(UOFAbilitySystemBlueprintLibrary) == 0x000008, "Wrong alignment on UOFAbilitySystemBlueprintLibrary");
static_assert(sizeof(UOFAbilitySystemBlueprintLibrary) == 0x000028, "Wrong size on UOFAbilitySystemBlueprintLibrary");

// Class ObsidianFox.FlowNode_ItemExamined
// 0x0028 (0x01F8 - 0x01D0)
class UFlowNode_ItemExamined final : public UFlowNode
{
public:
	TSoftObjectPtr<class UItemData>               ItemData;                                          // 0x01D0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnItemLookedExaminedHandler(const TSoftObjectPtr<class UItemData> InItemData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_ItemExamined">();
	}
	static class UFlowNode_ItemExamined* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_ItemExamined>();
	}
};
static_assert(alignof(UFlowNode_ItemExamined) == 0x000008, "Wrong alignment on UFlowNode_ItemExamined");
static_assert(sizeof(UFlowNode_ItemExamined) == 0x0001F8, "Wrong size on UFlowNode_ItemExamined");
static_assert(offsetof(UFlowNode_ItemExamined, ItemData) == 0x0001D0, "Member 'UFlowNode_ItemExamined::ItemData' has a wrong offset!");

// Class ObsidianFox.FlowNode_LockStateDoor
// 0x0028 (0x01F8 - 0x01D0)
class UFlowNode_LockStateDoor final : public UFlowNode
{
public:
	EDoorLockState                                LockState;                                         // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AffectedDoorTags;                                  // 0x01D8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_LockStateDoor">();
	}
	static class UFlowNode_LockStateDoor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_LockStateDoor>();
	}
};
static_assert(alignof(UFlowNode_LockStateDoor) == 0x000008, "Wrong alignment on UFlowNode_LockStateDoor");
static_assert(sizeof(UFlowNode_LockStateDoor) == 0x0001F8, "Wrong size on UFlowNode_LockStateDoor");
static_assert(offsetof(UFlowNode_LockStateDoor, LockState) == 0x0001D0, "Member 'UFlowNode_LockStateDoor::LockState' has a wrong offset!");
static_assert(offsetof(UFlowNode_LockStateDoor, AffectedDoorTags) == 0x0001D8, "Member 'UFlowNode_LockStateDoor::AffectedDoorTags' has a wrong offset!");

// Class ObsidianFox.ObjectiveListWidget
// 0x0090 (0x02F0 - 0x0260)
class UObjectiveListWidget : public UUserWidget
{
public:
	class UVerticalBox*                           ListObjectives;                                    // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 ObjectiveEntryClassWidget;                         // 0x0268(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 ModernObjectiveEntryClassWidget;                   // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 ObjectiveListEntrySeparator;                       // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x58];                                     // 0x0280(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ObjectiveDescription;                              // 0x02D8(0x0018)(NativeAccessSpecifierPrivate)

public:
	void CreateWidgets();
	void MakeObjectiveUnSeen();
	void UpdateObjectiveWidget(const struct FObjectiveChapter& ObjectiveChapterInfo);

	class FText GetObjectiveInfo() const;
	bool IsUnSeen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveListWidget">();
	}
	static class UObjectiveListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveListWidget>();
	}
};
static_assert(alignof(UObjectiveListWidget) == 0x000008, "Wrong alignment on UObjectiveListWidget");
static_assert(sizeof(UObjectiveListWidget) == 0x0002F0, "Wrong size on UObjectiveListWidget");
static_assert(offsetof(UObjectiveListWidget, ListObjectives) == 0x000260, "Member 'UObjectiveListWidget::ListObjectives' has a wrong offset!");
static_assert(offsetof(UObjectiveListWidget, ObjectiveEntryClassWidget) == 0x000268, "Member 'UObjectiveListWidget::ObjectiveEntryClassWidget' has a wrong offset!");
static_assert(offsetof(UObjectiveListWidget, ModernObjectiveEntryClassWidget) == 0x000270, "Member 'UObjectiveListWidget::ModernObjectiveEntryClassWidget' has a wrong offset!");
static_assert(offsetof(UObjectiveListWidget, ObjectiveListEntrySeparator) == 0x000278, "Member 'UObjectiveListWidget::ObjectiveListEntrySeparator' has a wrong offset!");
static_assert(offsetof(UObjectiveListWidget, ObjectiveDescription) == 0x0002D8, "Member 'UObjectiveListWidget::ObjectiveDescription' has a wrong offset!");

// Class ObsidianFox.FlowNode_Metrics_AnomalyTriggered
// 0x0000 (0x01D0 - 0x01D0)
class UFlowNode_Metrics_AnomalyTriggered final : public UFlowNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Metrics_AnomalyTriggered">();
	}
	static class UFlowNode_Metrics_AnomalyTriggered* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Metrics_AnomalyTriggered>();
	}
};
static_assert(alignof(UFlowNode_Metrics_AnomalyTriggered) == 0x000008, "Wrong alignment on UFlowNode_Metrics_AnomalyTriggered");
static_assert(sizeof(UFlowNode_Metrics_AnomalyTriggered) == 0x0001D0, "Wrong size on UFlowNode_Metrics_AnomalyTriggered");

// Class ObsidianFox.FlowNode_Metrics_OtherWorldReached
// 0x0000 (0x01D0 - 0x01D0)
class UFlowNode_Metrics_OtherWorldReached final : public UFlowNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_Metrics_OtherWorldReached">();
	}
	static class UFlowNode_Metrics_OtherWorldReached* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_Metrics_OtherWorldReached>();
	}
};
static_assert(alignof(UFlowNode_Metrics_OtherWorldReached) == 0x000008, "Wrong alignment on UFlowNode_Metrics_OtherWorldReached");
static_assert(sizeof(UFlowNode_Metrics_OtherWorldReached) == 0x0001D0, "Wrong size on UFlowNode_Metrics_OtherWorldReached");

// Class ObsidianFox.MoodSystemBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UMoodSystemBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void TriggerMoodStateEventOnNearbyComponents(class AActor* Instigator, const struct FVector& Origin, float Radius, const TMap<EEmotion, float>& AffectedEmotions);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoodSystemBlueprintLibrary">();
	}
	static class UMoodSystemBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoodSystemBlueprintLibrary>();
	}
};
static_assert(alignof(UMoodSystemBlueprintLibrary) == 0x000008, "Wrong alignment on UMoodSystemBlueprintLibrary");
static_assert(sizeof(UMoodSystemBlueprintLibrary) == 0x000028, "Wrong size on UMoodSystemBlueprintLibrary");

// Class ObsidianFox.FluidSource
// 0x0010 (0x0248 - 0x0238)
class AFluidSource : public AActor
{
public:
	class FName                                   SourceFluidTag;                                    // 0x0238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SourceWetnessPercent;                              // 0x0240(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FFluid GetFluid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FluidSource">();
	}
	static class AFluidSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFluidSource>();
	}
};
static_assert(alignof(AFluidSource) == 0x000008, "Wrong alignment on AFluidSource");
static_assert(sizeof(AFluidSource) == 0x000248, "Wrong size on AFluidSource");
static_assert(offsetof(AFluidSource, SourceFluidTag) == 0x000238, "Member 'AFluidSource::SourceFluidTag' has a wrong offset!");
static_assert(offsetof(AFluidSource, SourceWetnessPercent) == 0x000240, "Member 'AFluidSource::SourceWetnessPercent' has a wrong offset!");

// Class ObsidianFox.WorldSubsystem_RailingCompManager
// 0x0050 (0x0080 - 0x0030)
class UWorldSubsystem_RailingCompManager final : public UWorldSubsystem
{
public:
	TSet<class URailingSplineComponent*>          Splines;                                           // 0x0030(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	struct FSplinePointResult GetNearestSplineData(const struct FVector& Origin, float MaxSearchDistance) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldSubsystem_RailingCompManager">();
	}
	static class UWorldSubsystem_RailingCompManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldSubsystem_RailingCompManager>();
	}
};
static_assert(alignof(UWorldSubsystem_RailingCompManager) == 0x000008, "Wrong alignment on UWorldSubsystem_RailingCompManager");
static_assert(sizeof(UWorldSubsystem_RailingCompManager) == 0x000080, "Wrong size on UWorldSubsystem_RailingCompManager");
static_assert(offsetof(UWorldSubsystem_RailingCompManager, Splines) == 0x000030, "Member 'UWorldSubsystem_RailingCompManager::Splines' has a wrong offset!");

// Class ObsidianFox.ObjectiveWidget
// 0x0158 (0x03F8 - 0x02A0)
class UObjectiveWidget : public UWidgetInputHandlingBase
{
public:
	class UObjectiveListWidget*                   ObjectiveListWidget;                               // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectiveNotesWidget*                  ObjectiveNotesWidget;                              // 0x02A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrlButtonWidget*                      CtrlButtonWidget;                                  // 0x02B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurrentChapterText;                                // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionChangeObjective;                        // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionBack;                                   // 0x02C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionChangeNote;                             // 0x02D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionMoveScrollBox;                          // 0x02D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionPlayVO;                                 // 0x02E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   PlayText;                                          // 0x02E8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   StopText;                                          // 0x0300(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              ChangeNoteSound;                                   // 0x0318(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FObjectiveChapter                      ObjectiveChapterInfo;                              // 0x0340(0x0050)(NativeAccessSpecifierPrivate)
	TMap<int32, struct FObjectiveChapter>         ObjectiveMapInfo;                                  // 0x0390(0x0050)(NativeAccessSpecifierPrivate)
	int32                                         CurrentSelectedChapter;                            // 0x03E0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E4[0x14];                                     // 0x03E4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeNoteHandler(const struct FInputActionValue& InputActionValue);
	void FmodEventPlayed();
	void FmodEventStopped();
	void MoveNoteScrollboxHandler(const struct FInputActionValue& InputActionValue);
	void PlayVO(const struct FInputActionValue& InputActionValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveWidget">();
	}
	static class UObjectiveWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveWidget>();
	}
};
static_assert(alignof(UObjectiveWidget) == 0x000008, "Wrong alignment on UObjectiveWidget");
static_assert(sizeof(UObjectiveWidget) == 0x0003F8, "Wrong size on UObjectiveWidget");
static_assert(offsetof(UObjectiveWidget, ObjectiveListWidget) == 0x0002A0, "Member 'UObjectiveWidget::ObjectiveListWidget' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, ObjectiveNotesWidget) == 0x0002A8, "Member 'UObjectiveWidget::ObjectiveNotesWidget' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, CtrlButtonWidget) == 0x0002B0, "Member 'UObjectiveWidget::CtrlButtonWidget' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, CurrentChapterText) == 0x0002B8, "Member 'UObjectiveWidget::CurrentChapterText' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, InputActionChangeObjective) == 0x0002C0, "Member 'UObjectiveWidget::InputActionChangeObjective' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, InputActionBack) == 0x0002C8, "Member 'UObjectiveWidget::InputActionBack' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, InputActionChangeNote) == 0x0002D0, "Member 'UObjectiveWidget::InputActionChangeNote' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, InputActionMoveScrollBox) == 0x0002D8, "Member 'UObjectiveWidget::InputActionMoveScrollBox' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, InputActionPlayVO) == 0x0002E0, "Member 'UObjectiveWidget::InputActionPlayVO' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, PlayText) == 0x0002E8, "Member 'UObjectiveWidget::PlayText' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, StopText) == 0x000300, "Member 'UObjectiveWidget::StopText' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, ChangeNoteSound) == 0x000318, "Member 'UObjectiveWidget::ChangeNoteSound' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, ObjectiveChapterInfo) == 0x000340, "Member 'UObjectiveWidget::ObjectiveChapterInfo' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, ObjectiveMapInfo) == 0x000390, "Member 'UObjectiveWidget::ObjectiveMapInfo' has a wrong offset!");
static_assert(offsetof(UObjectiveWidget, CurrentSelectedChapter) == 0x0003E0, "Member 'UObjectiveWidget::CurrentSelectedChapter' has a wrong offset!");

// Class ObsidianFox.FoliageInteractionComponent
// 0x0030 (0x0240 - 0x0210)
class UFoliageInteractionComponent final : public USceneComponent
{
public:
	int32                                         InteractionPriority;                               // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractionStrength;                               // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractionRadius;                                 // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractionCapsuleHalfHeight;                      // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActiveRange;                                       // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseUpdateFrequency;                               // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpdateFrequencyRandomOffset;                       // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UFoliageInteractionManager*             ManagerRef;                                        // 0x0228(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpdateFrequency;                                   // 0x0230(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentUpdateDelay;                                // 0x0234(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SendInteractionToManager();

	float GetActiveRange() const;
	struct FFoliageInteraction GetFoliageInteractionData() const;
	int32 GetInteractionPriority() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageInteractionComponent">();
	}
	static class UFoliageInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFoliageInteractionComponent>();
	}
};
static_assert(alignof(UFoliageInteractionComponent) == 0x000010, "Wrong alignment on UFoliageInteractionComponent");
static_assert(sizeof(UFoliageInteractionComponent) == 0x000240, "Wrong size on UFoliageInteractionComponent");
static_assert(offsetof(UFoliageInteractionComponent, InteractionPriority) == 0x000208, "Member 'UFoliageInteractionComponent::InteractionPriority' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionComponent, InteractionStrength) == 0x00020C, "Member 'UFoliageInteractionComponent::InteractionStrength' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionComponent, InteractionRadius) == 0x000210, "Member 'UFoliageInteractionComponent::InteractionRadius' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionComponent, InteractionCapsuleHalfHeight) == 0x000214, "Member 'UFoliageInteractionComponent::InteractionCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionComponent, ActiveRange) == 0x000218, "Member 'UFoliageInteractionComponent::ActiveRange' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionComponent, BaseUpdateFrequency) == 0x00021C, "Member 'UFoliageInteractionComponent::BaseUpdateFrequency' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionComponent, UpdateFrequencyRandomOffset) == 0x000220, "Member 'UFoliageInteractionComponent::UpdateFrequencyRandomOffset' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionComponent, ManagerRef) == 0x000228, "Member 'UFoliageInteractionComponent::ManagerRef' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionComponent, UpdateFrequency) == 0x000230, "Member 'UFoliageInteractionComponent::UpdateFrequency' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionComponent, CurrentUpdateDelay) == 0x000234, "Member 'UFoliageInteractionComponent::CurrentUpdateDelay' has a wrong offset!");

// Class ObsidianFox.FoliageInteractionManager
// 0x0088 (0x0140 - 0x00B8)
class UFoliageInteractionManager final : public UActorComponent
{
public:
	class UMaterialParameterCollection*           MPC;                                               // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumberOfInteractionSlots;                          // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PriorityUpdateFrequency;                           // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UFoliageInteractionComponent*>   InteractionComponents;                             // 0x00C8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UFoliageInteractionComponent*>   ActiveInteractionComponents;                       // 0x00D8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class FString                                 InteractLocationParamName;                         // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 InteractStrengthParamName;                         // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 InteractRadiusParamName;                           // 0x0108(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 InteractHalfHeightParamName;                       // 0x0118(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentPriorityUpdateDelay;                        // 0x0128(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FFoliageInteractionParamNames>  InteractionParamNames;                             // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void Interation(const class UFoliageInteractionComponent*& Component);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FoliageInteractionManager">();
	}
	static class UFoliageInteractionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFoliageInteractionManager>();
	}
};
static_assert(alignof(UFoliageInteractionManager) == 0x000008, "Wrong alignment on UFoliageInteractionManager");
static_assert(sizeof(UFoliageInteractionManager) == 0x000140, "Wrong size on UFoliageInteractionManager");
static_assert(offsetof(UFoliageInteractionManager, MPC) == 0x0000B8, "Member 'UFoliageInteractionManager::MPC' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionManager, NumberOfInteractionSlots) == 0x0000C0, "Member 'UFoliageInteractionManager::NumberOfInteractionSlots' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionManager, PriorityUpdateFrequency) == 0x0000C4, "Member 'UFoliageInteractionManager::PriorityUpdateFrequency' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionManager, InteractionComponents) == 0x0000C8, "Member 'UFoliageInteractionManager::InteractionComponents' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionManager, ActiveInteractionComponents) == 0x0000D8, "Member 'UFoliageInteractionManager::ActiveInteractionComponents' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionManager, InteractLocationParamName) == 0x0000E8, "Member 'UFoliageInteractionManager::InteractLocationParamName' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionManager, InteractStrengthParamName) == 0x0000F8, "Member 'UFoliageInteractionManager::InteractStrengthParamName' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionManager, InteractRadiusParamName) == 0x000108, "Member 'UFoliageInteractionManager::InteractRadiusParamName' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionManager, InteractHalfHeightParamName) == 0x000118, "Member 'UFoliageInteractionManager::InteractHalfHeightParamName' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionManager, CurrentPriorityUpdateDelay) == 0x000128, "Member 'UFoliageInteractionManager::CurrentPriorityUpdateDelay' has a wrong offset!");
static_assert(offsetof(UFoliageInteractionManager, InteractionParamNames) == 0x000130, "Member 'UFoliageInteractionManager::InteractionParamNames' has a wrong offset!");

// Class ObsidianFox.OFActivityPlayChapter
// 0x0030 (0x0160 - 0x0130)
class UOFActivityPlayChapter final : public UPiecesActivityBase
{
public:
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBPAsyncAction_ChunkInstallWaitPopup*   ChunkInstallWaitTask;                              // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBPAsyncAction_ConfirmationPopup*       OverwriteConfirmTask;                              // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SaveSlot;                                          // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CheckpointTag;                                     // 0x014C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ChapterTag;                                        // 0x0154(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCharacterType                          PlayerCharacterType;                               // 0x015C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15D[0x3];                                      // 0x015D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AutosaveOverwriteConfirmed();
	void ChunkInstallSuccessful();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFActivityPlayChapter">();
	}
	static class UOFActivityPlayChapter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFActivityPlayChapter>();
	}
};
static_assert(alignof(UOFActivityPlayChapter) == 0x000008, "Wrong alignment on UOFActivityPlayChapter");
static_assert(sizeof(UOFActivityPlayChapter) == 0x000160, "Wrong size on UOFActivityPlayChapter");
static_assert(offsetof(UOFActivityPlayChapter, ChunkInstallWaitTask) == 0x000138, "Member 'UOFActivityPlayChapter::ChunkInstallWaitTask' has a wrong offset!");
static_assert(offsetof(UOFActivityPlayChapter, OverwriteConfirmTask) == 0x000140, "Member 'UOFActivityPlayChapter::OverwriteConfirmTask' has a wrong offset!");
static_assert(offsetof(UOFActivityPlayChapter, SaveSlot) == 0x000148, "Member 'UOFActivityPlayChapter::SaveSlot' has a wrong offset!");
static_assert(offsetof(UOFActivityPlayChapter, CheckpointTag) == 0x00014C, "Member 'UOFActivityPlayChapter::CheckpointTag' has a wrong offset!");
static_assert(offsetof(UOFActivityPlayChapter, ChapterTag) == 0x000154, "Member 'UOFActivityPlayChapter::ChapterTag' has a wrong offset!");
static_assert(offsetof(UOFActivityPlayChapter, PlayerCharacterType) == 0x00015C, "Member 'UOFActivityPlayChapter::PlayerCharacterType' has a wrong offset!");

// Class ObsidianFox.IKModifier
// 0x0000 (0x0028 - 0x0028)
class UIKModifier : public UObject
{
public:
	void OnApply(const class FName BoneName, class UAnimInstance* AnimInstance);
	void OnPaused(const class FName BoneName, class UAnimInstance* AnimInstance);
	void OnResumed(const class FName BoneName, class UAnimInstance* AnimInstance);
	struct FIKModifierUpdateReturnValue OnUpdate(const class FName BoneName, class UAnimInstance* AnimInstance, float DeltaTime);

	bool IsDone() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IKModifier">();
	}
	static class UIKModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIKModifier>();
	}
};
static_assert(alignof(UIKModifier) == 0x000008, "Wrong alignment on UIKModifier");
static_assert(sizeof(UIKModifier) == 0x000028, "Wrong size on UIKModifier");

// Class ObsidianFox.FootIKModifier
// 0x0000 (0x0028 - 0x0028)
class UFootIKModifier final : public UIKModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootIKModifier">();
	}
	static class UFootIKModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootIKModifier>();
	}
};
static_assert(alignof(UFootIKModifier) == 0x000008, "Wrong alignment on UFootIKModifier");
static_assert(sizeof(UFootIKModifier) == 0x000028, "Wrong size on UFootIKModifier");

// Class ObsidianFox.OFAchievementTrackingSubsystem
// 0x0170 (0x01A0 - 0x0030)
class UOFAchievementTrackingSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldAwardNoHealingAchievement;                  // 0x0050(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x14F];                                     // 0x0051(0x014F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AchievementCompletedHandler(class FName AchievementId);
	void AllCollectibleSetsCompletedHandler();
	void BanterCompleted(const struct FCompletedBanter& CompletedBanter);
	void CheckEnemyKilledAchievements(const struct FGameplayTagContainer& Tags);
	void CollectibleSetCompletedHandler(const class UCollectibleSet* CollectibleSet);
	void CollectibleSetsLoadedHandler();
	void DisableNoHealingAchievement();
	void FactUpdatedHandler(const struct FGameplayTag& Tag, ESubscriptionTagChangeType ChangeType);
	void GameSessionStartedHandler(class UGameplaySession* GameplaySession);
	void ItemExaminedHandler(const TSoftObjectPtr<class UItemData> ItemData);
	void PawnControllerChangedHandler(class APawn* Pawn, class AController* Controller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFAchievementTrackingSubsystem">();
	}
	static class UOFAchievementTrackingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFAchievementTrackingSubsystem>();
	}
};
static_assert(alignof(UOFAchievementTrackingSubsystem) == 0x000008, "Wrong alignment on UOFAchievementTrackingSubsystem");
static_assert(sizeof(UOFAchievementTrackingSubsystem) == 0x0001A0, "Wrong size on UOFAchievementTrackingSubsystem");
static_assert(offsetof(UOFAchievementTrackingSubsystem, bShouldAwardNoHealingAchievement) == 0x000050, "Member 'UOFAchievementTrackingSubsystem::bShouldAwardNoHealingAchievement' has a wrong offset!");

// Class ObsidianFox.FootPrintSpawnerComponent
// 0x00A0 (0x0158 - 0x00B8)
class UFootPrintSpawnerComponent final : public UActorComponent
{
public:
	TArray<struct FFoot>                          FeetDefinitions;                                   // 0x00B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FFootStepVFX>                   FootStepVFX;                                       // 0x00C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bTraceAlongFeetRotation;                           // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EProjectionDirection                          FeetGroundDirection;                               // 0x00D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FeetLengthFront;                                   // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FeetLengthBack;                                    // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 OwnerSkelMesh;                                     // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugTrace;                                       // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCacheFootPrints;                                  // 0x00F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     FluidFootPrintDecal;                               // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSurfaceFootPrint>              DryFootprintDecals;                                // 0x0100(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxFootPrintAmount;                                // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WantedInactiveFootPrints;                          // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LongestLifetime;                                   // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                DecalSize;                                         // 0x011C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WetnessDecreaseAmountPerStep;                      // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ADecalActor*>                    ActiveFootPrintDecalActors;                        // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ADecalActor*>                    InactiveFootPrintDecalActors;                      // 0x0140(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	float                                         GroundTraceLength;                                 // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             FluidTraceChannel;                                 // 0x0154(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnFootDown(const struct FVector& Location, EFootType FootStepType, const class FName& BoneName);
	void OnFootUp(const struct FVector& Location, EFootType FootStepType, const class FName& BoneName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FootPrintSpawnerComponent">();
	}
	static class UFootPrintSpawnerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootPrintSpawnerComponent>();
	}
};
static_assert(alignof(UFootPrintSpawnerComponent) == 0x000008, "Wrong alignment on UFootPrintSpawnerComponent");
static_assert(sizeof(UFootPrintSpawnerComponent) == 0x000158, "Wrong size on UFootPrintSpawnerComponent");
static_assert(offsetof(UFootPrintSpawnerComponent, FeetDefinitions) == 0x0000B8, "Member 'UFootPrintSpawnerComponent::FeetDefinitions' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, FootStepVFX) == 0x0000C8, "Member 'UFootPrintSpawnerComponent::FootStepVFX' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, bTraceAlongFeetRotation) == 0x0000D8, "Member 'UFootPrintSpawnerComponent::bTraceAlongFeetRotation' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, FeetGroundDirection) == 0x0000D9, "Member 'UFootPrintSpawnerComponent::FeetGroundDirection' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, FeetLengthFront) == 0x0000DC, "Member 'UFootPrintSpawnerComponent::FeetLengthFront' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, FeetLengthBack) == 0x0000E0, "Member 'UFootPrintSpawnerComponent::FeetLengthBack' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, OwnerSkelMesh) == 0x0000E8, "Member 'UFootPrintSpawnerComponent::OwnerSkelMesh' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, bDebugTrace) == 0x0000F0, "Member 'UFootPrintSpawnerComponent::bDebugTrace' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, bCacheFootPrints) == 0x0000F1, "Member 'UFootPrintSpawnerComponent::bCacheFootPrints' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, FluidFootPrintDecal) == 0x0000F8, "Member 'UFootPrintSpawnerComponent::FluidFootPrintDecal' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, DryFootprintDecals) == 0x000100, "Member 'UFootPrintSpawnerComponent::DryFootprintDecals' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, MaxFootPrintAmount) == 0x000110, "Member 'UFootPrintSpawnerComponent::MaxFootPrintAmount' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, WantedInactiveFootPrints) == 0x000114, "Member 'UFootPrintSpawnerComponent::WantedInactiveFootPrints' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, LongestLifetime) == 0x000118, "Member 'UFootPrintSpawnerComponent::LongestLifetime' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, DecalSize) == 0x00011C, "Member 'UFootPrintSpawnerComponent::DecalSize' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, WetnessDecreaseAmountPerStep) == 0x000128, "Member 'UFootPrintSpawnerComponent::WetnessDecreaseAmountPerStep' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, ActiveFootPrintDecalActors) == 0x000130, "Member 'UFootPrintSpawnerComponent::ActiveFootPrintDecalActors' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, InactiveFootPrintDecalActors) == 0x000140, "Member 'UFootPrintSpawnerComponent::InactiveFootPrintDecalActors' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, GroundTraceLength) == 0x000150, "Member 'UFootPrintSpawnerComponent::GroundTraceLength' has a wrong offset!");
static_assert(offsetof(UFootPrintSpawnerComponent, FluidTraceChannel) == 0x000154, "Member 'UFootPrintSpawnerComponent::FluidTraceChannel' has a wrong offset!");

// Class ObsidianFox.GameplayAbility_Passive
// 0x0008 (0x03C0 - 0x03B8)
class UGameplayAbility_Passive : public UPiecesGameplayAbility
{
public:
	uint8                                         ActivateAbilityOnGranted : 1;                      // 0x03B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayAbility_Passive">();
	}
	static class UGameplayAbility_Passive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbility_Passive>();
	}
};
static_assert(alignof(UGameplayAbility_Passive) == 0x000008, "Wrong alignment on UGameplayAbility_Passive");
static_assert(sizeof(UGameplayAbility_Passive) == 0x0003C0, "Wrong size on UGameplayAbility_Passive");

// Class ObsidianFox.GameplayAbility_Burrow
// 0x0000 (0x03C0 - 0x03C0)
class UGameplayAbility_Burrow final : public UGameplayAbility_Passive
{
public:
	void SetEnablePawnCollision(bool bEnable);
	void SetFootIKEnable(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayAbility_Burrow">();
	}
	static class UGameplayAbility_Burrow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbility_Burrow>();
	}
};
static_assert(alignof(UGameplayAbility_Burrow) == 0x000008, "Wrong alignment on UGameplayAbility_Burrow");
static_assert(sizeof(UGameplayAbility_Burrow) == 0x0003C0, "Wrong size on UGameplayAbility_Burrow");

// Class ObsidianFox.GameplayAbility_Charge
// 0x0018 (0x03C8 - 0x03B0)
class UGameplayAbility_Charge final : public UGameplayAbility
{
public:
	class UAnimMontage*                           ChargeAnimMontage;                                 // 0x03B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           HitAnimMontage;                                    // 0x03B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MissAnimMontage;                                   // 0x03C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayAbility_Charge">();
	}
	static class UGameplayAbility_Charge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbility_Charge>();
	}
};
static_assert(alignof(UGameplayAbility_Charge) == 0x000008, "Wrong alignment on UGameplayAbility_Charge");
static_assert(sizeof(UGameplayAbility_Charge) == 0x0003C8, "Wrong size on UGameplayAbility_Charge");
static_assert(offsetof(UGameplayAbility_Charge, ChargeAnimMontage) == 0x0003B0, "Member 'UGameplayAbility_Charge::ChargeAnimMontage' has a wrong offset!");
static_assert(offsetof(UGameplayAbility_Charge, HitAnimMontage) == 0x0003B8, "Member 'UGameplayAbility_Charge::HitAnimMontage' has a wrong offset!");
static_assert(offsetof(UGameplayAbility_Charge, MissAnimMontage) == 0x0003C0, "Member 'UGameplayAbility_Charge::MissAnimMontage' has a wrong offset!");

// Class ObsidianFox.GameplayAbility_DeathReaction
// 0x0000 (0x03B0 - 0x03B0)
class UGameplayAbility_DeathReaction : public UGameplayAbility
{
public:
	const struct FGameplayTag GetDeathReactionTag();
	const struct FGameplayTag GetFirstTagMatchingDeathReactionTag(const struct FGameplayTagContainer& TargetTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayAbility_DeathReaction">();
	}
	static class UGameplayAbility_DeathReaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbility_DeathReaction>();
	}
};
static_assert(alignof(UGameplayAbility_DeathReaction) == 0x000008, "Wrong alignment on UGameplayAbility_DeathReaction");
static_assert(sizeof(UGameplayAbility_DeathReaction) == 0x0003B0, "Wrong size on UGameplayAbility_DeathReaction");

// Class ObsidianFox.GameplayAbility_HitReaction
// 0x0000 (0x03B0 - 0x03B0)
class UGameplayAbility_HitReaction : public UGameplayAbility
{
public:
	bool GetHitReactionData(const struct FGameplayEventData& GameplayEventData, struct FHitReactionData* HitReactionData) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayAbility_HitReaction">();
	}
	static class UGameplayAbility_HitReaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbility_HitReaction>();
	}
};
static_assert(alignof(UGameplayAbility_HitReaction) == 0x000008, "Wrong alignment on UGameplayAbility_HitReaction");
static_assert(sizeof(UGameplayAbility_HitReaction) == 0x0003B0, "Wrong size on UGameplayAbility_HitReaction");

// Class ObsidianFox.OFAnimationBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UOFAnimationBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GetActorForwardInputDirectionAngle(const class UOFCharacterMovementComponent* MovementComponent, const class ACharacter* Actor);
	static TSoftObjectPtr<class UAnimMontage> GetAnimationMontageFromAssetManager(class UObject* WorldContextObject, const struct FGameplayTag& AnimationTag, const class ACharacter* Player);
	static float GetBlendInTime(const class UAnimMontage* Montage);
	static float GetBlendspace1DPositionFromAccumulatedCurveValue(const class UBlendSpace1D* BlendSpace, float BlendSpaceInput, const class FName CurveName, float TargetValue);
	static float GetBlendspacePositionFromCurveValue(const class UBlendSpaceBase* BlendSpace, const struct FVector& BlendSpaceInput, const class FName CurveName, float TargetValue);
	static struct FVector GetBoneLocationAt(class USkeletalMeshComponent* InSkeletalMesh, class UAnimSequenceBase* AnimSequenceBase, class FName BoneName, float Time);
	static struct FVector GetBoneLocationAtNotifyEvent(class USkeletalMeshComponent* InSkeletalMesh, class UAnimSequenceBase* AnimSequenceBase, class FName BoneName, const struct FAnimNotifyEvent& NotifyEvent);
	static void GetInteractionReachNotifyEvents(class UAnimSequenceBase* SequenceBase, TArray<struct FAnimNotifyEvent>* OutNotifyEvents, const class FName InteractionReachBoneName);
	static void GetInteractionReachNotifyEventsForCurrentSection(class UAnimSequenceBase* SequenceBase, const class UAnimInstance* AnimInstance, TArray<struct FAnimNotifyEvent>* OutNotifyEvents, const class FName InteractionReachBoneName);
	static void GetMontageSections(const class UAnimMontage* AnimMontage, TArray<class FName>* OutNames);
	static float GetMontageSectionStartTime(const class UAnimMontage* Montage, class FName SectionName);
	static void GetNotifyEvents(class UAnimSequenceBase* SequenceBase, TSubclassOf<class UAnimNotify> NotifyClass, TArray<struct FAnimNotifyEvent>* OutNotifyEvents);
	static float GetRandomAnimationStartPosition(class UAnimSequenceBase* AnimSequence);
	static class FName GetRandomMontageSection(class UAnimMontage* AnimMontage);
	static float GetSequenceLength(class UAnimSequenceBase* AnimSequence);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFAnimationBlueprintLibrary">();
	}
	static class UOFAnimationBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFAnimationBlueprintLibrary>();
	}
};
static_assert(alignof(UOFAnimationBlueprintLibrary) == 0x000008, "Wrong alignment on UOFAnimationBlueprintLibrary");
static_assert(sizeof(UOFAnimationBlueprintLibrary) == 0x000028, "Wrong size on UOFAnimationBlueprintLibrary");

// Class ObsidianFox.GameplayAbility_ItemActivatable
// 0x0008 (0x03C0 - 0x03B8)
class UGameplayAbility_ItemActivatable : public UPiecesGameplayAbility
{
public:
	class UItemData*                              RequiredItem;                                      // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayAbility_ItemActivatable">();
	}
	static class UGameplayAbility_ItemActivatable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbility_ItemActivatable>();
	}
};
static_assert(alignof(UGameplayAbility_ItemActivatable) == 0x000008, "Wrong alignment on UGameplayAbility_ItemActivatable");
static_assert(sizeof(UGameplayAbility_ItemActivatable) == 0x0003C0, "Wrong size on UGameplayAbility_ItemActivatable");
static_assert(offsetof(UGameplayAbility_ItemActivatable, RequiredItem) == 0x0003B8, "Member 'UGameplayAbility_ItemActivatable::RequiredItem' has a wrong offset!");

// Class ObsidianFox.GameplayAbility_WeaponAttack
// 0x0010 (0x03C8 - 0x03B8)
class UGameplayAbility_WeaponAttack : public UPiecesGameplayAbility
{
public:
	float                                         HitStrength;                                       // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitForce;                                          // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EForceDirectionType                           ForceDirectionType;                                // 0x03C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C5[0x3];                                      // 0x03C5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayAbility_WeaponAttack">();
	}
	static class UGameplayAbility_WeaponAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbility_WeaponAttack>();
	}
};
static_assert(alignof(UGameplayAbility_WeaponAttack) == 0x000008, "Wrong alignment on UGameplayAbility_WeaponAttack");
static_assert(sizeof(UGameplayAbility_WeaponAttack) == 0x0003C8, "Wrong size on UGameplayAbility_WeaponAttack");
static_assert(offsetof(UGameplayAbility_WeaponAttack, HitStrength) == 0x0003B8, "Member 'UGameplayAbility_WeaponAttack::HitStrength' has a wrong offset!");
static_assert(offsetof(UGameplayAbility_WeaponAttack, HitForce) == 0x0003BC, "Member 'UGameplayAbility_WeaponAttack::HitForce' has a wrong offset!");
static_assert(offsetof(UGameplayAbility_WeaponAttack, Duration) == 0x0003C0, "Member 'UGameplayAbility_WeaponAttack::Duration' has a wrong offset!");
static_assert(offsetof(UGameplayAbility_WeaponAttack, ForceDirectionType) == 0x0003C4, "Member 'UGameplayAbility_WeaponAttack::ForceDirectionType' has a wrong offset!");

// Class ObsidianFox.SubtitleWidget
// 0x0020 (0x0298 - 0x0278)
class USubtitleWidget : public UInGameUIWidget
{
public:
	TSubclassOf<class USubtitleTextWidget>        SubtitleClass;                                     // 0x0278(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_280[0x8];                                      // 0x0280(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVerticalBox*                           SubtitleVerticalBox;                               // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinimumSubtitleLength;                             // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondsToRemoveFromSubtitle;                       // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddSubtitle(const class FText& SubtitleText, const float Time);
	void OnDisplaySubtitlesHandler(const class FText& SubtitleText, const float Time);
	void OnKillSubtitlesHandler();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubtitleWidget">();
	}
	static class USubtitleWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubtitleWidget>();
	}
};
static_assert(alignof(USubtitleWidget) == 0x000008, "Wrong alignment on USubtitleWidget");
static_assert(sizeof(USubtitleWidget) == 0x000298, "Wrong size on USubtitleWidget");
static_assert(offsetof(USubtitleWidget, SubtitleClass) == 0x000278, "Member 'USubtitleWidget::SubtitleClass' has a wrong offset!");
static_assert(offsetof(USubtitleWidget, SubtitleVerticalBox) == 0x000288, "Member 'USubtitleWidget::SubtitleVerticalBox' has a wrong offset!");
static_assert(offsetof(USubtitleWidget, MinimumSubtitleLength) == 0x000290, "Member 'USubtitleWidget::MinimumSubtitleLength' has a wrong offset!");
static_assert(offsetof(USubtitleWidget, SecondsToRemoveFromSubtitle) == 0x000294, "Member 'USubtitleWidget::SecondsToRemoveFromSubtitle' has a wrong offset!");

// Class ObsidianFox.GameplayBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UGameplayBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FRotator FindLookAtRotationBetweenActors(const class AActor* SourceActor, const class AActor* TargetActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayBlueprintLibrary">();
	}
	static class UGameplayBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayBlueprintLibrary>();
	}
};
static_assert(alignof(UGameplayBlueprintLibrary) == 0x000008, "Wrong alignment on UGameplayBlueprintLibrary");
static_assert(sizeof(UGameplayBlueprintLibrary) == 0x000028, "Wrong size on UGameplayBlueprintLibrary");

// Class ObsidianFox.GameSubsystem_BalanceManager
// 0x00B8 (0x00E8 - 0x0030)
class UGameSubsystem_BalanceManager final : public UGameplaySessionSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnResourceBalanceValuesUpdated;                    // 0x0038(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x68];                                      // 0x0048(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         EmptyContainersOpened;                             // 0x00B0(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LastSetRowName;                                    // 0x00B4(0x0008)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x14];                                      // 0x00BC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ResourceBalanceTable;                              // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         bResourceBalanceValuesInitialized;                 // 0x00D8(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            HealGEClass;                                       // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static int32 GetRandomizedResourceTarget(const struct FResourceBalance& ResourceBalance);

	int32 GetAmountOfHealthPerItem();
	int32 GetCurrentItemAmountForType(EConsumableType Type);
	int32 GetMaxPotentialForConsumable(const EConsumableType ConsumableType);
	struct FResourceBalanceCollection GetResourceBalanceValues();
	void IncrementEmptyContainersOpened();
	void ResetEmptyContainersOpened();
	void ResourceBalanceValuesUpdated__DelegateSignature(const struct FResourceBalanceCollection& NewValues);
	void SetDefaultResourceBalanceValues(bool bForceDefaults);
	void UpdateResourceBalanceValues(class FName RowName);

	uint8 GetEmptyContainersOpened() const;
	class FName GetLastSetRowName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSubsystem_BalanceManager">();
	}
	static class UGameSubsystem_BalanceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSubsystem_BalanceManager>();
	}
};
static_assert(alignof(UGameSubsystem_BalanceManager) == 0x000008, "Wrong alignment on UGameSubsystem_BalanceManager");
static_assert(sizeof(UGameSubsystem_BalanceManager) == 0x0000E8, "Wrong size on UGameSubsystem_BalanceManager");
static_assert(offsetof(UGameSubsystem_BalanceManager, OnResourceBalanceValuesUpdated) == 0x000038, "Member 'UGameSubsystem_BalanceManager::OnResourceBalanceValuesUpdated' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_BalanceManager, EmptyContainersOpened) == 0x0000B0, "Member 'UGameSubsystem_BalanceManager::EmptyContainersOpened' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_BalanceManager, LastSetRowName) == 0x0000B4, "Member 'UGameSubsystem_BalanceManager::LastSetRowName' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_BalanceManager, ResourceBalanceTable) == 0x0000D0, "Member 'UGameSubsystem_BalanceManager::ResourceBalanceTable' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_BalanceManager, bResourceBalanceValuesInitialized) == 0x0000D8, "Member 'UGameSubsystem_BalanceManager::bResourceBalanceValuesInitialized' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_BalanceManager, HealGEClass) == 0x0000E0, "Member 'UGameSubsystem_BalanceManager::HealGEClass' has a wrong offset!");

// Class ObsidianFox.DarkManInterface
// 0x0000 (0x0028 - 0x0028)
class IDarkManInterface final : public IInterface
{
public:
	void DeactivateDarkMan();
	float GetObsessionRate();

	bool CanPlayerSeeDarkMan() const;
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DarkManInterface">();
	}
	static class IDarkManInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDarkManInterface>();
	}
};
static_assert(alignof(IDarkManInterface) == 0x000008, "Wrong alignment on IDarkManInterface");
static_assert(sizeof(IDarkManInterface) == 0x000028, "Wrong size on IDarkManInterface");

// Class ObsidianFox.GameSubsystem_MapData
// 0x0120 (0x0150 - 0x0030)
class UGameSubsystem_MapData final : public UGameplaySessionSubsystem
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MapDercetoActorPosition;                           // 0x0078(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_84[0xC];                                       // 0x0084(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             MapOffsetActorTransform;                           // 0x0090(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMapData>                       MapDatas;                                          // 0x00C8(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)
	TSet<struct FGameplayTag>                     ExploredAreas;                                     // 0x00D8(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	TArray<class AMapTrackerVolume*>              CurrentRoomVolumes;                                // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FRoomVolumeCollection>          RoomVolumes;                                       // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateMapDataAndAddToMap(const class UMapMarkerActorComponent* MarkerActorComponent);
	void RemoveMapDataFromMap(const class UMapMarkerActorComponent* MarkerActorComponent);
	void UpdateMapCalculateOffsetSettings(bool bInCalculateOffset, const struct FVector& InMapDercetoActorPosition, const struct FTransform& InMapOffsetActorTransform);
	void UpdateMapData(const class UMapMarkerActorComponent* MarkerActorComponent);

	const class AMapTrackerVolume* GetCurrentRoomVolume() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSubsystem_MapData">();
	}
	static class UGameSubsystem_MapData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSubsystem_MapData>();
	}
};
static_assert(alignof(UGameSubsystem_MapData) == 0x000010, "Wrong alignment on UGameSubsystem_MapData");
static_assert(sizeof(UGameSubsystem_MapData) == 0x000150, "Wrong size on UGameSubsystem_MapData");
static_assert(offsetof(UGameSubsystem_MapData, MapDercetoActorPosition) == 0x000078, "Member 'UGameSubsystem_MapData::MapDercetoActorPosition' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_MapData, MapOffsetActorTransform) == 0x000090, "Member 'UGameSubsystem_MapData::MapOffsetActorTransform' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_MapData, MapDatas) == 0x0000C8, "Member 'UGameSubsystem_MapData::MapDatas' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_MapData, ExploredAreas) == 0x0000D8, "Member 'UGameSubsystem_MapData::ExploredAreas' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_MapData, CurrentRoomVolumes) == 0x000128, "Member 'UGameSubsystem_MapData::CurrentRoomVolumes' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_MapData, RoomVolumes) == 0x000138, "Member 'UGameSubsystem_MapData::RoomVolumes' has a wrong offset!");

// Class ObsidianFox.GameSubsystem_PlayState
// 0x0078 (0x00A8 - 0x0030)
class UGameSubsystem_PlayState final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnGameMainStateChanged;                            // 0x0030(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCombatStateChanged;                              // 0x0040(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEnemyAggroStateChanged;                          // 0x0050(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerHealthStateChanged;                        // 0x0060(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x38];                                      // 0x0070(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static EPlayerCharacterType GetPlayerCharacterType(class UWorld* WorldContextObject, int32 PlayerIndex);

	void CombatStateChanged__DelegateSignature(bool bNewIsInCombat);
	void EnemyAggroStateChanged__DelegateSignature(bool bHasAggro, bool bInCombat);
	void GameMainStateChanged__DelegateSignature(EGameMainState OldGameState, EGameMainState NewGameState);
	EGameMainState GetMainState();
	void LoadingScreenFinishedHandler();
	void LoadingScreenStartedHandler();
	void PlayerHealthStateChanged__DelegateSignature(EPlayerHealthState NewHealthState);
	void PopMainState(const class UObject* StateOwner);
	void PushMainState(const class UObject* StateOwner, EGameMainState NewState);
	void ReportActOfAggression();
	void ResetMainState();
	void UpdatePlayerHealthState(float NewHealth, float MaxHealth);

	bool GetIsInCombat() const;
	EPlayerHealthState GetPlayerHealthState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSubsystem_PlayState">();
	}
	static class UGameSubsystem_PlayState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSubsystem_PlayState>();
	}
};
static_assert(alignof(UGameSubsystem_PlayState) == 0x000008, "Wrong alignment on UGameSubsystem_PlayState");
static_assert(sizeof(UGameSubsystem_PlayState) == 0x0000A8, "Wrong size on UGameSubsystem_PlayState");
static_assert(offsetof(UGameSubsystem_PlayState, OnGameMainStateChanged) == 0x000030, "Member 'UGameSubsystem_PlayState::OnGameMainStateChanged' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_PlayState, OnCombatStateChanged) == 0x000040, "Member 'UGameSubsystem_PlayState::OnCombatStateChanged' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_PlayState, OnEnemyAggroStateChanged) == 0x000050, "Member 'UGameSubsystem_PlayState::OnEnemyAggroStateChanged' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_PlayState, OnPlayerHealthStateChanged) == 0x000060, "Member 'UGameSubsystem_PlayState::OnPlayerHealthStateChanged' has a wrong offset!");

// Class ObsidianFox.GameSubsystem_Talisman
// 0x0040 (0x0070 - 0x0030)
class UGameSubsystem_Talisman final : public UGameplaySessionSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Ring0Value;                                        // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ring1Value;                                        // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ring2Value;                                        // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnNewTalismanCombination;                          // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSetTalismanActiveRing;                           // 0x0058(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         ActiveRing;                                        // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetCurrentTalismanCombination();
	void SetActiveRing(const int32 NewActiveRing);
	void SetRing0Value(int32 Value);
	void SetRing1Value(int32 Value);
	void SetRing2Value(int32 Value);
	void TalismanCombinationDelegate__DelegateSignature(int32 NewTalismanCombination);
	void TalismanNewActiveRingDelegate__DelegateSignature(int32 NewActiveRing);

	int32 GetActiveRing() const;
	int32 GetRing0Value() const;
	int32 GetRing1Value() const;
	int32 GetRing2Value() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSubsystem_Talisman">();
	}
	static class UGameSubsystem_Talisman* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameSubsystem_Talisman>();
	}
};
static_assert(alignof(UGameSubsystem_Talisman) == 0x000008, "Wrong alignment on UGameSubsystem_Talisman");
static_assert(sizeof(UGameSubsystem_Talisman) == 0x000070, "Wrong size on UGameSubsystem_Talisman");
static_assert(offsetof(UGameSubsystem_Talisman, Ring0Value) == 0x000038, "Member 'UGameSubsystem_Talisman::Ring0Value' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_Talisman, Ring1Value) == 0x00003C, "Member 'UGameSubsystem_Talisman::Ring1Value' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_Talisman, Ring2Value) == 0x000040, "Member 'UGameSubsystem_Talisman::Ring2Value' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_Talisman, OnNewTalismanCombination) == 0x000048, "Member 'UGameSubsystem_Talisman::OnNewTalismanCombination' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_Talisman, OnSetTalismanActiveRing) == 0x000058, "Member 'UGameSubsystem_Talisman::OnSetTalismanActiveRing' has a wrong offset!");
static_assert(offsetof(UGameSubsystem_Talisman, ActiveRing) == 0x000068, "Member 'UGameSubsystem_Talisman::ActiveRing' has a wrong offset!");

// Class ObsidianFox.GammaSettingsHud
// 0x0018 (0x0278 - 0x0260)
class UGammaSettingsHud final : public UUserWidget
{
public:
	class USlider*                                BrightnessSlider;                                  // 0x0260(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                AcceptButton;                                      // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BackButton;                                        // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DpadPressedLeft();
	void DpadPressedRight();
	void FaceButtonBottomPressed();
	void FaceButtonRightPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GammaSettingsHud">();
	}
	static class UGammaSettingsHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGammaSettingsHud>();
	}
};
static_assert(alignof(UGammaSettingsHud) == 0x000008, "Wrong alignment on UGammaSettingsHud");
static_assert(sizeof(UGammaSettingsHud) == 0x000278, "Wrong size on UGammaSettingsHud");
static_assert(offsetof(UGammaSettingsHud, BrightnessSlider) == 0x000260, "Member 'UGammaSettingsHud::BrightnessSlider' has a wrong offset!");
static_assert(offsetof(UGammaSettingsHud, AcceptButton) == 0x000268, "Member 'UGammaSettingsHud::AcceptButton' has a wrong offset!");
static_assert(offsetof(UGammaSettingsHud, BackButton) == 0x000270, "Member 'UGammaSettingsHud::BackButton' has a wrong offset!");

// Class ObsidianFox.GauntletPerformanceBlueprintSampler
// 0x0018 (0x0270 - 0x0258)
class AGauntletPerformanceBlueprintSampler final : public AGuantletPerformenceSampler
{
public:
	FMulticastInlineDelegateProperty_             OnPerformanceTestDone;                             // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_26C[0x4];                                      // 0x026C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GauntletPerformanceBlueprintSampler">();
	}
	static class AGauntletPerformanceBlueprintSampler* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGauntletPerformanceBlueprintSampler>();
	}
};
static_assert(alignof(AGauntletPerformanceBlueprintSampler) == 0x000008, "Wrong alignment on AGauntletPerformanceBlueprintSampler");
static_assert(sizeof(AGauntletPerformanceBlueprintSampler) == 0x000270, "Wrong size on AGauntletPerformanceBlueprintSampler");
static_assert(offsetof(AGauntletPerformanceBlueprintSampler, OnPerformanceTestDone) == 0x000258, "Member 'AGauntletPerformanceBlueprintSampler::OnPerformanceTestDone' has a wrong offset!");
static_assert(offsetof(AGauntletPerformanceBlueprintSampler, Priority) == 0x000268, "Member 'AGauntletPerformanceBlueprintSampler::Priority' has a wrong offset!");

// Class ObsidianFox.GenericTeamAgentComponent
// 0x0010 (0x00C8 - 0x00B8)
class UGenericTeamAgentComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGenericTeamId                         OurTeamID;                                         // 0x00C0(0x0001)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x7];                                       // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericTeamAgentComponent">();
	}
	static class UGenericTeamAgentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericTeamAgentComponent>();
	}
};
static_assert(alignof(UGenericTeamAgentComponent) == 0x000008, "Wrong alignment on UGenericTeamAgentComponent");
static_assert(sizeof(UGenericTeamAgentComponent) == 0x0000C8, "Wrong size on UGenericTeamAgentComponent");
static_assert(offsetof(UGenericTeamAgentComponent, OurTeamID) == 0x0000C0, "Member 'UGenericTeamAgentComponent::OurTeamID' has a wrong offset!");

// Class ObsidianFox.GuantletEditorTest
// 0x0030 (0x0268 - 0x0238)
class AGuantletEditorTest final : public AActor
{
public:
	uint8                                         Pad_238[0x30];                                     // 0x0238(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RunGauntlet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GuantletEditorTest">();
	}
	static class AGuantletEditorTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGuantletEditorTest>();
	}
};
static_assert(alignof(AGuantletEditorTest) == 0x000008, "Wrong alignment on AGuantletEditorTest");
static_assert(sizeof(AGuantletEditorTest) == 0x000268, "Wrong size on AGuantletEditorTest");

// Class ObsidianFox.HandPosesAnimInterface
// 0x0000 (0x0028 - 0x0028)
class IHandPosesAnimInterface final : public IInterface
{
public:
	void ApplyHandPose(const class UObject* Instigator, const TSoftObjectPtr<class UAnimSequenceBase>& HandPoseSequence, class FName BoneName);
	void RemoveHandPose(const class UObject* Instigator, class FName BoneName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HandPosesAnimInterface">();
	}
	static class IHandPosesAnimInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHandPosesAnimInterface>();
	}
};
static_assert(alignof(IHandPosesAnimInterface) == 0x000008, "Wrong alignment on IHandPosesAnimInterface");
static_assert(sizeof(IHandPosesAnimInterface) == 0x000028, "Wrong size on IHandPosesAnimInterface");

// Class ObsidianFox.HeavyHitReactionEvaluator
// 0x0028 (0x0050 - 0x0028)
class UHeavyHitReactionEvaluator final : public UObject
{
public:
	float                                         HeavyReactionDamageThreshold;                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeavyReactionTimeThreshold;                        // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class AObsidianFoxCharacter*                  Owner;                                             // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnHeavyReactionPlayed();
	void OnOwnerHealthChanged(float NewCurrentHealth, float DeltaValue, const struct FGameplayTagContainer& EventTags);
	void OnTimerElapsed();
	bool ShouldPlayHeavyReaction(const struct FHitReactionData& HitReactionData, const class UObject* OptionalObject, const class UAnimMontage* ReactionMontage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HeavyHitReactionEvaluator">();
	}
	static class UHeavyHitReactionEvaluator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHeavyHitReactionEvaluator>();
	}
};
static_assert(alignof(UHeavyHitReactionEvaluator) == 0x000008, "Wrong alignment on UHeavyHitReactionEvaluator");
static_assert(sizeof(UHeavyHitReactionEvaluator) == 0x000050, "Wrong size on UHeavyHitReactionEvaluator");
static_assert(offsetof(UHeavyHitReactionEvaluator, HeavyReactionDamageThreshold) == 0x000028, "Member 'UHeavyHitReactionEvaluator::HeavyReactionDamageThreshold' has a wrong offset!");
static_assert(offsetof(UHeavyHitReactionEvaluator, HeavyReactionTimeThreshold) == 0x00002C, "Member 'UHeavyHitReactionEvaluator::HeavyReactionTimeThreshold' has a wrong offset!");
static_assert(offsetof(UHeavyHitReactionEvaluator, Owner) == 0x000048, "Member 'UHeavyHitReactionEvaluator::Owner' has a wrong offset!");

// Class ObsidianFox.HelpTextHud
// 0x0008 (0x0268 - 0x0260)
class UHelpTextHud final : public UUserWidget
{
public:
	float                                         CurrentPercentage;                                 // 0x0260(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BottomFaceButtonPressed();
	void SetupInput();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelpTextHud">();
	}
	static class UHelpTextHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelpTextHud>();
	}
};
static_assert(alignof(UHelpTextHud) == 0x000008, "Wrong alignment on UHelpTextHud");
static_assert(sizeof(UHelpTextHud) == 0x000268, "Wrong size on UHelpTextHud");
static_assert(offsetof(UHelpTextHud, CurrentPercentage) == 0x000260, "Member 'UHelpTextHud::CurrentPercentage' has a wrong offset!");

// Class ObsidianFox.HighlightItemPickupHud
// 0x00B0 (0x0310 - 0x0260)
class UHighlightItemPickupHud final : public UUserWidget
{
public:
	class UImage*                                 ItemImage;                                         // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemText;                                          // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBoxItem;                                       // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHelpButtonHud*                         ButtonWidget;                                      // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              InteractButtonTexture;                             // 0x0280(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UItemData*                              ItemData;                                          // 0x02A8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UItemData>               MapItemData;                                       // 0x02B0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D8[0x10];                                     // 0x02D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           OpenInvestigationMenuAction;                       // 0x02E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           CloseAction;                                       // 0x02F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           KeyAndPuzzleItemTag;                               // 0x02F8(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CollectibleTag;                                    // 0x0300(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseDownWidget();
	void SetBackKeyPromptVisibility(ESlateVisibility NewVisibility);
	void SetInvestigationKeyWidgetVisibility(ESlateVisibility NewVisibility);
	void UpdateItemFrameAndText(const EItemType ItemType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HighlightItemPickupHud">();
	}
	static class UHighlightItemPickupHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHighlightItemPickupHud>();
	}
};
static_assert(alignof(UHighlightItemPickupHud) == 0x000008, "Wrong alignment on UHighlightItemPickupHud");
static_assert(sizeof(UHighlightItemPickupHud) == 0x000310, "Wrong size on UHighlightItemPickupHud");
static_assert(offsetof(UHighlightItemPickupHud, ItemImage) == 0x000260, "Member 'UHighlightItemPickupHud::ItemImage' has a wrong offset!");
static_assert(offsetof(UHighlightItemPickupHud, ItemText) == 0x000268, "Member 'UHighlightItemPickupHud::ItemText' has a wrong offset!");
static_assert(offsetof(UHighlightItemPickupHud, SizeBoxItem) == 0x000270, "Member 'UHighlightItemPickupHud::SizeBoxItem' has a wrong offset!");
static_assert(offsetof(UHighlightItemPickupHud, ButtonWidget) == 0x000278, "Member 'UHighlightItemPickupHud::ButtonWidget' has a wrong offset!");
static_assert(offsetof(UHighlightItemPickupHud, InteractButtonTexture) == 0x000280, "Member 'UHighlightItemPickupHud::InteractButtonTexture' has a wrong offset!");
static_assert(offsetof(UHighlightItemPickupHud, ItemData) == 0x0002A8, "Member 'UHighlightItemPickupHud::ItemData' has a wrong offset!");
static_assert(offsetof(UHighlightItemPickupHud, MapItemData) == 0x0002B0, "Member 'UHighlightItemPickupHud::MapItemData' has a wrong offset!");
static_assert(offsetof(UHighlightItemPickupHud, OpenInvestigationMenuAction) == 0x0002E8, "Member 'UHighlightItemPickupHud::OpenInvestigationMenuAction' has a wrong offset!");
static_assert(offsetof(UHighlightItemPickupHud, CloseAction) == 0x0002F0, "Member 'UHighlightItemPickupHud::CloseAction' has a wrong offset!");
static_assert(offsetof(UHighlightItemPickupHud, KeyAndPuzzleItemTag) == 0x0002F8, "Member 'UHighlightItemPickupHud::KeyAndPuzzleItemTag' has a wrong offset!");
static_assert(offsetof(UHighlightItemPickupHud, CollectibleTag) == 0x000300, "Member 'UHighlightItemPickupHud::CollectibleTag' has a wrong offset!");

// Class ObsidianFox.AnimNotifyState_DisableHipOffset
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_DisableHipOffset final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_DisableHipOffset">();
	}
	static class UAnimNotifyState_DisableHipOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_DisableHipOffset>();
	}
};
static_assert(alignof(UAnimNotifyState_DisableHipOffset) == 0x000008, "Wrong alignment on UAnimNotifyState_DisableHipOffset");
static_assert(sizeof(UAnimNotifyState_DisableHipOffset) == 0x000030, "Wrong size on UAnimNotifyState_DisableHipOffset");

// Class ObsidianFox.HitReactionComponent
// 0x0100 (0x0310 - 0x0210)
#pragma pack(push, 0x1)
class alignas(0x10) UHitReactionComponent : public USceneComponent
{
public:
	TMap<class FName, struct FReactionMontageContainer> BoneMontageMap;                                    // 0x0208(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ECardinalDirection, struct FReactionMontageData> QuadrantMontageMap;                                // 0x0258(0x0050)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FReactionMontageData                   SpecialHitReactionMontageData;                     // 0x02A8(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         TraceSweepRadius;                                  // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bIsPlayingMontage : 1;                             // 0x02C4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2C5[0xB];                                      // 0x02C5(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	EHitReactionType                              CurrentHitReactionType;                            // 0x02D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHitReactionType                              CurrentPlayingReactionType;                        // 0x02D1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D2[0x6];                                      // 0x02D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHitreactionDone;                                 // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHitreactionBegin;                                // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x10];                                     // 0x02F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndHitReaction(bool bFailed, bool bWasInterrupted, EHitReactionType HitReactionType);
	void OnAnimationBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnHeavyReaction(const struct FHitReactionData& HitReactionData, class AObsidianFoxCharacter* Character, const struct FReactionMontageData& MontageData);
	void OnHitreactionBegin__DelegateSignature(EHitReactionType HitReactionType);
	void OnHitreactionDone__DelegateSignature(EHitReactionType HitReactionType, bool bFailed, bool bWasInterrupted);
	void OnLightReaction(const struct FHitReactionData& HitReactionData, class AObsidianFoxCharacter* Character, const struct FReactionMontageData& MontageData);
	void OnMediumReaction(const struct FHitReactionData& HitReactionData, class AObsidianFoxCharacter* Character, const struct FReactionMontageData& MontageData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitReactionComponent">();
	}
	static class UHitReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitReactionComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UHitReactionComponent) == 0x000010, "Wrong alignment on UHitReactionComponent");
static_assert(sizeof(UHitReactionComponent) == 0x000310, "Wrong size on UHitReactionComponent");
static_assert(offsetof(UHitReactionComponent, BoneMontageMap) == 0x000208, "Member 'UHitReactionComponent::BoneMontageMap' has a wrong offset!");
static_assert(offsetof(UHitReactionComponent, QuadrantMontageMap) == 0x000258, "Member 'UHitReactionComponent::QuadrantMontageMap' has a wrong offset!");
static_assert(offsetof(UHitReactionComponent, SpecialHitReactionMontageData) == 0x0002A8, "Member 'UHitReactionComponent::SpecialHitReactionMontageData' has a wrong offset!");
static_assert(offsetof(UHitReactionComponent, TraceSweepRadius) == 0x0002C0, "Member 'UHitReactionComponent::TraceSweepRadius' has a wrong offset!");
static_assert(offsetof(UHitReactionComponent, CurrentHitReactionType) == 0x0002D0, "Member 'UHitReactionComponent::CurrentHitReactionType' has a wrong offset!");
static_assert(offsetof(UHitReactionComponent, CurrentPlayingReactionType) == 0x0002D1, "Member 'UHitReactionComponent::CurrentPlayingReactionType' has a wrong offset!");
static_assert(offsetof(UHitReactionComponent, OnHitreactionDone) == 0x0002D8, "Member 'UHitReactionComponent::OnHitreactionDone' has a wrong offset!");
static_assert(offsetof(UHitReactionComponent, OnHitreactionBegin) == 0x0002E8, "Member 'UHitReactionComponent::OnHitreactionBegin' has a wrong offset!");

// Class ObsidianFox.HittableInterface
// 0x0000 (0x0028 - 0x0028)
class IHittableInterface final : public IInterface
{
public:
	void WeaponHit(class AActor* Weapon, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HittableInterface">();
	}
	static class IHittableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHittableInterface>();
	}
};
static_assert(alignof(IHittableInterface) == 0x000008, "Wrong alignment on IHittableInterface");
static_assert(sizeof(IHittableInterface) == 0x000028, "Wrong size on IHittableInterface");

// Class ObsidianFox.HomeRangeComponent
// 0x0028 (0x00E0 - 0x00B8)
class UHomeRangeComponent final : public UActorComponent
{
public:
	class AHomeRangeActor*                        HomeRange;                                         // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WithinHomeRangeKey;                                // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WithinHomeRangeLocation;                           // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AHomeRangeActor>            HomeRangeActorClass;                               // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHomeRangeOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor);
	void OnHomeRangeOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HomeRangeComponent">();
	}
	static class UHomeRangeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHomeRangeComponent>();
	}
};
static_assert(alignof(UHomeRangeComponent) == 0x000008, "Wrong alignment on UHomeRangeComponent");
static_assert(sizeof(UHomeRangeComponent) == 0x0000E0, "Wrong size on UHomeRangeComponent");
static_assert(offsetof(UHomeRangeComponent, HomeRange) == 0x0000B8, "Member 'UHomeRangeComponent::HomeRange' has a wrong offset!");
static_assert(offsetof(UHomeRangeComponent, WithinHomeRangeKey) == 0x0000C0, "Member 'UHomeRangeComponent::WithinHomeRangeKey' has a wrong offset!");
static_assert(offsetof(UHomeRangeComponent, WithinHomeRangeLocation) == 0x0000C8, "Member 'UHomeRangeComponent::WithinHomeRangeLocation' has a wrong offset!");
static_assert(offsetof(UHomeRangeComponent, HomeRangeActorClass) == 0x0000D0, "Member 'UHomeRangeComponent::HomeRangeActorClass' has a wrong offset!");

// Class ObsidianFox.ImpassableTerrainDetectorComponent
// 0x00D0 (0x0188 - 0x00B8)
class UImpassableTerrainDetectorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FWallHitSettings                       WallHitSettings;                                   // 0x00C8(0x003C)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FPhysicsAnimationSettings              PhysicsAnimationSettings;                          // 0x0104(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FallbackReactionMontage;                           // 0x011C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           LedgeRunMontage;                                   // 0x0124(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           LedgeWalkMontage;                                  // 0x012C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActivateAngle;                                     // 0x0134(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinWallStopHeight;                                 // 0x0138(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWallStopHeight;                                 // 0x013C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveSpeedReactionThreshold;                        // 0x0140(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      OwnerCollider;                                     // 0x0148(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UAnimMontage>            LastPlayedMontage;                                 // 0x0150(0x0028)(Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimationInterruptInputDifference;                 // 0x0178(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17C[0xC];                                      // 0x017C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterPossessed(const class AOFPlayerCharacter* Character);
	void OnColliderHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImpassableTerrainDetectorComponent">();
	}
	static class UImpassableTerrainDetectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImpassableTerrainDetectorComponent>();
	}
};
static_assert(alignof(UImpassableTerrainDetectorComponent) == 0x000008, "Wrong alignment on UImpassableTerrainDetectorComponent");
static_assert(sizeof(UImpassableTerrainDetectorComponent) == 0x000188, "Wrong size on UImpassableTerrainDetectorComponent");
static_assert(offsetof(UImpassableTerrainDetectorComponent, WallHitSettings) == 0x0000C8, "Member 'UImpassableTerrainDetectorComponent::WallHitSettings' has a wrong offset!");
static_assert(offsetof(UImpassableTerrainDetectorComponent, PhysicsAnimationSettings) == 0x000104, "Member 'UImpassableTerrainDetectorComponent::PhysicsAnimationSettings' has a wrong offset!");
static_assert(offsetof(UImpassableTerrainDetectorComponent, FallbackReactionMontage) == 0x00011C, "Member 'UImpassableTerrainDetectorComponent::FallbackReactionMontage' has a wrong offset!");
static_assert(offsetof(UImpassableTerrainDetectorComponent, LedgeRunMontage) == 0x000124, "Member 'UImpassableTerrainDetectorComponent::LedgeRunMontage' has a wrong offset!");
static_assert(offsetof(UImpassableTerrainDetectorComponent, LedgeWalkMontage) == 0x00012C, "Member 'UImpassableTerrainDetectorComponent::LedgeWalkMontage' has a wrong offset!");
static_assert(offsetof(UImpassableTerrainDetectorComponent, ActivateAngle) == 0x000134, "Member 'UImpassableTerrainDetectorComponent::ActivateAngle' has a wrong offset!");
static_assert(offsetof(UImpassableTerrainDetectorComponent, MinWallStopHeight) == 0x000138, "Member 'UImpassableTerrainDetectorComponent::MinWallStopHeight' has a wrong offset!");
static_assert(offsetof(UImpassableTerrainDetectorComponent, MaxWallStopHeight) == 0x00013C, "Member 'UImpassableTerrainDetectorComponent::MaxWallStopHeight' has a wrong offset!");
static_assert(offsetof(UImpassableTerrainDetectorComponent, MoveSpeedReactionThreshold) == 0x000140, "Member 'UImpassableTerrainDetectorComponent::MoveSpeedReactionThreshold' has a wrong offset!");
static_assert(offsetof(UImpassableTerrainDetectorComponent, OwnerCollider) == 0x000148, "Member 'UImpassableTerrainDetectorComponent::OwnerCollider' has a wrong offset!");
static_assert(offsetof(UImpassableTerrainDetectorComponent, LastPlayedMontage) == 0x000150, "Member 'UImpassableTerrainDetectorComponent::LastPlayedMontage' has a wrong offset!");
static_assert(offsetof(UImpassableTerrainDetectorComponent, AnimationInterruptInputDifference) == 0x000178, "Member 'UImpassableTerrainDetectorComponent::AnimationInterruptInputDifference' has a wrong offset!");

// Class ObsidianFox.WaterLevelComponent
// 0x0020 (0x00D8 - 0x00B8)
class UWaterLevelComponent : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x10];                                      // 0x00B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaterLevel;                                        // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0xC];                                       // 0x00CC(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintBeginOverlap(const class AWaterLevelTriggerVolume* WaterLevelVolume, const class UWaterLevelTriggerBoxComponent* TriggerComponent);
	void BlueprintEndOverlapAny(const class AWaterLevelTriggerVolume* WaterLevelVolume, const class UWaterLevelTriggerBoxComponent* TriggerComponent);
	void BlueprintEndOverlapCurrent(const class AWaterLevelTriggerVolume* WaterLevelVolume, const class UWaterLevelTriggerBoxComponent* TriggerComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterLevelComponent">();
	}
	static class UWaterLevelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterLevelComponent>();
	}
};
static_assert(alignof(UWaterLevelComponent) == 0x000008, "Wrong alignment on UWaterLevelComponent");
static_assert(sizeof(UWaterLevelComponent) == 0x0000D8, "Wrong size on UWaterLevelComponent");
static_assert(offsetof(UWaterLevelComponent, WaterLevel) == 0x0000C8, "Member 'UWaterLevelComponent::WaterLevel' has a wrong offset!");

// Class ObsidianFox.InGameUIWidget_Combat
// 0x0058 (0x02D0 - 0x0278)
class UInGameUIWidget_Combat : public UInGameUIWidget
{
public:
	TWeakObjectPtr<class AOFPlayerCharacter>      PlayerCharacter;                                   // 0x0278(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInGameUIWidget_Equipment*              Equipment;                                         // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInGameUIWidget_HealthBar*              HealthBar;                                         // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInGameUIWidget_QuickSlotWidget*        QuickSlot;                                         // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeInEquipment;                                   // 0x0298(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeInHealthBar;                                   // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FadeInQuickSlot;                                   // 0x02A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VisibilityTimerLength;                             // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QuickSlotAmmoIncrementVisibilityTimerLength;       // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B8[0x18];                                     // 0x02B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginReload();
	void OnCharacterAim(bool bIsAiming);
	void OnCombatStateChanged(bool bNewIsInCombat);
	void OnEndReload();
	void OnHealthChanged(float NewCurrentHealth, float DeltaValue, const struct FGameplayTagContainer& EventTags);
	void OnItemIncrement(const class UItemData* ItemData, const struct FItemDisplayInfo& ItemDisplayInfo, int32 Amount);
	void OnPlayerEquipmentUpdated(const struct FWeaponInfo& EquippedWeapon, const struct FWeaponInfo& UnequippedWeapon);
	void TryingToPickUpMaxStackItemHandler(const class UItemData* ItemData);
	void WeaponBeginAttack(const struct FGameplayTag& AttackEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameUIWidget_Combat">();
	}
	static class UInGameUIWidget_Combat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameUIWidget_Combat>();
	}
};
static_assert(alignof(UInGameUIWidget_Combat) == 0x000008, "Wrong alignment on UInGameUIWidget_Combat");
static_assert(sizeof(UInGameUIWidget_Combat) == 0x0002D0, "Wrong size on UInGameUIWidget_Combat");
static_assert(offsetof(UInGameUIWidget_Combat, PlayerCharacter) == 0x000278, "Member 'UInGameUIWidget_Combat::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Combat, Equipment) == 0x000280, "Member 'UInGameUIWidget_Combat::Equipment' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Combat, HealthBar) == 0x000288, "Member 'UInGameUIWidget_Combat::HealthBar' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Combat, QuickSlot) == 0x000290, "Member 'UInGameUIWidget_Combat::QuickSlot' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Combat, FadeInEquipment) == 0x000298, "Member 'UInGameUIWidget_Combat::FadeInEquipment' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Combat, FadeInHealthBar) == 0x0002A0, "Member 'UInGameUIWidget_Combat::FadeInHealthBar' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Combat, FadeInQuickSlot) == 0x0002A8, "Member 'UInGameUIWidget_Combat::FadeInQuickSlot' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Combat, VisibilityTimerLength) == 0x0002B0, "Member 'UInGameUIWidget_Combat::VisibilityTimerLength' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_Combat, QuickSlotAmmoIncrementVisibilityTimerLength) == 0x0002B4, "Member 'UInGameUIWidget_Combat::QuickSlotAmmoIncrementVisibilityTimerLength' has a wrong offset!");

// Class ObsidianFox.InGameUIWidget_HealthBar
// 0x00C0 (0x0338 - 0x0278)
class UInGameUIWidget_HealthBar : public UInGameUIWidget
{
public:
	class AOFPlayerController*                    PlayerController;                                  // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOFPlayerCharacter*                     PlayerCharacter;                                   // 0x0280(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageHealthBar;                                    // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         BoxHealthPointer;                                  // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterial*                              MaterialHealthBar;                                 // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CurveHealthPercentToPointerAngle;                  // 0x02A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAttribute                     AttributeHealth;                                   // 0x02A8(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAttribute                     AttributeMaxHealth;                                // 0x02E0(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HealthDeltaSpeed;                                  // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimFlashSpeed;                                    // 0x031C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               MaterialInstanceHealthBar;                         // 0x0320(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHealthChanged(float NewCurrentHealth, float DeltaValue, const struct FGameplayTagContainer& EventTags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InGameUIWidget_HealthBar">();
	}
	static class UInGameUIWidget_HealthBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInGameUIWidget_HealthBar>();
	}
};
static_assert(alignof(UInGameUIWidget_HealthBar) == 0x000008, "Wrong alignment on UInGameUIWidget_HealthBar");
static_assert(sizeof(UInGameUIWidget_HealthBar) == 0x000338, "Wrong size on UInGameUIWidget_HealthBar");
static_assert(offsetof(UInGameUIWidget_HealthBar, PlayerController) == 0x000278, "Member 'UInGameUIWidget_HealthBar::PlayerController' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_HealthBar, PlayerCharacter) == 0x000280, "Member 'UInGameUIWidget_HealthBar::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_HealthBar, ImageHealthBar) == 0x000288, "Member 'UInGameUIWidget_HealthBar::ImageHealthBar' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_HealthBar, BoxHealthPointer) == 0x000290, "Member 'UInGameUIWidget_HealthBar::BoxHealthPointer' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_HealthBar, MaterialHealthBar) == 0x000298, "Member 'UInGameUIWidget_HealthBar::MaterialHealthBar' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_HealthBar, CurveHealthPercentToPointerAngle) == 0x0002A0, "Member 'UInGameUIWidget_HealthBar::CurveHealthPercentToPointerAngle' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_HealthBar, AttributeHealth) == 0x0002A8, "Member 'UInGameUIWidget_HealthBar::AttributeHealth' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_HealthBar, AttributeMaxHealth) == 0x0002E0, "Member 'UInGameUIWidget_HealthBar::AttributeMaxHealth' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_HealthBar, HealthDeltaSpeed) == 0x000318, "Member 'UInGameUIWidget_HealthBar::HealthDeltaSpeed' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_HealthBar, AnimFlashSpeed) == 0x00031C, "Member 'UInGameUIWidget_HealthBar::AnimFlashSpeed' has a wrong offset!");
static_assert(offsetof(UInGameUIWidget_HealthBar, MaterialInstanceHealthBar) == 0x000320, "Member 'UInGameUIWidget_HealthBar::MaterialInstanceHealthBar' has a wrong offset!");

// Class ObsidianFox.InteractInfoTextHud
// 0x0058 (0x02D0 - 0x0278)
class UInteractInfoTextHud : public UInGameUIWidget
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVerticalBox*                           VerticalBoxObjectives;                             // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimerLength;                                       // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TimerLengthNewItemHint;                            // 0x0290(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UOFStruckTextWidget>        StruckTextWidgetClass;                             // 0x0298(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UOFStruckTextWidget*>            ObjectiveTextWidgetCollection;                     // 0x02A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0x20];                                     // 0x02B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CollapseAllObjectiveTextWidget();
	void HideNewItemHint();
	void OnBlendOutObjective();
	void OnBlendOutTimerFinished();
	void OnItemAddedOrRemoved(const class UItemData* ItemData);
	void OnItemLookedAt(const TSoftObjectPtr<class UItemData> ItemData);
	void OnObjectiveCompleted(EObjectiveParts CompletedPart, const class FText& ObjectiveText);
	void OnObjectiveReview();
	void OnObjectiveUpdate(const class UObjectivesData* ObjectiveData, const struct FObjectiveInfo& ObjectiveInfo, EObjectiveParts OldPart, EObjectiveParts NewPart);
	void OnShowObjective();
	void OnSubObjectiveCompletedHandler(const class UObjectivesData* ObjectivesData, const struct FObjectiveInfo& ObjectiveInfo, const EObjectiveParts Part);
	void OnSubObjectiveStartedHandler(const class UObjectivesData* ObjectivesData, const struct FObjectiveInfo& ObjectiveInfo, const EObjectiveParts Part);
	void ShowNewItemHint();
	void UpdateNewItemHintVisibility();

	bool IsNewHintTimerActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractInfoTextHud">();
	}
	static class UInteractInfoTextHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractInfoTextHud>();
	}
};
static_assert(alignof(UInteractInfoTextHud) == 0x000008, "Wrong alignment on UInteractInfoTextHud");
static_assert(sizeof(UInteractInfoTextHud) == 0x0002D0, "Wrong size on UInteractInfoTextHud");
static_assert(offsetof(UInteractInfoTextHud, VerticalBoxObjectives) == 0x000280, "Member 'UInteractInfoTextHud::VerticalBoxObjectives' has a wrong offset!");
static_assert(offsetof(UInteractInfoTextHud, TimerLength) == 0x000288, "Member 'UInteractInfoTextHud::TimerLength' has a wrong offset!");
static_assert(offsetof(UInteractInfoTextHud, TimerLengthNewItemHint) == 0x000290, "Member 'UInteractInfoTextHud::TimerLengthNewItemHint' has a wrong offset!");
static_assert(offsetof(UInteractInfoTextHud, StruckTextWidgetClass) == 0x000298, "Member 'UInteractInfoTextHud::StruckTextWidgetClass' has a wrong offset!");
static_assert(offsetof(UInteractInfoTextHud, ObjectiveTextWidgetCollection) == 0x0002A0, "Member 'UInteractInfoTextHud::ObjectiveTextWidgetCollection' has a wrong offset!");

// Class ObsidianFox.InteractionComponent
// 0x0290 (0x07C0 - 0x0530)
class UInteractionComponent final : public UInteractionComponentBase
{
public:
	FMulticastInlineDelegateProperty_             OnInitiateInteract;                                // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBeginInteract;                                   // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndInteraction;                                  // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         bCombatOnly : 1;                                   // 0x0560(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_561[0x7];                                      // 0x0561(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnInteractionMontageStarted;                       // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInitiateInteraction;                             // 0x0578(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bBeginActivated : 1;                               // 0x0588(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, SaveGame, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseInteractionIconLocation : 1;                   // 0x0588(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPlayMontageOnInteract : 1;                        // 0x0588(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bWaitForInteractingAnim : 1;                       // 0x0588(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFreezeInputWhileMontageIsPlaying : 1;             // 0x0588(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPickNearestMontageSection : 1;                    // 0x0588(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bTransformInteractingCharacter : 1;                // 0x0588(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseAlignmentJoint : 1;                            // 0x0588(0x0001)(BitIndex: 0x07, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bContinousAlignment : 1;                           // 0x0589(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_58A[0x2];                                      // 0x058A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CharacterAlignmentJointName;                       // 0x058C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AlignmentTime;                                     // 0x0594(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FComponentReference                    AlignmentMeshReference;                            // 0x0598(0x0028)(Edit, Protected, NativeAccessSpecifierProtected)
	class FName                                   AlignmentMeshReferenceJointName;                   // 0x05C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InteractionIconLocation;                           // 0x05C8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InteractionIconWorldLocation;                      // 0x05D4(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInteractAnimType                             InteractionAnimType;                               // 0x05E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E1[0x3];                                      // 0x05E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxWaitTime;                                       // 0x05E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             CharReference;                                     // 0x05E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TimerHandle;                                       // 0x05F0(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           InteractionMontageTag;                             // 0x05F8(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IKInterpToSpeed;                                   // 0x0600(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IKInterpFromSpeed;                                 // 0x0604(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TagsUserShouldHave;                                // 0x0608(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TagsUserShouldNotHave;                             // 0x0628(0x0020)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_648[0x60];                                     // 0x0648(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransformTime;                                     // 0x06A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxAngleDifferenceBeforeInteract;                  // 0x06AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MaxDistanceDifferenceBeforeInteract;               // 0x06B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PlayeMoveToAcceptanceRadius;                       // 0x06B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ACharacter*, struct FCharacterTransformData> CharacterTransformMap;                             // 0x06B8(0x0050)(NativeAccessSpecifierPrivate)
	TMap<struct FAIRequestID, class ACharacter*>  PlayerMoveToRequestIDMap;                          // 0x0708(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class ACharacter*, struct FCharacterTransformData> CharacterAlignmentMap;                             // 0x0758(0x0050)(NativeAccessSpecifierPrivate)
	EInteractTransformMethod                      TransformMethod;                                   // 0x07A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7A9[0x7];                                      // 0x07A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        SceneComponentTransformGoal;                       // 0x07B0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B8[0x8];                                      // 0x07B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AfterInteractionCleanup();
	void BeginInteraction(class ACharacter* InteractingCharacter);
	void ClearTimer();
	bool GetCombatOnly();
	void HandleInteractButtonReleased(class ACharacter* InteractingCharacter);
	void InteractingCharAnimStart(class ACharacter* InCharacter);
	void InteractionEndSignature__DelegateSignature(class ACharacter* InteractionCharacter);
	void InteractionSignature__DelegateSignature(class ACharacter* InteractionCharacter);
	void OnCharacterTurnInPlaceEnd(class ACharacter* Character, bool bIsBlendOutToWalk);
	void OnCharacterTurnInPlaceFailed(class ACharacter* Character);
	void OnInitiateInteraction__DelegateSignature(class ACharacter* InteractingCharacter);
	void OnInteractionMontageStarted__DelegateSignature(class ACharacter* InteractingCharacter, class UAnimMontage* Montage);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnPlayerMoveToComplete(EPathFollowingResult MovementResult, const struct FAIRequestID& RequestID);
	void OnPlayerMoveToFail(EPathFollowingResult MovementResult, const struct FAIRequestID& RequestID);
	void SetIgnorePlayerInput(class ACharacter* InteractingCharacter, bool Value);
	void SetSceneComponentTransformGoal(class USceneComponent* InSceneComponentTransformGoal);
	void StopWaitingForAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionComponent">();
	}
	static class UInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionComponent>();
	}
};
static_assert(alignof(UInteractionComponent) == 0x000010, "Wrong alignment on UInteractionComponent");
static_assert(sizeof(UInteractionComponent) == 0x0007C0, "Wrong size on UInteractionComponent");
static_assert(offsetof(UInteractionComponent, OnInitiateInteract) == 0x000530, "Member 'UInteractionComponent::OnInitiateInteract' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, OnBeginInteract) == 0x000540, "Member 'UInteractionComponent::OnBeginInteract' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, OnEndInteraction) == 0x000550, "Member 'UInteractionComponent::OnEndInteraction' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, OnInteractionMontageStarted) == 0x000568, "Member 'UInteractionComponent::OnInteractionMontageStarted' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, OnInitiateInteraction) == 0x000578, "Member 'UInteractionComponent::OnInitiateInteraction' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, CharacterAlignmentJointName) == 0x00058C, "Member 'UInteractionComponent::CharacterAlignmentJointName' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, AlignmentTime) == 0x000594, "Member 'UInteractionComponent::AlignmentTime' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, AlignmentMeshReference) == 0x000598, "Member 'UInteractionComponent::AlignmentMeshReference' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, AlignmentMeshReferenceJointName) == 0x0005C0, "Member 'UInteractionComponent::AlignmentMeshReferenceJointName' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, InteractionIconLocation) == 0x0005C8, "Member 'UInteractionComponent::InteractionIconLocation' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, InteractionIconWorldLocation) == 0x0005D4, "Member 'UInteractionComponent::InteractionIconWorldLocation' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, InteractionAnimType) == 0x0005E0, "Member 'UInteractionComponent::InteractionAnimType' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, MaxWaitTime) == 0x0005E4, "Member 'UInteractionComponent::MaxWaitTime' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, CharReference) == 0x0005E8, "Member 'UInteractionComponent::CharReference' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, TimerHandle) == 0x0005F0, "Member 'UInteractionComponent::TimerHandle' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, InteractionMontageTag) == 0x0005F8, "Member 'UInteractionComponent::InteractionMontageTag' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, IKInterpToSpeed) == 0x000600, "Member 'UInteractionComponent::IKInterpToSpeed' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, IKInterpFromSpeed) == 0x000604, "Member 'UInteractionComponent::IKInterpFromSpeed' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, TagsUserShouldHave) == 0x000608, "Member 'UInteractionComponent::TagsUserShouldHave' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, TagsUserShouldNotHave) == 0x000628, "Member 'UInteractionComponent::TagsUserShouldNotHave' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, TransformTime) == 0x0006A8, "Member 'UInteractionComponent::TransformTime' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, MaxAngleDifferenceBeforeInteract) == 0x0006AC, "Member 'UInteractionComponent::MaxAngleDifferenceBeforeInteract' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, MaxDistanceDifferenceBeforeInteract) == 0x0006B0, "Member 'UInteractionComponent::MaxDistanceDifferenceBeforeInteract' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, PlayeMoveToAcceptanceRadius) == 0x0006B4, "Member 'UInteractionComponent::PlayeMoveToAcceptanceRadius' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, CharacterTransformMap) == 0x0006B8, "Member 'UInteractionComponent::CharacterTransformMap' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, PlayerMoveToRequestIDMap) == 0x000708, "Member 'UInteractionComponent::PlayerMoveToRequestIDMap' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, CharacterAlignmentMap) == 0x000758, "Member 'UInteractionComponent::CharacterAlignmentMap' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, TransformMethod) == 0x0007A8, "Member 'UInteractionComponent::TransformMethod' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, SceneComponentTransformGoal) == 0x0007B0, "Member 'UInteractionComponent::SceneComponentTransformGoal' has a wrong offset!");

// Class ObsidianFox.FrustumFilterInteractionComponentQuery
// 0x0188 (0x01C0 - 0x0038)
class UFrustumFilterInteractionComponentQuery final : public UInteractionComponentQuery
{
public:
	uint8                                         Pad_38[0x188];                                     // 0x0038(0x0188)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FrustumFilterInteractionComponentQuery">();
	}
	static class UFrustumFilterInteractionComponentQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFrustumFilterInteractionComponentQuery>();
	}
};
static_assert(alignof(UFrustumFilterInteractionComponentQuery) == 0x000008, "Wrong alignment on UFrustumFilterInteractionComponentQuery");
static_assert(sizeof(UFrustumFilterInteractionComponentQuery) == 0x0001C0, "Wrong size on UFrustumFilterInteractionComponentQuery");

// Class ObsidianFox.CurrentRoomInteractionComponentQuery
// 0x0028 (0x0060 - 0x0038)
class UCurrentRoomInteractionComponentQuery final : public UInteractionComponentQuery
{
public:
	TArray<class AMapTrackerVolume*>              CurrentRoomVolumes;                                // 0x0038(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrentRoomInteractionComponentQuery">();
	}
	static class UCurrentRoomInteractionComponentQuery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurrentRoomInteractionComponentQuery>();
	}
};
static_assert(alignof(UCurrentRoomInteractionComponentQuery) == 0x000008, "Wrong alignment on UCurrentRoomInteractionComponentQuery");
static_assert(sizeof(UCurrentRoomInteractionComponentQuery) == 0x000060, "Wrong size on UCurrentRoomInteractionComponentQuery");
static_assert(offsetof(UCurrentRoomInteractionComponentQuery, CurrentRoomVolumes) == 0x000038, "Member 'UCurrentRoomInteractionComponentQuery::CurrentRoomVolumes' has a wrong offset!");

// Class ObsidianFox.InteractionHUD
// 0x0008 (0x0280 - 0x0278)
class UInteractionHUD : public UInGameUIWidget
{
public:
	uint8                                         Pad_278[0x8];                                      // 0x0278(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddIcon(class UInteractionComponentBase* InteractionComponent);
	bool ClearAllIcons();
	void NativeTickIcons(float Delta);
	void NativeTranslateIcons();
	void NearbyInteractablesChanged(const TSet<class UInteractionComponentBase*>& NearbyInteractables, const TSet<class UInteractionComponentBase*>& AddedInteractables, const TSet<class UInteractionComponentBase*>& RemovedInteractables);
	void OnCombatInteractableSelectionChanged(const class UInteractionComponentBase* SelectedInteractable);
	void OnExaminationInteractableSelectionChanged(const class UInteractionComponentBase* SelectedInteractable);
	void OnStandardInteractableSelectionChanged(const class UInteractionComponentBase* SelectedInteractable);
	bool RemoveIcon(class UInteractionComponentBase* InteractionComponent);
	bool TickIcons(float Delta);
	bool TranslateIcons();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionHUD">();
	}
	static class UInteractionHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionHUD>();
	}
};
static_assert(alignof(UInteractionHUD) == 0x000008, "Wrong alignment on UInteractionHUD");
static_assert(sizeof(UInteractionHUD) == 0x000280, "Wrong size on UInteractionHUD");

// Class ObsidianFox.InventoryBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UInventoryBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddItemToInventory(const class UObject* WorldContextObject, class UItemData* ItemData, int32 Amount, EFInventoryPopUp PopUp);
	static const TArray<TSoftObjectPtr<class UItemData>> GetAllItems(const class UObject* WorldContextObject);
	static const TArray<TSoftObjectPtr<class UItemData>> GetAllItemsInSameCategory(const class UObject* WorldContextObject, const struct FGameplayTag& GameplayTagItemCategory);
	static int32 GetItemAmount(const class UObject* WorldContextObject, const class UItemData* Item);
	static const bool HasAnyItemNotBeenLookedAt(const class UObject* WorldContextObject, const TArray<TSoftObjectPtr<class UItemData>>& Items);
	static bool HasItem(const class UObject* WorldContextObject, const class UItemData* Item);
	static const bool HasItemBeenLookedAt(const class UObject* WorldContextObject, const TSoftObjectPtr<class UItemData> Item);
	static bool IsCollectibleSetComplete(const class UObject* WorldContextObject, TSoftObjectPtr<class UCollectiblesDataAsset> InCollectiblesDataAsset);
	static ECollectibleCompletionStatus IsCollectibleSetCompleteWithDelegate(const class UObject* WorldContextObject, TSoftObjectPtr<class UCollectiblesDataAsset> InCollectiblesDataAsset, TDelegate<void()> Callback);
	static bool IsItemImportant(const class UItemData* Item);
	static void RemoveAllItemsFromInventory(const class UObject* WorldContextObject);
	static bool RemoveItemFromInventory(const class UObject* WorldContextObject, class UItemData* ItemData, int32 Amount);
	static void SetItemLookedAt(const class UObject* WorldContextObject, const TSoftObjectPtr<class UItemData> Item, bool bLookedAt);
	static class UHighlightItemPickupHud* ShowHighlightItemWidget(const class UObject* WorldContextObject, class UItemData* Item);
	static void SortItemDataArray(TArray<class UItemData*>& ItemDataArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryBlueprintLibrary">();
	}
	static class UInventoryBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryBlueprintLibrary>();
	}
};
static_assert(alignof(UInventoryBlueprintLibrary) == 0x000008, "Wrong alignment on UInventoryBlueprintLibrary");
static_assert(sizeof(UInventoryBlueprintLibrary) == 0x000028, "Wrong size on UInventoryBlueprintLibrary");

// Class ObsidianFox.InventoryPickerHud
// 0x0040 (0x02A0 - 0x0260)
class UInventoryPickerHud : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnCancel;                                          // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            MouseWheelInputAction;                             // 0x0270(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_298[0x8];                                      // 0x0298(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Cancel();
	void Interact();
	void InventoryPickerCancel__DelegateSignature();
	void MouseWheelScroll(const struct FInputActionValue& InputActionValue);
	void MoveWidgetInputActionTriggeredHandler(const struct FInputActionValue& InputActionValue);
	void RotateBetweenItems(bool Clockwise);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryPickerHud">();
	}
	static class UInventoryPickerHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryPickerHud>();
	}
};
static_assert(alignof(UInventoryPickerHud) == 0x000008, "Wrong alignment on UInventoryPickerHud");
static_assert(sizeof(UInventoryPickerHud) == 0x0002A0, "Wrong size on UInventoryPickerHud");
static_assert(offsetof(UInventoryPickerHud, OnCancel) == 0x000260, "Member 'UInventoryPickerHud::OnCancel' has a wrong offset!");
static_assert(offsetof(UInventoryPickerHud, MouseWheelInputAction) == 0x000270, "Member 'UInventoryPickerHud::MouseWheelInputAction' has a wrong offset!");

// Class ObsidianFox.InvestigationExaminationView
// 0x02A8 (0x0508 - 0x0260)
class UInvestigationExaminationView : public UUserWidget
{
public:
	class UTextBlock*                             ItemLabel;                                         // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         ItemDescription;                                   // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemImage;                                         // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              ImageScaleBox;                                     // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrlButtonWidget*                      InputActions;                                      // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Gradient;                                          // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 GradientInverted;                                  // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBoxItemDescription;                          // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ItemMaxHeight;                                     // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExpansionAnimationSpeed;                           // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadingSpeed;                                       // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ModeChangingSpeed;                                 // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionRead;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionBack;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionSwitchBetweenWidgets;                   // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionAccept;                                 // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionOpenMenu;                               // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           InputActionPlayVO;                                 // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MultiplyValueToMoveInScrollBox;                    // 0x02E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E4[0xDC];                                     // 0x02E4(0x00DC)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             HighlightsEnabledStyleTable;                       // 0x03C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             HighlightsDisabledStyleTable;                      // 0x03C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   PlayVOText;                                        // 0x03D0(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   StopVOText;                                        // 0x03E8(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              ChangePageSound;                                   // 0x0400(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              FmodSound;                                         // 0x0428(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0x50];                                     // 0x0450(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFMODEvent>              ItemDataFMODEvent;                                 // 0x04A0(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x40];                                     // 0x04C8(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CategoryNextHandler();
	void CategoryPreviousHandler();
	void ChangeToInspectionMode();
	void ChangeToItemSelectionMode();
	void ChangeToReadingMode();
	void ExitExaminationView();
	void FadeIn();
	void LeftStickYTilt(float Value);
	void OnAcceptPressedHandler();
	void OnCancelPressedHandler();
	void OnExaminationMenuSetUp();
	void OnOpenMenuPressedHandler();
	void OnResetPressedHandler();
	void PlayerGuidanceStateUpdatedHandler(EPlayerGuidanceSystem System, bool bState);
	void PlayItemSlideInAnimation();
	void PlaySound_Internal();
	void SetExaminationDisplayInfo(const struct FItemDisplayInfo& NewDisplayInfo, bool bPlaySound);
	void SetUpExaminationView(const struct FItemDisplayInfo& NewDisplayInfo, class UOFSlotWidget* SourceSlot, class UItemData* NewItemData, bool PlayExpansionAnimation, bool bPlaySound);
	void StopSound();
	void UpdatePageCounter(EItemDisplayInfoType ItemType, int32 Current, int32 Total);

	const class UItemData* GetCurrentItemData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvestigationExaminationView">();
	}
	static class UInvestigationExaminationView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvestigationExaminationView>();
	}
};
static_assert(alignof(UInvestigationExaminationView) == 0x000008, "Wrong alignment on UInvestigationExaminationView");
static_assert(sizeof(UInvestigationExaminationView) == 0x000508, "Wrong size on UInvestigationExaminationView");
static_assert(offsetof(UInvestigationExaminationView, ItemLabel) == 0x000260, "Member 'UInvestigationExaminationView::ItemLabel' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, ItemDescription) == 0x000268, "Member 'UInvestigationExaminationView::ItemDescription' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, ItemImage) == 0x000270, "Member 'UInvestigationExaminationView::ItemImage' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, ImageScaleBox) == 0x000278, "Member 'UInvestigationExaminationView::ImageScaleBox' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, InputActions) == 0x000280, "Member 'UInvestigationExaminationView::InputActions' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, Gradient) == 0x000288, "Member 'UInvestigationExaminationView::Gradient' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, GradientInverted) == 0x000290, "Member 'UInvestigationExaminationView::GradientInverted' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, ScrollBoxItemDescription) == 0x000298, "Member 'UInvestigationExaminationView::ScrollBoxItemDescription' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, ItemMaxHeight) == 0x0002A0, "Member 'UInvestigationExaminationView::ItemMaxHeight' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, ExpansionAnimationSpeed) == 0x0002A4, "Member 'UInvestigationExaminationView::ExpansionAnimationSpeed' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, FadingSpeed) == 0x0002A8, "Member 'UInvestigationExaminationView::FadingSpeed' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, ModeChangingSpeed) == 0x0002AC, "Member 'UInvestigationExaminationView::ModeChangingSpeed' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, InputActionRead) == 0x0002B0, "Member 'UInvestigationExaminationView::InputActionRead' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, InputActionBack) == 0x0002B8, "Member 'UInvestigationExaminationView::InputActionBack' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, InputActionSwitchBetweenWidgets) == 0x0002C0, "Member 'UInvestigationExaminationView::InputActionSwitchBetweenWidgets' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, InputActionAccept) == 0x0002C8, "Member 'UInvestigationExaminationView::InputActionAccept' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, InputActionOpenMenu) == 0x0002D0, "Member 'UInvestigationExaminationView::InputActionOpenMenu' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, InputActionPlayVO) == 0x0002D8, "Member 'UInvestigationExaminationView::InputActionPlayVO' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, MultiplyValueToMoveInScrollBox) == 0x0002E0, "Member 'UInvestigationExaminationView::MultiplyValueToMoveInScrollBox' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, HighlightsEnabledStyleTable) == 0x0003C0, "Member 'UInvestigationExaminationView::HighlightsEnabledStyleTable' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, HighlightsDisabledStyleTable) == 0x0003C8, "Member 'UInvestigationExaminationView::HighlightsDisabledStyleTable' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, PlayVOText) == 0x0003D0, "Member 'UInvestigationExaminationView::PlayVOText' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, StopVOText) == 0x0003E8, "Member 'UInvestigationExaminationView::StopVOText' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, ChangePageSound) == 0x000400, "Member 'UInvestigationExaminationView::ChangePageSound' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, FmodSound) == 0x000428, "Member 'UInvestigationExaminationView::FmodSound' has a wrong offset!");
static_assert(offsetof(UInvestigationExaminationView, ItemDataFMODEvent) == 0x0004A0, "Member 'UInvestigationExaminationView::ItemDataFMODEvent' has a wrong offset!");

// Class ObsidianFox.InvestigationFolderDataAsset
// 0x0050 (0x0080 - 0x0030)
class UInvestigationFolderDataAsset final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, struct FInvestigationFolderData> FolderDatas;                                       // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvestigationFolderDataAsset">();
	}
	static class UInvestigationFolderDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvestigationFolderDataAsset>();
	}
};
static_assert(alignof(UInvestigationFolderDataAsset) == 0x000008, "Wrong alignment on UInvestigationFolderDataAsset");
static_assert(sizeof(UInvestigationFolderDataAsset) == 0x000080, "Wrong size on UInvestigationFolderDataAsset");
static_assert(offsetof(UInvestigationFolderDataAsset, FolderDatas) == 0x000030, "Member 'UInvestigationFolderDataAsset::FolderDatas' has a wrong offset!");

// Class ObsidianFox.OFSlotWidget
// 0x0128 (0x0388 - 0x0260)
class UOFSlotWidget : public UUserWidget
{
public:
	bool                                          bIsOccupied;                                       // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UOFButton*                              SlotButton;                                        // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSlotPressed;                                     // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSlotHovered;                                     // 0x0280(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UImage*                                 ItemIcon;                                          // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ItemIconShadow;                                    // 0x0298(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UItemData>               SlotItemData;                                      // 0x02A0(0x0028)(BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              HoverSound;                                        // 0x02C8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              PressedSound;                                      // 0x02F0(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_318[0x70];                                     // 0x0318(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Interact();
	void OnButtonHoveredHandler();
	void OnSlotHovered__DelegateSignature(class UOFSlotWidget* SlotWidget);
	void OnSlotPressed__DelegateSignature(class UOFSlotWidget* SlotWidget, class UItemData* ItemData);
	void ShowNewItemIcon();
	void ShowNewItemMaterial();
	void UpdateSlotUsingItemData(const TSoftObjectPtr<class UItemData> ItemData);

	const class FText GetCurrentName() const;
	const class FText GetCurrentShortDescription() const;
	struct FGeometry GetImageGeometry() const;
	const TSoftObjectPtr<class UItemData> GetSlotItemData() const;
	void Select() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFSlotWidget">();
	}
	static class UOFSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFSlotWidget>();
	}
};
static_assert(alignof(UOFSlotWidget) == 0x000008, "Wrong alignment on UOFSlotWidget");
static_assert(sizeof(UOFSlotWidget) == 0x000388, "Wrong size on UOFSlotWidget");
static_assert(offsetof(UOFSlotWidget, bIsOccupied) == 0x000260, "Member 'UOFSlotWidget::bIsOccupied' has a wrong offset!");
static_assert(offsetof(UOFSlotWidget, SlotButton) == 0x000268, "Member 'UOFSlotWidget::SlotButton' has a wrong offset!");
static_assert(offsetof(UOFSlotWidget, OnSlotPressed) == 0x000270, "Member 'UOFSlotWidget::OnSlotPressed' has a wrong offset!");
static_assert(offsetof(UOFSlotWidget, OnSlotHovered) == 0x000280, "Member 'UOFSlotWidget::OnSlotHovered' has a wrong offset!");
static_assert(offsetof(UOFSlotWidget, ItemIcon) == 0x000290, "Member 'UOFSlotWidget::ItemIcon' has a wrong offset!");
static_assert(offsetof(UOFSlotWidget, ItemIconShadow) == 0x000298, "Member 'UOFSlotWidget::ItemIconShadow' has a wrong offset!");
static_assert(offsetof(UOFSlotWidget, SlotItemData) == 0x0002A0, "Member 'UOFSlotWidget::SlotItemData' has a wrong offset!");
static_assert(offsetof(UOFSlotWidget, HoverSound) == 0x0002C8, "Member 'UOFSlotWidget::HoverSound' has a wrong offset!");
static_assert(offsetof(UOFSlotWidget, PressedSound) == 0x0002F0, "Member 'UOFSlotWidget::PressedSound' has a wrong offset!");

// Class ObsidianFox.InvestigationSlotWidget
// 0x0000 (0x0388 - 0x0388)
class UInvestigationSlotWidget : public UOFSlotWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvestigationSlotWidget">();
	}
	static class UInvestigationSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvestigationSlotWidget>();
	}
};
static_assert(alignof(UInvestigationSlotWidget) == 0x000008, "Wrong alignment on UInvestigationSlotWidget");
static_assert(sizeof(UInvestigationSlotWidget) == 0x000388, "Wrong size on UInvestigationSlotWidget");

// Class ObsidianFox.InvestigationWidget
// 0x0018 (0x0278 - 0x0260)
class UInvestigationWidget : public UUserWidget
{
public:
	class UInputAction*                           SwitchBetweenWidgetsActionRight;                   // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           SwitchBetweenWidgetsActionLeft;                    // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOpenObjectives;                                   // 0x0270(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnItemLookedAt(const TSoftObjectPtr<class UItemData> Item);
	void OpenExaminationViewWithItem(const class UItemData* ItemData, const bool bAutomaticPlaySound);
	void ProcessOnItemLookedAt();
	void SetOpenObjectives(const bool bValue);
	void SetToMapMenu();
	void SetupInput();
	void SwitchBetweenWidgetsHandler(const struct FInputActionValue& InputActionValue);
	void SwitchWidget(const bool bMoveRight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvestigationWidget">();
	}
	static class UInvestigationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvestigationWidget>();
	}
};
static_assert(alignof(UInvestigationWidget) == 0x000008, "Wrong alignment on UInvestigationWidget");
static_assert(sizeof(UInvestigationWidget) == 0x000278, "Wrong size on UInvestigationWidget");
static_assert(offsetof(UInvestigationWidget, SwitchBetweenWidgetsActionRight) == 0x000260, "Member 'UInvestigationWidget::SwitchBetweenWidgetsActionRight' has a wrong offset!");
static_assert(offsetof(UInvestigationWidget, SwitchBetweenWidgetsActionLeft) == 0x000268, "Member 'UInvestigationWidget::SwitchBetweenWidgetsActionLeft' has a wrong offset!");
static_assert(offsetof(UInvestigationWidget, bOpenObjectives) == 0x000270, "Member 'UInvestigationWidget::bOpenObjectives' has a wrong offset!");

// Class ObsidianFox.ItemData_Clues
// 0x0058 (0x01C8 - 0x0170)
class UItemData_Clues final : public UItemData
{
public:
	TSoftObjectPtr<class UFMODEvent>              ClueAudio;                                         // 0x0170(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             ClueMesh;                                          // 0x0198(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            ClueMeshGetter;                                    // 0x01C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UStaticMesh* GetClueMesh();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemData_Clues">();
	}
	static class UItemData_Clues* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemData_Clues>();
	}
};
static_assert(alignof(UItemData_Clues) == 0x000008, "Wrong alignment on UItemData_Clues");
static_assert(sizeof(UItemData_Clues) == 0x0001C8, "Wrong size on UItemData_Clues");
static_assert(offsetof(UItemData_Clues, ClueAudio) == 0x000170, "Member 'UItemData_Clues::ClueAudio' has a wrong offset!");
static_assert(offsetof(UItemData_Clues, ClueMesh) == 0x000198, "Member 'UItemData_Clues::ClueMesh' has a wrong offset!");
static_assert(offsetof(UItemData_Clues, ClueMeshGetter) == 0x0001C0, "Member 'UItemData_Clues::ClueMeshGetter' has a wrong offset!");

// Class ObsidianFox.ItemData_Equippable
// 0x0058 (0x01C8 - 0x0170)
class UItemData_Equippable final : public UItemData
{
public:
	TSoftClassPtr<class UClass>                   EquippableItem;                                    // 0x0170(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFMODEvent>              EquipSound;                                        // 0x0198(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEquipmentType                                EquipmentType;                                     // 0x01C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEquipmentSlot                                EquipmentSlot;                                     // 0x01C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C2[0x6];                                      // 0x01C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemData_Equippable">();
	}
	static class UItemData_Equippable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemData_Equippable>();
	}
};
static_assert(alignof(UItemData_Equippable) == 0x000008, "Wrong alignment on UItemData_Equippable");
static_assert(sizeof(UItemData_Equippable) == 0x0001C8, "Wrong size on UItemData_Equippable");
static_assert(offsetof(UItemData_Equippable, EquippableItem) == 0x000170, "Member 'UItemData_Equippable::EquippableItem' has a wrong offset!");
static_assert(offsetof(UItemData_Equippable, EquipSound) == 0x000198, "Member 'UItemData_Equippable::EquipSound' has a wrong offset!");
static_assert(offsetof(UItemData_Equippable, EquipmentType) == 0x0001C0, "Member 'UItemData_Equippable::EquipmentType' has a wrong offset!");
static_assert(offsetof(UItemData_Equippable, EquipmentSlot) == 0x0001C1, "Member 'UItemData_Equippable::EquipmentSlot' has a wrong offset!");

// Class ObsidianFox.ItemPickup
// 0x0030 (0x0268 - 0x0238)
class AItemPickup : public AActor
{
public:
	TSoftObjectPtr<class UItemData>               ItemData;                                          // 0x0238(0x0028)(Edit, BlueprintVisible, SaveGame, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPersistenceComponent*                  ItemPickupPersistenceComponent;                    // 0x0260(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool TraceForPickupTransform(const class ACharacter* InteractingCharacter, float TraceCapsuleHalfRadius, float TraceCapsuleHalfHeight, bool TraceComplex, const class FName& TraceProfileName, const float BlockingAngleThreshold, struct FHitResult* OutHit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemPickup">();
	}
	static class AItemPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemPickup>();
	}
};
static_assert(alignof(AItemPickup) == 0x000008, "Wrong alignment on AItemPickup");
static_assert(sizeof(AItemPickup) == 0x000268, "Wrong size on AItemPickup");
static_assert(offsetof(AItemPickup, ItemData) == 0x000238, "Member 'AItemPickup::ItemData' has a wrong offset!");
static_assert(offsetof(AItemPickup, ItemPickupPersistenceComponent) == 0x000260, "Member 'AItemPickup::ItemPickupPersistenceComponent' has a wrong offset!");

// Class ObsidianFox.KeyBindingTextureDataAsset
// 0x0208 (0x0238 - 0x0030)
class UKeyBindingTextureDataAsset final : public UDataAsset
{
public:
	TMap<struct FKey, TSoftObjectPtr<class UTexture2D>> XboxKeyTextures;                                   // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FKey, TSoftObjectPtr<class UTexture2D>> PlaystationKeyTextures;                            // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FKey, TSoftObjectPtr<class UTexture2D>> PCKeyTextures;                                     // 0x00D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FKey, TSoftObjectPtr<class UTexture2D>> SteamDeckKeyTextures;                              // 0x0120(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              UniversalKeyboardKey;                              // 0x0170(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              UniversalKeyboardKeyLarge;                         // 0x0198(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FKey, class FText>                PCKeyName;                                         // 0x01C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MaxCharacterForSmallImage;                         // 0x0210(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_214[0x24];                                     // 0x0214(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TMap<struct FKey, TSoftObjectPtr<class UTexture2D>> GetKeyTextures(const class UWorld* World);
	const class FText GetNameForKey(const struct FKey& Key);

	TSoftObjectPtr<class UTexture2D> GetUniversalTexture(const class FText& KeyName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyBindingTextureDataAsset">();
	}
	static class UKeyBindingTextureDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeyBindingTextureDataAsset>();
	}
};
static_assert(alignof(UKeyBindingTextureDataAsset) == 0x000008, "Wrong alignment on UKeyBindingTextureDataAsset");
static_assert(sizeof(UKeyBindingTextureDataAsset) == 0x000238, "Wrong size on UKeyBindingTextureDataAsset");
static_assert(offsetof(UKeyBindingTextureDataAsset, XboxKeyTextures) == 0x000030, "Member 'UKeyBindingTextureDataAsset::XboxKeyTextures' has a wrong offset!");
static_assert(offsetof(UKeyBindingTextureDataAsset, PlaystationKeyTextures) == 0x000080, "Member 'UKeyBindingTextureDataAsset::PlaystationKeyTextures' has a wrong offset!");
static_assert(offsetof(UKeyBindingTextureDataAsset, PCKeyTextures) == 0x0000D0, "Member 'UKeyBindingTextureDataAsset::PCKeyTextures' has a wrong offset!");
static_assert(offsetof(UKeyBindingTextureDataAsset, SteamDeckKeyTextures) == 0x000120, "Member 'UKeyBindingTextureDataAsset::SteamDeckKeyTextures' has a wrong offset!");
static_assert(offsetof(UKeyBindingTextureDataAsset, UniversalKeyboardKey) == 0x000170, "Member 'UKeyBindingTextureDataAsset::UniversalKeyboardKey' has a wrong offset!");
static_assert(offsetof(UKeyBindingTextureDataAsset, UniversalKeyboardKeyLarge) == 0x000198, "Member 'UKeyBindingTextureDataAsset::UniversalKeyboardKeyLarge' has a wrong offset!");
static_assert(offsetof(UKeyBindingTextureDataAsset, PCKeyName) == 0x0001C0, "Member 'UKeyBindingTextureDataAsset::PCKeyName' has a wrong offset!");
static_assert(offsetof(UKeyBindingTextureDataAsset, MaxCharacterForSmallImage) == 0x000210, "Member 'UKeyBindingTextureDataAsset::MaxCharacterForSmallImage' has a wrong offset!");

// Class ObsidianFox.LivingPaintingKeyData
// 0x0000 (0x0030 - 0x0030)
class ULivingPaintingKeyData final : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LivingPaintingKeyData">();
	}
	static class ULivingPaintingKeyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULivingPaintingKeyData>();
	}
};
static_assert(alignof(ULivingPaintingKeyData) == 0x000008, "Wrong alignment on ULivingPaintingKeyData");
static_assert(sizeof(ULivingPaintingKeyData) == 0x000030, "Wrong size on ULivingPaintingKeyData");

// Class ObsidianFox.LocationTrackingSubsystem
// 0x0048 (0x0078 - 0x0030)
class ULocationTrackingSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnEnterLocation;                                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExitLocation;                                    // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocationUpdated__DelegateSignature(const struct FGameplayTagContainer& LocationTags);

	struct FGameplayTagContainer GetCurrentLocationTags() const;
	struct FGameplayTag GetDercetoLocationTag() const;
	bool PlayerIsInDerceto() const;
	bool PlayerIsInLocation(const struct FGameplayTag& LocationTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocationTrackingSubsystem">();
	}
	static class ULocationTrackingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocationTrackingSubsystem>();
	}
};
static_assert(alignof(ULocationTrackingSubsystem) == 0x000008, "Wrong alignment on ULocationTrackingSubsystem");
static_assert(sizeof(ULocationTrackingSubsystem) == 0x000078, "Wrong size on ULocationTrackingSubsystem");
static_assert(offsetof(ULocationTrackingSubsystem, OnEnterLocation) == 0x000030, "Member 'ULocationTrackingSubsystem::OnEnterLocation' has a wrong offset!");
static_assert(offsetof(ULocationTrackingSubsystem, OnExitLocation) == 0x000040, "Member 'ULocationTrackingSubsystem::OnExitLocation' has a wrong offset!");

// Class ObsidianFox.LockAchievementTrackingComponent
// 0x0008 (0x00C0 - 0x00B8)
class ULockAchievementTrackingComponent final : public UActorComponent
{
public:
	bool                                          bIsRequired;                                       // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Unlocked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LockAchievementTrackingComponent">();
	}
	static class ULockAchievementTrackingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULockAchievementTrackingComponent>();
	}
};
static_assert(alignof(ULockAchievementTrackingComponent) == 0x000008, "Wrong alignment on ULockAchievementTrackingComponent");
static_assert(sizeof(ULockAchievementTrackingComponent) == 0x0000C0, "Wrong size on ULockAchievementTrackingComponent");
static_assert(offsetof(ULockAchievementTrackingComponent, bIsRequired) == 0x0000B8, "Member 'ULockAchievementTrackingComponent::bIsRequired' has a wrong offset!");

// Class ObsidianFox.MainMenuPT
// 0x0538 (0x0798 - 0x0260)
class UMainMenuPT final : public UUserWidget
{
public:
	class UButton*                                StartButton;                                       // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                OptionsButton;                                     // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             StartText;                                         // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             OptionsText;                                       // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ButtonVerticalBox;                                 // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FButtonStyle                           ButtonNormal;                                      // 0x0288(0x0278)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FButtonStyle                           ButtonHovered;                                     // 0x0500(0x0278)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_778[0x20];                                     // 0x0778(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeActiveButton();
	void InspectButtonPressed();
	void LeftStickY(float Val);
	void OnInitalize();
	void OptionsButtonHoveredCallback();
	void SetCanMoveWithLeftStickToTrue();
	void StartButtonHoveredCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuPT">();
	}
	static class UMainMenuPT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuPT>();
	}
};
static_assert(alignof(UMainMenuPT) == 0x000008, "Wrong alignment on UMainMenuPT");
static_assert(sizeof(UMainMenuPT) == 0x000798, "Wrong size on UMainMenuPT");
static_assert(offsetof(UMainMenuPT, StartButton) == 0x000260, "Member 'UMainMenuPT::StartButton' has a wrong offset!");
static_assert(offsetof(UMainMenuPT, OptionsButton) == 0x000268, "Member 'UMainMenuPT::OptionsButton' has a wrong offset!");
static_assert(offsetof(UMainMenuPT, StartText) == 0x000270, "Member 'UMainMenuPT::StartText' has a wrong offset!");
static_assert(offsetof(UMainMenuPT, OptionsText) == 0x000278, "Member 'UMainMenuPT::OptionsText' has a wrong offset!");
static_assert(offsetof(UMainMenuPT, ButtonVerticalBox) == 0x000280, "Member 'UMainMenuPT::ButtonVerticalBox' has a wrong offset!");
static_assert(offsetof(UMainMenuPT, ButtonNormal) == 0x000288, "Member 'UMainMenuPT::ButtonNormal' has a wrong offset!");
static_assert(offsetof(UMainMenuPT, ButtonHovered) == 0x000500, "Member 'UMainMenuPT::ButtonHovered' has a wrong offset!");

// Class ObsidianFox.MapMansionFloor
// 0x0108 (0x0368 - 0x0260)
class UMapMansionFloor : public UUserWidget
{
public:
	class UCanvasPanel*                           FloorCanvasPanel;                                  // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           DoorsCanvas;                                       // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 FloorMap;                                          // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerMapMarker*                       PlayerIcon;                                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 OrthographicCameraLocation;                        // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 MapReferenceActor;                                 // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   FloorName;                                         // 0x0290(0x0018)(Edit, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                PuzzleIconClass;                                   // 0x02A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAnchors                               PuzzleAnchors;                                     // 0x02B0(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              PuzzleAlignment;                                   // 0x02C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TWeakObjectPtr<class UMapMansionRoom>> Rooms;                                             // 0x02C8(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class FName, class UUserWidget*>         MapIcons;                                          // 0x0318(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMansionFloor">();
	}
	static class UMapMansionFloor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapMansionFloor>();
	}
};
static_assert(alignof(UMapMansionFloor) == 0x000008, "Wrong alignment on UMapMansionFloor");
static_assert(sizeof(UMapMansionFloor) == 0x000368, "Wrong size on UMapMansionFloor");
static_assert(offsetof(UMapMansionFloor, FloorCanvasPanel) == 0x000260, "Member 'UMapMansionFloor::FloorCanvasPanel' has a wrong offset!");
static_assert(offsetof(UMapMansionFloor, DoorsCanvas) == 0x000268, "Member 'UMapMansionFloor::DoorsCanvas' has a wrong offset!");
static_assert(offsetof(UMapMansionFloor, FloorMap) == 0x000270, "Member 'UMapMansionFloor::FloorMap' has a wrong offset!");
static_assert(offsetof(UMapMansionFloor, PlayerIcon) == 0x000278, "Member 'UMapMansionFloor::PlayerIcon' has a wrong offset!");
static_assert(offsetof(UMapMansionFloor, OrthographicCameraLocation) == 0x000280, "Member 'UMapMansionFloor::OrthographicCameraLocation' has a wrong offset!");
static_assert(offsetof(UMapMansionFloor, MapReferenceActor) == 0x000288, "Member 'UMapMansionFloor::MapReferenceActor' has a wrong offset!");
static_assert(offsetof(UMapMansionFloor, FloorName) == 0x000290, "Member 'UMapMansionFloor::FloorName' has a wrong offset!");
static_assert(offsetof(UMapMansionFloor, PuzzleIconClass) == 0x0002A8, "Member 'UMapMansionFloor::PuzzleIconClass' has a wrong offset!");
static_assert(offsetof(UMapMansionFloor, PuzzleAnchors) == 0x0002B0, "Member 'UMapMansionFloor::PuzzleAnchors' has a wrong offset!");
static_assert(offsetof(UMapMansionFloor, PuzzleAlignment) == 0x0002C0, "Member 'UMapMansionFloor::PuzzleAlignment' has a wrong offset!");
static_assert(offsetof(UMapMansionFloor, Rooms) == 0x0002C8, "Member 'UMapMansionFloor::Rooms' has a wrong offset!");
static_assert(offsetof(UMapMansionFloor, MapIcons) == 0x000318, "Member 'UMapMansionFloor::MapIcons' has a wrong offset!");

// Class ObsidianFox.MapMansionRoom
// 0x00B8 (0x0318 - 0x0260)
class UMapMansionRoom : public UUserWidget
{
public:
	class UTextBlock*                             RoomName;                                          // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           RoomTag;                                           // 0x0268(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCleared;                                          // 0x0270(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseRoomMarker;                                    // 0x0271(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExplored;                                         // 0x0272(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMarkerSolvable;                                 // 0x0273(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             MapMarkerSaveIDS;                                  // 0x0278(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class FName, bool>                       MapMarkerQuestionMarkSaveIDS;                      // 0x02C8(0x0050)(NativeAccessSpecifierPrivate)

public:
	void HighlightRoomName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMansionRoom">();
	}
	static class UMapMansionRoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapMansionRoom>();
	}
};
static_assert(alignof(UMapMansionRoom) == 0x000008, "Wrong alignment on UMapMansionRoom");
static_assert(sizeof(UMapMansionRoom) == 0x000318, "Wrong size on UMapMansionRoom");
static_assert(offsetof(UMapMansionRoom, RoomName) == 0x000260, "Member 'UMapMansionRoom::RoomName' has a wrong offset!");
static_assert(offsetof(UMapMansionRoom, RoomTag) == 0x000268, "Member 'UMapMansionRoom::RoomTag' has a wrong offset!");
static_assert(offsetof(UMapMansionRoom, bCleared) == 0x000270, "Member 'UMapMansionRoom::bCleared' has a wrong offset!");
static_assert(offsetof(UMapMansionRoom, bUseRoomMarker) == 0x000271, "Member 'UMapMansionRoom::bUseRoomMarker' has a wrong offset!");
static_assert(offsetof(UMapMansionRoom, bExplored) == 0x000272, "Member 'UMapMansionRoom::bExplored' has a wrong offset!");
static_assert(offsetof(UMapMansionRoom, bIsMarkerSolvable) == 0x000273, "Member 'UMapMansionRoom::bIsMarkerSolvable' has a wrong offset!");
static_assert(offsetof(UMapMansionRoom, MapMarkerSaveIDS) == 0x000278, "Member 'UMapMansionRoom::MapMarkerSaveIDS' has a wrong offset!");
static_assert(offsetof(UMapMansionRoom, MapMarkerQuestionMarkSaveIDS) == 0x0002C8, "Member 'UMapMansionRoom::MapMarkerQuestionMarkSaveIDS' has a wrong offset!");

// Class ObsidianFox.MapMarker
// 0x0020 (0x0280 - 0x0260)
class UMapMarker : public UUserWidget
{
public:
	class UImage*                                 MapMarkerImage;                                    // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AreaTag;                                           // 0x0268(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SaveID;                                            // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSolvable;                                         // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMarker">();
	}
	static class UMapMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapMarker>();
	}
};
static_assert(alignof(UMapMarker) == 0x000008, "Wrong alignment on UMapMarker");
static_assert(sizeof(UMapMarker) == 0x000280, "Wrong size on UMapMarker");
static_assert(offsetof(UMapMarker, MapMarkerImage) == 0x000260, "Member 'UMapMarker::MapMarkerImage' has a wrong offset!");
static_assert(offsetof(UMapMarker, AreaTag) == 0x000268, "Member 'UMapMarker::AreaTag' has a wrong offset!");
static_assert(offsetof(UMapMarker, SaveID) == 0x000270, "Member 'UMapMarker::SaveID' has a wrong offset!");
static_assert(offsetof(UMapMarker, bSolvable) == 0x000278, "Member 'UMapMarker::bSolvable' has a wrong offset!");

// Class ObsidianFox.MapMarkerDoorComponent
// 0x0060 (0x0590 - 0x0530)
class UMapMarkerDoorComponent final : public UMapMarkerActorComponent
{
public:
	TMap<EDoorIconState, struct FSlateBrush>      DoorBrushes;                                       // 0x0530(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EDoorIconState                                CurrentDisplayState;                               // 0x0580(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_584[0xC];                                      // 0x0584(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToMap();
	void InteractingWithDoor(class ACharacter* InteractionCharacter);
	void OnDoorStateSetHandler(EDoorLockState NewLockState, EDoorLockState OldLockState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMarkerDoorComponent">();
	}
	static class UMapMarkerDoorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapMarkerDoorComponent>();
	}
};
static_assert(alignof(UMapMarkerDoorComponent) == 0x000010, "Wrong alignment on UMapMarkerDoorComponent");
static_assert(sizeof(UMapMarkerDoorComponent) == 0x000590, "Wrong size on UMapMarkerDoorComponent");
static_assert(offsetof(UMapMarkerDoorComponent, DoorBrushes) == 0x000530, "Member 'UMapMarkerDoorComponent::DoorBrushes' has a wrong offset!");
static_assert(offsetof(UMapMarkerDoorComponent, CurrentDisplayState) == 0x000580, "Member 'UMapMarkerDoorComponent::CurrentDisplayState' has a wrong offset!");

// Class ObsidianFox.MapMarkerPuzzleComponent
// 0x0010 (0x0540 - 0x0530)
class UMapMarkerPuzzleComponent final : public UMapMarkerActorComponent
{
public:
	uint8                                         Pad_530[0x10];                                     // 0x0530(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetIsSolvable(bool bSolvable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapMarkerPuzzleComponent">();
	}
	static class UMapMarkerPuzzleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapMarkerPuzzleComponent>();
	}
};
static_assert(alignof(UMapMarkerPuzzleComponent) == 0x000010, "Wrong alignment on UMapMarkerPuzzleComponent");
static_assert(sizeof(UMapMarkerPuzzleComponent) == 0x000540, "Wrong size on UMapMarkerPuzzleComponent");

// Class ObsidianFox.MapPositionActor
// 0x0000 (0x0238 - 0x0238)
class AMapPositionActor : public AActor
{
public:
	float GetDistanceToMapOrthographicCamera() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapPositionActor">();
	}
	static class AMapPositionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapPositionActor>();
	}
};
static_assert(alignof(AMapPositionActor) == 0x000008, "Wrong alignment on AMapPositionActor");
static_assert(sizeof(AMapPositionActor) == 0x000238, "Wrong size on AMapPositionActor");

// Class ObsidianFox.MapTeleporter
// 0x0030 (0x0268 - 0x0238)
class AMapTeleporter final : public AActor
{
public:
	TSoftObjectPtr<class UWorld>                  DestinationLevel;                                  // 0x0238(0x0028)(Edit, BlueprintVisible, DisableEditOnTemplate, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DestinationLevelName;                              // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ConvertToLightWeightSoftRef(TSoftObjectPtr<class UWorld> OldLevelReference);
	void OnDestinationChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapTeleporter">();
	}
	static class AMapTeleporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapTeleporter>();
	}
};
static_assert(alignof(AMapTeleporter) == 0x000008, "Wrong alignment on AMapTeleporter");
static_assert(sizeof(AMapTeleporter) == 0x000268, "Wrong size on AMapTeleporter");
static_assert(offsetof(AMapTeleporter, DestinationLevel) == 0x000238, "Member 'AMapTeleporter::DestinationLevel' has a wrong offset!");
static_assert(offsetof(AMapTeleporter, DestinationLevelName) == 0x000260, "Member 'AMapTeleporter::DestinationLevelName' has a wrong offset!");

// Class ObsidianFox.MapTrackerVolume
// 0x0010 (0x0280 - 0x0270)
class AMapTrackerVolume final : public AVolume
{
public:
	struct FGameplayTag                           RoomTag;                                           // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFlowTriggerComponent*                  FlowTriggerComponent;                              // 0x0278(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ComponentBeginOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bFromSweep, const struct FHitResult& InSweepResult);
	void ComponentEndOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapTrackerVolume">();
	}
	static class AMapTrackerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMapTrackerVolume>();
	}
};
static_assert(alignof(AMapTrackerVolume) == 0x000008, "Wrong alignment on AMapTrackerVolume");
static_assert(sizeof(AMapTrackerVolume) == 0x000280, "Wrong size on AMapTrackerVolume");
static_assert(offsetof(AMapTrackerVolume, RoomTag) == 0x000270, "Member 'AMapTrackerVolume::RoomTag' has a wrong offset!");
static_assert(offsetof(AMapTrackerVolume, FlowTriggerComponent) == 0x000278, "Member 'AMapTrackerVolume::FlowTriggerComponent' has a wrong offset!");

// Class ObsidianFox.WeaponAnimationComponent
// 0x0190 (0x0248 - 0x00B8)
class UWeaponAnimationComponent final : public UActorComponent
{
public:
	bool                                          bHolstered;                                        // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             UnHolsterDone;                                     // 0x00C0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             HolsterDone;                                       // 0x00D0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AOFWeaponActor*                         HeldWeapon;                                        // 0x00E0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOFPlayerCharacter*                     PlayerCharacter;                                   // 0x00E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UEquipmentManager>       EquipmentManagerWeakPtr;                           // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F8[0x10];                                      // 0x00F8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bEnableAnimationLayerLinking : 1;                  // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  UnholsterBlockingTags;                             // 0x0110(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  TimerHolsterBlockingTags;                          // 0x0130(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           CurrentUnholsterMontage;                           // 0x0150(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           CurrentHolsterMontage;                             // 0x0158(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0xE8];                                     // 0x0160(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelCurrentHolster();
	void ChangeHeldWeapon(class AOFWeaponActor* NewWeapon, bool bInstantSwitch);
	void HolsterWeapon(class AOFWeaponActor* WeaponToHolster, bool bInstant);
	bool IsHolsterByTimerBlocked();
	void MoveHeldWeaponToSocket(EEquipmentSocket SocketLocation);
	void MoveWeaponToEquipmentSocket(class AOFWeaponActor* Weapon, EEquipmentSocket SocketLocation);
	void OnCombatStatusChanged(bool bInCombat);
	void OnHolsterDone();
	void OnMontageEndedHandleForHolster(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageEndedHandleForUnholster(class UAnimMontage* Montage, bool bInterrupted);
	void OnPauseHolsterTimerMultiBoolValueChanged(bool NewValue);
	void OnUnHolsterDone();
	void OnWeaponEquip(const struct FWeaponInfo& EquippedWeapon, const struct FWeaponInfo& UnequippedWeapon);
	void ParentCinematicModeStatusChangedHandler(bool bIsTransitioningToCinematicMode);
	void PauseHolsterTimer(class UObject* LockOwnerReference);
	void ResumeHolsterTimer(class UObject* LockOwnerReference);
	void StartHolsterTimer(const class UObject* LockOwnerReference);
	void StopHolsterTimer(const class UObject* LockOwnerReference);
	void UnHolsterWeapon(class AOFWeaponActor* NewWeapon, bool bInstant);
	void UpdateMultiBoolReferences();

	bool IsHolstering() const;
	bool IsUnHolstering() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAnimationComponent">();
	}
	static class UWeaponAnimationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAnimationComponent>();
	}
};
static_assert(alignof(UWeaponAnimationComponent) == 0x000008, "Wrong alignment on UWeaponAnimationComponent");
static_assert(sizeof(UWeaponAnimationComponent) == 0x000248, "Wrong size on UWeaponAnimationComponent");
static_assert(offsetof(UWeaponAnimationComponent, bHolstered) == 0x0000B8, "Member 'UWeaponAnimationComponent::bHolstered' has a wrong offset!");
static_assert(offsetof(UWeaponAnimationComponent, UnHolsterDone) == 0x0000C0, "Member 'UWeaponAnimationComponent::UnHolsterDone' has a wrong offset!");
static_assert(offsetof(UWeaponAnimationComponent, HolsterDone) == 0x0000D0, "Member 'UWeaponAnimationComponent::HolsterDone' has a wrong offset!");
static_assert(offsetof(UWeaponAnimationComponent, HeldWeapon) == 0x0000E0, "Member 'UWeaponAnimationComponent::HeldWeapon' has a wrong offset!");
static_assert(offsetof(UWeaponAnimationComponent, PlayerCharacter) == 0x0000E8, "Member 'UWeaponAnimationComponent::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(UWeaponAnimationComponent, EquipmentManagerWeakPtr) == 0x0000F0, "Member 'UWeaponAnimationComponent::EquipmentManagerWeakPtr' has a wrong offset!");
static_assert(offsetof(UWeaponAnimationComponent, UnholsterBlockingTags) == 0x000110, "Member 'UWeaponAnimationComponent::UnholsterBlockingTags' has a wrong offset!");
static_assert(offsetof(UWeaponAnimationComponent, TimerHolsterBlockingTags) == 0x000130, "Member 'UWeaponAnimationComponent::TimerHolsterBlockingTags' has a wrong offset!");
static_assert(offsetof(UWeaponAnimationComponent, CurrentUnholsterMontage) == 0x000150, "Member 'UWeaponAnimationComponent::CurrentUnholsterMontage' has a wrong offset!");
static_assert(offsetof(UWeaponAnimationComponent, CurrentHolsterMontage) == 0x000158, "Member 'UWeaponAnimationComponent::CurrentHolsterMontage' has a wrong offset!");

// Class ObsidianFox.MeleeAttackHitZonesComponent
// 0x0018 (0x00D0 - 0x00B8)
class UMeleeAttackHitZonesComponent final : public UActorComponent
{
public:
	TArray<class FName>                           Zones;                                             // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         bDebugDraw : 1;                                    // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckIfHit(const class UDamagePoint* DamagePoint, const struct FVector& HitLocation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeleeAttackHitZonesComponent">();
	}
	static class UMeleeAttackHitZonesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeleeAttackHitZonesComponent>();
	}
};
static_assert(alignof(UMeleeAttackHitZonesComponent) == 0x000008, "Wrong alignment on UMeleeAttackHitZonesComponent");
static_assert(sizeof(UMeleeAttackHitZonesComponent) == 0x0000D0, "Wrong size on UMeleeAttackHitZonesComponent");
static_assert(offsetof(UMeleeAttackHitZonesComponent, Zones) == 0x0000B8, "Member 'UMeleeAttackHitZonesComponent::Zones' has a wrong offset!");

// Class ObsidianFox.MeleeWeaponActor
// 0x00D0 (0x0460 - 0x0390)
class AMeleeWeaponActor : public AOFWeaponActor
{
public:
	FMulticastInlineDelegateProperty_             WeaponBeginAttack;                                 // 0x0390(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         HitOverlapDelay;                                   // 0x03A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugDisplayTime;                                  // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDisplayDebugHelp : 1;                             // 0x03A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisplayDebugCollisionSweep : 1;                   // 0x03A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisplayDebugCollisionHit : 1;                     // 0x03A8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisplayDebugImpactSphere : 1;                     // 0x03A8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bDisplayDebugImpactVector : 1;                     // 0x03A8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3A9[0x57];                                     // 0x03A9(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCollisionProfileName                  TraceProfile;                                      // 0x0400(0x0008)(Edit, BlueprintVisible, Config, NoDestructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              WeaponMaterialHitSFX;                              // 0x0408(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UShapeComponent*>                Colliders;                                         // 0x0440(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	bool                                          CanHitEnvironment;                                 // 0x0450(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_451[0xF];                                      // 0x0451(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor);
	void RemoveImmuneActor(class AActor* OtherActor);
	void WeaponAttack__DelegateSignature(const struct FGameplayTag& AttackEvent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeleeWeaponActor">();
	}
	static class AMeleeWeaponActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMeleeWeaponActor>();
	}
};
static_assert(alignof(AMeleeWeaponActor) == 0x000008, "Wrong alignment on AMeleeWeaponActor");
static_assert(sizeof(AMeleeWeaponActor) == 0x000460, "Wrong size on AMeleeWeaponActor");
static_assert(offsetof(AMeleeWeaponActor, WeaponBeginAttack) == 0x000390, "Member 'AMeleeWeaponActor::WeaponBeginAttack' has a wrong offset!");
static_assert(offsetof(AMeleeWeaponActor, HitOverlapDelay) == 0x0003A0, "Member 'AMeleeWeaponActor::HitOverlapDelay' has a wrong offset!");
static_assert(offsetof(AMeleeWeaponActor, DebugDisplayTime) == 0x0003A4, "Member 'AMeleeWeaponActor::DebugDisplayTime' has a wrong offset!");
static_assert(offsetof(AMeleeWeaponActor, TraceProfile) == 0x000400, "Member 'AMeleeWeaponActor::TraceProfile' has a wrong offset!");
static_assert(offsetof(AMeleeWeaponActor, WeaponMaterialHitSFX) == 0x000408, "Member 'AMeleeWeaponActor::WeaponMaterialHitSFX' has a wrong offset!");
static_assert(offsetof(AMeleeWeaponActor, Colliders) == 0x000440, "Member 'AMeleeWeaponActor::Colliders' has a wrong offset!");
static_assert(offsetof(AMeleeWeaponActor, CanHitEnvironment) == 0x000450, "Member 'AMeleeWeaponActor::CanHitEnvironment' has a wrong offset!");

// Class ObsidianFox.MenuInventorySelectionSlot
// 0x0038 (0x0298 - 0x0260)
class UMenuInventorySelectionSlot : public UUserWidget
{
public:
	class UOFButton*                              SlotButton;                                        // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ItemIcon;                                          // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SlotIndex;                                         // 0x0270(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemData*                              ItemData;                                          // 0x0278(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelected;                                         // 0x0280(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_281[0x17];                                     // 0x0281(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAsActiveSlot();
	void SetItemSlotVisibility(ESlateVisibility NewVisibility);
	void UpdateSlot(const class UItemData* NewItemData);
	void UpdateSlotFromSoftReferenceData(const TSoftObjectPtr<class UItemData> NewItemData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MenuInventorySelectionSlot">();
	}
	static class UMenuInventorySelectionSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMenuInventorySelectionSlot>();
	}
};
static_assert(alignof(UMenuInventorySelectionSlot) == 0x000008, "Wrong alignment on UMenuInventorySelectionSlot");
static_assert(sizeof(UMenuInventorySelectionSlot) == 0x000298, "Wrong size on UMenuInventorySelectionSlot");
static_assert(offsetof(UMenuInventorySelectionSlot, SlotButton) == 0x000260, "Member 'UMenuInventorySelectionSlot::SlotButton' has a wrong offset!");
static_assert(offsetof(UMenuInventorySelectionSlot, ItemIcon) == 0x000268, "Member 'UMenuInventorySelectionSlot::ItemIcon' has a wrong offset!");
static_assert(offsetof(UMenuInventorySelectionSlot, SlotIndex) == 0x000270, "Member 'UMenuInventorySelectionSlot::SlotIndex' has a wrong offset!");
static_assert(offsetof(UMenuInventorySelectionSlot, ItemData) == 0x000278, "Member 'UMenuInventorySelectionSlot::ItemData' has a wrong offset!");
static_assert(offsetof(UMenuInventorySelectionSlot, bSelected) == 0x000280, "Member 'UMenuInventorySelectionSlot::bSelected' has a wrong offset!");

// Class ObsidianFox.MetricsDeveloperSettings
// 0x0028 (0x0060 - 0x0038)
class UMetricsDeveloperSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UDataAsset>              HealthItem;                                        // 0x0038(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetricsDeveloperSettings">();
	}
	static class UMetricsDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMetricsDeveloperSettings>();
	}
};
static_assert(alignof(UMetricsDeveloperSettings) == 0x000008, "Wrong alignment on UMetricsDeveloperSettings");
static_assert(sizeof(UMetricsDeveloperSettings) == 0x000060, "Wrong size on UMetricsDeveloperSettings");
static_assert(offsetof(UMetricsDeveloperSettings, HealthItem) == 0x000038, "Member 'UMetricsDeveloperSettings::HealthItem' has a wrong offset!");

// Class ObsidianFox.MetricStatsSystem
// 0x0080 (0x00B0 - 0x0030)
class UMetricStatsSystem final : public UGameplaySessionSubsystem
{
public:
	uint8                                         Pad_30[0x80];                                      // 0x0030(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCharacterDeathHandler(class AObsidianFoxCharacter* InCharacter);
	void OnItemAddedHandler(const class UItemData* InItemData);
	void OnItemRemovedHandler(const class UItemData* InItemData);
	void OnPuzzleSolvedGenericHandler(class APuzzleActor* InPuzzleActor);
	void OnSettingsChangedDelegate(class UOFGameUserSettings* Settings);
	void OnWeaponFireHandler(class AHitscanWeaponActor* InWeapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetricStatsSystem">();
	}
	static class UMetricStatsSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMetricStatsSystem>();
	}
};
static_assert(alignof(UMetricStatsSystem) == 0x000008, "Wrong alignment on UMetricStatsSystem");
static_assert(sizeof(UMetricStatsSystem) == 0x0000B0, "Wrong size on UMetricStatsSystem");

// Class ObsidianFox.MovementCommandInterface
// 0x0000 (0x0028 - 0x0028)
class IMovementCommandInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementCommandInterface">();
	}
	static class IMovementCommandInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMovementCommandInterface>();
	}
};
static_assert(alignof(IMovementCommandInterface) == 0x000008, "Wrong alignment on IMovementCommandInterface");
static_assert(sizeof(IMovementCommandInterface) == 0x000028, "Wrong size on IMovementCommandInterface");

// Class ObsidianFox.NestLocationActor
// 0x0008 (0x0240 - 0x0238)
class ANestLocationActor final : public AActor
{
public:
	class UArrowComponent*                        ArrowComponent;                                    // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NestLocationActor">();
	}
	static class ANestLocationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANestLocationActor>();
	}
};
static_assert(alignof(ANestLocationActor) == 0x000008, "Wrong alignment on ANestLocationActor");
static_assert(sizeof(ANestLocationActor) == 0x000240, "Wrong size on ANestLocationActor");
static_assert(offsetof(ANestLocationActor, ArrowComponent) == 0x000238, "Member 'ANestLocationActor::ArrowComponent' has a wrong offset!");

// Class ObsidianFox.ObjectiveEntryListWidget
// 0x0040 (0x02A0 - 0x0260)
class UObjectiveEntryListWidget : public UUserWidget
{
public:
	class UTextBlock*                             ObjectiveText;                                     // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           SubObjectives;                                     // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 StrikethroughTextClass;                            // 0x0270(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UObjectivesData>         ObjectivesData;                                    // 0x0278(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveEntryListWidget">();
	}
	static class UObjectiveEntryListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveEntryListWidget>();
	}
};
static_assert(alignof(UObjectiveEntryListWidget) == 0x000008, "Wrong alignment on UObjectiveEntryListWidget");
static_assert(sizeof(UObjectiveEntryListWidget) == 0x0002A0, "Wrong size on UObjectiveEntryListWidget");
static_assert(offsetof(UObjectiveEntryListWidget, ObjectiveText) == 0x000260, "Member 'UObjectiveEntryListWidget::ObjectiveText' has a wrong offset!");
static_assert(offsetof(UObjectiveEntryListWidget, SubObjectives) == 0x000268, "Member 'UObjectiveEntryListWidget::SubObjectives' has a wrong offset!");
static_assert(offsetof(UObjectiveEntryListWidget, StrikethroughTextClass) == 0x000270, "Member 'UObjectiveEntryListWidget::StrikethroughTextClass' has a wrong offset!");
static_assert(offsetof(UObjectiveEntryListWidget, ObjectivesData) == 0x000278, "Member 'UObjectiveEntryListWidget::ObjectivesData' has a wrong offset!");

// Class ObsidianFox.ObjectiveNotesWidget
// 0x00F0 (0x0350 - 0x0260)
class UObjectiveNotesWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x20];                                     // 0x0260(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class URichTextBlock*                         Notes;                                             // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             HighlightsEnabledStyleTable;                       // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             HighlightsDisabledStyleTable;                      // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             NoteScrollBox;                                     // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             NoteNumbers;                                       // 0x02A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MultiplyValueToMoveInScrollBox;                    // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNoteInfo>                      NotesTexts;                                        // 0x02B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentActiveNoteIndex;                            // 0x02C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFMODEvent>              NoteBookEntriesFmodEvent;                          // 0x02C8(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F0[0x60];                                     // 0x02F0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnActive();
	void PlayCurrentNote();
	void PlayerGuidanceStateUpdatedHandler(EPlayerGuidanceSystem System, bool bState);
	void SetNewNotes(const struct FObjectiveChapter& ObjectiveChapterInfo);
	void SoundStoppedHandler();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveNotesWidget">();
	}
	static class UObjectiveNotesWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveNotesWidget>();
	}
};
static_assert(alignof(UObjectiveNotesWidget) == 0x000008, "Wrong alignment on UObjectiveNotesWidget");
static_assert(sizeof(UObjectiveNotesWidget) == 0x000350, "Wrong size on UObjectiveNotesWidget");
static_assert(offsetof(UObjectiveNotesWidget, Notes) == 0x000280, "Member 'UObjectiveNotesWidget::Notes' has a wrong offset!");
static_assert(offsetof(UObjectiveNotesWidget, HighlightsEnabledStyleTable) == 0x000288, "Member 'UObjectiveNotesWidget::HighlightsEnabledStyleTable' has a wrong offset!");
static_assert(offsetof(UObjectiveNotesWidget, HighlightsDisabledStyleTable) == 0x000290, "Member 'UObjectiveNotesWidget::HighlightsDisabledStyleTable' has a wrong offset!");
static_assert(offsetof(UObjectiveNotesWidget, NoteScrollBox) == 0x000298, "Member 'UObjectiveNotesWidget::NoteScrollBox' has a wrong offset!");
static_assert(offsetof(UObjectiveNotesWidget, NoteNumbers) == 0x0002A0, "Member 'UObjectiveNotesWidget::NoteNumbers' has a wrong offset!");
static_assert(offsetof(UObjectiveNotesWidget, MultiplyValueToMoveInScrollBox) == 0x0002A8, "Member 'UObjectiveNotesWidget::MultiplyValueToMoveInScrollBox' has a wrong offset!");
static_assert(offsetof(UObjectiveNotesWidget, NotesTexts) == 0x0002B0, "Member 'UObjectiveNotesWidget::NotesTexts' has a wrong offset!");
static_assert(offsetof(UObjectiveNotesWidget, CurrentActiveNoteIndex) == 0x0002C0, "Member 'UObjectiveNotesWidget::CurrentActiveNoteIndex' has a wrong offset!");
static_assert(offsetof(UObjectiveNotesWidget, NoteBookEntriesFmodEvent) == 0x0002C8, "Member 'UObjectiveNotesWidget::NoteBookEntriesFmodEvent' has a wrong offset!");

// Class ObsidianFox.ObjectivesData
// 0x0090 (0x00C0 - 0x0030)
class UObjectivesData final : public UDataAsset
{
public:
	class FText                                   ObjectivName;                                      // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, SaveGame, NativeAccessSpecifierPublic)
	bool                                          bIsModernObjective;                                // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPlayerCharacterType, TSoftObjectPtr<class UObjectivesData>> ParentSuperObjective;                              // 0x0050(0x0050)(Edit, BlueprintVisible, AdvancedDisplay, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         HowManyParts;                                      // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FObjectiveStruct>               Objectives;                                        // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, NativeAccessSpecifierPublic)
	int32                                         Chapter;                                           // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectivesData">();
	}
	static class UObjectivesData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectivesData>();
	}
};
static_assert(alignof(UObjectivesData) == 0x000008, "Wrong alignment on UObjectivesData");
static_assert(sizeof(UObjectivesData) == 0x0000C0, "Wrong size on UObjectivesData");
static_assert(offsetof(UObjectivesData, ObjectivName) == 0x000030, "Member 'UObjectivesData::ObjectivName' has a wrong offset!");
static_assert(offsetof(UObjectivesData, bIsModernObjective) == 0x000048, "Member 'UObjectivesData::bIsModernObjective' has a wrong offset!");
static_assert(offsetof(UObjectivesData, ParentSuperObjective) == 0x000050, "Member 'UObjectivesData::ParentSuperObjective' has a wrong offset!");
static_assert(offsetof(UObjectivesData, HowManyParts) == 0x0000A0, "Member 'UObjectivesData::HowManyParts' has a wrong offset!");
static_assert(offsetof(UObjectivesData, Objectives) == 0x0000A8, "Member 'UObjectivesData::Objectives' has a wrong offset!");
static_assert(offsetof(UObjectivesData, Chapter) == 0x0000B8, "Member 'UObjectivesData::Chapter' has a wrong offset!");

// Class ObsidianFox.ObjectiveUtils
// 0x0000 (0x0028 - 0x0028)
class UObjectiveUtils final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveUtils">();
	}
	static class UObjectiveUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveUtils>();
	}
};
static_assert(alignof(UObjectiveUtils) == 0x000008, "Wrong alignment on UObjectiveUtils");
static_assert(sizeof(UObjectiveUtils) == 0x000028, "Wrong size on UObjectiveUtils");

// Class ObsidianFox.ObsidianFoxGameMode
// 0x0010 (0x02F0 - 0x02E0)
class AObsidianFoxGameMode : public AGameModeBase
{
public:
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Tweak(const class FString& Table, const class FString& Key, float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObsidianFoxGameMode">();
	}
	static class AObsidianFoxGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AObsidianFoxGameMode>();
	}
};
static_assert(alignof(AObsidianFoxGameMode) == 0x000008, "Wrong alignment on AObsidianFoxGameMode");
static_assert(sizeof(AObsidianFoxGameMode) == 0x0002F0, "Wrong size on AObsidianFoxGameMode");

// Class ObsidianFox.OFAbilitySystemGlobals
// 0x0000 (0x0260 - 0x0260)
class UOFAbilitySystemGlobals final : public UAbilitySystemGlobals
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFAbilitySystemGlobals">();
	}
	static class UOFAbilitySystemGlobals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFAbilitySystemGlobals>();
	}
};
static_assert(alignof(UOFAbilitySystemGlobals) == 0x000008, "Wrong alignment on UOFAbilitySystemGlobals");
static_assert(sizeof(UOFAbilitySystemGlobals) == 0x000260, "Wrong size on UOFAbilitySystemGlobals");

// Class ObsidianFox.OFActivitiesSubsystem
// 0x0010 (0x0078 - 0x0068)
class UOFActivitiesSubsystem final : public UPiecesActivitiesSubsystem
{
public:
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAllSavesDeletedHandler();
	void OnChapterUpdatedHandler(const struct FGameplayTag& NewTag, const struct FGameplayTag& OldTag);
	void OnFactUpdatedHandler(const struct FGameplayTag& Tag, ESubscriptionTagChangeType ChangeType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFActivitiesSubsystem">();
	}
	static class UOFActivitiesSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFActivitiesSubsystem>();
	}
};
static_assert(alignof(UOFActivitiesSubsystem) == 0x000008, "Wrong alignment on UOFActivitiesSubsystem");
static_assert(sizeof(UOFActivitiesSubsystem) == 0x000078, "Wrong size on UOFActivitiesSubsystem");

// Class ObsidianFox.OFActivityLoadLatestSave
// 0x0008 (0x0138 - 0x0130)
class UOFActivityLoadLatestSave final : public UPiecesActivityBase
{
public:
	class UBPAsyncAction_ChunkInstallWaitPopup*   ChunkInstallWaitTask;                              // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChunkInstallSuccessful();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFActivityLoadLatestSave">();
	}
	static class UOFActivityLoadLatestSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFActivityLoadLatestSave>();
	}
};
static_assert(alignof(UOFActivityLoadLatestSave) == 0x000008, "Wrong alignment on UOFActivityLoadLatestSave");
static_assert(sizeof(UOFActivityLoadLatestSave) == 0x000138, "Wrong size on UOFActivityLoadLatestSave");
static_assert(offsetof(UOFActivityLoadLatestSave, ChunkInstallWaitTask) == 0x000130, "Member 'UOFActivityLoadLatestSave::ChunkInstallWaitTask' has a wrong offset!");

// Class ObsidianFox.OFActivityStory
// 0x0010 (0x0140 - 0x0130)
class UOFActivityStory final : public UPiecesActivityBase
{
public:
	uint8                                         Pad_130[0x8];                                      // 0x0130(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBPAsyncAction_ChunkInstallWaitPopup*   ChunkInstallWaitTask;                              // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChunkInstallSuccessful();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFActivityStory">();
	}
	static class UOFActivityStory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFActivityStory>();
	}
};
static_assert(alignof(UOFActivityStory) == 0x000008, "Wrong alignment on UOFActivityStory");
static_assert(sizeof(UOFActivityStory) == 0x000140, "Wrong size on UOFActivityStory");
static_assert(offsetof(UOFActivityStory, ChunkInstallWaitTask) == 0x000138, "Member 'UOFActivityStory::ChunkInstallWaitTask' has a wrong offset!");

// Class ObsidianFox.OFArchiveGridWidget
// 0x0018 (0x02D8 - 0x02C0)
class UOFArchiveGridWidget : public UOFGridPanel
{
public:
	class UScrollBox*                             ArchiveScrollBox;                                  // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ProgressionTag;                                    // 0x02C8(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetHasItems() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFArchiveGridWidget">();
	}
	static class UOFArchiveGridWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFArchiveGridWidget>();
	}
};
static_assert(alignof(UOFArchiveGridWidget) == 0x000008, "Wrong alignment on UOFArchiveGridWidget");
static_assert(sizeof(UOFArchiveGridWidget) == 0x0002D8, "Wrong size on UOFArchiveGridWidget");
static_assert(offsetof(UOFArchiveGridWidget, ArchiveScrollBox) == 0x0002C0, "Member 'UOFArchiveGridWidget::ArchiveScrollBox' has a wrong offset!");
static_assert(offsetof(UOFArchiveGridWidget, ProgressionTag) == 0x0002C8, "Member 'UOFArchiveGridWidget::ProgressionTag' has a wrong offset!");

// Class ObsidianFox.OFArchiveSlotWidget
// 0x0000 (0x0388 - 0x0388)
class UOFArchiveSlotWidget : public UOFSlotWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFArchiveSlotWidget">();
	}
	static class UOFArchiveSlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFArchiveSlotWidget>();
	}
};
static_assert(alignof(UOFArchiveSlotWidget) == 0x000008, "Wrong alignment on UOFArchiveSlotWidget");
static_assert(sizeof(UOFArchiveSlotWidget) == 0x000388, "Wrong size on UOFArchiveSlotWidget");

// Class ObsidianFox.OFBalanceSettings
// 0x0160 (0x0198 - 0x0038)
class UOFBalanceSettings final : public UOFDeveloperSettingsBase
{
public:
	TSoftObjectPtr<class UDataTable>              ResourceBalanceTable;                              // 0x0038(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HealGE;                                            // 0x0060(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ResourceBalanceTableDefaultRow;                    // 0x0088(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmptyContainerTargetMultiplierMinRand;             // 0x0090(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmptyContainerTargetMultiplierMaxRand;             // 0x0094(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FConsumableItemReference>       ItemDataRefs;                                      // 0x0098(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EDifficulty, float>                      EnemyHealthDifficultyModifiers;                    // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EDifficulty, float>                      EnemyDamageDifficultyModifiers;                    // 0x00F8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EDifficulty, float>                      ConsumableAmountDifficultyModifiers;               // 0x0148(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFBalanceSettings">();
	}
	static class UOFBalanceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFBalanceSettings>();
	}
};
static_assert(alignof(UOFBalanceSettings) == 0x000008, "Wrong alignment on UOFBalanceSettings");
static_assert(sizeof(UOFBalanceSettings) == 0x000198, "Wrong size on UOFBalanceSettings");
static_assert(offsetof(UOFBalanceSettings, ResourceBalanceTable) == 0x000038, "Member 'UOFBalanceSettings::ResourceBalanceTable' has a wrong offset!");
static_assert(offsetof(UOFBalanceSettings, HealGE) == 0x000060, "Member 'UOFBalanceSettings::HealGE' has a wrong offset!");
static_assert(offsetof(UOFBalanceSettings, ResourceBalanceTableDefaultRow) == 0x000088, "Member 'UOFBalanceSettings::ResourceBalanceTableDefaultRow' has a wrong offset!");
static_assert(offsetof(UOFBalanceSettings, EmptyContainerTargetMultiplierMinRand) == 0x000090, "Member 'UOFBalanceSettings::EmptyContainerTargetMultiplierMinRand' has a wrong offset!");
static_assert(offsetof(UOFBalanceSettings, EmptyContainerTargetMultiplierMaxRand) == 0x000094, "Member 'UOFBalanceSettings::EmptyContainerTargetMultiplierMaxRand' has a wrong offset!");
static_assert(offsetof(UOFBalanceSettings, ItemDataRefs) == 0x000098, "Member 'UOFBalanceSettings::ItemDataRefs' has a wrong offset!");
static_assert(offsetof(UOFBalanceSettings, EnemyHealthDifficultyModifiers) == 0x0000A8, "Member 'UOFBalanceSettings::EnemyHealthDifficultyModifiers' has a wrong offset!");
static_assert(offsetof(UOFBalanceSettings, EnemyDamageDifficultyModifiers) == 0x0000F8, "Member 'UOFBalanceSettings::EnemyDamageDifficultyModifiers' has a wrong offset!");
static_assert(offsetof(UOFBalanceSettings, ConsumableAmountDifficultyModifiers) == 0x000148, "Member 'UOFBalanceSettings::ConsumableAmountDifficultyModifiers' has a wrong offset!");

// Class ObsidianFox.OFBFL_ActorUtils
// 0x0000 (0x0028 - 0x0028)
class UOFBFL_ActorUtils final : public UBlueprintFunctionLibrary
{
public:
	static void DisableActor(class AActor* InActor, const bool InDisable);
	static void MoveEnemiesToSpawnLocation(const class UObject* WorldContextObject, const struct FVector& Origin, const float Radius);
	static bool PreStreamTextures_ActorsWithTag(const class UObject* WorldContextObject, const class FName Tag, const bool ForceUpdateTextures);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFBFL_ActorUtils">();
	}
	static class UOFBFL_ActorUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFBFL_ActorUtils>();
	}
};
static_assert(alignof(UOFBFL_ActorUtils) == 0x000008, "Wrong alignment on UOFBFL_ActorUtils");
static_assert(sizeof(UOFBFL_ActorUtils) == 0x000028, "Wrong size on UOFBFL_ActorUtils");

// Class ObsidianFox.OFBFL_Input
// 0x0000 (0x0028 - 0x0028)
class UOFBFL_Input final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyInputAxis(class UObject* Context, const class FName& AxisName, float AxisValue);
	static void FakeInputKey(class APlayerController* InPlayerController, const struct FKey& Key, EInputEvent EventType, float AmountDepressed, bool bGamepad);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFBFL_Input">();
	}
	static class UOFBFL_Input* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFBFL_Input>();
	}
};
static_assert(alignof(UOFBFL_Input) == 0x000008, "Wrong alignment on UOFBFL_Input");
static_assert(sizeof(UOFBFL_Input) == 0x000028, "Wrong size on UOFBFL_Input");

// Class ObsidianFox.OFBFL_PawnUtils
// 0x0000 (0x0028 - 0x0028)
class UOFBFL_PawnUtils final : public UBlueprintFunctionLibrary
{
public:
	static void DisablePawn(class APawn* InPawn, const bool InDisable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFBFL_PawnUtils">();
	}
	static class UOFBFL_PawnUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFBFL_PawnUtils>();
	}
};
static_assert(alignof(UOFBFL_PawnUtils) == 0x000008, "Wrong alignment on UOFBFL_PawnUtils");
static_assert(sizeof(UOFBFL_PawnUtils) == 0x000028, "Wrong size on UOFBFL_PawnUtils");

// Class ObsidianFox.OFBFL_UI
// 0x0000 (0x0028 - 0x0028)
class UOFBFL_UI final : public UBlueprintFunctionLibrary
{
public:
	static float ActualValueToDisplayValue(float ActualValue, float ActualMaxValue, float ActualMinValue, float DisplayMaxValue, float DisplayMinValue);
	static float ActualValueToDisplayValueSens(const float ActualValue);
	static float DecrementAimSens();
	static float DecrementBrightness();
	static float DecrementCameraSens();
	static float DecrementContrast();
	static void DeleteInGameAndPauseMenu(const class UObject* WorldContextObject);
	static float DisplayValueToActualValue(const float DisplayValue, const float ActualMaxValue, const float ActualMinValue, const float DisplayMaxValue, const float DisplayMinValue);
	static float DisplayValueToActualValueSens(const float ReadableValue);
	static float GetCurrentAimSensDisplayValue();
	static float GetCurrentBrightnessDisplayValue();
	static float GetCurrentCameraSensDisplayValue();
	static float GetCurrentContrastDisplayValue();
	static class UObject* GetCurrentFontForCulture();
	static float GetMaxAllowedFOVUserSettings();
	static float GetMinAllowedFOVUserSettings();
	static class UWidgetInputHandlingBase* GetParentWidgetInputHandlingBase(class UWidget* InWidget);
	static EProjectType GetProjectType();
	static TMap<int32, class FText> GetQualitySettings();
	static class FText GetQualitySettingsValue(int32 QualityLevel);
	static float IncrementAimSens();
	static float IncrementBrightness();
	static float IncrementCameraSens();
	static float IncrementContrast();
	static bool IsModuleLoaded(class FName NameModul);
	static void KillAllSubtitles();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFBFL_UI">();
	}
	static class UOFBFL_UI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFBFL_UI>();
	}
};
static_assert(alignof(UOFBFL_UI) == 0x000008, "Wrong alignment on UOFBFL_UI");
static_assert(sizeof(UOFBFL_UI) == 0x000028, "Wrong size on UOFBFL_UI");

// Class ObsidianFox.OFBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOFBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FCameraBlendSettingsInput BlendCameraSettings(EEasingFunc Function, float BlendExp, const struct FCameraBlendSettingsInput& A, const struct FCameraBlendSettingsInput& B, float Alpha);
	static void DisableCameraModifiers(const struct FCameraModifierCollection& ModifierCollection, bool bImmediate);
	static bool DoesSprintRequireHeldInput(const class UObject* WorldContextObject, int32 PlayerIndex);
	static bool DoesSprintRequireHeldInput_Gamepad();
	static bool DoesSprintRequireHeldInput_KBM();
	static class UCameraModifier* EnableCameraModifier(const class UObject* WorldContextObject, TSoftClassPtr<class UClass> ModifierClass);
	static struct FCameraModifierCollection EnableCameraModifiers(const class UObject* WorldContextObject, const TArray<TSoftClassPtr<class UClass>>& Modifiers);
	static void FindSocketLocations(const class USceneComponent* Component, class FName Substring, TArray<struct FVector>* SocketLocations, bool bExactMatch);
	static void GetAllActorsOfClassWithinRange(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, TArray<class AActor*>* OutActors, const struct FVector& Origin, float Range);
	static struct FVector GetClosestLocation(const struct FVector& OriginLocation, const TArray<struct FVector>& Locations);
	static TArray<struct FGameplayTag> GetGameplayTagChildren(const struct FGameplayTag& Root);
	static class AOFPlayerController* GetObsidianFoxPlayerController(const class UObject* WorldContextObject, int32 PlayerIndex);
	static class UOFGameInstance* GetOFGameInstance(const class UObject* WorldContextObject);
	static class UOFGameUserSettings* GetOFGameUserSettings();
	static class AOFPlayerCameraManager* GetOFPlayerCameraManager(const class UObject* WorldContextObject, int32 PlayerIndex);
	static struct FGameplayTag GetSprintTreatAsHoldTag_Gamepad();
	static struct FGameplayTag GetSprintTreatAsHoldTag_KBM();
	static class AThirdPersonPlayerCameraManager* GetThirdPersonPlayerCameraManager(const class UObject* WorldContextObject, int32 PlayerIndex);
	static class FText GetTimespanAsText(const struct FTimespan& Timespan);
	static bool HasAnyEndingAchievement(const class UObject* WorldContextObject);
	static bool IsNewGamePlus(const class UObject* WorldContextObject);
	static bool IsNewGamePlusAvailable(const class UObject* WorldContextObject);
	static void SetGameFinished(const class UObject* WorldContextObject);
	static bool SetSprintRequiresHeldInput_Gamepad(bool bNewRequireHeld);
	static bool SetSprintRequiresHeldInput_KBM(bool bNewRequireHeld);
	static void UnloadLevelsForStreamingVolumes(const class UObject* WorldContextObject, const TArray<TSoftObjectPtr<class ALevelStreamingVolume>>& StreamingVolumes, bool BlockUntilStreamingUpdated, bool DisableVolumes, bool DisableMinTimeBetweenUnloadRequests);
	static void WriteErrorToMessageLog(const class FString& ErrorMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFBlueprintFunctionLibrary">();
	}
	static class UOFBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UOFBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UOFBlueprintFunctionLibrary");
static_assert(sizeof(UOFBlueprintFunctionLibrary) == 0x000028, "Wrong size on UOFBlueprintFunctionLibrary");

// Class ObsidianFox.WeaponOwnerAnimInterface
// 0x0000 (0x0028 - 0x0028)
class IWeaponOwnerAnimInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponOwnerAnimInterface">();
	}
	static class IWeaponOwnerAnimInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IWeaponOwnerAnimInterface>();
	}
};
static_assert(alignof(IWeaponOwnerAnimInterface) == 0x000008, "Wrong alignment on IWeaponOwnerAnimInterface");
static_assert(sizeof(IWeaponOwnerAnimInterface) == 0x000028, "Wrong size on IWeaponOwnerAnimInterface");

// Class ObsidianFox.OFBoids
// 0x00D0 (0x0308 - 0x0238)
class AOFBoids : public AActor
{
public:
	class UInstancedStaticMeshComponent*          ISMBoid;                                           // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBillboardComponent*                    Billboard;                                         // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBoid>                          Boids;                                             // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	int32                                         NumberOfBoids;                                     // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Lifetime;                                          // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DestroySelfAfterLifetime;                          // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261[0x3];                                      // 0x0261(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseSpeed;                                         // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SightRange;                                        // 0x0268(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoherenceStrength;                                 // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SeparationStrength;                                // 0x0270(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AlignmentStrength;                                 // 0x0274(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MoveDirectionPreference;                           // 0x0278(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VelocityDirectionStrength;                         // 0x0284(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnSpeed;                                         // 0x0288(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Deceleration;                                      // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FAttractionPoint>               AttractionPoints;                                  // 0x0290(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FPushPlane>                     PushPlanes;                                        // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FRandomStream                          Seed;                                              // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                ActivateVelocityDirection;                         // 0x02B8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActivateVelocityVariationAmount;                   // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ActivateSpeedMult;                                 // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinRandomScale;                                    // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxRandomScale;                                    // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLimitToArea;                                      // 0x02D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D5[0x3];                                      // 0x02D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AreaSize;                                          // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebug;                                            // 0x02DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugCoherence;                                   // 0x02DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugSeparation;                                  // 0x02DE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugAlignment;                                   // 0x02DF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 DebugIndices;                                      // 0x02E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAreBoidsActive;                                   // 0x02F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F1[0x3];                                      // 0x02F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AverageBoidsLocation;                              // 0x02F4(0x000C)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentBoidLifetime;                               // 0x0300(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateBoids();
	void DeactivateBoids();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFBoids">();
	}
	static class AOFBoids* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOFBoids>();
	}
};
static_assert(alignof(AOFBoids) == 0x000008, "Wrong alignment on AOFBoids");
static_assert(sizeof(AOFBoids) == 0x000308, "Wrong size on AOFBoids");
static_assert(offsetof(AOFBoids, ISMBoid) == 0x000238, "Member 'AOFBoids::ISMBoid' has a wrong offset!");
static_assert(offsetof(AOFBoids, Billboard) == 0x000240, "Member 'AOFBoids::Billboard' has a wrong offset!");
static_assert(offsetof(AOFBoids, Boids) == 0x000248, "Member 'AOFBoids::Boids' has a wrong offset!");
static_assert(offsetof(AOFBoids, NumberOfBoids) == 0x000258, "Member 'AOFBoids::NumberOfBoids' has a wrong offset!");
static_assert(offsetof(AOFBoids, Lifetime) == 0x00025C, "Member 'AOFBoids::Lifetime' has a wrong offset!");
static_assert(offsetof(AOFBoids, DestroySelfAfterLifetime) == 0x000260, "Member 'AOFBoids::DestroySelfAfterLifetime' has a wrong offset!");
static_assert(offsetof(AOFBoids, BaseSpeed) == 0x000264, "Member 'AOFBoids::BaseSpeed' has a wrong offset!");
static_assert(offsetof(AOFBoids, SightRange) == 0x000268, "Member 'AOFBoids::SightRange' has a wrong offset!");
static_assert(offsetof(AOFBoids, CoherenceStrength) == 0x00026C, "Member 'AOFBoids::CoherenceStrength' has a wrong offset!");
static_assert(offsetof(AOFBoids, SeparationStrength) == 0x000270, "Member 'AOFBoids::SeparationStrength' has a wrong offset!");
static_assert(offsetof(AOFBoids, AlignmentStrength) == 0x000274, "Member 'AOFBoids::AlignmentStrength' has a wrong offset!");
static_assert(offsetof(AOFBoids, MoveDirectionPreference) == 0x000278, "Member 'AOFBoids::MoveDirectionPreference' has a wrong offset!");
static_assert(offsetof(AOFBoids, VelocityDirectionStrength) == 0x000284, "Member 'AOFBoids::VelocityDirectionStrength' has a wrong offset!");
static_assert(offsetof(AOFBoids, TurnSpeed) == 0x000288, "Member 'AOFBoids::TurnSpeed' has a wrong offset!");
static_assert(offsetof(AOFBoids, Deceleration) == 0x00028C, "Member 'AOFBoids::Deceleration' has a wrong offset!");
static_assert(offsetof(AOFBoids, AttractionPoints) == 0x000290, "Member 'AOFBoids::AttractionPoints' has a wrong offset!");
static_assert(offsetof(AOFBoids, PushPlanes) == 0x0002A0, "Member 'AOFBoids::PushPlanes' has a wrong offset!");
static_assert(offsetof(AOFBoids, Seed) == 0x0002B0, "Member 'AOFBoids::Seed' has a wrong offset!");
static_assert(offsetof(AOFBoids, ActivateVelocityDirection) == 0x0002B8, "Member 'AOFBoids::ActivateVelocityDirection' has a wrong offset!");
static_assert(offsetof(AOFBoids, ActivateVelocityVariationAmount) == 0x0002C4, "Member 'AOFBoids::ActivateVelocityVariationAmount' has a wrong offset!");
static_assert(offsetof(AOFBoids, ActivateSpeedMult) == 0x0002C8, "Member 'AOFBoids::ActivateSpeedMult' has a wrong offset!");
static_assert(offsetof(AOFBoids, MinRandomScale) == 0x0002CC, "Member 'AOFBoids::MinRandomScale' has a wrong offset!");
static_assert(offsetof(AOFBoids, MaxRandomScale) == 0x0002D0, "Member 'AOFBoids::MaxRandomScale' has a wrong offset!");
static_assert(offsetof(AOFBoids, bLimitToArea) == 0x0002D4, "Member 'AOFBoids::bLimitToArea' has a wrong offset!");
static_assert(offsetof(AOFBoids, AreaSize) == 0x0002D8, "Member 'AOFBoids::AreaSize' has a wrong offset!");
static_assert(offsetof(AOFBoids, bDebug) == 0x0002DC, "Member 'AOFBoids::bDebug' has a wrong offset!");
static_assert(offsetof(AOFBoids, bDebugCoherence) == 0x0002DD, "Member 'AOFBoids::bDebugCoherence' has a wrong offset!");
static_assert(offsetof(AOFBoids, bDebugSeparation) == 0x0002DE, "Member 'AOFBoids::bDebugSeparation' has a wrong offset!");
static_assert(offsetof(AOFBoids, bDebugAlignment) == 0x0002DF, "Member 'AOFBoids::bDebugAlignment' has a wrong offset!");
static_assert(offsetof(AOFBoids, DebugIndices) == 0x0002E0, "Member 'AOFBoids::DebugIndices' has a wrong offset!");
static_assert(offsetof(AOFBoids, bAreBoidsActive) == 0x0002F0, "Member 'AOFBoids::bAreBoidsActive' has a wrong offset!");
static_assert(offsetof(AOFBoids, AverageBoidsLocation) == 0x0002F4, "Member 'AOFBoids::AverageBoidsLocation' has a wrong offset!");
static_assert(offsetof(AOFBoids, CurrentBoidLifetime) == 0x000300, "Member 'AOFBoids::CurrentBoidLifetime' has a wrong offset!");

// Class ObsidianFox.OFButton
// 0x0020 (0x0448 - 0x0428)
class UOFButton final : public UButton
{
public:
	FMulticastInlineDelegateProperty_             OnHoveredButton;                                   // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             UnHoveredButton;                                   // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ButtonOnHovered();
	void ButtonUnHovered();
	void CallOnHoveredEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFButton">();
	}
	static class UOFButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFButton>();
	}
};
static_assert(alignof(UOFButton) == 0x000008, "Wrong alignment on UOFButton");
static_assert(sizeof(UOFButton) == 0x000448, "Wrong size on UOFButton");
static_assert(offsetof(UOFButton, OnHoveredButton) == 0x000428, "Member 'UOFButton::OnHoveredButton' has a wrong offset!");
static_assert(offsetof(UOFButton, UnHoveredButton) == 0x000438, "Member 'UOFButton::UnHoveredButton' has a wrong offset!");

// Class ObsidianFox.TurnInPlaceAsyncAction
// 0x0038 (0x0068 - 0x0030)
class UTurnInPlaceAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnEndBlendToIdle;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndBlendToWalk;                                  // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FailedAngleTooSmall;                               // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UTurnInPlaceAsyncAction* RequestTurnInPlace(class AObsidianFoxCharacter* Character, float RequestedAngleDegrees);

	void OnTurnInPlaceEnded(class ACharacter* TurningCharacter, bool bIsBlendingOutToWalk);
	void OnTurnInPlaceFailedAngleTooSmall(class ACharacter* TurningCharacter);
	void TurnInPlaceTaskEnd__DelegateSignature();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurnInPlaceAsyncAction">();
	}
	static class UTurnInPlaceAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTurnInPlaceAsyncAction>();
	}
};
static_assert(alignof(UTurnInPlaceAsyncAction) == 0x000008, "Wrong alignment on UTurnInPlaceAsyncAction");
static_assert(sizeof(UTurnInPlaceAsyncAction) == 0x000068, "Wrong size on UTurnInPlaceAsyncAction");
static_assert(offsetof(UTurnInPlaceAsyncAction, OnEndBlendToIdle) == 0x000030, "Member 'UTurnInPlaceAsyncAction::OnEndBlendToIdle' has a wrong offset!");
static_assert(offsetof(UTurnInPlaceAsyncAction, OnEndBlendToWalk) == 0x000040, "Member 'UTurnInPlaceAsyncAction::OnEndBlendToWalk' has a wrong offset!");
static_assert(offsetof(UTurnInPlaceAsyncAction, FailedAngleTooSmall) == 0x000050, "Member 'UTurnInPlaceAsyncAction::FailedAngleTooSmall' has a wrong offset!");

// Class ObsidianFox.OFCharacterMovementComponent
// 0x0460 (0x0F70 - 0x0B10)
class UOFCharacterMovementComponent : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_B10[0x20];                                     // 0x0B10(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnSprintStateChange;                               // 0x0B30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B40[0xE0];                                     // 0x0B40(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SprintToWalkSpeedBlendTime;                        // 0x0C20(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsRootMotionDisabled;                              // 0x0C24(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C25[0x3];                                      // 0x0C25(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RootmotionDebugWidth;                              // 0x0C28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RootmotionStartForward;                            // 0x0C2C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         baseRotationMult;                                  // 0x0C38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ExtraForwardVelocityCurve;                         // 0x0C3C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ExtraVelocityForwardDirection;                     // 0x0C44(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VelocityLockCurveName;                             // 0x0C50(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VelocityLockBlendFallbackSpeed;                    // 0x0C58(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C5C[0x4];                                      // 0x0C5C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   VelocityClampMaxCurveName;                         // 0x0C60(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   VelocityClampMinCurveName;                         // 0x0C68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class UObject*>                          RootMotionActiveLock;                              // 0x0C70(0x0050)(Protected, NativeAccessSpecifierProtected)
	TSet<class UObject*>                          RootMotionLockRemoveQueue;                         // 0x0CC0(0x0050)(Protected, NativeAccessSpecifierProtected)
	struct FRootMotionData                        RootMotionData;                                    // 0x0D10(0x002C)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         SprintMaxFullSpeedTurn;                            // 0x0D3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintMaxTurn;                                     // 0x0D40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintStartSpeed;                                  // 0x0D44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            SprintMaxTurnRate;                                 // 0x0D48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D50[0x18];                                     // 0x0D50(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AverageTargetInputVector;                          // 0x0D68(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AverageTargetInputVectorMagnitude;                 // 0x0D74(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D78[0x28];                                     // 0x0D78(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FastTurnSpeedThreshold;                            // 0x0DA0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastTurnTriggerAngle;                              // 0x0DA4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastTurnHorizontalSpeedPenalty;                    // 0x0DA8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DAC[0x30];                                     // 0x0DAC(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FastTurnAnimationYawRotationCurveName;             // 0x0DDC(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DE4[0xC];                                      // 0x0DE4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bIsFastTurn : 1;                                   // 0x0DF0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableFastTurn : 1;                               // 0x0DF0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFinishFastTurnWithAnimNofity : 1;                 // 0x0DF0(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bIsSprinting : 1;                                  // 0x0DF0(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bSprintHold : 1;                                   // 0x0DF0(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bZeroVelocityIfFastTurnBelowSpeedThreshold : 1;    // 0x0DF0(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_DF0_6 : 2;                                  // 0x0DF0(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         BitPad_DF1_0 : 2;                                  // 0x0DF1(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bEnableSprintLimit : 1;                            // 0x0DF1(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableTurnInPlace : 1;                            // 0x0DF1(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bEnableTurnInPlaceTranslationRMRelease : 1;        // 0x0DF1(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_DF1_5 : 1;                                  // 0x0DF1(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bUseAverageInput : 1;                              // 0x0DF1(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_DF2[0x66];                                     // 0x0DF2(0x0066)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AverageInputFrameHistorySize;                      // 0x0E58(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FastTurnInputFramesToCheck;                        // 0x0E5C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastTurnAngleDegrees;                              // 0x0E60(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LockedVelocityBlendSpeed;                          // 0x0E64(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            MinTurnInPlaceAngle;                               // 0x0E68(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnInPlaceActivationThreshold;                    // 0x0E70(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bBypassEverything : 1;                             // 0x0E74(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_E75[0x3];                                      // 0x0E75(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           FocusWalkTag;                                      // 0x0E78(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakingDecelerationCrawling;                       // 0x0E80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCrawlSpeed;                                     // 0x0E84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrawlingSpeedAcceleration;                         // 0x0E88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CrawlRotationSpeed;                                // 0x0E8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E90[0x8];                                      // 0x0E90(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SlopeMaxSpeed;                                     // 0x0E98(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundAngle;                                       // 0x0EA0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundAngleAveraged;                               // 0x0EA4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundAngleActorRelative;                          // 0x0EA8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundAngleActorRelativeAveraged;                  // 0x0EAC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                GroundNormal;                                      // 0x0EB0(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                GroundNormalCharacterRelative;                     // 0x0EBC(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             StairTraceChannel;                                 // 0x0EC8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EC9[0x7];                                      // 0x0EC9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FTagFeatureSettings>              TagFeatures;                                       // 0x0ED0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F20[0x18];                                     // 0x0F20(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WallMovementTraceLength;                           // 0x0F38(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallSweepCapsuleRadiusMultiplier;                  // 0x0F3C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallSpeedStopAngle;                                // 0x0F40(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F44[0x14];                                     // 0x0F44(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          EnableMovementCommandQueue;                        // 0x0F58(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F59[0x17];                                     // 0x0F59(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableRootMotion(bool RootMotionDisabled);
	void DisableTurnRadius();
	void DisableVelocityModifyingAnimationCurves(const class UObject* LockReference);
	void EnableTurnRadius();
	void EnableVelocityModifyingAnimationCurves(const class UObject* LockReference);
	void EndTurnInPlace();
	bool IsFocusWalk();
	void K2_EndFastTurn();
	void LockInput();
	void OnMovementModeChanged__DelegateSignature(EMovementMode PreviousMovementMode, EMovementMode NewMovementMode);
	void OnOwnerAim(bool IsAiming);
	void ReleaseLockedInput();
	void ReleaseRootMotionTranslation();
	void RootMotionEnd(const class UObject* LockOwner, bool Force);
	bool RootMotionStart(const class UObject* LockOwner, bool ApplyTranslation, bool ApplyRotation, bool IsRotationAbsolute);
	void RootMotionUpdate(float DeltaTime);
	void SetBaseMovementSpeed(float Value);
	void SetRootMotionData(float InRootMotionSpeed, const struct FVector& InRootMotionMoveDir, const struct FRotator& InRootMotionRotation);
	void SprintStateChangeSignature__DelegateSignature(bool bIsSprinting_0);
	void StartSprint();
	void StopSprint();
	void TurnInPlaceBranchToWalkIfAppropriate(const class UObject* LockOwner);
	void TurnInPlaceCacheInputForEndBranch();
	void TurnInPlaceEnd__DelegateSignature(class ACharacter* TurningCharacter, bool bIsBlendingOutToWalk);
	void TurnInPlaceFailed__DelegateSignature(class ACharacter* TurningCharacter);

	float GetCurrentMoveSpeed() const;
	struct FVector GetCurrentVelocity() const;
	float GetLockedRotationAngleDegrees() const;
	float GetRequestedTurnAngle() const;
	bool GetRootMotionState() const;
	bool IsFastTurn() const;
	bool IsTurningInPlace() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFCharacterMovementComponent">();
	}
	static class UOFCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFCharacterMovementComponent>();
	}
};
static_assert(alignof(UOFCharacterMovementComponent) == 0x000010, "Wrong alignment on UOFCharacterMovementComponent");
static_assert(sizeof(UOFCharacterMovementComponent) == 0x000F70, "Wrong size on UOFCharacterMovementComponent");
static_assert(offsetof(UOFCharacterMovementComponent, OnSprintStateChange) == 0x000B30, "Member 'UOFCharacterMovementComponent::OnSprintStateChange' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, SprintToWalkSpeedBlendTime) == 0x000C20, "Member 'UOFCharacterMovementComponent::SprintToWalkSpeedBlendTime' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, IsRootMotionDisabled) == 0x000C24, "Member 'UOFCharacterMovementComponent::IsRootMotionDisabled' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, RootmotionDebugWidth) == 0x000C28, "Member 'UOFCharacterMovementComponent::RootmotionDebugWidth' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, RootmotionStartForward) == 0x000C2C, "Member 'UOFCharacterMovementComponent::RootmotionStartForward' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, baseRotationMult) == 0x000C38, "Member 'UOFCharacterMovementComponent::baseRotationMult' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, ExtraForwardVelocityCurve) == 0x000C3C, "Member 'UOFCharacterMovementComponent::ExtraForwardVelocityCurve' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, ExtraVelocityForwardDirection) == 0x000C44, "Member 'UOFCharacterMovementComponent::ExtraVelocityForwardDirection' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, VelocityLockCurveName) == 0x000C50, "Member 'UOFCharacterMovementComponent::VelocityLockCurveName' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, VelocityLockBlendFallbackSpeed) == 0x000C58, "Member 'UOFCharacterMovementComponent::VelocityLockBlendFallbackSpeed' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, VelocityClampMaxCurveName) == 0x000C60, "Member 'UOFCharacterMovementComponent::VelocityClampMaxCurveName' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, VelocityClampMinCurveName) == 0x000C68, "Member 'UOFCharacterMovementComponent::VelocityClampMinCurveName' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, RootMotionActiveLock) == 0x000C70, "Member 'UOFCharacterMovementComponent::RootMotionActiveLock' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, RootMotionLockRemoveQueue) == 0x000CC0, "Member 'UOFCharacterMovementComponent::RootMotionLockRemoveQueue' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, RootMotionData) == 0x000D10, "Member 'UOFCharacterMovementComponent::RootMotionData' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, SprintMaxFullSpeedTurn) == 0x000D3C, "Member 'UOFCharacterMovementComponent::SprintMaxFullSpeedTurn' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, SprintMaxTurn) == 0x000D40, "Member 'UOFCharacterMovementComponent::SprintMaxTurn' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, SprintStartSpeed) == 0x000D44, "Member 'UOFCharacterMovementComponent::SprintStartSpeed' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, SprintMaxTurnRate) == 0x000D48, "Member 'UOFCharacterMovementComponent::SprintMaxTurnRate' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, AverageTargetInputVector) == 0x000D68, "Member 'UOFCharacterMovementComponent::AverageTargetInputVector' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, AverageTargetInputVectorMagnitude) == 0x000D74, "Member 'UOFCharacterMovementComponent::AverageTargetInputVectorMagnitude' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, FastTurnSpeedThreshold) == 0x000DA0, "Member 'UOFCharacterMovementComponent::FastTurnSpeedThreshold' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, FastTurnTriggerAngle) == 0x000DA4, "Member 'UOFCharacterMovementComponent::FastTurnTriggerAngle' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, FastTurnHorizontalSpeedPenalty) == 0x000DA8, "Member 'UOFCharacterMovementComponent::FastTurnHorizontalSpeedPenalty' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, FastTurnAnimationYawRotationCurveName) == 0x000DDC, "Member 'UOFCharacterMovementComponent::FastTurnAnimationYawRotationCurveName' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, AverageInputFrameHistorySize) == 0x000E58, "Member 'UOFCharacterMovementComponent::AverageInputFrameHistorySize' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, FastTurnInputFramesToCheck) == 0x000E5C, "Member 'UOFCharacterMovementComponent::FastTurnInputFramesToCheck' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, FastTurnAngleDegrees) == 0x000E60, "Member 'UOFCharacterMovementComponent::FastTurnAngleDegrees' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, LockedVelocityBlendSpeed) == 0x000E64, "Member 'UOFCharacterMovementComponent::LockedVelocityBlendSpeed' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, MinTurnInPlaceAngle) == 0x000E68, "Member 'UOFCharacterMovementComponent::MinTurnInPlaceAngle' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, TurnInPlaceActivationThreshold) == 0x000E70, "Member 'UOFCharacterMovementComponent::TurnInPlaceActivationThreshold' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, FocusWalkTag) == 0x000E78, "Member 'UOFCharacterMovementComponent::FocusWalkTag' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, BrakingDecelerationCrawling) == 0x000E80, "Member 'UOFCharacterMovementComponent::BrakingDecelerationCrawling' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, MaxCrawlSpeed) == 0x000E84, "Member 'UOFCharacterMovementComponent::MaxCrawlSpeed' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, CrawlingSpeedAcceleration) == 0x000E88, "Member 'UOFCharacterMovementComponent::CrawlingSpeedAcceleration' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, CrawlRotationSpeed) == 0x000E8C, "Member 'UOFCharacterMovementComponent::CrawlRotationSpeed' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, SlopeMaxSpeed) == 0x000E98, "Member 'UOFCharacterMovementComponent::SlopeMaxSpeed' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, GroundAngle) == 0x000EA0, "Member 'UOFCharacterMovementComponent::GroundAngle' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, GroundAngleAveraged) == 0x000EA4, "Member 'UOFCharacterMovementComponent::GroundAngleAveraged' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, GroundAngleActorRelative) == 0x000EA8, "Member 'UOFCharacterMovementComponent::GroundAngleActorRelative' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, GroundAngleActorRelativeAveraged) == 0x000EAC, "Member 'UOFCharacterMovementComponent::GroundAngleActorRelativeAveraged' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, GroundNormal) == 0x000EB0, "Member 'UOFCharacterMovementComponent::GroundNormal' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, GroundNormalCharacterRelative) == 0x000EBC, "Member 'UOFCharacterMovementComponent::GroundNormalCharacterRelative' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, StairTraceChannel) == 0x000EC8, "Member 'UOFCharacterMovementComponent::StairTraceChannel' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, TagFeatures) == 0x000ED0, "Member 'UOFCharacterMovementComponent::TagFeatures' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, WallMovementTraceLength) == 0x000F38, "Member 'UOFCharacterMovementComponent::WallMovementTraceLength' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, WallSweepCapsuleRadiusMultiplier) == 0x000F3C, "Member 'UOFCharacterMovementComponent::WallSweepCapsuleRadiusMultiplier' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, WallSpeedStopAngle) == 0x000F40, "Member 'UOFCharacterMovementComponent::WallSpeedStopAngle' has a wrong offset!");
static_assert(offsetof(UOFCharacterMovementComponent, EnableMovementCommandQueue) == 0x000F58, "Member 'UOFCharacterMovementComponent::EnableMovementCommandQueue' has a wrong offset!");

// Class ObsidianFox.OFCharacterNoiseEmitter
// 0x0000 (0x00B8 - 0x00B8)
class UOFCharacterNoiseEmitter : public UActorComponent
{
public:
	void FootstepNoise(const struct FVector& StepLocation);
	void FootstepNoise_Internal(const struct FVector& StepLocation, EFootType FootStepType, const class FName& BoneName);

	bool FootstepsCanMakeNoise() const;
	float GetFootstepLoudness() const;
	float GetFootstepNoiseMaxRange() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFCharacterNoiseEmitter">();
	}
	static class UOFCharacterNoiseEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFCharacterNoiseEmitter>();
	}
};
static_assert(alignof(UOFCharacterNoiseEmitter) == 0x000008, "Wrong alignment on UOFCharacterNoiseEmitter");
static_assert(sizeof(UOFCharacterNoiseEmitter) == 0x0000B8, "Wrong size on UOFCharacterNoiseEmitter");

// Class ObsidianFox.OFCheatManager
// 0x0008 (0x0090 - 0x0088)
class UOFCheatManager final : public UCheatManager
{
public:
	bool                                          PlayerImmortal;                                    // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MonsterGod;                                        // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayerSpirit;                                      // 0x008A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MonsterHealthbar;                                  // 0x008B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UnlockAllDoors;                                    // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MonsterAIDebugText;                                // 0x008D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAllPuzzleItems();
	void BuildVersion();
	void CheatDebugCrosshair();
	void CheatHelp();
	void CheatImmortal(int32 Enable);
	void CheatKillAllEnemies();
	void CheatMonsterAIDebugText(int32 Enable);
	void CheatMonsterHealthbar(int32 Enable);
	void CheatScreenshot();
	void CheatSpirit(int32 Enable);
	void CheatUnlockAllDoors();
	void CheatUnlockAllDoorsNativeEvent();
	void ClearSavedFmodParameters();
	void CompleteAchievement(const class FString& AchievementId);
	void DbgCamera();
	void EnvironmentDebugMessages();
	void FmodSetControllerOutputBusPortIndex(int32 Index_0);
	void ForceSpawnDynamicActors();
	void GetAllItemsFromChapter(int32 Chapter, bool bShowPopup);
	void HackTeleport(const class FString& InKey);
	void LoadFromSlot(int32 SlotIndex);
	void OFTeleportTo(const class FString& InDest);
	void OnCheatDebugCrosshair();
	void OnCheatHelp();
	void OnPostInitStartSpotHandler();
	void OverrideVODelayTime(const float InDelay);
	void OverrideVOIndex(const int32 InIndex);
	void PrintCollisionResponseForPlayer();
	void PrintMainState();
	void PrintSavedFmodParameters();
	void QueryDLCStatus();
	void QuickLoad();
	void QuickSave();
	void RefreshPersistenceComponents();
	void ResetAchievements();
	void SaveToSlot(int32 SlotIndex);
	void SetCamDefaultTargetArmLength(float Length);
	void SetCamRelativeOffset(const struct FVector& Vector);
	void SetCamRelativeOffsetX(float Value);
	void SetCamRelativeOffsetY(float Value);
	void SetCamRelativeOffsetZ(float Value);
	void SetCamSocketOffset(const struct FVector& Value);
	void SetCamSocketOffsetX(float Value);
	void SetCamSocketOffsetY(float Value);
	void SetCamSocketOffsetZ(float Value);
	void SetCharacter1982Effect(bool InEnable1982CharacterEffect, bool InHDR);
	void SetCollisionResponseToAllChannelsForPlayer(const class FString& InName, const int32 InCollisionChannel, const int32 InCollisionResponse);
	void SetExtraFilter(EPostEffectExtra InExtraEffect, bool InHDR);
	void SetFactValue(const class FString& InFactTagStr, int32 InValue);
	void SetLightbarEffect(bool bEnabled, uint8 R, uint8 G, uint8 B, uint8 A);
	void SetNewGamePlus(bool Enabled);
	void SetPlayerDebugLightCastShadows(const bool InCastShadows);
	void SetPlayerDebugLightIntensity(const float InIntensity);
	void SetPlayerDebugLightSourceRadius(const float InSourceRadius);
	void SetTriggerFeedbackEffect(bool bRightTrigger, uint8 Position, uint8 Strength);
	void SetTriggerVibrationEffect(bool bRightTrigger, uint8 Position, uint8 Frequency, uint8 Amplitude);
	void SetTriggerWeaponEffect(bool bRightTrigger, uint8 StartPosition, uint8 EndPosition, uint8 Strength);
	void SimulateDLCOwnership(bool DLCOwned);
	void SwitchPlayerCharacter(EPlayerCharacterType InCharacterType);
	void TeleportToSequence(const class FString& SubStr);
	void ToggleAchievementDebugInfo();
	void TryToStartSequence(const class FString& SubStr);
	void TryToStartSequenceAfterTeleport();

	void DumpFacts(bool bAllowOverwriting, bool bExportForUnreal, const class FString& Filename) const;
	void ObsessionLock(bool bLock) const;
	void ObsessionOverride(float Obsession) const;
	void ObsessionPrint() const;
	void VerboseFacts(const bool bVerboseFactsEnabled) const;
	void VerboseFactsDuration(const int32 Duration) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFCheatManager">();
	}
	static class UOFCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFCheatManager>();
	}
};
static_assert(alignof(UOFCheatManager) == 0x000008, "Wrong alignment on UOFCheatManager");
static_assert(sizeof(UOFCheatManager) == 0x000090, "Wrong size on UOFCheatManager");
static_assert(offsetof(UOFCheatManager, PlayerImmortal) == 0x000088, "Member 'UOFCheatManager::PlayerImmortal' has a wrong offset!");
static_assert(offsetof(UOFCheatManager, MonsterGod) == 0x000089, "Member 'UOFCheatManager::MonsterGod' has a wrong offset!");
static_assert(offsetof(UOFCheatManager, PlayerSpirit) == 0x00008A, "Member 'UOFCheatManager::PlayerSpirit' has a wrong offset!");
static_assert(offsetof(UOFCheatManager, MonsterHealthbar) == 0x00008B, "Member 'UOFCheatManager::MonsterHealthbar' has a wrong offset!");
static_assert(offsetof(UOFCheatManager, UnlockAllDoors) == 0x00008C, "Member 'UOFCheatManager::UnlockAllDoors' has a wrong offset!");
static_assert(offsetof(UOFCheatManager, MonsterAIDebugText) == 0x00008D, "Member 'UOFCheatManager::MonsterAIDebugText' has a wrong offset!");

// Class ObsidianFox.OFCheatTeleportObject
// 0x0008 (0x0268 - 0x0260)
class AOFCheatTeleportObject final : public ANavigationObjectBase
{
public:
	class FName                                   LevelName;                                         // 0x0260(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFCheatTeleportObject">();
	}
	static class AOFCheatTeleportObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOFCheatTeleportObject>();
	}
};
static_assert(alignof(AOFCheatTeleportObject) == 0x000008, "Wrong alignment on AOFCheatTeleportObject");
static_assert(sizeof(AOFCheatTeleportObject) == 0x000268, "Wrong size on AOFCheatTeleportObject");
static_assert(offsetof(AOFCheatTeleportObject, LevelName) == 0x000260, "Member 'AOFCheatTeleportObject::LevelName' has a wrong offset!");

// Class ObsidianFox.OFCheckBoxUserWidget
// 0x0008 (0x03D0 - 0x03C8)
class UOFCheckBoxUserWidget : public UOFButtonUserWidget
{
public:
	class UCheckBox*                              CheckBox;                                          // 0x03C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnCheckBoxPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFCheckBoxUserWidget">();
	}
	static class UOFCheckBoxUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFCheckBoxUserWidget>();
	}
};
static_assert(alignof(UOFCheckBoxUserWidget) == 0x000008, "Wrong alignment on UOFCheckBoxUserWidget");
static_assert(sizeof(UOFCheckBoxUserWidget) == 0x0003D0, "Wrong size on UOFCheckBoxUserWidget");
static_assert(offsetof(UOFCheckBoxUserWidget, CheckBox) == 0x0003C8, "Member 'UOFCheckBoxUserWidget::CheckBox' has a wrong offset!");

// Class ObsidianFox.OFCheckpoint
// 0x0028 (0x0340 - 0x0318)
class AOFCheckpoint : public AEventTrigger
{
public:
	class UBillboardComponent*                    PlayerSpawnComponent;                              // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CheckpointTag;                                     // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      PlacementIndicatorCapsuleComponent;                // 0x0328(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerSpawned;                                   // 0x0330(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFCheckpoint">();
	}
	static class AOFCheckpoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOFCheckpoint>();
	}
};
static_assert(alignof(AOFCheckpoint) == 0x000008, "Wrong alignment on AOFCheckpoint");
static_assert(sizeof(AOFCheckpoint) == 0x000340, "Wrong size on AOFCheckpoint");
static_assert(offsetof(AOFCheckpoint, PlayerSpawnComponent) == 0x000318, "Member 'AOFCheckpoint::PlayerSpawnComponent' has a wrong offset!");
static_assert(offsetof(AOFCheckpoint, CheckpointTag) == 0x000320, "Member 'AOFCheckpoint::CheckpointTag' has a wrong offset!");
static_assert(offsetof(AOFCheckpoint, PlacementIndicatorCapsuleComponent) == 0x000328, "Member 'AOFCheckpoint::PlacementIndicatorCapsuleComponent' has a wrong offset!");
static_assert(offsetof(AOFCheckpoint, OnPlayerSpawned) == 0x000330, "Member 'AOFCheckpoint::OnPlayerSpawned' has a wrong offset!");

// Class ObsidianFox.OFChildActorComponent
// 0x0000 (0x0240 - 0x0240)
class UOFChildActorComponent final : public UChildActorComponent
{
public:
	void ActivateChild();
	void DeactivateChild();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFChildActorComponent">();
	}
	static class UOFChildActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFChildActorComponent>();
	}
};
static_assert(alignof(UOFChildActorComponent) == 0x000010, "Wrong alignment on UOFChildActorComponent");
static_assert(sizeof(UOFChildActorComponent) == 0x000240, "Wrong size on UOFChildActorComponent");

// Class ObsidianFox.OFConfirmationPopupWidget
// 0x00B0 (0x0350 - 0x02A0)
class UOFConfirmationPopupWidget : public UWidgetInputHandlingBase
{
public:
	FMulticastInlineDelegateProperty_             OnConfirmationDone;                                // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x02B0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   Description;                                       // 0x02C8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              ConfirmationPopupAcceptSound;                      // 0x02E0(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UFMODEvent>              ConfirmationPopupCancelSound;                      // 0x0308(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x20];                                     // 0x0330(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFConfirmationPopupWidget">();
	}
	static class UOFConfirmationPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFConfirmationPopupWidget>();
	}
};
static_assert(alignof(UOFConfirmationPopupWidget) == 0x000008, "Wrong alignment on UOFConfirmationPopupWidget");
static_assert(sizeof(UOFConfirmationPopupWidget) == 0x000350, "Wrong size on UOFConfirmationPopupWidget");
static_assert(offsetof(UOFConfirmationPopupWidget, OnConfirmationDone) == 0x0002A0, "Member 'UOFConfirmationPopupWidget::OnConfirmationDone' has a wrong offset!");
static_assert(offsetof(UOFConfirmationPopupWidget, Title) == 0x0002B0, "Member 'UOFConfirmationPopupWidget::Title' has a wrong offset!");
static_assert(offsetof(UOFConfirmationPopupWidget, Description) == 0x0002C8, "Member 'UOFConfirmationPopupWidget::Description' has a wrong offset!");
static_assert(offsetof(UOFConfirmationPopupWidget, ConfirmationPopupAcceptSound) == 0x0002E0, "Member 'UOFConfirmationPopupWidget::ConfirmationPopupAcceptSound' has a wrong offset!");
static_assert(offsetof(UOFConfirmationPopupWidget, ConfirmationPopupCancelSound) == 0x000308, "Member 'UOFConfirmationPopupWidget::ConfirmationPopupCancelSound' has a wrong offset!");

// Class ObsidianFox.OFChunkInstallPopupWidget
// 0x0008 (0x0358 - 0x0350)
class UOFChunkInstallPopupWidget : public UOFConfirmationPopupWidget
{
public:
	float                                         PercentOfChunk;                                    // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_354[0x4];                                      // 0x0354(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetChunkIndex(const int32 NewChunkIndex);
	void SetMessage(const class FText& _strText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFChunkInstallPopupWidget">();
	}
	static class UOFChunkInstallPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFChunkInstallPopupWidget>();
	}
};
static_assert(alignof(UOFChunkInstallPopupWidget) == 0x000008, "Wrong alignment on UOFChunkInstallPopupWidget");
static_assert(sizeof(UOFChunkInstallPopupWidget) == 0x000358, "Wrong size on UOFChunkInstallPopupWidget");
static_assert(offsetof(UOFChunkInstallPopupWidget, PercentOfChunk) == 0x000350, "Member 'UOFChunkInstallPopupWidget::PercentOfChunk' has a wrong offset!");

// Class ObsidianFox.WorldSubsystem_FocusPointManager
// 0x20C0 (0x20F0 - 0x0030)
class UWorldSubsystem_FocusPointManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0xA0];                                      // 0x0030(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFocusPointSearchHandleWithData*> AsyncSearchPointActiveHandles;                     // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UFocusPointSearchHandleWithData*        AsyncSearchPointAvailableHandles[0x400];           // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20E0[0x10];                                    // 0x20E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldSubsystem_FocusPointManager">();
	}
	static class UWorldSubsystem_FocusPointManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldSubsystem_FocusPointManager>();
	}
};
static_assert(alignof(UWorldSubsystem_FocusPointManager) == 0x000008, "Wrong alignment on UWorldSubsystem_FocusPointManager");
static_assert(sizeof(UWorldSubsystem_FocusPointManager) == 0x0020F0, "Wrong size on UWorldSubsystem_FocusPointManager");
static_assert(offsetof(UWorldSubsystem_FocusPointManager, AsyncSearchPointActiveHandles) == 0x0000D0, "Member 'UWorldSubsystem_FocusPointManager::AsyncSearchPointActiveHandles' has a wrong offset!");
static_assert(offsetof(UWorldSubsystem_FocusPointManager, AsyncSearchPointAvailableHandles) == 0x0000E0, "Member 'UWorldSubsystem_FocusPointManager::AsyncSearchPointAvailableHandles' has a wrong offset!");

// Class ObsidianFox.OFChunkSubSystem
// 0x0000 (0x0030 - 0x0030)
class UOFChunkSubSystem final : public UWorldSubsystem
{
public:
	float GetProgressForChunk(uint32 CheckChunkIndex) const;
	bool IsChunkForIndexLoaded(uint32 CheckChunkIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFChunkSubSystem">();
	}
	static class UOFChunkSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFChunkSubSystem>();
	}
};
static_assert(alignof(UOFChunkSubSystem) == 0x000008, "Wrong alignment on UOFChunkSubSystem");
static_assert(sizeof(UOFChunkSubSystem) == 0x000030, "Wrong size on UOFChunkSubSystem");

// Class ObsidianFox.OFCreditsTextPanelWidget
// 0x0010 (0x0270 - 0x0260)
class UOFCreditsTextPanelWidget final : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnCreditsTextPanelDone;                            // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Action_OnCreditsTextPanelDone__DelegateSignature(class UOFCreditsTextPanelWidget* Panel);
	void ScrollFinished();
	void SetFont(const struct FSlateFontInfo& FontInfo);
	void SetText(const class FText& Text);
	void TriggerScrollAnimation(float PlaybackSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFCreditsTextPanelWidget">();
	}
	static class UOFCreditsTextPanelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFCreditsTextPanelWidget>();
	}
};
static_assert(alignof(UOFCreditsTextPanelWidget) == 0x000008, "Wrong alignment on UOFCreditsTextPanelWidget");
static_assert(sizeof(UOFCreditsTextPanelWidget) == 0x000270, "Wrong size on UOFCreditsTextPanelWidget");
static_assert(offsetof(UOFCreditsTextPanelWidget, OnCreditsTextPanelDone) == 0x000260, "Member 'UOFCreditsTextPanelWidget::OnCreditsTextPanelDone' has a wrong offset!");

// Class ObsidianFox.OFCreditsWidget
// 0x0168 (0x0408 - 0x02A0)
class UOFCreditsWidget final : public UWidgetInputHandlingBase
{
public:
	float                                         CreditInterval;                                    // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CreditScrollSpeedMofifier;                         // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         H1FontInfo;                                        // 0x02A8(0x0058)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         H1IntervalAddition;                                // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         H2FontInfo;                                        // 0x0308(0x0058)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         H2IntervalAddition;                                // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         H3FontInfo;                                        // 0x0368(0x0058)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         H3IntervalAddition;                                // 0x03C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CreditsPath;                                       // 0x03C8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D8[0x20];                                     // 0x03D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UOFCreditsTextPanelWidget*>      TextPanelCacheArray;                               // 0x03F8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	class UOFCreditsTextPanelWidget* CreateTextPanel();
	void HandleTextPanelDone(class UOFCreditsTextPanelWidget* Panel);
	void OnLastTextSpawned();
	void OnRollCredits();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFCreditsWidget">();
	}
	static class UOFCreditsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFCreditsWidget>();
	}
};
static_assert(alignof(UOFCreditsWidget) == 0x000008, "Wrong alignment on UOFCreditsWidget");
static_assert(sizeof(UOFCreditsWidget) == 0x000408, "Wrong size on UOFCreditsWidget");
static_assert(offsetof(UOFCreditsWidget, CreditInterval) == 0x0002A0, "Member 'UOFCreditsWidget::CreditInterval' has a wrong offset!");
static_assert(offsetof(UOFCreditsWidget, CreditScrollSpeedMofifier) == 0x0002A4, "Member 'UOFCreditsWidget::CreditScrollSpeedMofifier' has a wrong offset!");
static_assert(offsetof(UOFCreditsWidget, H1FontInfo) == 0x0002A8, "Member 'UOFCreditsWidget::H1FontInfo' has a wrong offset!");
static_assert(offsetof(UOFCreditsWidget, H1IntervalAddition) == 0x000300, "Member 'UOFCreditsWidget::H1IntervalAddition' has a wrong offset!");
static_assert(offsetof(UOFCreditsWidget, H2FontInfo) == 0x000308, "Member 'UOFCreditsWidget::H2FontInfo' has a wrong offset!");
static_assert(offsetof(UOFCreditsWidget, H2IntervalAddition) == 0x000360, "Member 'UOFCreditsWidget::H2IntervalAddition' has a wrong offset!");
static_assert(offsetof(UOFCreditsWidget, H3FontInfo) == 0x000368, "Member 'UOFCreditsWidget::H3FontInfo' has a wrong offset!");
static_assert(offsetof(UOFCreditsWidget, H3IntervalAddition) == 0x0003C0, "Member 'UOFCreditsWidget::H3IntervalAddition' has a wrong offset!");
static_assert(offsetof(UOFCreditsWidget, CreditsPath) == 0x0003C8, "Member 'UOFCreditsWidget::CreditsPath' has a wrong offset!");
static_assert(offsetof(UOFCreditsWidget, TextPanelCacheArray) == 0x0003F8, "Member 'UOFCreditsWidget::TextPanelCacheArray' has a wrong offset!");

// Class ObsidianFox.BFL_OFCustomMovementMode
// 0x0000 (0x0028 - 0x0028)
class UBFL_OFCustomMovementMode final : public UBlueprintFunctionLibrary
{
public:
	static uint8 GetOFCustomMovementMode(const EOFCustomMovementMode InCustomMovementMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFL_OFCustomMovementMode">();
	}
	static class UBFL_OFCustomMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFL_OFCustomMovementMode>();
	}
};
static_assert(alignof(UBFL_OFCustomMovementMode) == 0x000008, "Wrong alignment on UBFL_OFCustomMovementMode");
static_assert(sizeof(UBFL_OFCustomMovementMode) == 0x000028, "Wrong size on UBFL_OFCustomMovementMode");

// Class ObsidianFox.OFDamageExecution_Nonlethal
// 0x0000 (0x0040 - 0x0040)
class UOFDamageExecution_Nonlethal final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFDamageExecution_Nonlethal">();
	}
	static class UOFDamageExecution_Nonlethal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFDamageExecution_Nonlethal>();
	}
};
static_assert(alignof(UOFDamageExecution_Nonlethal) == 0x000008, "Wrong alignment on UOFDamageExecution_Nonlethal");
static_assert(sizeof(UOFDamageExecution_Nonlethal) == 0x000040, "Wrong size on UOFDamageExecution_Nonlethal");

// Class ObsidianFox.OFDeveloperSettings
// 0x0848 (0x0880 - 0x0038)
class UOFDeveloperSettings final : public UDeveloperSettings
{
public:
	float                                         ObsessionDecayMultiplier;                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObsessionDecayMin;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObsessionStage2Threshold;                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObsessionStage3Threshold;                          // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialParameterCollection> DarkManMaterialParamCollection;                    // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNiagaraParameterCollection> DarkManNiagaraParamCollection;                     // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ObsessionParamName;                                // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DarkManLocationParamName;                          // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DarkManAreaEffectsOpacityParamName;                // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   DarkManAreaEffectEaseFadeFunc;                     // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ObsessionCameraModifier;                           // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ObsessionDeathReactionTag;                         // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCharacterType                          StartingPlayerCharacter;                           // 0x00E8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   GraceCharacterClass;                               // 0x00F0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EdwardCharacterClass;                              // 0x0118(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EmilyCharacterClass;                               // 0x0140(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPlayerCharacterType, class FText>       CharacterNamesByType;                              // 0x0168(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InteractionTag;                                    // 0x01B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DeathStatusTag;                                    // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DeathReactionTagPlayer;                            // 0x01C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DeathReactionTagEnemy;                             // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESceneCaptureSource                           CameraCaptureSource;                               // 0x01D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class FText>                      RenderSettings;                                    // 0x01E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInvestigationFolderDataAsset> InvestigationFolderDataAsset;                      // 0x0230(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvestigationMaxColumn;                            // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvestigationMaxRow;                               // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           KeyAndPuzzleTag;                                   // 0x0260(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CollectibleTag;                                    // 0x0268(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DercetoLocationTag;                                // 0x0270(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimedObjectivesMinimumWaitTime;                    // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27C[0x4];                                      // 0x027C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  LocationsToTrackTimedObjectives;                   // 0x0280(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           PlayerCharacterContextualTraverseAnimInstances;    // 0x02A0(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UPoseMatchingCacheAsset> PlayerCharacterContextualTraversePoseMatchingCache; // 0x02B0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayerCharacterContextualTraversePropertyName;     // 0x02D8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UChapterSelectDataAsset>> ChapterSelectDataAssets;                           // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, int32>              TalismanCombinations;                              // 0x02F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	float                                         ActualSensMaxValue;                                // 0x0340(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActualSensMinValue;                                // 0x0344(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayValueSensMaxValue;                          // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayValueSensMinValue;                          // 0x034C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayValueSensIncrementValue;                    // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOVMin;                                      // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFOVMax;                                      // 0x0358(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35C[0x4];                                      // 0x035C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, TSoftObjectPtr<class UObject>> FontMapWithCulture;                                // 0x0360(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         MinimumAnalogInputThreshold;                       // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EDifficulty, class FText>                LocalizedDifficultyNames;                          // 0x03B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EPlayerGuidanceLevel, class FText>       LocalizedPlayerGuidanceNames;                      // 0x0408(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UCollectiblesDataAsset>> Collectibles;                                      // 0x0458(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UKeyBindingTextureDataAsset> KeyBindingTextureDataAsset;                        // 0x0468(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         SubtitleFontSlateInfo;                             // 0x0490(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PlatformSpecificKeyWidget;                         // 0x04E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            MovementMenuInputAction;                           // 0x0510(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            InteractMenuInputAction;                           // 0x0538(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            AcceptMenuInputAction;                             // 0x0560(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            ResetMenuInputAction;                              // 0x0588(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            BackMenuInputAction;                               // 0x05B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            ShoulderButtonMenuInputAction;                     // 0x05D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            InGameMenuInputAction;                             // 0x0600(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputAction>            PauseMenuInputAction;                              // 0x0628(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPlayerCharacterType, TSoftObjectPtr<class UTexture2D>> CharacterUIIconsByType;                            // 0x0650(0x0050)(Edit, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         ConfirmationPopupZOrder;                           // 0x06A0(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrightnessMaxValue;                                // 0x06A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrightnessMinValue;                                // 0x06A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrightnessDisplayMaxValue;                         // 0x06AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BrightnessDisplayMinValue;                         // 0x06B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContrastMaxValue;                                  // 0x06B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContrastMinValue;                                  // 0x06B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContrastDisplayMaxValue;                           // 0x06BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContrastDisplayMinValue;                           // 0x06C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayValueHDRIncrementValue;                     // 0x06C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShadowEV100;                                       // 0x06C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MidtoneEV100;                                      // 0x06CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighlightEV100;                                    // 0x06D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D4[0x4];                                      // 0x06D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UFMODEvent>              ItemDataFMODEvent;                                 // 0x06D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PreventDecalSpawningComponentTag;                  // 0x0700(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ProgressionLoadingScreen;                          // 0x0708(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableRemovalOfItemPickupsDueToProgression;       // 0x0730(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_731[0x7];                                      // 0x0731(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   ChunkInstallPopupWidget;                           // 0x0738(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InitialChunkProgressionTags;                       // 0x0760(0x0020)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         HUDMainStateChangedTimerLength;                    // 0x0780(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_784[0x4];                                      // 0x0784(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EGameMainState>                        HUDMainStatesToUseTimer;                           // 0x0788(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSet<TSoftObjectPtr<class UWorld>>            LevelsToIgnoreWhenPreStreaming;                    // 0x0798(0x0050)(Edit, Config, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<ESubtitleSizes, int32>                   SubtitleFontSizes;                                 // 0x07E8(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         FocusPointManagerAsyncTickRate;                    // 0x0838(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumAsyncTracesInFlight;                            // 0x083C(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           KeysNotPossiblyToRebindTo;                         // 0x0840(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FOFInGameHUDClass>              GraceHUDWidgetClasses;                             // 0x0850(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FOFInGameHUDClass>              EdwardHUDWidgetClasses;                            // 0x0860(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FOFInGameHUDClass>              EmilyHUDWidgetClasses;                             // 0x0870(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFDeveloperSettings">();
	}
	static class UOFDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFDeveloperSettings>();
	}
};
static_assert(alignof(UOFDeveloperSettings) == 0x000008, "Wrong alignment on UOFDeveloperSettings");
static_assert(sizeof(UOFDeveloperSettings) == 0x000880, "Wrong size on UOFDeveloperSettings");
static_assert(offsetof(UOFDeveloperSettings, ObsessionDecayMultiplier) == 0x000038, "Member 'UOFDeveloperSettings::ObsessionDecayMultiplier' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ObsessionDecayMin) == 0x00003C, "Member 'UOFDeveloperSettings::ObsessionDecayMin' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ObsessionStage2Threshold) == 0x000040, "Member 'UOFDeveloperSettings::ObsessionStage2Threshold' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ObsessionStage3Threshold) == 0x000044, "Member 'UOFDeveloperSettings::ObsessionStage3Threshold' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, DarkManMaterialParamCollection) == 0x000048, "Member 'UOFDeveloperSettings::DarkManMaterialParamCollection' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, DarkManNiagaraParamCollection) == 0x000070, "Member 'UOFDeveloperSettings::DarkManNiagaraParamCollection' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ObsessionParamName) == 0x000098, "Member 'UOFDeveloperSettings::ObsessionParamName' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, DarkManLocationParamName) == 0x0000A0, "Member 'UOFDeveloperSettings::DarkManLocationParamName' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, DarkManAreaEffectsOpacityParamName) == 0x0000A8, "Member 'UOFDeveloperSettings::DarkManAreaEffectsOpacityParamName' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, DarkManAreaEffectEaseFadeFunc) == 0x0000B0, "Member 'UOFDeveloperSettings::DarkManAreaEffectEaseFadeFunc' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ObsessionCameraModifier) == 0x0000B8, "Member 'UOFDeveloperSettings::ObsessionCameraModifier' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ObsessionDeathReactionTag) == 0x0000E0, "Member 'UOFDeveloperSettings::ObsessionDeathReactionTag' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, StartingPlayerCharacter) == 0x0000E8, "Member 'UOFDeveloperSettings::StartingPlayerCharacter' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, GraceCharacterClass) == 0x0000F0, "Member 'UOFDeveloperSettings::GraceCharacterClass' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, EdwardCharacterClass) == 0x000118, "Member 'UOFDeveloperSettings::EdwardCharacterClass' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, EmilyCharacterClass) == 0x000140, "Member 'UOFDeveloperSettings::EmilyCharacterClass' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, CharacterNamesByType) == 0x000168, "Member 'UOFDeveloperSettings::CharacterNamesByType' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, InteractionTag) == 0x0001B8, "Member 'UOFDeveloperSettings::InteractionTag' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, DeathStatusTag) == 0x0001C0, "Member 'UOFDeveloperSettings::DeathStatusTag' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, DeathReactionTagPlayer) == 0x0001C8, "Member 'UOFDeveloperSettings::DeathReactionTagPlayer' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, DeathReactionTagEnemy) == 0x0001D0, "Member 'UOFDeveloperSettings::DeathReactionTagEnemy' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, CameraCaptureSource) == 0x0001D8, "Member 'UOFDeveloperSettings::CameraCaptureSource' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, RenderSettings) == 0x0001E0, "Member 'UOFDeveloperSettings::RenderSettings' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, InvestigationFolderDataAsset) == 0x000230, "Member 'UOFDeveloperSettings::InvestigationFolderDataAsset' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, InvestigationMaxColumn) == 0x000258, "Member 'UOFDeveloperSettings::InvestigationMaxColumn' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, InvestigationMaxRow) == 0x00025C, "Member 'UOFDeveloperSettings::InvestigationMaxRow' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, KeyAndPuzzleTag) == 0x000260, "Member 'UOFDeveloperSettings::KeyAndPuzzleTag' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, CollectibleTag) == 0x000268, "Member 'UOFDeveloperSettings::CollectibleTag' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, DercetoLocationTag) == 0x000270, "Member 'UOFDeveloperSettings::DercetoLocationTag' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, TimedObjectivesMinimumWaitTime) == 0x000278, "Member 'UOFDeveloperSettings::TimedObjectivesMinimumWaitTime' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, LocationsToTrackTimedObjectives) == 0x000280, "Member 'UOFDeveloperSettings::LocationsToTrackTimedObjectives' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, PlayerCharacterContextualTraverseAnimInstances) == 0x0002A0, "Member 'UOFDeveloperSettings::PlayerCharacterContextualTraverseAnimInstances' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, PlayerCharacterContextualTraversePoseMatchingCache) == 0x0002B0, "Member 'UOFDeveloperSettings::PlayerCharacterContextualTraversePoseMatchingCache' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, PlayerCharacterContextualTraversePropertyName) == 0x0002D8, "Member 'UOFDeveloperSettings::PlayerCharacterContextualTraversePropertyName' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ChapterSelectDataAssets) == 0x0002E0, "Member 'UOFDeveloperSettings::ChapterSelectDataAssets' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, TalismanCombinations) == 0x0002F0, "Member 'UOFDeveloperSettings::TalismanCombinations' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ActualSensMaxValue) == 0x000340, "Member 'UOFDeveloperSettings::ActualSensMaxValue' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ActualSensMinValue) == 0x000344, "Member 'UOFDeveloperSettings::ActualSensMinValue' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, DisplayValueSensMaxValue) == 0x000348, "Member 'UOFDeveloperSettings::DisplayValueSensMaxValue' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, DisplayValueSensMinValue) == 0x00034C, "Member 'UOFDeveloperSettings::DisplayValueSensMinValue' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, DisplayValueSensIncrementValue) == 0x000350, "Member 'UOFDeveloperSettings::DisplayValueSensIncrementValue' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, CameraFOVMin) == 0x000354, "Member 'UOFDeveloperSettings::CameraFOVMin' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, CameraFOVMax) == 0x000358, "Member 'UOFDeveloperSettings::CameraFOVMax' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, FontMapWithCulture) == 0x000360, "Member 'UOFDeveloperSettings::FontMapWithCulture' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, MinimumAnalogInputThreshold) == 0x0003B0, "Member 'UOFDeveloperSettings::MinimumAnalogInputThreshold' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, LocalizedDifficultyNames) == 0x0003B8, "Member 'UOFDeveloperSettings::LocalizedDifficultyNames' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, LocalizedPlayerGuidanceNames) == 0x000408, "Member 'UOFDeveloperSettings::LocalizedPlayerGuidanceNames' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, Collectibles) == 0x000458, "Member 'UOFDeveloperSettings::Collectibles' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, KeyBindingTextureDataAsset) == 0x000468, "Member 'UOFDeveloperSettings::KeyBindingTextureDataAsset' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, SubtitleFontSlateInfo) == 0x000490, "Member 'UOFDeveloperSettings::SubtitleFontSlateInfo' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, PlatformSpecificKeyWidget) == 0x0004E8, "Member 'UOFDeveloperSettings::PlatformSpecificKeyWidget' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, MovementMenuInputAction) == 0x000510, "Member 'UOFDeveloperSettings::MovementMenuInputAction' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, InteractMenuInputAction) == 0x000538, "Member 'UOFDeveloperSettings::InteractMenuInputAction' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, AcceptMenuInputAction) == 0x000560, "Member 'UOFDeveloperSettings::AcceptMenuInputAction' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ResetMenuInputAction) == 0x000588, "Member 'UOFDeveloperSettings::ResetMenuInputAction' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, BackMenuInputAction) == 0x0005B0, "Member 'UOFDeveloperSettings::BackMenuInputAction' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ShoulderButtonMenuInputAction) == 0x0005D8, "Member 'UOFDeveloperSettings::ShoulderButtonMenuInputAction' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, InGameMenuInputAction) == 0x000600, "Member 'UOFDeveloperSettings::InGameMenuInputAction' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, PauseMenuInputAction) == 0x000628, "Member 'UOFDeveloperSettings::PauseMenuInputAction' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, CharacterUIIconsByType) == 0x000650, "Member 'UOFDeveloperSettings::CharacterUIIconsByType' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ConfirmationPopupZOrder) == 0x0006A0, "Member 'UOFDeveloperSettings::ConfirmationPopupZOrder' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, BrightnessMaxValue) == 0x0006A4, "Member 'UOFDeveloperSettings::BrightnessMaxValue' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, BrightnessMinValue) == 0x0006A8, "Member 'UOFDeveloperSettings::BrightnessMinValue' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, BrightnessDisplayMaxValue) == 0x0006AC, "Member 'UOFDeveloperSettings::BrightnessDisplayMaxValue' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, BrightnessDisplayMinValue) == 0x0006B0, "Member 'UOFDeveloperSettings::BrightnessDisplayMinValue' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ContrastMaxValue) == 0x0006B4, "Member 'UOFDeveloperSettings::ContrastMaxValue' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ContrastMinValue) == 0x0006B8, "Member 'UOFDeveloperSettings::ContrastMinValue' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ContrastDisplayMaxValue) == 0x0006BC, "Member 'UOFDeveloperSettings::ContrastDisplayMaxValue' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ContrastDisplayMinValue) == 0x0006C0, "Member 'UOFDeveloperSettings::ContrastDisplayMinValue' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, DisplayValueHDRIncrementValue) == 0x0006C4, "Member 'UOFDeveloperSettings::DisplayValueHDRIncrementValue' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ShadowEV100) == 0x0006C8, "Member 'UOFDeveloperSettings::ShadowEV100' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, MidtoneEV100) == 0x0006CC, "Member 'UOFDeveloperSettings::MidtoneEV100' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, HighlightEV100) == 0x0006D0, "Member 'UOFDeveloperSettings::HighlightEV100' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ItemDataFMODEvent) == 0x0006D8, "Member 'UOFDeveloperSettings::ItemDataFMODEvent' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, PreventDecalSpawningComponentTag) == 0x000700, "Member 'UOFDeveloperSettings::PreventDecalSpawningComponentTag' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ProgressionLoadingScreen) == 0x000708, "Member 'UOFDeveloperSettings::ProgressionLoadingScreen' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, DisableRemovalOfItemPickupsDueToProgression) == 0x000730, "Member 'UOFDeveloperSettings::DisableRemovalOfItemPickupsDueToProgression' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, ChunkInstallPopupWidget) == 0x000738, "Member 'UOFDeveloperSettings::ChunkInstallPopupWidget' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, InitialChunkProgressionTags) == 0x000760, "Member 'UOFDeveloperSettings::InitialChunkProgressionTags' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, HUDMainStateChangedTimerLength) == 0x000780, "Member 'UOFDeveloperSettings::HUDMainStateChangedTimerLength' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, HUDMainStatesToUseTimer) == 0x000788, "Member 'UOFDeveloperSettings::HUDMainStatesToUseTimer' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, LevelsToIgnoreWhenPreStreaming) == 0x000798, "Member 'UOFDeveloperSettings::LevelsToIgnoreWhenPreStreaming' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, SubtitleFontSizes) == 0x0007E8, "Member 'UOFDeveloperSettings::SubtitleFontSizes' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, FocusPointManagerAsyncTickRate) == 0x000838, "Member 'UOFDeveloperSettings::FocusPointManagerAsyncTickRate' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, NumAsyncTracesInFlight) == 0x00083C, "Member 'UOFDeveloperSettings::NumAsyncTracesInFlight' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, KeysNotPossiblyToRebindTo) == 0x000840, "Member 'UOFDeveloperSettings::KeysNotPossiblyToRebindTo' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, GraceHUDWidgetClasses) == 0x000850, "Member 'UOFDeveloperSettings::GraceHUDWidgetClasses' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, EdwardHUDWidgetClasses) == 0x000860, "Member 'UOFDeveloperSettings::EdwardHUDWidgetClasses' has a wrong offset!");
static_assert(offsetof(UOFDeveloperSettings, EmilyHUDWidgetClasses) == 0x000870, "Member 'UOFDeveloperSettings::EmilyHUDWidgetClasses' has a wrong offset!");

// Class ObsidianFox.OFEnemyAIController
// 0x0028 (0x0368 - 0x0340)
class AOFEnemyAIController : public AAIController
{
public:
	class UBehaviorTree*                          BehaviourTreeAsset;                                // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOFEnemyCharacter*                      EnemyCharacterOwner;                               // 0x0348(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         BitPad_350_0 : 1;                                  // 0x0350(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bEnableRotationLock : 1;                           // 0x0350(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFocalPointOutsideRotationLockAngle : 1;           // 0x0350(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_351[0x3];                                      // 0x0351(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocalPointAngle;                                   // 0x0354(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationLockAngleThreshold;                        // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bRotationLockManualDisable : 1;                    // 0x035C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_35D[0x3];                                      // 0x035D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationLockMoveSpeedTolerance;                    // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayStateChanged(EGameMainState OldGameState, EGameMainState NewGameState);
	void OnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus);
	void SetAggro(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFEnemyAIController">();
	}
	static class AOFEnemyAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOFEnemyAIController>();
	}
};
static_assert(alignof(AOFEnemyAIController) == 0x000008, "Wrong alignment on AOFEnemyAIController");
static_assert(sizeof(AOFEnemyAIController) == 0x000368, "Wrong size on AOFEnemyAIController");
static_assert(offsetof(AOFEnemyAIController, BehaviourTreeAsset) == 0x000340, "Member 'AOFEnemyAIController::BehaviourTreeAsset' has a wrong offset!");
static_assert(offsetof(AOFEnemyAIController, EnemyCharacterOwner) == 0x000348, "Member 'AOFEnemyAIController::EnemyCharacterOwner' has a wrong offset!");
static_assert(offsetof(AOFEnemyAIController, FocalPointAngle) == 0x000354, "Member 'AOFEnemyAIController::FocalPointAngle' has a wrong offset!");
static_assert(offsetof(AOFEnemyAIController, RotationLockAngleThreshold) == 0x000358, "Member 'AOFEnemyAIController::RotationLockAngleThreshold' has a wrong offset!");
static_assert(offsetof(AOFEnemyAIController, RotationLockMoveSpeedTolerance) == 0x000360, "Member 'AOFEnemyAIController::RotationLockMoveSpeedTolerance' has a wrong offset!");

// Class ObsidianFox.OFEnemyCharacter
// 0x0140 (0x0890 - 0x0750)
class AOFEnemyCharacter : public AObsidianFoxCharacter
{
public:
	uint8                                         StartWithTarget : 1;                               // 0x0748(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         StartActiveBehaviour : 1;                          // 0x0748(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         IdleWanderAround : 1;                              // 0x0748(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_749[0x3];                                      // 0x0749(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HasTargetKey;                                      // 0x074C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HealthKey;                                         // 0x0754(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IdleWanderKey;                                     // 0x075C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DistToTargetKey;                                   // 0x0764(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WithinHomeRangeKey;                                // 0x076C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThreatDetectionKey;                                // 0x0774(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThreatDetectionMaxKey;                             // 0x077C(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeedScale;                                // 0x0784(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAggroChanged;                                    // 0x0788(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bBehaviourTreeActive;                              // 0x0798(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bHasTarget;                                        // 0x0799(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79A[0x6];                                      // 0x079A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDonNavigationComponent*                DonNavigationComponent;                            // 0x07A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckGroundedAtStartupAC*              CheckGroundedAtStartup;                            // 0x07A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AOFEnemyAIController*                   OurAIController;                                   // 0x07B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FCharHitFX                             CharHitFX;                                         // 0x07B8(0x0040)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FCharHitFX                             WeakpointHitFX;                                    // 0x07F8(0x0040)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   ShrapnelDirParamName;                              // 0x0838(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalLifetime;                                     // 0x0840(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DecalSize;                                         // 0x0844(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_848[0x8];                                      // 0x0848(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0850(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_880[0x10];                                     // 0x0880(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AggroChanged__DelegateSignature(bool bEnabled);
	void ForceAggro();
	void PlayCharHitSound(const struct FHitResult& Hit, float Damage, class UFMODEvent* Sound);
	void SetSpawnerActor(class AEnemySpawner* Spawner);
	void SpawnCharHitDecal(const struct FHitResult& Hit, float Damage, class UMaterialInstance* DecalMaterial);
	void SpawnCharHitParticleEffect(const struct FHitResult& Hit, float Damage, const struct FCharHitFX& HitFX);
	void UpdateBlackboardHealth(float NewCurrentHealth, float DeltaValue, const struct FGameplayTagContainer& EventTags);

	float GetDistToTarget() const;
	bool IsInCombat() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFEnemyCharacter">();
	}
	static class AOFEnemyCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOFEnemyCharacter>();
	}
};
static_assert(alignof(AOFEnemyCharacter) == 0x000010, "Wrong alignment on AOFEnemyCharacter");
static_assert(sizeof(AOFEnemyCharacter) == 0x000890, "Wrong size on AOFEnemyCharacter");
static_assert(offsetof(AOFEnemyCharacter, HasTargetKey) == 0x00074C, "Member 'AOFEnemyCharacter::HasTargetKey' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, HealthKey) == 0x000754, "Member 'AOFEnemyCharacter::HealthKey' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, IdleWanderKey) == 0x00075C, "Member 'AOFEnemyCharacter::IdleWanderKey' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, DistToTargetKey) == 0x000764, "Member 'AOFEnemyCharacter::DistToTargetKey' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, WithinHomeRangeKey) == 0x00076C, "Member 'AOFEnemyCharacter::WithinHomeRangeKey' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, ThreatDetectionKey) == 0x000774, "Member 'AOFEnemyCharacter::ThreatDetectionKey' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, ThreatDetectionMaxKey) == 0x00077C, "Member 'AOFEnemyCharacter::ThreatDetectionMaxKey' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, RotationSpeedScale) == 0x000784, "Member 'AOFEnemyCharacter::RotationSpeedScale' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, OnAggroChanged) == 0x000788, "Member 'AOFEnemyCharacter::OnAggroChanged' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, bBehaviourTreeActive) == 0x000798, "Member 'AOFEnemyCharacter::bBehaviourTreeActive' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, bHasTarget) == 0x000799, "Member 'AOFEnemyCharacter::bHasTarget' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, DonNavigationComponent) == 0x0007A0, "Member 'AOFEnemyCharacter::DonNavigationComponent' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, CheckGroundedAtStartup) == 0x0007A8, "Member 'AOFEnemyCharacter::CheckGroundedAtStartup' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, OurAIController) == 0x0007B0, "Member 'AOFEnemyCharacter::OurAIController' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, CharHitFX) == 0x0007B8, "Member 'AOFEnemyCharacter::CharHitFX' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, WeakpointHitFX) == 0x0007F8, "Member 'AOFEnemyCharacter::WeakpointHitFX' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, ShrapnelDirParamName) == 0x000838, "Member 'AOFEnemyCharacter::ShrapnelDirParamName' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, DecalLifetime) == 0x000840, "Member 'AOFEnemyCharacter::DecalLifetime' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, DecalSize) == 0x000844, "Member 'AOFEnemyCharacter::DecalSize' has a wrong offset!");
static_assert(offsetof(AOFEnemyCharacter, SpawnTransform) == 0x000850, "Member 'AOFEnemyCharacter::SpawnTransform' has a wrong offset!");

// Class ObsidianFox.OFFMODAmbientSound
// 0x0010 (0x0248 - 0x0238)
class AOFFMODAmbientSound final : public AActor
{
public:
	class UFMODAudioComponent*                    AudioComponent;                                    // 0x0238(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFocusPointComponent*                   FocusPointComponent;                               // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void PlayFMODEvent();
	void PlayFMODEventWithStartle();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFFMODAmbientSound">();
	}
	static class AOFFMODAmbientSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOFFMODAmbientSound>();
	}
};
static_assert(alignof(AOFFMODAmbientSound) == 0x000008, "Wrong alignment on AOFFMODAmbientSound");
static_assert(sizeof(AOFFMODAmbientSound) == 0x000248, "Wrong size on AOFFMODAmbientSound");
static_assert(offsetof(AOFFMODAmbientSound, AudioComponent) == 0x000238, "Member 'AOFFMODAmbientSound::AudioComponent' has a wrong offset!");
static_assert(offsetof(AOFFMODAmbientSound, FocusPointComponent) == 0x000240, "Member 'AOFFMODAmbientSound::FocusPointComponent' has a wrong offset!");

// Class ObsidianFox.OFGameInstance
// 0x0000 (0x01B8 - 0x01B8)
class UOFGameInstance : public UPiecesGameplaySessionGameInstance
{
public:
	bool CheatsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFGameInstance">();
	}
	static class UOFGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFGameInstance>();
	}
};
static_assert(alignof(UOFGameInstance) == 0x000008, "Wrong alignment on UOFGameInstance");
static_assert(sizeof(UOFGameInstance) == 0x0001B8, "Wrong size on UOFGameInstance");

// Class ObsidianFox.OFGameplayAbilitySet
// 0x0010 (0x0040 - 0x0030)
class UOFGameplayAbilitySet final : public UDataAsset
{
public:
	TArray<struct FOFGameplayAbilityBindInfo>     Abilities;                                         // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFGameplayAbilitySet">();
	}
	static class UOFGameplayAbilitySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFGameplayAbilitySet>();
	}
};
static_assert(alignof(UOFGameplayAbilitySet) == 0x000008, "Wrong alignment on UOFGameplayAbilitySet");
static_assert(sizeof(UOFGameplayAbilitySet) == 0x000040, "Wrong size on UOFGameplayAbilitySet");
static_assert(offsetof(UOFGameplayAbilitySet, Abilities) == 0x000030, "Member 'UOFGameplayAbilitySet::Abilities' has a wrong offset!");

// Class ObsidianFox.OFGameplayCueManager
// 0x0000 (0x0310 - 0x0310)
class UOFGameplayCueManager final : public UGameplayCueManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFGameplayCueManager">();
	}
	static class UOFGameplayCueManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFGameplayCueManager>();
	}
};
static_assert(alignof(UOFGameplayCueManager) == 0x000008, "Wrong alignment on UOFGameplayCueManager");
static_assert(sizeof(UOFGameplayCueManager) == 0x000310, "Wrong size on UOFGameplayCueManager");

// Class ObsidianFox.OFHealthReserveHealingExecution
// 0x0000 (0x0040 - 0x0040)
class UOFHealthReserveHealingExecution final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFHealthReserveHealingExecution">();
	}
	static class UOFHealthReserveHealingExecution* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFHealthReserveHealingExecution>();
	}
};
static_assert(alignof(UOFHealthReserveHealingExecution) == 0x000008, "Wrong alignment on UOFHealthReserveHealingExecution");
static_assert(sizeof(UOFHealthReserveHealingExecution) == 0x000040, "Wrong size on UOFHealthReserveHealingExecution");

// Class ObsidianFox.OFHUD
// 0x0020 (0x0348 - 0x0328)
class AOFHUD : public AHUD
{
public:
	TArray<class UInGameUIWidget*>                HUDWidgets;                                        // 0x0328(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UInGameUIWidget>>    DisplayWidgetClasses;                              // 0x0338(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	class UInGameUIWidget* GetWidgetOfClass(const TSoftClassPtr<class UClass>& WidgetClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFHUD">();
	}
	static class AOFHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOFHUD>();
	}
};
static_assert(alignof(AOFHUD) == 0x000008, "Wrong alignment on AOFHUD");
static_assert(sizeof(AOFHUD) == 0x000348, "Wrong size on AOFHUD");
static_assert(offsetof(AOFHUD, HUDWidgets) == 0x000328, "Member 'AOFHUD::HUDWidgets' has a wrong offset!");
static_assert(offsetof(AOFHUD, DisplayWidgetClasses) == 0x000338, "Member 'AOFHUD::DisplayWidgetClasses' has a wrong offset!");

// Class ObsidianFox.OFLevelScriptActor
// 0x0008 (0x0250 - 0x0248)
class AOFLevelScriptActor : public ALevelScriptActorGunfire
{
public:
	class UPersistenceComponent*                  Persistence;                                       // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFLevelScriptActor">();
	}
	static class AOFLevelScriptActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOFLevelScriptActor>();
	}
};
static_assert(alignof(AOFLevelScriptActor) == 0x000008, "Wrong alignment on AOFLevelScriptActor");
static_assert(sizeof(AOFLevelScriptActor) == 0x000250, "Wrong size on AOFLevelScriptActor");
static_assert(offsetof(AOFLevelScriptActor, Persistence) == 0x000248, "Member 'AOFLevelScriptActor::Persistence' has a wrong offset!");

// Class ObsidianFox.UIButton
// 0x0010 (0x0438 - 0x0428)
class UUIButton final : public UButton
{
public:
	uint8                                         Pad_428[0x10];                                     // 0x0428(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ButtonOnHovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIButton">();
	}
	static class UUIButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIButton>();
	}
};
static_assert(alignof(UUIButton) == 0x000008, "Wrong alignment on UUIButton");
static_assert(sizeof(UUIButton) == 0x000438, "Wrong size on UUIButton");

// Class ObsidianFox.OFLoadGameMenuWidget
// 0x00C8 (0x0368 - 0x02A0)
class UOFLoadGameMenuWidget : public UWidgetInputHandlingBase
{
public:
	TSubclassOf<class USaveSlotWidget>            LoadSaveSlotWidgetClass;                           // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UOFSaveConfirmationPopupWidget> ConfirmationPopupClass;                            // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LevelPicture;                                      // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_CharacterName;                                // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_ChapterDisplayName;                           // 0x02C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text_TotalTimePlayed;                              // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           LoadGameList;                                      // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrlButtonWidget*                      CtrlButtonWidget;                                  // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           AcceptAction;                                      // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           BackAction;                                        // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           DeleteAction;                                      // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   LoadText;                                          // 0x02F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   BackText;                                          // 0x0310(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   DeleteSaveText;                                    // 0x0328(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             ImageSeparator;                                    // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBoxLoadSave;                                 // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOFSaveConfirmationPopupWidget*         ConfirmationPopup;                                 // 0x0350(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_358[0x10];                                     // 0x0358(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnConfirmationDone(bool bIsAccepted);
	void OnDeleteSaveFinished();
	void OnLoadSaveButtonHover(class UWidget* Widget);
	void OnSaveFinished(bool Success);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFLoadGameMenuWidget">();
	}
	static class UOFLoadGameMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFLoadGameMenuWidget>();
	}
};
static_assert(alignof(UOFLoadGameMenuWidget) == 0x000008, "Wrong alignment on UOFLoadGameMenuWidget");
static_assert(sizeof(UOFLoadGameMenuWidget) == 0x000368, "Wrong size on UOFLoadGameMenuWidget");
static_assert(offsetof(UOFLoadGameMenuWidget, LoadSaveSlotWidgetClass) == 0x0002A0, "Member 'UOFLoadGameMenuWidget::LoadSaveSlotWidgetClass' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, ConfirmationPopupClass) == 0x0002A8, "Member 'UOFLoadGameMenuWidget::ConfirmationPopupClass' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, LevelPicture) == 0x0002B0, "Member 'UOFLoadGameMenuWidget::LevelPicture' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, Text_CharacterName) == 0x0002B8, "Member 'UOFLoadGameMenuWidget::Text_CharacterName' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, Text_ChapterDisplayName) == 0x0002C0, "Member 'UOFLoadGameMenuWidget::Text_ChapterDisplayName' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, Text_TotalTimePlayed) == 0x0002C8, "Member 'UOFLoadGameMenuWidget::Text_TotalTimePlayed' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, LoadGameList) == 0x0002D0, "Member 'UOFLoadGameMenuWidget::LoadGameList' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, CtrlButtonWidget) == 0x0002D8, "Member 'UOFLoadGameMenuWidget::CtrlButtonWidget' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, AcceptAction) == 0x0002E0, "Member 'UOFLoadGameMenuWidget::AcceptAction' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, BackAction) == 0x0002E8, "Member 'UOFLoadGameMenuWidget::BackAction' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, DeleteAction) == 0x0002F0, "Member 'UOFLoadGameMenuWidget::DeleteAction' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, LoadText) == 0x0002F8, "Member 'UOFLoadGameMenuWidget::LoadText' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, BackText) == 0x000310, "Member 'UOFLoadGameMenuWidget::BackText' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, DeleteSaveText) == 0x000328, "Member 'UOFLoadGameMenuWidget::DeleteSaveText' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, ImageSeparator) == 0x000340, "Member 'UOFLoadGameMenuWidget::ImageSeparator' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, ScrollBoxLoadSave) == 0x000348, "Member 'UOFLoadGameMenuWidget::ScrollBoxLoadSave' has a wrong offset!");
static_assert(offsetof(UOFLoadGameMenuWidget, ConfirmationPopup) == 0x000350, "Member 'UOFLoadGameMenuWidget::ConfirmationPopup' has a wrong offset!");

// Class ObsidianFox.OFMenuSpinningItemSelector
// 0x0150 (0x03B0 - 0x0260)
class UOFMenuSpinningItemSelector : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             SlotUpdated;                                       // 0x0260(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             SlotPressed;                                       // 0x0270(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngleBegin;                                        // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AngleEnd;                                          // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimationSpeed;                                    // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumSlots;                                          // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinScaleSlot;                                      // 0x0294(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxScaleSlot;                                      // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SlotOffsetSelected;                                // 0x029C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           SlotCanvas;                                        // 0x02A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ImageSelectorBG;                                   // 0x02A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UMenuInventorySelectionSlot*>    Slots;                                             // 0x02B0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UCanvasPanelSlot*>               CanvasSlots;                                       // 0x02C0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UMenuInventorySelectionSlot> SlotClass;                                         // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CurveSlotOpacity;                                  // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            CurveSlotScale;                                    // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            BrushSlotBG;                                       // 0x02E8(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UItemData>>       Items;                                             // 0x0370(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UImage*>                         SlotBGImages;                                      // 0x0380(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x20];                                     // 0x0390(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitDesignTime();
	void MoveSelection(int32 Direction);
	void OnSelectionSlotPressed();
	void Reset();
	void SetItems(const TArray<TSoftObjectPtr<class UItemData>>& SoftItems);
	void UpdateSelectorState(float State);

	class UMenuInventorySelectionSlot* GetActiveMenuSlot() const;
	int32 GetNumItems() const;
	int32 GetSelectedItemIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFMenuSpinningItemSelector">();
	}
	static class UOFMenuSpinningItemSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFMenuSpinningItemSelector>();
	}
};
static_assert(alignof(UOFMenuSpinningItemSelector) == 0x000008, "Wrong alignment on UOFMenuSpinningItemSelector");
static_assert(sizeof(UOFMenuSpinningItemSelector) == 0x0003B0, "Wrong size on UOFMenuSpinningItemSelector");
static_assert(offsetof(UOFMenuSpinningItemSelector, SlotUpdated) == 0x000260, "Member 'UOFMenuSpinningItemSelector::SlotUpdated' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, SlotPressed) == 0x000270, "Member 'UOFMenuSpinningItemSelector::SlotPressed' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, Radius) == 0x000280, "Member 'UOFMenuSpinningItemSelector::Radius' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, AngleBegin) == 0x000284, "Member 'UOFMenuSpinningItemSelector::AngleBegin' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, AngleEnd) == 0x000288, "Member 'UOFMenuSpinningItemSelector::AngleEnd' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, AnimationSpeed) == 0x00028C, "Member 'UOFMenuSpinningItemSelector::AnimationSpeed' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, NumSlots) == 0x000290, "Member 'UOFMenuSpinningItemSelector::NumSlots' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, MinScaleSlot) == 0x000294, "Member 'UOFMenuSpinningItemSelector::MinScaleSlot' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, MaxScaleSlot) == 0x000298, "Member 'UOFMenuSpinningItemSelector::MaxScaleSlot' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, SlotOffsetSelected) == 0x00029C, "Member 'UOFMenuSpinningItemSelector::SlotOffsetSelected' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, SlotCanvas) == 0x0002A0, "Member 'UOFMenuSpinningItemSelector::SlotCanvas' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, ImageSelectorBG) == 0x0002A8, "Member 'UOFMenuSpinningItemSelector::ImageSelectorBG' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, Slots) == 0x0002B0, "Member 'UOFMenuSpinningItemSelector::Slots' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, CanvasSlots) == 0x0002C0, "Member 'UOFMenuSpinningItemSelector::CanvasSlots' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, SlotClass) == 0x0002D0, "Member 'UOFMenuSpinningItemSelector::SlotClass' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, CurveSlotOpacity) == 0x0002D8, "Member 'UOFMenuSpinningItemSelector::CurveSlotOpacity' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, CurveSlotScale) == 0x0002E0, "Member 'UOFMenuSpinningItemSelector::CurveSlotScale' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, BrushSlotBG) == 0x0002E8, "Member 'UOFMenuSpinningItemSelector::BrushSlotBG' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, Items) == 0x000370, "Member 'UOFMenuSpinningItemSelector::Items' has a wrong offset!");
static_assert(offsetof(UOFMenuSpinningItemSelector, SlotBGImages) == 0x000380, "Member 'UOFMenuSpinningItemSelector::SlotBGImages' has a wrong offset!");

// Class ObsidianFox.OFNPCAnimInstance
// 0x0010 (0x11D0 - 0x11C0)
class UOFNPCAnimInstance : public UOFAnimInstance
{
public:
	class UAnimComponentFootIK*                   FootIK;                                            // 0x11C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C8[0x8];                                     // 0x11C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFNPCAnimInstance">();
	}
	static class UOFNPCAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFNPCAnimInstance>();
	}
};
static_assert(alignof(UOFNPCAnimInstance) == 0x000010, "Wrong alignment on UOFNPCAnimInstance");
static_assert(sizeof(UOFNPCAnimInstance) == 0x0011D0, "Wrong size on UOFNPCAnimInstance");
static_assert(offsetof(UOFNPCAnimInstance, FootIK) == 0x0011C0, "Member 'UOFNPCAnimInstance::FootIK' has a wrong offset!");

// Class ObsidianFox.OFOnlineSettings
// 0x0038 (0x0070 - 0x0038)
class UOFOnlineSettings final : public UDeveloperSettings
{
public:
	TSubclassOf<class UOFConfirmationPopupWidget> AutosaveOverwritePopupClass;                       // 0x0038(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AutosaveOverwriteTitle;                            // 0x0040(0x0018)(Edit, Config, NativeAccessSpecifierPublic)
	class FText                                   AutosaveOverwriteMessage;                          // 0x0058(0x0018)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFOnlineSettings">();
	}
	static class UOFOnlineSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFOnlineSettings>();
	}
};
static_assert(alignof(UOFOnlineSettings) == 0x000008, "Wrong alignment on UOFOnlineSettings");
static_assert(sizeof(UOFOnlineSettings) == 0x000070, "Wrong size on UOFOnlineSettings");
static_assert(offsetof(UOFOnlineSettings, AutosaveOverwritePopupClass) == 0x000038, "Member 'UOFOnlineSettings::AutosaveOverwritePopupClass' has a wrong offset!");
static_assert(offsetof(UOFOnlineSettings, AutosaveOverwriteTitle) == 0x000040, "Member 'UOFOnlineSettings::AutosaveOverwriteTitle' has a wrong offset!");
static_assert(offsetof(UOFOnlineSettings, AutosaveOverwriteMessage) == 0x000058, "Member 'UOFOnlineSettings::AutosaveOverwriteMessage' has a wrong offset!");

// Class ObsidianFox.OFPerfSampleLevelGauntletController
// 0x0040 (0x0070 - 0x0030)
class UOFPerfSampleLevelGauntletController final : public UGauntletTestController
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartTesting();
	void StopProfiling();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFPerfSampleLevelGauntletController">();
	}
	static class UOFPerfSampleLevelGauntletController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFPerfSampleLevelGauntletController>();
	}
};
static_assert(alignof(UOFPerfSampleLevelGauntletController) == 0x000008, "Wrong alignment on UOFPerfSampleLevelGauntletController");
static_assert(sizeof(UOFPerfSampleLevelGauntletController) == 0x000070, "Wrong size on UOFPerfSampleLevelGauntletController");

// Class ObsidianFox.ThreatVisualizerComponent
// 0x0088 (0x0140 - 0x00B8)
class UThreatVisualizerComponent : public UActorComponent
{
public:
	struct FGameplayTagContainer                  RequiredPlayerTagsForUpdate;                       // 0x00B8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         HaltVisualizingUpdateMaxTime;                      // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnemyThreatRange;                                  // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class IInterface>                 ThreatInterface;                                   // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ThreatBBKeyName;                                   // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxNumberOfEnemies;                                // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnemyUpdateTime;                                   // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialParameterCollection*           ThreatParameterMaterialCollection;                 // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ThreatParameterName;                               // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PositionParameterName;                             // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EdgePercentage;                                    // 0x0110(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct ObsidianFox::FEnemyThreatData>  ImportantThreatEnemies;                            // 0x0118(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_128[0x18];                                     // 0x0128(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_ConvertWorldToScreenLocation(const class UWorld* WorldContextObject, const struct FVector& WorldLocation, const float& EdgePercent, struct FVector2D* ScreenPosition, float* EdgePositionAlpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThreatVisualizerComponent">();
	}
	static class UThreatVisualizerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThreatVisualizerComponent>();
	}
};
static_assert(alignof(UThreatVisualizerComponent) == 0x000008, "Wrong alignment on UThreatVisualizerComponent");
static_assert(sizeof(UThreatVisualizerComponent) == 0x000140, "Wrong size on UThreatVisualizerComponent");
static_assert(offsetof(UThreatVisualizerComponent, RequiredPlayerTagsForUpdate) == 0x0000B8, "Member 'UThreatVisualizerComponent::RequiredPlayerTagsForUpdate' has a wrong offset!");
static_assert(offsetof(UThreatVisualizerComponent, HaltVisualizingUpdateMaxTime) == 0x0000D8, "Member 'UThreatVisualizerComponent::HaltVisualizingUpdateMaxTime' has a wrong offset!");
static_assert(offsetof(UThreatVisualizerComponent, EnemyThreatRange) == 0x0000DC, "Member 'UThreatVisualizerComponent::EnemyThreatRange' has a wrong offset!");
static_assert(offsetof(UThreatVisualizerComponent, ThreatInterface) == 0x0000E0, "Member 'UThreatVisualizerComponent::ThreatInterface' has a wrong offset!");
static_assert(offsetof(UThreatVisualizerComponent, ThreatBBKeyName) == 0x0000E8, "Member 'UThreatVisualizerComponent::ThreatBBKeyName' has a wrong offset!");
static_assert(offsetof(UThreatVisualizerComponent, MaxNumberOfEnemies) == 0x0000F0, "Member 'UThreatVisualizerComponent::MaxNumberOfEnemies' has a wrong offset!");
static_assert(offsetof(UThreatVisualizerComponent, EnemyUpdateTime) == 0x0000F4, "Member 'UThreatVisualizerComponent::EnemyUpdateTime' has a wrong offset!");
static_assert(offsetof(UThreatVisualizerComponent, ThreatParameterMaterialCollection) == 0x0000F8, "Member 'UThreatVisualizerComponent::ThreatParameterMaterialCollection' has a wrong offset!");
static_assert(offsetof(UThreatVisualizerComponent, ThreatParameterName) == 0x000100, "Member 'UThreatVisualizerComponent::ThreatParameterName' has a wrong offset!");
static_assert(offsetof(UThreatVisualizerComponent, PositionParameterName) == 0x000108, "Member 'UThreatVisualizerComponent::PositionParameterName' has a wrong offset!");
static_assert(offsetof(UThreatVisualizerComponent, EdgePercentage) == 0x000110, "Member 'UThreatVisualizerComponent::EdgePercentage' has a wrong offset!");
static_assert(offsetof(UThreatVisualizerComponent, ImportantThreatEnemies) == 0x000118, "Member 'UThreatVisualizerComponent::ImportantThreatEnemies' has a wrong offset!");

// Class ObsidianFox.OFPlayerAttributeSet
// 0x0030 (0x00A0 - 0x0070)
class UOFPlayerAttributeSet final : public UOFAttributeSet
{
public:
	struct FOFGameplayAttributeData               Obsession;                                         // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	struct FOFGameplayAttributeData               HealthReserve;                                     // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	struct FOFGameplayAttributeData               HealthReserveMax;                                  // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFPlayerAttributeSet">();
	}
	static class UOFPlayerAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFPlayerAttributeSet>();
	}
};
static_assert(alignof(UOFPlayerAttributeSet) == 0x000008, "Wrong alignment on UOFPlayerAttributeSet");
static_assert(sizeof(UOFPlayerAttributeSet) == 0x0000A0, "Wrong size on UOFPlayerAttributeSet");
static_assert(offsetof(UOFPlayerAttributeSet, Obsession) == 0x000070, "Member 'UOFPlayerAttributeSet::Obsession' has a wrong offset!");
static_assert(offsetof(UOFPlayerAttributeSet, HealthReserve) == 0x000080, "Member 'UOFPlayerAttributeSet::HealthReserve' has a wrong offset!");
static_assert(offsetof(UOFPlayerAttributeSet, HealthReserveMax) == 0x000090, "Member 'UOFPlayerAttributeSet::HealthReserveMax' has a wrong offset!");

// Class ObsidianFox.OFPlayerCharacter
// 0x0270 (0x09C0 - 0x0750)
class AOFPlayerCharacter : public AObsidianFoxCharacter
{
public:
	uint8                                         Pad_748[0x8];                                      // 0x0748(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UThirdPersonSpringArmComponent*         ThirdPersonCameraBoom;                             // 0x0750(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       FollowCamera;                                      // 0x0758(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerInteractionComponent*            PlayerInteractionComponent;                        // 0x0760(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFMODAudioComponent*                    FMODAudioComponent;                                // 0x0768(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnemiesWithinRangeComponent*           EnemiesWithinRangeComponent;                       // 0x0770(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCameraControlsVerticalInverted;                   // 0x0778(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCameraControlsHorizontalInverted;                 // 0x0779(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_77A[0x2];                                      // 0x077A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraSensitivity;                                 // 0x077C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AimSensitivity;                                    // 0x0780(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BaseTurnRate;                                      // 0x0784(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLookUpRate;                                    // 0x0788(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomedTurnRate;                                    // 0x078C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomedLookUpScale;                                 // 0x0790(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_794[0x4];                                      // 0x0794(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDummyCharacter;                                   // 0x0798(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_799[0x7];                                      // 0x0799(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ExamineTags;                                       // 0x07A0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  RangedAttackTags;                                  // 0x07C0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  DodgeTags;                                         // 0x07E0(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ReloadTags;                                        // 0x0800(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  MeleeAttackTags;                                   // 0x0820(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  AimTags;                                           // 0x0840(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  CameraShiftTags;                                   // 0x0860(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SprintTags;                                        // 0x0880(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SprintHoldTags;                                    // 0x08A0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  StealthTags;                                       // 0x08C0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  UseConsumableTags;                                 // 0x08E0(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UActorMoodComponent*                    CharacterABPMediator;                              // 0x0900(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFirstTimeInGauntlet;                              // 0x0908(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, SaveGame, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_909[0x27];                                     // 0x0909(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       LoadingSphere;                                     // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnLossOfControl;                                   // 0x0938(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UInputConfigDataAsset*                  InputConfig;                                       // 0x0948(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOFCharacterMovementComponent*          MovementComponent;                                 // 0x0950(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImpassableTerrainDetectorComponent*    ImpassableTerrainComponent;                        // 0x0958(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWeaponAnimationComponent*              WeaponAnimationController;                         // 0x0960(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEquipmentManager*                      EquipmentManager;                                  // 0x0968(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerCharacterType                          CharacterType;                                     // 0x0970(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_971[0x7];                                      // 0x0971(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCheckGroundedAtStartupAC*              CheckGroundedAtStartup;                            // 0x0978(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCharacterMeshInterpolationComponent*   MeshInterpolationComponent;                        // 0x0980(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayerHitReactionComponent*            HitReactionComponent;                              // 0x0988(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_990[0x30];                                     // 0x0990(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginCrawl();
	void CheckForLossOfControl();
	void GrantAbilityWithInput(TSubclassOf<class UGameplayAbility> NewAbility, EAbilityInput AbilityInput);
	void InputTypeChanged(bool bIsGamepadType);
	void Interact(EInteractionType ComponentType);
	bool IsAiming();
	void Look(const struct FInputActionValue& InputActionValue);
	void LossOfControlDelegate__DelegateSignature(bool bGameplayInputIgnored, bool bLookInputIgnored, bool bMoveInputIgnored);
	void Move(const struct FInputActionValue& InputActionValue);
	void OnEnterGauntlet();
	void OnExitGauntlet();
	void OnSettingsChangedHandler(class UOFGameUserSettings* Settings);
	void PrintActivatableAbilities();
	void PrintActiveAbilities();
	void SetGhostBustingRange(float Range);
	void SmoothRotateTo(const struct FRotator& Rotation, float Time, EEasingFunc EasingFunction);
	void StopCrawl();
	void ToggleGhostBusterMode();

	class AOFEnemyCharacter* GetNearestEnemyInVisionCone(float VisionConeDegrees) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFPlayerCharacter">();
	}
	static class AOFPlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOFPlayerCharacter>();
	}
};
static_assert(alignof(AOFPlayerCharacter) == 0x000010, "Wrong alignment on AOFPlayerCharacter");
static_assert(sizeof(AOFPlayerCharacter) == 0x0009C0, "Wrong size on AOFPlayerCharacter");
static_assert(offsetof(AOFPlayerCharacter, ThirdPersonCameraBoom) == 0x000750, "Member 'AOFPlayerCharacter::ThirdPersonCameraBoom' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, FollowCamera) == 0x000758, "Member 'AOFPlayerCharacter::FollowCamera' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, PlayerInteractionComponent) == 0x000760, "Member 'AOFPlayerCharacter::PlayerInteractionComponent' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, FMODAudioComponent) == 0x000768, "Member 'AOFPlayerCharacter::FMODAudioComponent' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, EnemiesWithinRangeComponent) == 0x000770, "Member 'AOFPlayerCharacter::EnemiesWithinRangeComponent' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, bCameraControlsVerticalInverted) == 0x000778, "Member 'AOFPlayerCharacter::bCameraControlsVerticalInverted' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, bCameraControlsHorizontalInverted) == 0x000779, "Member 'AOFPlayerCharacter::bCameraControlsHorizontalInverted' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, CameraSensitivity) == 0x00077C, "Member 'AOFPlayerCharacter::CameraSensitivity' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, AimSensitivity) == 0x000780, "Member 'AOFPlayerCharacter::AimSensitivity' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, BaseTurnRate) == 0x000784, "Member 'AOFPlayerCharacter::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, BaseLookUpRate) == 0x000788, "Member 'AOFPlayerCharacter::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, ZoomedTurnRate) == 0x00078C, "Member 'AOFPlayerCharacter::ZoomedTurnRate' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, ZoomedLookUpScale) == 0x000790, "Member 'AOFPlayerCharacter::ZoomedLookUpScale' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, bDummyCharacter) == 0x000798, "Member 'AOFPlayerCharacter::bDummyCharacter' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, ExamineTags) == 0x0007A0, "Member 'AOFPlayerCharacter::ExamineTags' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, RangedAttackTags) == 0x0007C0, "Member 'AOFPlayerCharacter::RangedAttackTags' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, DodgeTags) == 0x0007E0, "Member 'AOFPlayerCharacter::DodgeTags' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, ReloadTags) == 0x000800, "Member 'AOFPlayerCharacter::ReloadTags' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, MeleeAttackTags) == 0x000820, "Member 'AOFPlayerCharacter::MeleeAttackTags' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, AimTags) == 0x000840, "Member 'AOFPlayerCharacter::AimTags' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, CameraShiftTags) == 0x000860, "Member 'AOFPlayerCharacter::CameraShiftTags' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, SprintTags) == 0x000880, "Member 'AOFPlayerCharacter::SprintTags' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, SprintHoldTags) == 0x0008A0, "Member 'AOFPlayerCharacter::SprintHoldTags' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, StealthTags) == 0x0008C0, "Member 'AOFPlayerCharacter::StealthTags' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, UseConsumableTags) == 0x0008E0, "Member 'AOFPlayerCharacter::UseConsumableTags' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, CharacterABPMediator) == 0x000900, "Member 'AOFPlayerCharacter::CharacterABPMediator' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, bFirstTimeInGauntlet) == 0x000908, "Member 'AOFPlayerCharacter::bFirstTimeInGauntlet' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, LoadingSphere) == 0x000930, "Member 'AOFPlayerCharacter::LoadingSphere' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, OnLossOfControl) == 0x000938, "Member 'AOFPlayerCharacter::OnLossOfControl' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, InputConfig) == 0x000948, "Member 'AOFPlayerCharacter::InputConfig' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, MovementComponent) == 0x000950, "Member 'AOFPlayerCharacter::MovementComponent' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, ImpassableTerrainComponent) == 0x000958, "Member 'AOFPlayerCharacter::ImpassableTerrainComponent' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, WeaponAnimationController) == 0x000960, "Member 'AOFPlayerCharacter::WeaponAnimationController' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, EquipmentManager) == 0x000968, "Member 'AOFPlayerCharacter::EquipmentManager' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, CharacterType) == 0x000970, "Member 'AOFPlayerCharacter::CharacterType' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, CheckGroundedAtStartup) == 0x000978, "Member 'AOFPlayerCharacter::CheckGroundedAtStartup' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, MeshInterpolationComponent) == 0x000980, "Member 'AOFPlayerCharacter::MeshInterpolationComponent' has a wrong offset!");
static_assert(offsetof(AOFPlayerCharacter, HitReactionComponent) == 0x000988, "Member 'AOFPlayerCharacter::HitReactionComponent' has a wrong offset!");

// Class ObsidianFox.WorldSubsystem_CharacterStateDebugger
// 0x0030 (0x0070 - 0x0040)
class UWorldSubsystem_CharacterStateDebugger final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x30];                                      // 0x0040(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RefreshCharacterCollection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldSubsystem_CharacterStateDebugger">();
	}
	static class UWorldSubsystem_CharacterStateDebugger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldSubsystem_CharacterStateDebugger>();
	}
};
static_assert(alignof(UWorldSubsystem_CharacterStateDebugger) == 0x000008, "Wrong alignment on UWorldSubsystem_CharacterStateDebugger");
static_assert(sizeof(UWorldSubsystem_CharacterStateDebugger) == 0x000070, "Wrong size on UWorldSubsystem_CharacterStateDebugger");

// Class ObsidianFox.OFCharacterTypeSpecificSettingsUtils
// 0x0000 (0x0028 - 0x0028)
class UOFCharacterTypeSpecificSettingsUtils final : public UBlueprintFunctionLibrary
{
public:
	static TSoftClassPtr<class UClass> GetPauseMenuClass(const EPlayerCharacterType CharacterType);
	static bool IsOpenInGameMenuEnabled(const EPlayerCharacterType CharacterType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFCharacterTypeSpecificSettingsUtils">();
	}
	static class UOFCharacterTypeSpecificSettingsUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFCharacterTypeSpecificSettingsUtils>();
	}
};
static_assert(alignof(UOFCharacterTypeSpecificSettingsUtils) == 0x000008, "Wrong alignment on UOFCharacterTypeSpecificSettingsUtils");
static_assert(sizeof(UOFCharacterTypeSpecificSettingsUtils) == 0x000028, "Wrong size on UOFCharacterTypeSpecificSettingsUtils");

// Class ObsidianFox.BFLPlayerUtils
// 0x0000 (0x0028 - 0x0028)
class UBFLPlayerUtils final : public UBlueprintFunctionLibrary
{
public:
	static EPlayerCharacterType GetPlayerCharacterType(const class UObject* WorldContextObject);
	static class UPointLightComponent* GetPlayerDebugLight(const class UObject* WorldContextObject);
	static class UPointLightComponent* GetPlayerLight(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BFLPlayerUtils">();
	}
	static class UBFLPlayerUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBFLPlayerUtils>();
	}
};
static_assert(alignof(UBFLPlayerUtils) == 0x000008, "Wrong alignment on UBFLPlayerUtils");
static_assert(sizeof(UBFLPlayerUtils) == 0x000028, "Wrong size on UBFLPlayerUtils");

// Class ObsidianFox.OFProjectile
// 0x0028 (0x0260 - 0x0238)
class AOFProjectile : public AActor
{
public:
	struct FGameplayTag                           AttackEventTag;                                    // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCollisionProfileName                  TraceProfile;                                      // 0x0240(0x0008)(Edit, BlueprintVisible, Config, NoDestructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	uint8                                         bDisableCollisionOnEndAttack : 1;                  // 0x0248(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, Config, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_249[0x3];                                      // 0x0249(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugDisplayTime;                                  // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginAttack(const struct FGameplayTag& AttackEvent);
	void EndAttack();
	void HandleHit(const struct FGameplayAbilityTargetDataHandle& TargetData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFProjectile">();
	}
	static class AOFProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOFProjectile>();
	}
};
static_assert(alignof(AOFProjectile) == 0x000008, "Wrong alignment on AOFProjectile");
static_assert(sizeof(AOFProjectile) == 0x000260, "Wrong size on AOFProjectile");
static_assert(offsetof(AOFProjectile, AttackEventTag) == 0x000238, "Member 'AOFProjectile::AttackEventTag' has a wrong offset!");
static_assert(offsetof(AOFProjectile, TraceProfile) == 0x000240, "Member 'AOFProjectile::TraceProfile' has a wrong offset!");
static_assert(offsetof(AOFProjectile, DebugDisplayTime) == 0x00024C, "Member 'AOFProjectile::DebugDisplayTime' has a wrong offset!");

// Class ObsidianFox.OFPTDeveloperSettings
// 0x0028 (0x0060 - 0x0038)
class UOFPTDeveloperSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class ULevelSequence>          EndingCutscene;                                    // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFPTDeveloperSettings">();
	}
	static class UOFPTDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFPTDeveloperSettings>();
	}
};
static_assert(alignof(UOFPTDeveloperSettings) == 0x000008, "Wrong alignment on UOFPTDeveloperSettings");
static_assert(sizeof(UOFPTDeveloperSettings) == 0x000060, "Wrong size on UOFPTDeveloperSettings");
static_assert(offsetof(UOFPTDeveloperSettings, EndingCutscene) == 0x000038, "Member 'UOFPTDeveloperSettings::EndingCutscene' has a wrong offset!");

// Class ObsidianFox.WaterLevelTriggerBoxComponent
// 0x0000 (0x0490 - 0x0490)
class UWaterLevelTriggerBoxComponent final : public UBoxComponent
{
public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterLevelTriggerBoxComponent">();
	}
	static class UWaterLevelTriggerBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWaterLevelTriggerBoxComponent>();
	}
};
static_assert(alignof(UWaterLevelTriggerBoxComponent) == 0x000010, "Wrong alignment on UWaterLevelTriggerBoxComponent");
static_assert(sizeof(UWaterLevelTriggerBoxComponent) == 0x000490, "Wrong size on UWaterLevelTriggerBoxComponent");

// Class ObsidianFox.OFRichTextBlockPlatformKeyDecorator
// 0x0008 (0x0030 - 0x0028)
class UOFRichTextBlockPlatformKeyDecorator : public URichTextBlockDecorator
{
public:
	class UDataTable*                             UserWidgetSet;                                     // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFRichTextBlockPlatformKeyDecorator">();
	}
	static class UOFRichTextBlockPlatformKeyDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFRichTextBlockPlatformKeyDecorator>();
	}
};
static_assert(alignof(UOFRichTextBlockPlatformKeyDecorator) == 0x000008, "Wrong alignment on UOFRichTextBlockPlatformKeyDecorator");
static_assert(sizeof(UOFRichTextBlockPlatformKeyDecorator) == 0x000030, "Wrong size on UOFRichTextBlockPlatformKeyDecorator");
static_assert(offsetof(UOFRichTextBlockPlatformKeyDecorator, UserWidgetSet) == 0x000028, "Member 'UOFRichTextBlockPlatformKeyDecorator::UserWidgetSet' has a wrong offset!");

// Class ObsidianFox.OFSaveConfirmationPopupWidget
// 0x00B8 (0x0408 - 0x0350)
class UOFSaveConfirmationPopupWidget : public UOFConfirmationPopupWidget
{
public:
	struct FLoadSaveGameUIData                    LoadSaveUIData;                                    // 0x0350(0x0098)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             UIIndexText;                                       // 0x03E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             LevelText;                                         // 0x03F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TimeText;                                          // 0x03F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsOverride;                                       // 0x0400(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFSaveConfirmationPopupWidget">();
	}
	static class UOFSaveConfirmationPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFSaveConfirmationPopupWidget>();
	}
};
static_assert(alignof(UOFSaveConfirmationPopupWidget) == 0x000008, "Wrong alignment on UOFSaveConfirmationPopupWidget");
static_assert(sizeof(UOFSaveConfirmationPopupWidget) == 0x000408, "Wrong size on UOFSaveConfirmationPopupWidget");
static_assert(offsetof(UOFSaveConfirmationPopupWidget, LoadSaveUIData) == 0x000350, "Member 'UOFSaveConfirmationPopupWidget::LoadSaveUIData' has a wrong offset!");
static_assert(offsetof(UOFSaveConfirmationPopupWidget, UIIndexText) == 0x0003E8, "Member 'UOFSaveConfirmationPopupWidget::UIIndexText' has a wrong offset!");
static_assert(offsetof(UOFSaveConfirmationPopupWidget, LevelText) == 0x0003F0, "Member 'UOFSaveConfirmationPopupWidget::LevelText' has a wrong offset!");
static_assert(offsetof(UOFSaveConfirmationPopupWidget, TimeText) == 0x0003F8, "Member 'UOFSaveConfirmationPopupWidget::TimeText' has a wrong offset!");
static_assert(offsetof(UOFSaveConfirmationPopupWidget, bIsOverride) == 0x000400, "Member 'UOFSaveConfirmationPopupWidget::bIsOverride' has a wrong offset!");

// Class ObsidianFox.OFSaveGameMenuWidget
// 0x0018 (0x02B8 - 0x02A0)
class UOFSaveGameMenuWidget : public UWidgetInputHandlingBase
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USaveSlotWidget>            LoadSaveSlotWidgetClass;                           // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           SaveGameList;                                      // 0x02B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnDeleteFinished(bool bResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFSaveGameMenuWidget">();
	}
	static class UOFSaveGameMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFSaveGameMenuWidget>();
	}
};
static_assert(alignof(UOFSaveGameMenuWidget) == 0x000008, "Wrong alignment on UOFSaveGameMenuWidget");
static_assert(sizeof(UOFSaveGameMenuWidget) == 0x0002B8, "Wrong size on UOFSaveGameMenuWidget");
static_assert(offsetof(UOFSaveGameMenuWidget, LoadSaveSlotWidgetClass) == 0x0002A8, "Member 'UOFSaveGameMenuWidget::LoadSaveSlotWidgetClass' has a wrong offset!");
static_assert(offsetof(UOFSaveGameMenuWidget, SaveGameList) == 0x0002B0, "Member 'UOFSaveGameMenuWidget::SaveGameList' has a wrong offset!");

// Class ObsidianFox.OFSaveGameProfile
// 0x0130 (0x0178 - 0x0048)
class UOFSaveGameProfile final : public USaveGameProfile
{
public:
	TArray<struct FCollectibleSaveData>           CollectibleSets;                                   // 0x0048(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	struct FTimespan                              TotalInGameTime;                                   // 0x0058(0x0008)(ZeroConstructor, SaveGame, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FString>                           LocksOpened;                                       // 0x0070(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	TSet<struct FCompletedBanter>                 CompletedBanters;                                  // 0x00C0(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	TSet<struct FSoftObjectPath>                  CluesRead;                                         // 0x0110(0x0050)(SaveGame, NativeAccessSpecifierPublic)
	TArray<class FString>                         CompletedActivities;                               // 0x0160(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPublic)
	bool                                          HasFinishedGame;                                   // 0x0170(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFSaveGameProfile">();
	}
	static class UOFSaveGameProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFSaveGameProfile>();
	}
};
static_assert(alignof(UOFSaveGameProfile) == 0x000008, "Wrong alignment on UOFSaveGameProfile");
static_assert(sizeof(UOFSaveGameProfile) == 0x000178, "Wrong size on UOFSaveGameProfile");
static_assert(offsetof(UOFSaveGameProfile, CollectibleSets) == 0x000048, "Member 'UOFSaveGameProfile::CollectibleSets' has a wrong offset!");
static_assert(offsetof(UOFSaveGameProfile, TotalInGameTime) == 0x000058, "Member 'UOFSaveGameProfile::TotalInGameTime' has a wrong offset!");
static_assert(offsetof(UOFSaveGameProfile, LocksOpened) == 0x000070, "Member 'UOFSaveGameProfile::LocksOpened' has a wrong offset!");
static_assert(offsetof(UOFSaveGameProfile, CompletedBanters) == 0x0000C0, "Member 'UOFSaveGameProfile::CompletedBanters' has a wrong offset!");
static_assert(offsetof(UOFSaveGameProfile, CluesRead) == 0x000110, "Member 'UOFSaveGameProfile::CluesRead' has a wrong offset!");
static_assert(offsetof(UOFSaveGameProfile, CompletedActivities) == 0x000160, "Member 'UOFSaveGameProfile::CompletedActivities' has a wrong offset!");
static_assert(offsetof(UOFSaveGameProfile, HasFinishedGame) == 0x000170, "Member 'UOFSaveGameProfile::HasFinishedGame' has a wrong offset!");

// Class ObsidianFox.OFSaveGameWidget
// 0x0038 (0x02B0 - 0x0278)
class UOFSaveGameWidget : public UInGameUIWidget
{
public:
	class UOverlay*                               OverlayIcon;                                       // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeInTime;                                        // 0x0280(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutTime;                                       // 0x0284(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxWaitingTime;                                    // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FlashAnimationTime;                                // 0x028C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_290[0x20];                                     // 0x0290(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSaveFinished(bool Success);
	void OnSaveStarted();
	void PlayFlashAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFSaveGameWidget">();
	}
	static class UOFSaveGameWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFSaveGameWidget>();
	}
};
static_assert(alignof(UOFSaveGameWidget) == 0x000008, "Wrong alignment on UOFSaveGameWidget");
static_assert(sizeof(UOFSaveGameWidget) == 0x0002B0, "Wrong size on UOFSaveGameWidget");
static_assert(offsetof(UOFSaveGameWidget, OverlayIcon) == 0x000278, "Member 'UOFSaveGameWidget::OverlayIcon' has a wrong offset!");
static_assert(offsetof(UOFSaveGameWidget, FadeInTime) == 0x000280, "Member 'UOFSaveGameWidget::FadeInTime' has a wrong offset!");
static_assert(offsetof(UOFSaveGameWidget, FadeOutTime) == 0x000284, "Member 'UOFSaveGameWidget::FadeOutTime' has a wrong offset!");
static_assert(offsetof(UOFSaveGameWidget, MaxWaitingTime) == 0x000288, "Member 'UOFSaveGameWidget::MaxWaitingTime' has a wrong offset!");
static_assert(offsetof(UOFSaveGameWidget, FlashAnimationTime) == 0x00028C, "Member 'UOFSaveGameWidget::FlashAnimationTime' has a wrong offset!");

// Class ObsidianFox.WallSplineCharacterPath
// 0x0018 (0x0250 - 0x0238)
class AWallSplineCharacterPath final : public AActor
{
public:
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USplineComponent*                       Spline;                                            // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bDrawDownDirection : 1;                            // 0x0248(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_249[0x7];                                      // 0x0249(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector GetDirectionToLocation(const struct FVector& CurrentLocation, const struct FVector& TargetLocation) const;
	struct FWallSplineCharacterPathPoint GetNearestPointOnSpline(const struct FVector& Origin) const;
	struct FWallSplineCharacterPathPoint GetRandomPointOnSpline() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WallSplineCharacterPath">();
	}
	static class AWallSplineCharacterPath* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWallSplineCharacterPath>();
	}
};
static_assert(alignof(AWallSplineCharacterPath) == 0x000008, "Wrong alignment on AWallSplineCharacterPath");
static_assert(sizeof(AWallSplineCharacterPath) == 0x000250, "Wrong size on AWallSplineCharacterPath");
static_assert(offsetof(AWallSplineCharacterPath, Spline) == 0x000240, "Member 'AWallSplineCharacterPath::Spline' has a wrong offset!");

// Class ObsidianFox.OFStruckTextWidget
// 0x00C8 (0x0328 - 0x0260)
class UOFStruckTextWidget : public UUserWidget
{
public:
	class FText                                   RawText;                                           // 0x0260(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          IsStrokeEnabled;                                   // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class URichTextBlock*                         TextElement;                                       // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            StrokeImage;                                       // 0x0288(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FMargin                                StrokePadding;                                     // 0x0310(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UImage*                                 ImageCheckMark;                                    // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FadeIn();
	void SetStrokeEnabled(bool InEnabled);
	void SetText(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFStruckTextWidget">();
	}
	static class UOFStruckTextWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFStruckTextWidget>();
	}
};
static_assert(alignof(UOFStruckTextWidget) == 0x000008, "Wrong alignment on UOFStruckTextWidget");
static_assert(sizeof(UOFStruckTextWidget) == 0x000328, "Wrong size on UOFStruckTextWidget");
static_assert(offsetof(UOFStruckTextWidget, RawText) == 0x000260, "Member 'UOFStruckTextWidget::RawText' has a wrong offset!");
static_assert(offsetof(UOFStruckTextWidget, IsStrokeEnabled) == 0x000278, "Member 'UOFStruckTextWidget::IsStrokeEnabled' has a wrong offset!");
static_assert(offsetof(UOFStruckTextWidget, TextElement) == 0x000280, "Member 'UOFStruckTextWidget::TextElement' has a wrong offset!");
static_assert(offsetof(UOFStruckTextWidget, StrokeImage) == 0x000288, "Member 'UOFStruckTextWidget::StrokeImage' has a wrong offset!");
static_assert(offsetof(UOFStruckTextWidget, StrokePadding) == 0x000310, "Member 'UOFStruckTextWidget::StrokePadding' has a wrong offset!");
static_assert(offsetof(UOFStruckTextWidget, ImageCheckMark) == 0x000320, "Member 'UOFStruckTextWidget::ImageCheckMark' has a wrong offset!");

// Class ObsidianFox.OFSubtitleEngineSubsystem
// 0x0000 (0x0030 - 0x0030)
class UOFSubtitleEngineSubsystem final : public UEngineSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFSubtitleEngineSubsystem">();
	}
	static class UOFSubtitleEngineSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOFSubtitleEngineSubsystem>();
	}
};
static_assert(alignof(UOFSubtitleEngineSubsystem) == 0x000008, "Wrong alignment on UOFSubtitleEngineSubsystem");
static_assert(sizeof(UOFSubtitleEngineSubsystem) == 0x000030, "Wrong size on UOFSubtitleEngineSubsystem");

// Class ObsidianFox.OFWidgetInterface
// 0x0000 (0x0028 - 0x0028)
class IOFWidgetInterface final : public IInterface
{
public:
	void FadeOutAndThenDestroy();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OFWidgetInterface">();
	}
	static class IOFWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IOFWidgetInterface>();
	}
};
static_assert(alignof(IOFWidgetInterface) == 0x000008, "Wrong alignment on IOFWidgetInterface");
static_assert(sizeof(IOFWidgetInterface) == 0x000028, "Wrong size on IOFWidgetInterface");

// Class ObsidianFox.Opportunity
// 0x0020 (0x0280 - 0x0260)
class AOpportunity : public AOFProjectile
{
public:
	FMulticastInlineDelegateProperty_             OnAdditionalAssetsLoaded;                          // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdditionalAssetsLoaded__DelegateSignature(const TArray<TSoftObjectPtr<class UObject>>& Assets, const TArray<TSoftClassPtr<class UClass>>& Classes);
	void GetAdditionalRequiredAssets(TArray<TSoftObjectPtr<class UObject>>* AdditionalAssets, TArray<TSoftClassPtr<class UClass>>* AdditionalClasses);
	struct FGameplayEffectContextHandle SetOpportunityEffectContext(const struct FGameplayEffectContextHandle& EffectContextHandle, class AActor* OpportunityInstigator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Opportunity">();
	}
	static class AOpportunity* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOpportunity>();
	}
};
static_assert(alignof(AOpportunity) == 0x000008, "Wrong alignment on AOpportunity");
static_assert(sizeof(AOpportunity) == 0x000280, "Wrong size on AOpportunity");
static_assert(offsetof(AOpportunity, OnAdditionalAssetsLoaded) == 0x000260, "Member 'AOpportunity::OnAdditionalAssetsLoaded' has a wrong offset!");

// Class ObsidianFox.ParticleBlockerManager
// 0x0078 (0x0130 - 0x00B8)
class UParticleBlockerManager final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         BlockerActors;                                     // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         MaxNumberOfActiveBlockers;                         // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpdateFrequency;                                   // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 LocationParamName;                                 // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 RotationParamName;                                 // 0x00E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SizeParamName;                                     // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentUpdateTime;                                 // 0x0108(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBoxComponent*>                  BlockerComponents;                                 // 0x0110(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UBoxComponent*>                  ActiveBlockerComponents;                           // 0x0120(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void SetNiagaraParameterCollection(class UNiagaraParameterCollectionInstance* NiagaraPC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ParticleBlockerManager">();
	}
	static class UParticleBlockerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UParticleBlockerManager>();
	}
};
static_assert(alignof(UParticleBlockerManager) == 0x000008, "Wrong alignment on UParticleBlockerManager");
static_assert(sizeof(UParticleBlockerManager) == 0x000130, "Wrong size on UParticleBlockerManager");
static_assert(offsetof(UParticleBlockerManager, BlockerActors) == 0x0000C0, "Member 'UParticleBlockerManager::BlockerActors' has a wrong offset!");
static_assert(offsetof(UParticleBlockerManager, MaxNumberOfActiveBlockers) == 0x0000D0, "Member 'UParticleBlockerManager::MaxNumberOfActiveBlockers' has a wrong offset!");
static_assert(offsetof(UParticleBlockerManager, UpdateFrequency) == 0x0000D4, "Member 'UParticleBlockerManager::UpdateFrequency' has a wrong offset!");
static_assert(offsetof(UParticleBlockerManager, LocationParamName) == 0x0000D8, "Member 'UParticleBlockerManager::LocationParamName' has a wrong offset!");
static_assert(offsetof(UParticleBlockerManager, RotationParamName) == 0x0000E8, "Member 'UParticleBlockerManager::RotationParamName' has a wrong offset!");
static_assert(offsetof(UParticleBlockerManager, SizeParamName) == 0x0000F8, "Member 'UParticleBlockerManager::SizeParamName' has a wrong offset!");
static_assert(offsetof(UParticleBlockerManager, CurrentUpdateTime) == 0x000108, "Member 'UParticleBlockerManager::CurrentUpdateTime' has a wrong offset!");
static_assert(offsetof(UParticleBlockerManager, BlockerComponents) == 0x000110, "Member 'UParticleBlockerManager::BlockerComponents' has a wrong offset!");
static_assert(offsetof(UParticleBlockerManager, ActiveBlockerComponents) == 0x000120, "Member 'UParticleBlockerManager::ActiveBlockerComponents' has a wrong offset!");

// Class ObsidianFox.PauseComponent
// 0x0070 (0x0128 - 0x00B8)
class UPauseComponent final : public UActorComponent
{
public:
	uint8                                         bIsPaused : 1;                                     // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TWeakObjectPtr<class UPrimitiveComponent>, struct FVector> SleepingPrimitivesVelocities;                      // 0x00C0(0x0050)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x18];                                     // 0x0110(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayStateChanged(EGameMainState OldGameState, EGameMainState NewGameState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PauseComponent">();
	}
	static class UPauseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPauseComponent>();
	}
};
static_assert(alignof(UPauseComponent) == 0x000008, "Wrong alignment on UPauseComponent");
static_assert(sizeof(UPauseComponent) == 0x000128, "Wrong size on UPauseComponent");
static_assert(offsetof(UPauseComponent, SleepingPrimitivesVelocities) == 0x0000C0, "Member 'UPauseComponent::SleepingPrimitivesVelocities' has a wrong offset!");

// Class ObsidianFox.PauseMenuPT
// 0x0568 (0x07C8 - 0x0260)
class UPauseMenuPT final : public UUserWidget
{
public:
	class UIncreaseDecreaseOption*                ControllerSensitivity;                             // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckBox*                              InvertedCheckBox;                                  // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                InvertedButton;                                    // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                QuitButton;                                        // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                QuickLoadButton;                                   // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                SaveGameButton;                                    // 0x0288(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FButtonStyle                           ButtonNormalStyle;                                 // 0x0290(0x0278)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FButtonStyle                           ButtonHoveredStyle;                                // 0x0508(0x0278)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_780[0x48];                                     // 0x0780(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ButtonHovered();
	void ButtonUnHovered();
	void CancelButtonPressed();
	void DecreaseOption();
	void IncreaseOption();
	void InteractButtonPressed();
	void LeftStickX(float Val);
	void LeftStickY(float Val);
	void OnExitSaveDone(bool Success);
	void OpenLoadGameMenu();
	void OpenSaveGameMenu();
	void PlayHoverSound();
	void PlayPressedSound();
	void QuitGame();
	void SelectDownPressed();
	void SelectNextPressed();
	void SelectPreviousPressed();
	void SelectUpPressed();
	void SetCanMoveWithLeftStickXToTrue();
	void SetCanMoveWithLeftStickYToTrue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PauseMenuPT">();
	}
	static class UPauseMenuPT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPauseMenuPT>();
	}
};
static_assert(alignof(UPauseMenuPT) == 0x000008, "Wrong alignment on UPauseMenuPT");
static_assert(sizeof(UPauseMenuPT) == 0x0007C8, "Wrong size on UPauseMenuPT");
static_assert(offsetof(UPauseMenuPT, ControllerSensitivity) == 0x000260, "Member 'UPauseMenuPT::ControllerSensitivity' has a wrong offset!");
static_assert(offsetof(UPauseMenuPT, InvertedCheckBox) == 0x000268, "Member 'UPauseMenuPT::InvertedCheckBox' has a wrong offset!");
static_assert(offsetof(UPauseMenuPT, InvertedButton) == 0x000270, "Member 'UPauseMenuPT::InvertedButton' has a wrong offset!");
static_assert(offsetof(UPauseMenuPT, QuitButton) == 0x000278, "Member 'UPauseMenuPT::QuitButton' has a wrong offset!");
static_assert(offsetof(UPauseMenuPT, QuickLoadButton) == 0x000280, "Member 'UPauseMenuPT::QuickLoadButton' has a wrong offset!");
static_assert(offsetof(UPauseMenuPT, SaveGameButton) == 0x000288, "Member 'UPauseMenuPT::SaveGameButton' has a wrong offset!");
static_assert(offsetof(UPauseMenuPT, ButtonNormalStyle) == 0x000290, "Member 'UPauseMenuPT::ButtonNormalStyle' has a wrong offset!");
static_assert(offsetof(UPauseMenuPT, ButtonHoveredStyle) == 0x000508, "Member 'UPauseMenuPT::ButtonHoveredStyle' has a wrong offset!");

// Class ObsidianFox.PlayerAnimInstance
// 0x0A90 (0x2230 - 0x17A0)
class UPlayerAnimInstance : public UHumanoidAnimInstance
{
public:
	uint8                                         Pad_17A0[0x18];                                    // 0x17A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FocusUpperBodyBaseAlpha;                           // 0x17B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17BC[0x4];                                     // 0x17BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            FocusUpperbodyExtraAlphaCurve;                     // 0x17C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FocusCameraTraceMinimumDistance;                   // 0x17C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17CC[0x4];                                     // 0x17CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPickupAnimationData>           PickupAnimations;                                  // 0x17D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSet<TSubclassOf<class UPlayerSubGraphAnimInstance>> LinkedLayers;                                      // 0x17E0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class AOFPlayerCharacter*                     PlayerCharacterOwner;                              // 0x1830(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bContextualTraverseIsActive : 1;                   // 0x1838(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseTraceForFocusPoint : 1;                        // 0x1838(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1839[0x3];                                     // 0x1839(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LowAttackAnimationCurveName;                       // 0x183C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LowAttackAdditiveAlpha;                            // 0x1844(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FHandPosesData>      HandPoseMap;                                       // 0x1848(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         HandPoseMontageOverrideInterpolationSpeed;         // 0x1898(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RightHandMontageOverrideAlpha;                     // 0x189C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      FaceAnimationBaseLayerOverride;                    // 0x18A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FaceAnimationBaseLayerOverrideBlendTime;           // 0x18A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallWalkTwistBlendSpaceInput;                      // 0x18AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18B0[0x8];                                     // 0x18B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ULocomotionStateAnimComponent> LocomotionStateAnimComponentClass;                 // 0x18B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULocomotionStateAnimComponent*          LocomotionStateAnimComponent;                      // 0x18C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18C8[0x8];                                     // 0x18C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            HealthBlendCurve;                                  // 0x18D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HurtBlend;                                         // 0x18D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastTurnTurnSpeed;                                 // 0x18DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FArmIKEffectorData                     RHandIKData;                                       // 0x18E0(0x0040)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FArmIKEffectorData                     LHandIKData;                                       // 0x1920(0x0040)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          UseSimpleHipOffset;                                // 0x1960(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1961[0x3];                                     // 0x1961(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpolatedGroundAngle;                           // 0x1964(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocomotionPlayRate;                                // 0x1968(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_196C[0x4];                                     // 0x196C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnLean;                                          // 0x1970(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HeadBodyFocusBlendCurveName;                       // 0x1974(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BodyFocusAlphaDisableModifierCurveName;            // 0x197C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeadBodyFocusBlend;                                // 0x1984(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BodyFocusAlphaDisableModifier;                     // 0x1988(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           InteractingTag;                                    // 0x198C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SuicidalTag;                                       // 0x1994(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PickupSmallTag;                                    // 0x199C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FocusWalkTag;                                      // 0x19A4(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           StealthTag;                                        // 0x19AC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_19B4[0x4];                                     // 0x19B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  AimBlockTags;                                      // 0x19B8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  GrappledTags;                                      // 0x19D8(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      RightHandPose;                                     // 0x19F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSuicidal;                                        // 0x1A00(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A01[0x3];                                     // 0x1A01(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FaceMontageOverrideBlendWeight;                    // 0x1A04(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FaceMontageOverrideBlendTargetWeight;              // 0x1A08(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FreezeTurnAngleSample;                             // 0x1A0C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldTransitionToFastTurn;                        // 0x1A0D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A0E[0x2];                                     // 0x1A0E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceRotationTurnAngle;                         // 0x1A10(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeavyBreathAlpha;                                  // 0x1A14(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            HeavyBreathAlphaCurve;                             // 0x1A18(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HasPickupSmallTag;                                 // 0x1A20(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HasFocuswalkTag;                                   // 0x1A21(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AimIsblocked;                                      // 0x1A22(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShouldPlayStillFullbodyMontage;                    // 0x1A23(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   StillFullbodyMontageSlotName;                      // 0x1A24(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   FullbodyMontageSlotName;                           // 0x1A2C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   BothArmsMontageSlotName;                           // 0x1A34(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WallTwistArmTweaksInput;                           // 0x1A3C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintTiltMaxAcceleration;                         // 0x1A40(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SprintStartTilt;                                   // 0x1A44(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CarefulBlend;                                      // 0x1A48(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnimationLocomotionState                     LocomotionState;                                   // 0x1A4C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnimationLocomotionState                     FrozenPlaceLocomotionState;                        // 0x1A4D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOnStairs;                                        // 0x1A4E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A4F[0x1];                                     // 0x1A4F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCachedAnimStateArray                  LocomotionStateFreezeStates;                       // 0x1A50(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          EnableRotationDelay;                               // 0x1A68(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A69[0x7];                                     // 0x1A69(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSequenceAutoBlendData                 MouthAnimationBaseLayer;                           // 0x1A70(0x0038)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          IsGrappled;                                        // 0x1AA8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AA9[0x7];                                     // 0x1AA9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerAnimInstanceProxy               PlayerAnimInstanceProxy;                           // 0x1AB0(0x0780)(Transient, NativeAccessSpecifierPrivate)

public:
	struct FPickupAnimationData GetClosestPickupAnimation(const struct FVector& ItemLocation);
	class UAnimationDataAssetBase* LoadEditorPreviewAnimations(TSubclassOf<class UAnimationDataAssetBase> AssetType, TSoftObjectPtr<class UAnimationDataAssetBase> AnimationDataAsset);
	void PlayPickupAnimation(const struct FVector& ItemLocation, float InterpToSpeed, float InterpFromSpeed);
	void VisualizePickupAnimCoverage(float DrawDuration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAnimInstance">();
	}
	static class UPlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAnimInstance>();
	}
};
static_assert(alignof(UPlayerAnimInstance) == 0x000010, "Wrong alignment on UPlayerAnimInstance");
static_assert(sizeof(UPlayerAnimInstance) == 0x002230, "Wrong size on UPlayerAnimInstance");
static_assert(offsetof(UPlayerAnimInstance, FocusUpperBodyBaseAlpha) == 0x0017B8, "Member 'UPlayerAnimInstance::FocusUpperBodyBaseAlpha' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, FocusUpperbodyExtraAlphaCurve) == 0x0017C0, "Member 'UPlayerAnimInstance::FocusUpperbodyExtraAlphaCurve' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, FocusCameraTraceMinimumDistance) == 0x0017C8, "Member 'UPlayerAnimInstance::FocusCameraTraceMinimumDistance' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, PickupAnimations) == 0x0017D0, "Member 'UPlayerAnimInstance::PickupAnimations' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, LinkedLayers) == 0x0017E0, "Member 'UPlayerAnimInstance::LinkedLayers' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, PlayerCharacterOwner) == 0x001830, "Member 'UPlayerAnimInstance::PlayerCharacterOwner' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, LowAttackAnimationCurveName) == 0x00183C, "Member 'UPlayerAnimInstance::LowAttackAnimationCurveName' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, LowAttackAdditiveAlpha) == 0x001844, "Member 'UPlayerAnimInstance::LowAttackAdditiveAlpha' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, HandPoseMap) == 0x001848, "Member 'UPlayerAnimInstance::HandPoseMap' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, HandPoseMontageOverrideInterpolationSpeed) == 0x001898, "Member 'UPlayerAnimInstance::HandPoseMontageOverrideInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, RightHandMontageOverrideAlpha) == 0x00189C, "Member 'UPlayerAnimInstance::RightHandMontageOverrideAlpha' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, FaceAnimationBaseLayerOverride) == 0x0018A0, "Member 'UPlayerAnimInstance::FaceAnimationBaseLayerOverride' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, FaceAnimationBaseLayerOverrideBlendTime) == 0x0018A8, "Member 'UPlayerAnimInstance::FaceAnimationBaseLayerOverrideBlendTime' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, WallWalkTwistBlendSpaceInput) == 0x0018AC, "Member 'UPlayerAnimInstance::WallWalkTwistBlendSpaceInput' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, LocomotionStateAnimComponentClass) == 0x0018B8, "Member 'UPlayerAnimInstance::LocomotionStateAnimComponentClass' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, LocomotionStateAnimComponent) == 0x0018C0, "Member 'UPlayerAnimInstance::LocomotionStateAnimComponent' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, HealthBlendCurve) == 0x0018D0, "Member 'UPlayerAnimInstance::HealthBlendCurve' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, HurtBlend) == 0x0018D8, "Member 'UPlayerAnimInstance::HurtBlend' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, FastTurnTurnSpeed) == 0x0018DC, "Member 'UPlayerAnimInstance::FastTurnTurnSpeed' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, RHandIKData) == 0x0018E0, "Member 'UPlayerAnimInstance::RHandIKData' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, LHandIKData) == 0x001920, "Member 'UPlayerAnimInstance::LHandIKData' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, UseSimpleHipOffset) == 0x001960, "Member 'UPlayerAnimInstance::UseSimpleHipOffset' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, InterpolatedGroundAngle) == 0x001964, "Member 'UPlayerAnimInstance::InterpolatedGroundAngle' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, LocomotionPlayRate) == 0x001968, "Member 'UPlayerAnimInstance::LocomotionPlayRate' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, TurnLean) == 0x001970, "Member 'UPlayerAnimInstance::TurnLean' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, HeadBodyFocusBlendCurveName) == 0x001974, "Member 'UPlayerAnimInstance::HeadBodyFocusBlendCurveName' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, BodyFocusAlphaDisableModifierCurveName) == 0x00197C, "Member 'UPlayerAnimInstance::BodyFocusAlphaDisableModifierCurveName' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, HeadBodyFocusBlend) == 0x001984, "Member 'UPlayerAnimInstance::HeadBodyFocusBlend' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, BodyFocusAlphaDisableModifier) == 0x001988, "Member 'UPlayerAnimInstance::BodyFocusAlphaDisableModifier' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, InteractingTag) == 0x00198C, "Member 'UPlayerAnimInstance::InteractingTag' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, SuicidalTag) == 0x001994, "Member 'UPlayerAnimInstance::SuicidalTag' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, PickupSmallTag) == 0x00199C, "Member 'UPlayerAnimInstance::PickupSmallTag' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, FocusWalkTag) == 0x0019A4, "Member 'UPlayerAnimInstance::FocusWalkTag' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, StealthTag) == 0x0019AC, "Member 'UPlayerAnimInstance::StealthTag' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, AimBlockTags) == 0x0019B8, "Member 'UPlayerAnimInstance::AimBlockTags' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, GrappledTags) == 0x0019D8, "Member 'UPlayerAnimInstance::GrappledTags' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, RightHandPose) == 0x0019F8, "Member 'UPlayerAnimInstance::RightHandPose' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, IsSuicidal) == 0x001A00, "Member 'UPlayerAnimInstance::IsSuicidal' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, FaceMontageOverrideBlendWeight) == 0x001A04, "Member 'UPlayerAnimInstance::FaceMontageOverrideBlendWeight' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, FaceMontageOverrideBlendTargetWeight) == 0x001A08, "Member 'UPlayerAnimInstance::FaceMontageOverrideBlendTargetWeight' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, FreezeTurnAngleSample) == 0x001A0C, "Member 'UPlayerAnimInstance::FreezeTurnAngleSample' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, ShouldTransitionToFastTurn) == 0x001A0D, "Member 'UPlayerAnimInstance::ShouldTransitionToFastTurn' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, DistanceRotationTurnAngle) == 0x001A10, "Member 'UPlayerAnimInstance::DistanceRotationTurnAngle' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, HeavyBreathAlpha) == 0x001A14, "Member 'UPlayerAnimInstance::HeavyBreathAlpha' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, HeavyBreathAlphaCurve) == 0x001A18, "Member 'UPlayerAnimInstance::HeavyBreathAlphaCurve' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, HasPickupSmallTag) == 0x001A20, "Member 'UPlayerAnimInstance::HasPickupSmallTag' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, HasFocuswalkTag) == 0x001A21, "Member 'UPlayerAnimInstance::HasFocuswalkTag' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, AimIsblocked) == 0x001A22, "Member 'UPlayerAnimInstance::AimIsblocked' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, ShouldPlayStillFullbodyMontage) == 0x001A23, "Member 'UPlayerAnimInstance::ShouldPlayStillFullbodyMontage' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, StillFullbodyMontageSlotName) == 0x001A24, "Member 'UPlayerAnimInstance::StillFullbodyMontageSlotName' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, FullbodyMontageSlotName) == 0x001A2C, "Member 'UPlayerAnimInstance::FullbodyMontageSlotName' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, BothArmsMontageSlotName) == 0x001A34, "Member 'UPlayerAnimInstance::BothArmsMontageSlotName' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, WallTwistArmTweaksInput) == 0x001A3C, "Member 'UPlayerAnimInstance::WallTwistArmTweaksInput' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, SprintTiltMaxAcceleration) == 0x001A40, "Member 'UPlayerAnimInstance::SprintTiltMaxAcceleration' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, SprintStartTilt) == 0x001A44, "Member 'UPlayerAnimInstance::SprintStartTilt' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, CarefulBlend) == 0x001A48, "Member 'UPlayerAnimInstance::CarefulBlend' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, LocomotionState) == 0x001A4C, "Member 'UPlayerAnimInstance::LocomotionState' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, FrozenPlaceLocomotionState) == 0x001A4D, "Member 'UPlayerAnimInstance::FrozenPlaceLocomotionState' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, IsOnStairs) == 0x001A4E, "Member 'UPlayerAnimInstance::IsOnStairs' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, LocomotionStateFreezeStates) == 0x001A50, "Member 'UPlayerAnimInstance::LocomotionStateFreezeStates' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, EnableRotationDelay) == 0x001A68, "Member 'UPlayerAnimInstance::EnableRotationDelay' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, MouthAnimationBaseLayer) == 0x001A70, "Member 'UPlayerAnimInstance::MouthAnimationBaseLayer' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, IsGrappled) == 0x001AA8, "Member 'UPlayerAnimInstance::IsGrappled' has a wrong offset!");
static_assert(offsetof(UPlayerAnimInstance, PlayerAnimInstanceProxy) == 0x001AB0, "Member 'UPlayerAnimInstance::PlayerAnimInstanceProxy' has a wrong offset!");

// Class ObsidianFox.PlayerAsyncTaskBlueprintProxyHolder_GameSubSystem
// 0x0010 (0x0040 - 0x0030)
class UPlayerAsyncTaskBlueprintProxyHolder_GameSubSystem final : public UGameInstanceSubsystem
{
public:
	TArray<class UPlayerAsyncTaskBlueprintProxy*> AllProxyObjects;                                   // 0x0030(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAsyncTaskBlueprintProxyHolder_GameSubSystem">();
	}
	static class UPlayerAsyncTaskBlueprintProxyHolder_GameSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAsyncTaskBlueprintProxyHolder_GameSubSystem>();
	}
};
static_assert(alignof(UPlayerAsyncTaskBlueprintProxyHolder_GameSubSystem) == 0x000008, "Wrong alignment on UPlayerAsyncTaskBlueprintProxyHolder_GameSubSystem");
static_assert(sizeof(UPlayerAsyncTaskBlueprintProxyHolder_GameSubSystem) == 0x000040, "Wrong size on UPlayerAsyncTaskBlueprintProxyHolder_GameSubSystem");
static_assert(offsetof(UPlayerAsyncTaskBlueprintProxyHolder_GameSubSystem, AllProxyObjects) == 0x000030, "Member 'UPlayerAsyncTaskBlueprintProxyHolder_GameSubSystem::AllProxyObjects' has a wrong offset!");

// Class ObsidianFox.WorldSubsystem_InteractionComponentManager
// 0x0000 (0x0030 - 0x0030)
class UWorldSubsystem_InteractionComponentManager final : public UWorldSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldSubsystem_InteractionComponentManager">();
	}
	static class UWorldSubsystem_InteractionComponentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldSubsystem_InteractionComponentManager>();
	}
};
static_assert(alignof(UWorldSubsystem_InteractionComponentManager) == 0x000008, "Wrong alignment on UWorldSubsystem_InteractionComponentManager");
static_assert(sizeof(UWorldSubsystem_InteractionComponentManager) == 0x000030, "Wrong size on UWorldSubsystem_InteractionComponentManager");

// Class ObsidianFox.PlayerCharacterMovementComponent
// 0x0050 (0x0FC0 - 0x0F70)
class UPlayerCharacterMovementComponent final : public UOFCharacterMovementComponent
{
public:
	FMulticastInlineDelegateProperty_             OnSprintInputStateChange;                          // 0x0F70(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_F80[0x8];                                      // 0x0F80(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AimRotationRate;                                   // 0x0F88(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_F94[0xC];                                      // 0x0F94(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bEnableCombatStrafe : 1;                           // 0x0FA0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_FA1[0x3];                                      // 0x0FA1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StrafeTime;                                        // 0x0FA4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FA8[0x4];                                      // 0x0FA8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CombatStrafeVisionCone;                            // 0x0FAC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAdjustToNavmesh : 1;                              // 0x0FB0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_FB1[0xF];                                      // 0x0FB1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SprintHoldPressed();
	void SprintHoldReleased();
	void SprintPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerCharacterMovementComponent">();
	}
	static class UPlayerCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerCharacterMovementComponent>();
	}
};
static_assert(alignof(UPlayerCharacterMovementComponent) == 0x000010, "Wrong alignment on UPlayerCharacterMovementComponent");
static_assert(sizeof(UPlayerCharacterMovementComponent) == 0x000FC0, "Wrong size on UPlayerCharacterMovementComponent");
static_assert(offsetof(UPlayerCharacterMovementComponent, OnSprintInputStateChange) == 0x000F70, "Member 'UPlayerCharacterMovementComponent::OnSprintInputStateChange' has a wrong offset!");
static_assert(offsetof(UPlayerCharacterMovementComponent, AimRotationRate) == 0x000F88, "Member 'UPlayerCharacterMovementComponent::AimRotationRate' has a wrong offset!");
static_assert(offsetof(UPlayerCharacterMovementComponent, StrafeTime) == 0x000FA4, "Member 'UPlayerCharacterMovementComponent::StrafeTime' has a wrong offset!");
static_assert(offsetof(UPlayerCharacterMovementComponent, CombatStrafeVisionCone) == 0x000FAC, "Member 'UPlayerCharacterMovementComponent::CombatStrafeVisionCone' has a wrong offset!");

// Class ObsidianFox.PlayerHitReactionComponent
// 0x00B0 (0x03C0 - 0x0310)
class UPlayerHitReactionComponent final : public UHitReactionComponent
{
public:
	float                                         MovingMontageThreshold;                            // 0x0308(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECardinalDirection, struct FGameplayTag> HeavyTags;                                         // 0x0310(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<ECardinalDirection, struct FGameplayTag> HeavyMovingTags;                                   // 0x0360(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x10];                                     // 0x03B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerPossessed(class AController* NewController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerHitReactionComponent">();
	}
	static class UPlayerHitReactionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerHitReactionComponent>();
	}
};
static_assert(alignof(UPlayerHitReactionComponent) == 0x000010, "Wrong alignment on UPlayerHitReactionComponent");
static_assert(sizeof(UPlayerHitReactionComponent) == 0x0003C0, "Wrong size on UPlayerHitReactionComponent");
static_assert(offsetof(UPlayerHitReactionComponent, MovingMontageThreshold) == 0x000308, "Member 'UPlayerHitReactionComponent::MovingMontageThreshold' has a wrong offset!");
static_assert(offsetof(UPlayerHitReactionComponent, HeavyTags) == 0x000310, "Member 'UPlayerHitReactionComponent::HeavyTags' has a wrong offset!");
static_assert(offsetof(UPlayerHitReactionComponent, HeavyMovingTags) == 0x000360, "Member 'UPlayerHitReactionComponent::HeavyMovingTags' has a wrong offset!");

// Class ObsidianFox.PlayerInteractionComponent
// 0x0150 (0x0208 - 0x00B8)
class UPlayerInteractionComponent final : public UActorComponent
{
public:
	float                                         StartupTickInterval;                               // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnNearbyInteractablesChanged;                      // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectionChanged;                                // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOpportunitySelectionChanged;                     // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExaminationSelectionChanged;                     // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bDrawDetectDebugSphere : 1;                        // 0x0100(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bDrawDebugSelectionSphere : 1;                     // 0x0100(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UInteractionComponentBase*>        InteractablesNearby;                               // 0x0108(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<ECollisionChannel>                     InteractableTraceObjectTypes;                      // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         InteractableSearchForwardDistance;                 // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractableSelectionOffsetDistance;               // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                InteractableSelectionOffset;                       // 0x0170(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SelectionMaxRange;                                 // 0x017C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInteractionComponentBase*              SelectedInteractable;                              // 0x0180(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EInteractionType, TWeakObjectPtr<class UInteractionComponentBase>> SelectedInteractables;                             // 0x0188(0x0050)(ExportObject, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         DiscoveryFrustumNearPlane;                         // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiscoveryFrustumBackwardOffset;                    // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiscoveryFrustumFOVModifier;                       // 0x01E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiscoveryCurrentRoomRadiusFallback;                // 0x01E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiscoveryCurrentRoomMaximumDistance;               // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiscoveryCurrentRoomPaddingDistance;               // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F0[0x18];                                     // 0x01F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UInteractionComponentBase* GetStandardSelectedInteractable();
	bool InteractWithSelected(class AOFPlayerCharacter* InteractingPlayer);
	void InterruptInteraction();
	void NearbyInteractablesChangedSignature__DelegateSignature(const TSet<class UInteractionComponentBase*>& NearbyInteractables, const TSet<class UInteractionComponentBase*>& AddedInteractables, const TSet<class UInteractionComponentBase*>& RemovedInteractables);
	void SelectionChangedSignature__DelegateSignature(const class UInteractionComponentBase* SelectedInteractable_0);
	void SetUseRoomFilter(bool bUseFilter);

	TSet<class UInteractionComponentBase*> GetInteractablesNearby() const;
	class UInteractionComponentBase* GetSelectedInteractable(EInteractionType Type) const;
	bool HasSelectedInteractable(EInteractionType Type) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInteractionComponent">();
	}
	static class UPlayerInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInteractionComponent>();
	}
};
static_assert(alignof(UPlayerInteractionComponent) == 0x000008, "Wrong alignment on UPlayerInteractionComponent");
static_assert(sizeof(UPlayerInteractionComponent) == 0x000208, "Wrong size on UPlayerInteractionComponent");
static_assert(offsetof(UPlayerInteractionComponent, StartupTickInterval) == 0x0000B8, "Member 'UPlayerInteractionComponent::StartupTickInterval' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, OnNearbyInteractablesChanged) == 0x0000C0, "Member 'UPlayerInteractionComponent::OnNearbyInteractablesChanged' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, OnSelectionChanged) == 0x0000D0, "Member 'UPlayerInteractionComponent::OnSelectionChanged' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, OnOpportunitySelectionChanged) == 0x0000E0, "Member 'UPlayerInteractionComponent::OnOpportunitySelectionChanged' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, OnExaminationSelectionChanged) == 0x0000F0, "Member 'UPlayerInteractionComponent::OnExaminationSelectionChanged' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, InteractablesNearby) == 0x000108, "Member 'UPlayerInteractionComponent::InteractablesNearby' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, InteractableTraceObjectTypes) == 0x000158, "Member 'UPlayerInteractionComponent::InteractableTraceObjectTypes' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, InteractableSearchForwardDistance) == 0x000168, "Member 'UPlayerInteractionComponent::InteractableSearchForwardDistance' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, InteractableSelectionOffsetDistance) == 0x00016C, "Member 'UPlayerInteractionComponent::InteractableSelectionOffsetDistance' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, InteractableSelectionOffset) == 0x000170, "Member 'UPlayerInteractionComponent::InteractableSelectionOffset' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, SelectionMaxRange) == 0x00017C, "Member 'UPlayerInteractionComponent::SelectionMaxRange' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, SelectedInteractable) == 0x000180, "Member 'UPlayerInteractionComponent::SelectedInteractable' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, SelectedInteractables) == 0x000188, "Member 'UPlayerInteractionComponent::SelectedInteractables' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, DiscoveryFrustumNearPlane) == 0x0001D8, "Member 'UPlayerInteractionComponent::DiscoveryFrustumNearPlane' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, DiscoveryFrustumBackwardOffset) == 0x0001DC, "Member 'UPlayerInteractionComponent::DiscoveryFrustumBackwardOffset' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, DiscoveryFrustumFOVModifier) == 0x0001E0, "Member 'UPlayerInteractionComponent::DiscoveryFrustumFOVModifier' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, DiscoveryCurrentRoomRadiusFallback) == 0x0001E4, "Member 'UPlayerInteractionComponent::DiscoveryCurrentRoomRadiusFallback' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, DiscoveryCurrentRoomMaximumDistance) == 0x0001E8, "Member 'UPlayerInteractionComponent::DiscoveryCurrentRoomMaximumDistance' has a wrong offset!");
static_assert(offsetof(UPlayerInteractionComponent, DiscoveryCurrentRoomPaddingDistance) == 0x0001EC, "Member 'UPlayerInteractionComponent::DiscoveryCurrentRoomPaddingDistance' has a wrong offset!");

// Class ObsidianFox.UIProgressBar
// 0x0088 (0x03A0 - 0x0318)
class UUIProgressBar final : public UProgressBar
{
public:
	struct FSlateBrush                            DamageFillImage;                                   // 0x0318(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIProgressBar">();
	}
	static class UUIProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIProgressBar>();
	}
};
static_assert(alignof(UUIProgressBar) == 0x000008, "Wrong alignment on UUIProgressBar");
static_assert(sizeof(UUIProgressBar) == 0x0003A0, "Wrong size on UUIProgressBar");
static_assert(offsetof(UUIProgressBar, DamageFillImage) == 0x000318, "Member 'UUIProgressBar::DamageFillImage' has a wrong offset!");

// Class ObsidianFox.PlayerLocationTrackingSubsystem
// 0x0048 (0x0078 - 0x0030)
class UPlayerLocationTrackingSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnEnterLocation;                                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnExitLocation;                                    // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnLocationUpdated__DelegateSignature(const struct FGameplayTagContainer& LocationTags);

	struct FGameplayTagContainer GetCurrentLocationTags() const;
	struct FGameplayTag GetDercetoLocationTag() const;
	bool PlayerIsInDerceto() const;
	bool PlayerIsInLocation(const struct FGameplayTag& LocationTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerLocationTrackingSubsystem">();
	}
	static class UPlayerLocationTrackingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerLocationTrackingSubsystem>();
	}
};
static_assert(alignof(UPlayerLocationTrackingSubsystem) == 0x000008, "Wrong alignment on UPlayerLocationTrackingSubsystem");
static_assert(sizeof(UPlayerLocationTrackingSubsystem) == 0x000078, "Wrong size on UPlayerLocationTrackingSubsystem");
static_assert(offsetof(UPlayerLocationTrackingSubsystem, OnEnterLocation) == 0x000030, "Member 'UPlayerLocationTrackingSubsystem::OnEnterLocation' has a wrong offset!");
static_assert(offsetof(UPlayerLocationTrackingSubsystem, OnExitLocation) == 0x000040, "Member 'UPlayerLocationTrackingSubsystem::OnExitLocation' has a wrong offset!");

// Class ObsidianFox.PlayerLocomotionStateAnimComponent
// 0x0098 (0x00F8 - 0x0060)
class UPlayerLocomotionStateAnimComponent : public ULocomotionStateAnimComponent
{
public:
	float                                         GroundAngleThreshold;                              // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxSlopeAngle;                                     // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StairGroundAngleThresholdReleaseSlack;             // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x2C];                                      // 0x006C(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ResistanceWalkTags;                                // 0x0098(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  SneakWalkTags;                                     // 0x00B8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  ResistanceWeatherTags;                             // 0x00D8(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerLocomotionStateAnimComponent">();
	}
	static class UPlayerLocomotionStateAnimComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerLocomotionStateAnimComponent>();
	}
};
static_assert(alignof(UPlayerLocomotionStateAnimComponent) == 0x000008, "Wrong alignment on UPlayerLocomotionStateAnimComponent");
static_assert(sizeof(UPlayerLocomotionStateAnimComponent) == 0x0000F8, "Wrong size on UPlayerLocomotionStateAnimComponent");
static_assert(offsetof(UPlayerLocomotionStateAnimComponent, GroundAngleThreshold) == 0x000060, "Member 'UPlayerLocomotionStateAnimComponent::GroundAngleThreshold' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionStateAnimComponent, MaxSlopeAngle) == 0x000064, "Member 'UPlayerLocomotionStateAnimComponent::MaxSlopeAngle' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionStateAnimComponent, StairGroundAngleThresholdReleaseSlack) == 0x000068, "Member 'UPlayerLocomotionStateAnimComponent::StairGroundAngleThresholdReleaseSlack' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionStateAnimComponent, ResistanceWalkTags) == 0x000098, "Member 'UPlayerLocomotionStateAnimComponent::ResistanceWalkTags' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionStateAnimComponent, SneakWalkTags) == 0x0000B8, "Member 'UPlayerLocomotionStateAnimComponent::SneakWalkTags' has a wrong offset!");
static_assert(offsetof(UPlayerLocomotionStateAnimComponent, ResistanceWeatherTags) == 0x0000D8, "Member 'UPlayerLocomotionStateAnimComponent::ResistanceWeatherTags' has a wrong offset!");

// Class ObsidianFox.PlayerMapMarker
// 0x0008 (0x0288 - 0x0280)
class UPlayerMapMarker : public UMapMarker
{
public:
	class UWidgetAnimation*                       HighlightMarkerAnimation;                          // 0x0280(0x0008)(Edit, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMapMarker">();
	}
	static class UPlayerMapMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMapMarker>();
	}
};
static_assert(alignof(UPlayerMapMarker) == 0x000008, "Wrong alignment on UPlayerMapMarker");
static_assert(sizeof(UPlayerMapMarker) == 0x000288, "Wrong size on UPlayerMapMarker");
static_assert(offsetof(UPlayerMapMarker, HighlightMarkerAnimation) == 0x000280, "Member 'UPlayerMapMarker::HighlightMarkerAnimation' has a wrong offset!");

// Class ObsidianFox.PlayerMoveToComponent
// 0x0028 (0x00E0 - 0x00B8)
class UPlayerMoveToComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             ReceiveMoveCompleted;                              // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     DefaultNavigationFilterClass;                      // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x10];                                      // 0x00D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMoveToComponent">();
	}
	static class UPlayerMoveToComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMoveToComponent>();
	}
};
static_assert(alignof(UPlayerMoveToComponent) == 0x000008, "Wrong alignment on UPlayerMoveToComponent");
static_assert(sizeof(UPlayerMoveToComponent) == 0x0000E0, "Wrong size on UPlayerMoveToComponent");
static_assert(offsetof(UPlayerMoveToComponent, ReceiveMoveCompleted) == 0x0000B8, "Member 'UPlayerMoveToComponent::ReceiveMoveCompleted' has a wrong offset!");
static_assert(offsetof(UPlayerMoveToComponent, DefaultNavigationFilterClass) == 0x0000C8, "Member 'UPlayerMoveToComponent::DefaultNavigationFilterClass' has a wrong offset!");

// Class ObsidianFox.PlayerStartTransitional
// 0x0008 (0x0270 - 0x0268)
class APlayerStartTransitional final : public APlayerStart
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitTransition(class AController* SpawnedController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStartTransitional">();
	}
	static class APlayerStartTransitional* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStartTransitional>();
	}
};
static_assert(alignof(APlayerStartTransitional) == 0x000008, "Wrong alignment on APlayerStartTransitional");
static_assert(sizeof(APlayerStartTransitional) == 0x000270, "Wrong size on APlayerStartTransitional");

// Class ObsidianFox.PlayerSubsystem_PlayerHUD
// 0x0028 (0x0058 - 0x0030)
class UPlayerSubsystem_PlayerHUD final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnPlayerHUDVisibilityChanged;                      // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MainStateChanged(EGameMainState OldState, EGameMainState NewGameState);
	void PlayerHealthStateChanged(EPlayerHealthState NewHealthState);
	void PlayerHUDVisibilitySignature__DelegateSignature(bool bNewHUDVisibility);
	void SetAllowedHUDVisibility(const bool bInAllowedHUDVisibility);
	void SetUpdateHUDFromMainStateChanged(const bool bInAllowedHUDVisibility);

	bool GetAllowedHUDVisibility() const;
	bool GetForceShowHealthBar() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerSubsystem_PlayerHUD">();
	}
	static class UPlayerSubsystem_PlayerHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerSubsystem_PlayerHUD>();
	}
};
static_assert(alignof(UPlayerSubsystem_PlayerHUD) == 0x000008, "Wrong alignment on UPlayerSubsystem_PlayerHUD");
static_assert(sizeof(UPlayerSubsystem_PlayerHUD) == 0x000058, "Wrong size on UPlayerSubsystem_PlayerHUD");
static_assert(offsetof(UPlayerSubsystem_PlayerHUD, OnPlayerHUDVisibilityChanged) == 0x000030, "Member 'UPlayerSubsystem_PlayerHUD::OnPlayerHUDVisibilityChanged' has a wrong offset!");

// Class ObsidianFox.PreloadLevelsGISubsystem
// 0x0148 (0x0178 - 0x0030)
class UPreloadLevelsGISubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x148];                                     // 0x0030(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPreActorBeginPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreloadLevelsGISubsystem">();
	}
	static class UPreloadLevelsGISubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreloadLevelsGISubsystem>();
	}
};
static_assert(alignof(UPreloadLevelsGISubsystem) == 0x000008, "Wrong alignment on UPreloadLevelsGISubsystem");
static_assert(sizeof(UPreloadLevelsGISubsystem) == 0x000178, "Wrong size on UPreloadLevelsGISubsystem");

// Class ObsidianFox.ProgressionDeveloperSettings
// 0x00E8 (0x0120 - 0x0038)
class UProgressionDeveloperSettings final : public UDeveloperSettings
{
public:
	TArray<struct FProgressionInfo>               ProgressionInfos;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              MissingLevelImage;                                 // 0x0048(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ChapterFactsTag;                                   // 0x0070(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, struct FChapterInfo>              ChapterMappings;                                   // 0x0078(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LevelFactsTag;                                     // 0x00C8(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EProgressLevel, struct FLevelInfo>       LevelMappings;                                     // 0x00D0(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionDeveloperSettings">();
	}
	static class UProgressionDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressionDeveloperSettings>();
	}
};
static_assert(alignof(UProgressionDeveloperSettings) == 0x000008, "Wrong alignment on UProgressionDeveloperSettings");
static_assert(sizeof(UProgressionDeveloperSettings) == 0x000120, "Wrong size on UProgressionDeveloperSettings");
static_assert(offsetof(UProgressionDeveloperSettings, ProgressionInfos) == 0x000038, "Member 'UProgressionDeveloperSettings::ProgressionInfos' has a wrong offset!");
static_assert(offsetof(UProgressionDeveloperSettings, MissingLevelImage) == 0x000048, "Member 'UProgressionDeveloperSettings::MissingLevelImage' has a wrong offset!");
static_assert(offsetof(UProgressionDeveloperSettings, ChapterFactsTag) == 0x000070, "Member 'UProgressionDeveloperSettings::ChapterFactsTag' has a wrong offset!");
static_assert(offsetof(UProgressionDeveloperSettings, ChapterMappings) == 0x000078, "Member 'UProgressionDeveloperSettings::ChapterMappings' has a wrong offset!");
static_assert(offsetof(UProgressionDeveloperSettings, LevelFactsTag) == 0x0000C8, "Member 'UProgressionDeveloperSettings::LevelFactsTag' has a wrong offset!");
static_assert(offsetof(UProgressionDeveloperSettings, LevelMappings) == 0x0000D0, "Member 'UProgressionDeveloperSettings::LevelMappings' has a wrong offset!");

// Class ObsidianFox.ProgressionSubsystem
// 0x0180 (0x01B0 - 0x0030)
class UProgressionSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnChapterUpdated;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLevelUpdated;                                    // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProgressionUpdated;                              // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x150];                                     // 0x0060(0x0150)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FactChangedHandler(const struct FGameplayTag& Tag, ESubscriptionTagChangeType ChangeType);
	void GameLoadedHandler(EPersistenceLoadResult Result, class USaveGameWorld* SaveGame);
	void GameSessionEndedHandler(class UGameplaySession* GameplaySession);
	void GameSessionStartedHandler(class UGameplaySession* GameplaySession);
	void SetChapterFactFromTag(const struct FGameplayTag& ChapterTag);
	void SetFactsFromProgressionTag(const struct FGameplayTag& ProgressionTag);
	void SetLevelFactFromTag(const struct FGameplayTag& LevelTag);

	class FText GetChapterName(const struct FGameplayTag& ChapterTag) const;
	struct FGameplayTag GetChapterTagFromProgression(const struct FGameplayTag& ProgressionTag) const;
	struct FGameplayTag GetCurrentChapter() const;
	class FText GetCurrentChapterName() const;
	struct FGameplayTag GetCurrentLevel() const;
	class FText GetCurrentLevelName() const;
	TSoftObjectPtr<class UTexture2D> GetCurrentMenuImage() const;
	struct FGameplayTag GetCurrentProgression() const;
	TSoftObjectPtr<class UTexture2D> GetCurrentSaveSlotImage() const;
	class FText GetLevelName(const struct FGameplayTag& LevelTag) const;
	struct FGameplayTag GetLevelTagFromProgression(const struct FGameplayTag& ProgressionTag) const;
	TSoftObjectPtr<class UTexture2D> GetLoadingScreenImage(const struct FGameplayTag& ProgressionTag) const;
	TSoftObjectPtr<class UTexture2D> GetMenuImage(const struct FGameplayTag& ProgressionTag) const;
	struct FGameplayTag GetProgressionTag(const struct FGameplayTag& ChapterTag, const struct FGameplayTag& LevelTag) const;
	TSoftObjectPtr<class UTexture2D> GetSaveSlotImage(const struct FGameplayTag& ProgressionTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionSubsystem">();
	}
	static class UProgressionSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressionSubsystem>();
	}
};
static_assert(alignof(UProgressionSubsystem) == 0x000008, "Wrong alignment on UProgressionSubsystem");
static_assert(sizeof(UProgressionSubsystem) == 0x0001B0, "Wrong size on UProgressionSubsystem");
static_assert(offsetof(UProgressionSubsystem, OnChapterUpdated) == 0x000030, "Member 'UProgressionSubsystem::OnChapterUpdated' has a wrong offset!");
static_assert(offsetof(UProgressionSubsystem, OnLevelUpdated) == 0x000040, "Member 'UProgressionSubsystem::OnLevelUpdated' has a wrong offset!");
static_assert(offsetof(UProgressionSubsystem, OnProgressionUpdated) == 0x000050, "Member 'UProgressionSubsystem::OnProgressionUpdated' has a wrong offset!");

// Class ObsidianFox.FocusPointSearchHandle
// 0x0000 (0x0028 - 0x0028)
class UFocusPointSearchHandle : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FocusPointSearchHandle">();
	}
	static class UFocusPointSearchHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFocusPointSearchHandle>();
	}
};
static_assert(alignof(UFocusPointSearchHandle) == 0x000008, "Wrong alignment on UFocusPointSearchHandle");
static_assert(sizeof(UFocusPointSearchHandle) == 0x000028, "Wrong size on UFocusPointSearchHandle");

// Class ObsidianFox.PSOCachingEngineSubsystem
// 0x0000 (0x0030 - 0x0030)
class UPSOCachingEngineSubsystem final : public UEngineSubsystem
{
public:
	void OnSettingsChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PSOCachingEngineSubsystem">();
	}
	static class UPSOCachingEngineSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPSOCachingEngineSubsystem>();
	}
};
static_assert(alignof(UPSOCachingEngineSubsystem) == 0x000008, "Wrong alignment on UPSOCachingEngineSubsystem");
static_assert(sizeof(UPSOCachingEngineSubsystem) == 0x000030, "Wrong size on UPSOCachingEngineSubsystem");

// Class ObsidianFox.StarWorldActor
// 0x0000 (0x0238 - 0x0238)
class AStarWorldActor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StarWorldActor">();
	}
	static class AStarWorldActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStarWorldActor>();
	}
};
static_assert(alignof(AStarWorldActor) == 0x000008, "Wrong alignment on AStarWorldActor");
static_assert(sizeof(AStarWorldActor) == 0x000238, "Wrong size on AStarWorldActor");

// Class ObsidianFox.PTPCameraModifier_Aim
// 0x0008 (0x0570 - 0x0568)
class UPTPCameraModifier_Aim : public UPTPCameraModifier_BoneTracker
{
public:
	float                                         AimSensitivityModifer;                             // 0x0568(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_56C[0x4];                                      // 0x056C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PTPCameraModifier_Aim">();
	}
	static class UPTPCameraModifier_Aim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPTPCameraModifier_Aim>();
	}
};
static_assert(alignof(UPTPCameraModifier_Aim) == 0x000008, "Wrong alignment on UPTPCameraModifier_Aim");
static_assert(sizeof(UPTPCameraModifier_Aim) == 0x000570, "Wrong size on UPTPCameraModifier_Aim");
static_assert(offsetof(UPTPCameraModifier_Aim, AimSensitivityModifer) == 0x000568, "Member 'UPTPCameraModifier_Aim::AimSensitivityModifer' has a wrong offset!");

// Class ObsidianFox.RailingSplineComponent
// 0x0000 (0x0560 - 0x0560)
class URailingSplineComponent final : public USplineComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RailingSplineComponent">();
	}
	static class URailingSplineComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URailingSplineComponent>();
	}
};
static_assert(alignof(URailingSplineComponent) == 0x000010, "Wrong alignment on URailingSplineComponent");
static_assert(sizeof(URailingSplineComponent) == 0x000560, "Wrong size on URailingSplineComponent");

// Class ObsidianFox.SaveBFL
// 0x0000 (0x0028 - 0x0028)
class USaveBFL final : public UBlueprintFunctionLibrary
{
public:
	static void SaveVariableDoOnce(bool& SaveVariable, ESaveBFLDoOnceExec* Branches);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SaveBFL">();
	}
	static class USaveBFL* GetDefaultObj()
	{
		return GetDefaultObjImpl<USaveBFL>();
	}
};
static_assert(alignof(USaveBFL) == 0x000008, "Wrong alignment on USaveBFL");
static_assert(sizeof(USaveBFL) == 0x000028, "Wrong size on USaveBFL");

// Class ObsidianFox.ShubAnimInstance
// 0x0000 (0x1210 - 0x1210)
class UShubAnimInstance final : public UEnemyAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShubAnimInstance">();
	}
	static class UShubAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShubAnimInstance>();
	}
};
static_assert(alignof(UShubAnimInstance) == 0x000010, "Wrong alignment on UShubAnimInstance");
static_assert(sizeof(UShubAnimInstance) == 0x001210, "Wrong size on UShubAnimInstance");

// Class ObsidianFox.SolventSubsystem
// 0x0060 (0x0090 - 0x0030)
class USolventSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateGauntlet(class AActor* SplinePath, float MaxTime, ESolventGauntlet* Action);
	void EndGauntlet(ESolventGauntlet* Action);
	struct FVector GetGauntletEndLocation();
	int32 GetGauntletEndSplinePoint();
	struct FVector GetGauntletStartLocation();
	float GetGauntletTimer();
	float GetMaxTimeInGauntlet();
	struct FVector GetPathLocation(float Distance);
	struct FVector GetPlayerPosition();
	float GetProgressPercent();
	struct FVector GetSplinePosition();
	float GetTimePercent();
	bool IsGauntletActive();
	bool IsGauntletReversed();
	void StartGauntlet(class AActor* SplinePath, float MaxTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SolventSubsystem">();
	}
	static class USolventSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USolventSubsystem>();
	}
};
static_assert(alignof(USolventSubsystem) == 0x000008, "Wrong alignment on USolventSubsystem");
static_assert(sizeof(USolventSubsystem) == 0x000090, "Wrong size on USolventSubsystem");

// Class ObsidianFox.SplineMovementComponent
// 0x0080 (0x0138 - 0x00B8)
class USplineMovementComponent final : public UActorComponent
{
public:
	float                                         Acceleration;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Deceleration;                                      // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x4];                                       // 0x00C0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpVectorInterpolationSpeed;                        // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bOrientTowardsMovement : 1;                        // 0x00C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationRate;                                      // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Velocity;                                          // 0x00D8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E4[0x54];                                      // 0x00E4(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MoveBackward();
	void MoveForward();
	void StartSplineMovement(class USplineComponent* Spline);
	void StopAutomatedSplineMovement();
	void StopSplineMovement(EMovementMode NewMovementMode);

	bool IsOnSpline() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineMovementComponent">();
	}
	static class USplineMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USplineMovementComponent>();
	}
};
static_assert(alignof(USplineMovementComponent) == 0x000008, "Wrong alignment on USplineMovementComponent");
static_assert(sizeof(USplineMovementComponent) == 0x000138, "Wrong size on USplineMovementComponent");
static_assert(offsetof(USplineMovementComponent, Acceleration) == 0x0000B8, "Member 'USplineMovementComponent::Acceleration' has a wrong offset!");
static_assert(offsetof(USplineMovementComponent, Deceleration) == 0x0000BC, "Member 'USplineMovementComponent::Deceleration' has a wrong offset!");
static_assert(offsetof(USplineMovementComponent, UpVectorInterpolationSpeed) == 0x0000C4, "Member 'USplineMovementComponent::UpVectorInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(USplineMovementComponent, RotationRate) == 0x0000CC, "Member 'USplineMovementComponent::RotationRate' has a wrong offset!");
static_assert(offsetof(USplineMovementComponent, Velocity) == 0x0000D8, "Member 'USplineMovementComponent::Velocity' has a wrong offset!");

// Class ObsidianFox.StartleComponent
// 0x0000 (0x0210 - 0x0210)
class UStartleComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartleComponent">();
	}
	static class UStartleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStartleComponent>();
	}
};
static_assert(alignof(UStartleComponent) == 0x000010, "Wrong alignment on UStartleComponent");
static_assert(sizeof(UStartleComponent) == 0x000210, "Wrong size on UStartleComponent");

// Class ObsidianFox.StartleInterface
// 0x0000 (0x0028 - 0x0028)
class IStartleInterface final : public IInterface
{
public:
	void OnStartle(const struct FFocusPointData& StartleComponentData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartleInterface">();
	}
	static class IStartleInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStartleInterface>();
	}
};
static_assert(alignof(IStartleInterface) == 0x000008, "Wrong alignment on IStartleInterface");
static_assert(sizeof(IStartleInterface) == 0x000028, "Wrong size on IStartleInterface");

// Class ObsidianFox.SteamboatCreatureAnimInstance
// 0x0000 (0x1210 - 0x1210)
class USteamboatCreatureAnimInstance final : public UEnemyAnimInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamboatCreatureAnimInstance">();
	}
	static class USteamboatCreatureAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamboatCreatureAnimInstance>();
	}
};
static_assert(alignof(USteamboatCreatureAnimInstance) == 0x000010, "Wrong alignment on USteamboatCreatureAnimInstance");
static_assert(sizeof(USteamboatCreatureAnimInstance) == 0x001210, "Wrong size on USteamboatCreatureAnimInstance");

// Class ObsidianFox.Talisman
// 0x0000 (0x03C0 - 0x03C0)
class ATalisman : public APuzzleActor
{
public:
	bool CheckCombination(int32 Combination, struct FGameplayTag* FlowTag) const;
	bool CheckCurrentCombination(struct FGameplayTag* FlowTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Talisman">();
	}
	static class ATalisman* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATalisman>();
	}
};
static_assert(alignof(ATalisman) == 0x000008, "Wrong alignment on ATalisman");
static_assert(sizeof(ATalisman) == 0x0003C0, "Wrong size on ATalisman");

// Class ObsidianFox.TimedObjectiveSubsystem
// 0x0148 (0x0178 - 0x0030)
class UTimedObjectiveSubsystem final : public UGameplaySessionSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, struct FTimedObjective> TimedObjectives;                                   // 0x0038(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	TArray<struct FTimedObjective>                ObjectivesWaiting;                                 // 0x0088(0x0010)(ZeroConstructor, SaveGame, NativeAccessSpecifierPrivate)
	TSet<ETimerPauseSource>                       PauseTimerSources;                                 // 0x0098(0x0050)(SaveGame, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x90];                                      // 0x00E8(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelTimer(const struct FGameplayTag& IdentityTag);
	float GetRemainingObjectiveTime(const struct FGameplayTag& IdentityTag);
	bool IsObjectPauseSource(class UObject* SourceObject);
	void OnCustomPauseSourcesValueUpdatedHandler(bool bNewValue);
	void OnLocationEnterHandler(const struct FGameplayTagContainer& LocationTags);
	void OnLocationExitHandler(const struct FGameplayTagContainer& LocationTags);
	void OnMainGameStateUpdatedHandler(EGameMainState OldGameState, EGameMainState NewGameState);
	void PauseAllTimers(class UObject* SourceObject);
	void PauseTimer(const struct FGameplayTag& IdentityTag);
	void ResumeAllTimers(class UObject* SourceObject);
	void ResumeTimer(const struct FGameplayTag& IdentityTag);
	void StartMinimumWaitTime();
	void StartTimedObjective(class UObjectivesData* ObjectiveData, EObjectiveParts Part, float Time, const struct FGameplayTag& IdentityTag, const struct FGameplayTag& InObjectiveTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedObjectiveSubsystem">();
	}
	static class UTimedObjectiveSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimedObjectiveSubsystem>();
	}
};
static_assert(alignof(UTimedObjectiveSubsystem) == 0x000008, "Wrong alignment on UTimedObjectiveSubsystem");
static_assert(sizeof(UTimedObjectiveSubsystem) == 0x000178, "Wrong size on UTimedObjectiveSubsystem");
static_assert(offsetof(UTimedObjectiveSubsystem, TimedObjectives) == 0x000038, "Member 'UTimedObjectiveSubsystem::TimedObjectives' has a wrong offset!");
static_assert(offsetof(UTimedObjectiveSubsystem, ObjectivesWaiting) == 0x000088, "Member 'UTimedObjectiveSubsystem::ObjectivesWaiting' has a wrong offset!");
static_assert(offsetof(UTimedObjectiveSubsystem, PauseTimerSources) == 0x000098, "Member 'UTimedObjectiveSubsystem::PauseTimerSources' has a wrong offset!");

// Class ObsidianFox.UISlider
// 0x0018 (0x0510 - 0x04F8)
class UUISlider final : public USlider
{
public:
	uint8                                         Pad_4F8[0x18];                                     // 0x04F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UISlider">();
	}
	static class UUISlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUISlider>();
	}
};
static_assert(alignof(UUISlider) == 0x000008, "Wrong alignment on UUISlider");
static_assert(sizeof(UUISlider) == 0x000510, "Wrong size on UUISlider");

// Class ObsidianFox.WaterLevelTriggerVolume
// 0x0000 (0x0240 - 0x0240)
class AWaterLevelTriggerVolume final : public ATriggerBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaterLevelTriggerVolume">();
	}
	static class AWaterLevelTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaterLevelTriggerVolume>();
	}
};
static_assert(alignof(AWaterLevelTriggerVolume) == 0x000008, "Wrong alignment on AWaterLevelTriggerVolume");
static_assert(sizeof(AWaterLevelTriggerVolume) == 0x000240, "Wrong size on AWaterLevelTriggerVolume");

// Class ObsidianFox.WeaponAnimationHandDataAsset
// 0x0050 (0x0080 - 0x0030)
class UWeaponAnimationHandDataAsset final : public UDataAsset
{
public:
	TMap<EPlayerCharacterType, struct FWeaponAnimationHandData> CharacterPoseMapping;                              // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	struct FWeaponAnimationHandData GetAnimationDataForCharacter(const class AOFPlayerCharacter* Character) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAnimationHandDataAsset">();
	}
	static class UWeaponAnimationHandDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAnimationHandDataAsset>();
	}
};
static_assert(alignof(UWeaponAnimationHandDataAsset) == 0x000008, "Wrong alignment on UWeaponAnimationHandDataAsset");
static_assert(sizeof(UWeaponAnimationHandDataAsset) == 0x000080, "Wrong size on UWeaponAnimationHandDataAsset");
static_assert(offsetof(UWeaponAnimationHandDataAsset, CharacterPoseMapping) == 0x000030, "Member 'UWeaponAnimationHandDataAsset::CharacterPoseMapping' has a wrong offset!");

// Class ObsidianFox.WeaponAnimInstance
// 0x0020 (0x02F0 - 0x02D0)
class UWeaponAnimInstance : public UAnimInstance
{
public:
	class AObsidianFoxCharacter*                  OwnerChar;                                         // 0x02C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOFPlayerCharacter*                     PlayerOwner;                                       // 0x02D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 OwnerComponent;                                    // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AOFWeaponActor*                         WeaponOwner;                                       // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MoveSpeed;                                         // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPlayerCharacterType                          PlayerCharacterType;                               // 0x02EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsOwnerCharacterAiming;                            // 0x02ED(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EE[0x2];                                      // 0x02EE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool StateTimeoutReached(int32 MachineIndex, float Timeout);

	bool IsAttachedToSocket(class FName SocketName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponAnimInstance">();
	}
	static class UWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponAnimInstance>();
	}
};
static_assert(alignof(UWeaponAnimInstance) == 0x000010, "Wrong alignment on UWeaponAnimInstance");
static_assert(sizeof(UWeaponAnimInstance) == 0x0002F0, "Wrong size on UWeaponAnimInstance");
static_assert(offsetof(UWeaponAnimInstance, OwnerChar) == 0x0002C8, "Member 'UWeaponAnimInstance::OwnerChar' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, PlayerOwner) == 0x0002D0, "Member 'UWeaponAnimInstance::PlayerOwner' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, OwnerComponent) == 0x0002D8, "Member 'UWeaponAnimInstance::OwnerComponent' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, WeaponOwner) == 0x0002E0, "Member 'UWeaponAnimInstance::WeaponOwner' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, MoveSpeed) == 0x0002E8, "Member 'UWeaponAnimInstance::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, PlayerCharacterType) == 0x0002EC, "Member 'UWeaponAnimInstance::PlayerCharacterType' has a wrong offset!");
static_assert(offsetof(UWeaponAnimInstance, IsOwnerCharacterAiming) == 0x0002ED, "Member 'UWeaponAnimInstance::IsOwnerCharacterAiming' has a wrong offset!");

// Class ObsidianFox.WeaponWidget
// 0x0008 (0x0280 - 0x0278)
class UWeaponWidget final : public UInGameUIWidget
{
public:
	class AOFWeaponActor*                         MonitoredWeapon;                                   // 0x0278(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnMonitoredWeaponDestroyed(class AActor* DestroyedActor);
	void OnMonitoredWeaponEquipped(class AOFWeaponActor* DestroyedActor);
	void OnMonitoredWeaponUnequipped(class AOFWeaponActor* DestroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WeaponWidget">();
	}
	static class UWeaponWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWeaponWidget>();
	}
};
static_assert(alignof(UWeaponWidget) == 0x000008, "Wrong alignment on UWeaponWidget");
static_assert(sizeof(UWeaponWidget) == 0x000280, "Wrong size on UWeaponWidget");
static_assert(offsetof(UWeaponWidget, MonitoredWeapon) == 0x000278, "Member 'UWeaponWidget::MonitoredWeapon' has a wrong offset!");

// Class ObsidianFox.WorldSubsystem_EQSPlayerValidPoints
// 0x0040 (0x0070 - 0x0030)
class UWorldSubsystem_EQSPlayerValidPoints final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x40];                                      // 0x0030(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetNearbyPoints(const TArray<struct FVector>& Points);

	const TArray<struct FVector> GetNearbyPoints() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldSubsystem_EQSPlayerValidPoints">();
	}
	static class UWorldSubsystem_EQSPlayerValidPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldSubsystem_EQSPlayerValidPoints>();
	}
};
static_assert(alignof(UWorldSubsystem_EQSPlayerValidPoints) == 0x000008, "Wrong alignment on UWorldSubsystem_EQSPlayerValidPoints");
static_assert(sizeof(UWorldSubsystem_EQSPlayerValidPoints) == 0x000070, "Wrong size on UWorldSubsystem_EQSPlayerValidPoints");

// Class ObsidianFox.FocusPointSearchHandleWithData
// 0x0108 (0x0130 - 0x0028)
class UFocusPointSearchHandleWithData final : public UFocusPointSearchHandle
{
public:
	uint8                                         Pad_28[0x108];                                     // 0x0028(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FocusPointSearchHandleWithData">();
	}
	static class UFocusPointSearchHandleWithData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFocusPointSearchHandleWithData>();
	}
};
static_assert(alignof(UFocusPointSearchHandleWithData) == 0x000008, "Wrong alignment on UFocusPointSearchHandleWithData");
static_assert(sizeof(UFocusPointSearchHandleWithData) == 0x000130, "Wrong size on UFocusPointSearchHandleWithData");

// Class ObsidianFox.WorldSubsystem_MonsterManager
// 0x0000 (0x0030 - 0x0030)
class UWorldSubsystem_MonsterManager final : public UWorldSubsystem
{
public:
	void MonsterDisengaged(class AObsidianFoxCharacter* OFCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldSubsystem_MonsterManager">();
	}
	static class UWorldSubsystem_MonsterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldSubsystem_MonsterManager>();
	}
};
static_assert(alignof(UWorldSubsystem_MonsterManager) == 0x000008, "Wrong alignment on UWorldSubsystem_MonsterManager");
static_assert(sizeof(UWorldSubsystem_MonsterManager) == 0x000030, "Wrong size on UWorldSubsystem_MonsterManager");

// Class ObsidianFox.WorldSubsystem_MoodCompManager
// 0x0050 (0x0080 - 0x0030)
class UWorldSubsystem_MoodCompManager final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldSubsystem_MoodCompManager">();
	}
	static class UWorldSubsystem_MoodCompManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldSubsystem_MoodCompManager>();
	}
};
static_assert(alignof(UWorldSubsystem_MoodCompManager) == 0x000008, "Wrong alignment on UWorldSubsystem_MoodCompManager");
static_assert(sizeof(UWorldSubsystem_MoodCompManager) == 0x000080, "Wrong size on UWorldSubsystem_MoodCompManager");

}

