#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PiecesFlowGraph

#include "Basic.hpp"

#include "PiecesFlowGraph_structs.hpp"
#include "Flow_structs.hpp"
#include "Flow_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_classes.hpp"
#include "PiecesFactsDB_structs.hpp"
#include "DeveloperSettings_classes.hpp"


namespace SDK
{

// Class PiecesFlowGraph.FlowActivatorComponent
// 0x0010 (0x01E0 - 0x01D0)
class UFlowActivatorComponent final : public UFlowComponent
{
public:
	EFlowActivatorComponentSelection              ComponentSelection;                                // 0x01D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ComponentTag;                                      // 0x01D4(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bResetComponent : 1;                               // 0x01DC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1DD[0x3];                                      // 0x01DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowActivatorComponent">();
	}
	static class UFlowActivatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowActivatorComponent>();
	}
};
static_assert(alignof(UFlowActivatorComponent) == 0x000008, "Wrong alignment on UFlowActivatorComponent");
static_assert(sizeof(UFlowActivatorComponent) == 0x0001E0, "Wrong size on UFlowActivatorComponent");
static_assert(offsetof(UFlowActivatorComponent, ComponentSelection) == 0x0001D0, "Member 'UFlowActivatorComponent::ComponentSelection' has a wrong offset!");
static_assert(offsetof(UFlowActivatorComponent, ComponentTag) == 0x0001D4, "Member 'UFlowActivatorComponent::ComponentTag' has a wrong offset!");

// Class PiecesFlowGraph.FlowLevelStreamingComponent
// 0x0008 (0x01D8 - 0x01D0)
class UFlowLevelStreamingComponent final : public UFlowComponent
{
public:
	bool                                          bHideLevelsOnDisable;                              // 0x01D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReceiveNotify(class UFlowComponent* FlowComponent, const struct FGameplayTag& NotifyTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowLevelStreamingComponent">();
	}
	static class UFlowLevelStreamingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowLevelStreamingComponent>();
	}
};
static_assert(alignof(UFlowLevelStreamingComponent) == 0x000008, "Wrong alignment on UFlowLevelStreamingComponent");
static_assert(sizeof(UFlowLevelStreamingComponent) == 0x0001D8, "Wrong size on UFlowLevelStreamingComponent");
static_assert(offsetof(UFlowLevelStreamingComponent, bHideLevelsOnDisable) == 0x0001D0, "Member 'UFlowLevelStreamingComponent::bHideLevelsOnDisable' has a wrong offset!");

// Class PiecesFlowGraph.FlowLevelStreamingVolume
// 0x0008 (0x0290 - 0x0288)
class AFlowLevelStreamingVolume final : public ALevelStreamingVolume
{
public:
	class UFlowLevelStreamingComponent*           FlowLevelStreamingComponent;                       // 0x0288(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowLevelStreamingVolume">();
	}
	static class AFlowLevelStreamingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlowLevelStreamingVolume>();
	}
};
static_assert(alignof(AFlowLevelStreamingVolume) == 0x000008, "Wrong alignment on AFlowLevelStreamingVolume");
static_assert(sizeof(AFlowLevelStreamingVolume) == 0x000290, "Wrong size on AFlowLevelStreamingVolume");
static_assert(offsetof(AFlowLevelStreamingVolume, FlowLevelStreamingComponent) == 0x000288, "Member 'AFlowLevelStreamingVolume::FlowLevelStreamingComponent' has a wrong offset!");

// Class PiecesFlowGraph.FlowNode_FactsDB
// 0x0010 (0x01E0 - 0x01D0)
class UFlowNode_FactsDB : public UFlowNode
{
public:
	struct FGameplayTag                           FactTag;                                           // 0x01D0(0x0008)(Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D8[0x8];                                      // 0x01D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_FactsDB">();
	}
	static class UFlowNode_FactsDB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_FactsDB>();
	}
};
static_assert(alignof(UFlowNode_FactsDB) == 0x000008, "Wrong alignment on UFlowNode_FactsDB");
static_assert(sizeof(UFlowNode_FactsDB) == 0x0001E0, "Wrong size on UFlowNode_FactsDB");
static_assert(offsetof(UFlowNode_FactsDB, FactTag) == 0x0001D0, "Member 'UFlowNode_FactsDB::FactTag' has a wrong offset!");

// Class PiecesFlowGraph.FlowNode_FactDBDoOnce
// 0x0000 (0x01E0 - 0x01E0)
class UFlowNode_FactDBDoOnce final : public UFlowNode_FactsDB
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_FactDBDoOnce">();
	}
	static class UFlowNode_FactDBDoOnce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_FactDBDoOnce>();
	}
};
static_assert(alignof(UFlowNode_FactDBDoOnce) == 0x000008, "Wrong alignment on UFlowNode_FactDBDoOnce");
static_assert(sizeof(UFlowNode_FactDBDoOnce) == 0x0001E0, "Wrong size on UFlowNode_FactDBDoOnce");

// Class PiecesFlowGraph.FlowNode_FactDB_OnFactUpdated
// 0x0020 (0x0200 - 0x01E0)
class UFlowNode_FactDB_OnFactUpdated final : public UFlowNode_FactsDB
{
public:
	bool                                          bNeedSpecificValue;                                // 0x01E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E1[0x3];                                      // 0x01E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RequiredValue;                                     // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNeedSpecificChangeType;                           // 0x01E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESubscriptionTagChangeType                    RequiredChangeType;                                // 0x01E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1EA[0x16];                                     // 0x01EA(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FactUpdatedHandler(const struct FGameplayTag& Tag, ESubscriptionTagChangeType ChangeType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_FactDB_OnFactUpdated">();
	}
	static class UFlowNode_FactDB_OnFactUpdated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_FactDB_OnFactUpdated>();
	}
};
static_assert(alignof(UFlowNode_FactDB_OnFactUpdated) == 0x000008, "Wrong alignment on UFlowNode_FactDB_OnFactUpdated");
static_assert(sizeof(UFlowNode_FactDB_OnFactUpdated) == 0x000200, "Wrong size on UFlowNode_FactDB_OnFactUpdated");
static_assert(offsetof(UFlowNode_FactDB_OnFactUpdated, bNeedSpecificValue) == 0x0001E0, "Member 'UFlowNode_FactDB_OnFactUpdated::bNeedSpecificValue' has a wrong offset!");
static_assert(offsetof(UFlowNode_FactDB_OnFactUpdated, RequiredValue) == 0x0001E4, "Member 'UFlowNode_FactDB_OnFactUpdated::RequiredValue' has a wrong offset!");
static_assert(offsetof(UFlowNode_FactDB_OnFactUpdated, bNeedSpecificChangeType) == 0x0001E8, "Member 'UFlowNode_FactDB_OnFactUpdated::bNeedSpecificChangeType' has a wrong offset!");
static_assert(offsetof(UFlowNode_FactDB_OnFactUpdated, RequiredChangeType) == 0x0001E9, "Member 'UFlowNode_FactDB_OnFactUpdated::RequiredChangeType' has a wrong offset!");

// Class PiecesFlowGraph.FlowNode_FactsDB_Bool
// 0x0000 (0x01E0 - 0x01E0)
class UFlowNode_FactsDB_Bool : public UFlowNode_FactsDB
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_FactsDB_Bool">();
	}
	static class UFlowNode_FactsDB_Bool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_FactsDB_Bool>();
	}
};
static_assert(alignof(UFlowNode_FactsDB_Bool) == 0x000008, "Wrong alignment on UFlowNode_FactsDB_Bool");
static_assert(sizeof(UFlowNode_FactsDB_Bool) == 0x0001E0, "Wrong size on UFlowNode_FactsDB_Bool");

// Class PiecesFlowGraph.FlowNode_FactsDB_Comparator
// 0x0008 (0x01E8 - 0x01E0)
class UFlowNode_FactsDB_Comparator : public UFlowNode_FactsDB
{
public:
	int32                                         Value;                                             // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bTreatMissingFactAsZero : 1;                       // 0x01E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1E5[0x3];                                      // 0x01E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_FactsDB_Comparator">();
	}
	static class UFlowNode_FactsDB_Comparator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_FactsDB_Comparator>();
	}
};
static_assert(alignof(UFlowNode_FactsDB_Comparator) == 0x000008, "Wrong alignment on UFlowNode_FactsDB_Comparator");
static_assert(sizeof(UFlowNode_FactsDB_Comparator) == 0x0001E8, "Wrong size on UFlowNode_FactsDB_Comparator");
static_assert(offsetof(UFlowNode_FactsDB_Comparator, Value) == 0x0001E0, "Member 'UFlowNode_FactsDB_Comparator::Value' has a wrong offset!");

// Class PiecesFlowGraph.FlowNode_FactsDB_DoesFactExist
// 0x0000 (0x01E0 - 0x01E0)
class UFlowNode_FactsDB_DoesFactExist final : public UFlowNode_FactsDB
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_FactsDB_DoesFactExist">();
	}
	static class UFlowNode_FactsDB_DoesFactExist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_FactsDB_DoesFactExist>();
	}
};
static_assert(alignof(UFlowNode_FactsDB_DoesFactExist) == 0x000008, "Wrong alignment on UFlowNode_FactsDB_DoesFactExist");
static_assert(sizeof(UFlowNode_FactsDB_DoesFactExist) == 0x0001E0, "Wrong size on UFlowNode_FactsDB_DoesFactExist");

// Class PiecesFlowGraph.FlowNode_FactsDB_Increment
// 0x0008 (0x01E8 - 0x01E0)
class UFlowNode_FactsDB_Increment final : public UFlowNode_FactsDB
{
public:
	int32                                         Increment;                                         // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAddIfMissing : 1;                                 // 0x01E4(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1E5[0x3];                                      // 0x01E5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_FactsDB_Increment">();
	}
	static class UFlowNode_FactsDB_Increment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_FactsDB_Increment>();
	}
};
static_assert(alignof(UFlowNode_FactsDB_Increment) == 0x000008, "Wrong alignment on UFlowNode_FactsDB_Increment");
static_assert(sizeof(UFlowNode_FactsDB_Increment) == 0x0001E8, "Wrong size on UFlowNode_FactsDB_Increment");
static_assert(offsetof(UFlowNode_FactsDB_Increment, Increment) == 0x0001E0, "Member 'UFlowNode_FactsDB_Increment::Increment' has a wrong offset!");

// Class PiecesFlowGraph.FlowNode_FactsDB_IncrementComp
// 0x0008 (0x01F0 - 0x01E8)
class UFlowNode_FactsDB_IncrementComp final : public UFlowNode_FactsDB_Comparator
{
public:
	int32                                         Increment;                                         // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         bAddIfMissing : 1;                                 // 0x01EC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1ED[0x3];                                      // 0x01ED(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_FactsDB_IncrementComp">();
	}
	static class UFlowNode_FactsDB_IncrementComp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_FactsDB_IncrementComp>();
	}
};
static_assert(alignof(UFlowNode_FactsDB_IncrementComp) == 0x000008, "Wrong alignment on UFlowNode_FactsDB_IncrementComp");
static_assert(sizeof(UFlowNode_FactsDB_IncrementComp) == 0x0001F0, "Wrong size on UFlowNode_FactsDB_IncrementComp");
static_assert(offsetof(UFlowNode_FactsDB_IncrementComp, Increment) == 0x0001E8, "Member 'UFlowNode_FactsDB_IncrementComp::Increment' has a wrong offset!");

// Class PiecesFlowGraph.FlowNode_FactsDB_IsFactTrue
// 0x0008 (0x01E8 - 0x01E0)
class UFlowNode_FactsDB_IsFactTrue final : public UFlowNode_FactsDB_Bool
{
public:
	uint8                                         bTriggerFalseIfMissing : 1;                        // 0x01E0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_1E1[0x7];                                      // 0x01E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_FactsDB_IsFactTrue">();
	}
	static class UFlowNode_FactsDB_IsFactTrue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_FactsDB_IsFactTrue>();
	}
};
static_assert(alignof(UFlowNode_FactsDB_IsFactTrue) == 0x000008, "Wrong alignment on UFlowNode_FactsDB_IsFactTrue");
static_assert(sizeof(UFlowNode_FactsDB_IsFactTrue) == 0x0001E8, "Wrong size on UFlowNode_FactsDB_IsFactTrue");

// Class PiecesFlowGraph.FlowNode_FactsDB_RemoveFact
// 0x0000 (0x01E0 - 0x01E0)
class UFlowNode_FactsDB_RemoveFact final : public UFlowNode_FactsDB
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_FactsDB_RemoveFact">();
	}
	static class UFlowNode_FactsDB_RemoveFact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_FactsDB_RemoveFact>();
	}
};
static_assert(alignof(UFlowNode_FactsDB_RemoveFact) == 0x000008, "Wrong alignment on UFlowNode_FactsDB_RemoveFact");
static_assert(sizeof(UFlowNode_FactsDB_RemoveFact) == 0x0001E0, "Wrong size on UFlowNode_FactsDB_RemoveFact");

// Class PiecesFlowGraph.FlowNode_FactsDB_SetFactBool
// 0x0008 (0x01E8 - 0x01E0)
class UFlowNode_FactsDB_SetFactBool final : public UFlowNode_FactsDB_Bool
{
public:
	bool                                          Value;                                             // 0x01E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0x7];                                      // 0x01E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_FactsDB_SetFactBool">();
	}
	static class UFlowNode_FactsDB_SetFactBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_FactsDB_SetFactBool>();
	}
};
static_assert(alignof(UFlowNode_FactsDB_SetFactBool) == 0x000008, "Wrong alignment on UFlowNode_FactsDB_SetFactBool");
static_assert(sizeof(UFlowNode_FactsDB_SetFactBool) == 0x0001E8, "Wrong size on UFlowNode_FactsDB_SetFactBool");
static_assert(offsetof(UFlowNode_FactsDB_SetFactBool, Value) == 0x0001E0, "Member 'UFlowNode_FactsDB_SetFactBool::Value' has a wrong offset!");

// Class PiecesFlowGraph.FlowNode_OnSystemNotify
// 0x0050 (0x0220 - 0x01D0)
class UFlowNode_OnSystemNotify final : public UFlowNode
{
public:
	struct FGameplayTagContainer                  NotifyTags;                                        // 0x01D0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  IdentityTags;                                      // 0x01F0(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	EFlowTagContainerMatchType                    IdentityMatchType;                                 // 0x0210(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SuccessLimit;                                      // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SuccessCount;                                      // 0x0218(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_OnSystemNotify">();
	}
	static class UFlowNode_OnSystemNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_OnSystemNotify>();
	}
};
static_assert(alignof(UFlowNode_OnSystemNotify) == 0x000008, "Wrong alignment on UFlowNode_OnSystemNotify");
static_assert(sizeof(UFlowNode_OnSystemNotify) == 0x000220, "Wrong size on UFlowNode_OnSystemNotify");
static_assert(offsetof(UFlowNode_OnSystemNotify, NotifyTags) == 0x0001D0, "Member 'UFlowNode_OnSystemNotify::NotifyTags' has a wrong offset!");
static_assert(offsetof(UFlowNode_OnSystemNotify, IdentityTags) == 0x0001F0, "Member 'UFlowNode_OnSystemNotify::IdentityTags' has a wrong offset!");
static_assert(offsetof(UFlowNode_OnSystemNotify, IdentityMatchType) == 0x000210, "Member 'UFlowNode_OnSystemNotify::IdentityMatchType' has a wrong offset!");
static_assert(offsetof(UFlowNode_OnSystemNotify, SuccessLimit) == 0x000214, "Member 'UFlowNode_OnSystemNotify::SuccessLimit' has a wrong offset!");
static_assert(offsetof(UFlowNode_OnSystemNotify, SuccessCount) == 0x000218, "Member 'UFlowNode_OnSystemNotify::SuccessCount' has a wrong offset!");

// Class PiecesFlowGraph.FlowNode_OnTriggerEvent
// 0x0030 (0x0288 - 0x0258)
class UFlowNode_OnTriggerEvent : public UFlowNode_ComponentObserver
{
public:
	struct FGameplayTagContainer                  OverlappedActorTags;                               // 0x0258(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_278[0x10];                                     // 0x0278(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_OnTriggerEvent">();
	}
	static class UFlowNode_OnTriggerEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_OnTriggerEvent>();
	}
};
static_assert(alignof(UFlowNode_OnTriggerEvent) == 0x000008, "Wrong alignment on UFlowNode_OnTriggerEvent");
static_assert(sizeof(UFlowNode_OnTriggerEvent) == 0x000288, "Wrong size on UFlowNode_OnTriggerEvent");
static_assert(offsetof(UFlowNode_OnTriggerEvent, OverlappedActorTags) == 0x000258, "Member 'UFlowNode_OnTriggerEvent::OverlappedActorTags' has a wrong offset!");

// Class PiecesFlowGraph.FlowNode_OnTriggerEnter
// 0x0000 (0x0288 - 0x0288)
class UFlowNode_OnTriggerEnter final : public UFlowNode_OnTriggerEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_OnTriggerEnter">();
	}
	static class UFlowNode_OnTriggerEnter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_OnTriggerEnter>();
	}
};
static_assert(alignof(UFlowNode_OnTriggerEnter) == 0x000008, "Wrong alignment on UFlowNode_OnTriggerEnter");
static_assert(sizeof(UFlowNode_OnTriggerEnter) == 0x000288, "Wrong size on UFlowNode_OnTriggerEnter");

// Class PiecesFlowGraph.FlowNode_OnTriggerExit
// 0x0000 (0x0288 - 0x0288)
class UFlowNode_OnTriggerExit final : public UFlowNode_OnTriggerEvent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_OnTriggerExit">();
	}
	static class UFlowNode_OnTriggerExit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_OnTriggerExit>();
	}
};
static_assert(alignof(UFlowNode_OnTriggerExit) == 0x000008, "Wrong alignment on UFlowNode_OnTriggerExit");
static_assert(sizeof(UFlowNode_OnTriggerExit) == 0x000288, "Wrong size on UFlowNode_OnTriggerExit");

// Class PiecesFlowGraph.FlowNode_SaveGame
// 0x0010 (0x01E0 - 0x01D0)
class UFlowNode_SaveGame final : public UFlowNode
{
public:
	uint8                                         Pad_1D0[0x10];                                     // 0x01D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSaveDone(bool bSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_SaveGame">();
	}
	static class UFlowNode_SaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_SaveGame>();
	}
};
static_assert(alignof(UFlowNode_SaveGame) == 0x000008, "Wrong alignment on UFlowNode_SaveGame");
static_assert(sizeof(UFlowNode_SaveGame) == 0x0001E0, "Wrong size on UFlowNode_SaveGame");

// Class PiecesFlowGraph.FlowNode_SetFact
// 0x0008 (0x01E8 - 0x01E0)
class UFlowNode_SetFact final : public UFlowNode_FactsDB
{
public:
	int32                                         Value;                                             // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowNode_SetFact">();
	}
	static class UFlowNode_SetFact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowNode_SetFact>();
	}
};
static_assert(alignof(UFlowNode_SetFact) == 0x000008, "Wrong alignment on UFlowNode_SetFact");
static_assert(sizeof(UFlowNode_SetFact) == 0x0001E8, "Wrong size on UFlowNode_SetFact");
static_assert(offsetof(UFlowNode_SetFact, Value) == 0x0001E0, "Member 'UFlowNode_SetFact::Value' has a wrong offset!");

// Class PiecesFlowGraph.FlowTriggerBox
// 0x0008 (0x0248 - 0x0240)
class AFlowTriggerBox final : public ATriggerBox
{
public:
	class UFlowTriggerComponent*                  FlowTriggerComponent;                              // 0x0240(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowTriggerBox">();
	}
	static class AFlowTriggerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlowTriggerBox>();
	}
};
static_assert(alignof(AFlowTriggerBox) == 0x000008, "Wrong alignment on AFlowTriggerBox");
static_assert(sizeof(AFlowTriggerBox) == 0x000248, "Wrong size on AFlowTriggerBox");
static_assert(offsetof(AFlowTriggerBox, FlowTriggerComponent) == 0x000240, "Member 'AFlowTriggerBox::FlowTriggerComponent' has a wrong offset!");

// Class PiecesFlowGraph.FlowTriggerComponent
// 0x0030 (0x0200 - 0x01D0)
class UFlowTriggerComponent final : public UFlowComponent
{
public:
	bool                                          bAutoEnable;                                       // 0x01D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverlapEnabled;                                   // 0x01D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D2[0x2E];                                     // 0x01D2(0x002E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ComponentBeginOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bFromSweep, const struct FHitResult& InSweepResult);
	void ComponentEndOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowTriggerComponent">();
	}
	static class UFlowTriggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowTriggerComponent>();
	}
};
static_assert(alignof(UFlowTriggerComponent) == 0x000008, "Wrong alignment on UFlowTriggerComponent");
static_assert(sizeof(UFlowTriggerComponent) == 0x000200, "Wrong size on UFlowTriggerComponent");
static_assert(offsetof(UFlowTriggerComponent, bAutoEnable) == 0x0001D0, "Member 'UFlowTriggerComponent::bAutoEnable' has a wrong offset!");
static_assert(offsetof(UFlowTriggerComponent, bOverlapEnabled) == 0x0001D1, "Member 'UFlowTriggerComponent::bOverlapEnabled' has a wrong offset!");

// Class PiecesFlowGraph.FlowTriggerVolume
// 0x0008 (0x0278 - 0x0270)
class AFlowTriggerVolume final : public AVolume
{
public:
	class UFlowTriggerComponent*                  FlowTriggerComponent;                              // 0x0270(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowTriggerVolume">();
	}
	static class AFlowTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlowTriggerVolume>();
	}
};
static_assert(alignof(AFlowTriggerVolume) == 0x000008, "Wrong alignment on AFlowTriggerVolume");
static_assert(sizeof(AFlowTriggerVolume) == 0x000278, "Wrong size on AFlowTriggerVolume");
static_assert(offsetof(AFlowTriggerVolume, FlowTriggerComponent) == 0x000270, "Member 'AFlowTriggerVolume::FlowTriggerComponent' has a wrong offset!");

// Class PiecesFlowGraph.PiecesFlowGraphSettings
// 0x0040 (0x0078 - 0x0038)
class UPiecesFlowGraphSettings final : public UDeveloperSettings
{
public:
	struct FGameplayTag                           PlayerPawnGameplayTag;                             // 0x0038(0x0008)(Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CommonEnableGameplayTag;                           // 0x0040(0x0008)(Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           CommonDisableGameplayTag;                          // 0x0048(0x0008)(Edit, Config, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UFlowAsset>              WorldSpanningFlowAsset;                            // 0x0050(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesFlowGraphSettings">();
	}
	static class UPiecesFlowGraphSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPiecesFlowGraphSettings>();
	}
};
static_assert(alignof(UPiecesFlowGraphSettings) == 0x000008, "Wrong alignment on UPiecesFlowGraphSettings");
static_assert(sizeof(UPiecesFlowGraphSettings) == 0x000078, "Wrong size on UPiecesFlowGraphSettings");
static_assert(offsetof(UPiecesFlowGraphSettings, PlayerPawnGameplayTag) == 0x000038, "Member 'UPiecesFlowGraphSettings::PlayerPawnGameplayTag' has a wrong offset!");
static_assert(offsetof(UPiecesFlowGraphSettings, CommonEnableGameplayTag) == 0x000040, "Member 'UPiecesFlowGraphSettings::CommonEnableGameplayTag' has a wrong offset!");
static_assert(offsetof(UPiecesFlowGraphSettings, CommonDisableGameplayTag) == 0x000048, "Member 'UPiecesFlowGraphSettings::CommonDisableGameplayTag' has a wrong offset!");
static_assert(offsetof(UPiecesFlowGraphSettings, WorldSpanningFlowAsset) == 0x000050, "Member 'UPiecesFlowGraphSettings::WorldSpanningFlowAsset' has a wrong offset!");

// Class PiecesFlowGraph.PiecesFlowSubsystem
// 0x0018 (0x0288 - 0x0270)
class UPiecesFlowSubsystem final : public UFlowSubsystem
{
public:
	uint8                                         Pad_270[0x18];                                     // 0x0270(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesFlowSubsystem">();
	}
	static class UPiecesFlowSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPiecesFlowSubsystem>();
	}
};
static_assert(alignof(UPiecesFlowSubsystem) == 0x000008, "Wrong alignment on UPiecesFlowSubsystem");
static_assert(sizeof(UPiecesFlowSubsystem) == 0x000288, "Wrong size on UPiecesFlowSubsystem");

}

