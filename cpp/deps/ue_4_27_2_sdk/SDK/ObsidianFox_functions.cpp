#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ObsidianFox

#include "Basic.hpp"

#include "ObsidianFox_classes.hpp"
#include "ObsidianFox_parameters.hpp"


namespace SDK
{

// Function ObsidianFox.AbilityTask_ApplyRootMotionJumpTargetForce.ApplyRootMotionJumpTargetForce
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          JumpTargetLocation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         JumpTargetRotation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EEasingFunc                             RotationTargetEasingFunction                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   JumpHeight                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   JumpDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMinimumLandedTriggerTime                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERootMotionFinishVelocityMode           VelocityOnFinishMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          SetVelocityOnFinish                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClampVelocityOnFinish                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveVector*                     InPathOffsetCurve                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      InTimeMappingCurve                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_ApplyRootMotionJumpTargetForce*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_ApplyRootMotionJumpTargetForce* UAbilityTask_ApplyRootMotionJumpTargetForce::ApplyRootMotionJumpTargetForce(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FVector& JumpTargetLocation, const struct FRotator& JumpTargetRotation, EEasingFunc RotationTargetEasingFunction, float JumpHeight, float JumpDuration, float InMinimumLandedTriggerTime, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish, class UCurveVector* InPathOffsetCurve, class UCurveFloat* InTimeMappingCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_ApplyRootMotionJumpTargetForce", "ApplyRootMotionJumpTargetForce");

	Params::AbilityTask_ApplyRootMotionJumpTargetForce_ApplyRootMotionJumpTargetForce Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.JumpTargetLocation = std::move(JumpTargetLocation);
	Parms.JumpTargetRotation = std::move(JumpTargetRotation);
	Parms.RotationTargetEasingFunction = RotationTargetEasingFunction;
	Parms.JumpHeight = JumpHeight;
	Parms.JumpDuration = JumpDuration;
	Parms.InMinimumLandedTriggerTime = InMinimumLandedTriggerTime;
	Parms.VelocityOnFinishMode = VelocityOnFinishMode;
	Parms.SetVelocityOnFinish = std::move(SetVelocityOnFinish);
	Parms.ClampVelocityOnFinish = ClampVelocityOnFinish;
	Parms.InPathOffsetCurve = InPathOffsetCurve;
	Parms.InTimeMappingCurve = InTimeMappingCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AbilityTask_ApplyRootMotionJumpTargetForce.OnLanded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAbilityTask_ApplyRootMotionJumpTargetForce::OnLanded(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_ApplyRootMotionJumpTargetForce", "OnLanded");

	Params::AbilityTask_ApplyRootMotionJumpTargetForce_OnLanded Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AbilityTask_WaitInputActionAll.WaitInputActionTriggered
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFinishOnComplete                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitInputActionAll*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitInputActionAll* UAbilityTask_WaitInputActionAll::WaitInputActionTriggered(class UGameplayAbility* OwningAbility, class UInputAction* InputAction, bool bFinishOnComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitInputActionAll", "WaitInputActionTriggered");

	Params::AbilityTask_WaitInputActionAll_WaitInputActionTriggered Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InputAction = InputAction;
	Parms.bFinishOnComplete = bFinishOnComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.AbilityTask_WaitInputActionAll.WaitInputDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UAbilityTask_WaitInputActionAll::WaitInputDelegate__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_WaitInputActionAll", "WaitInputDelegate__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.PlayerStartTransitionInterface.InitTransition
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      SpawnedController                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IPlayerStartTransitionInterface::InitTransition(class AController* SpawnedController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStartTransitionInterface", "InitTransition");

	Params::PlayerStartTransitionInterface_InitTransition Parms{};

	Parms.SpawnedController = SpawnedController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFInvestigationSelectionWidget.UpdateLabelBox
// (Final, Native, Protected, BlueprintCallable)

void UOFInvestigationSelectionWidget::UpdateLabelBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFInvestigationSelectionWidget", "UpdateLabelBox");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AbilityTask_WaitInputActionOngoing.WaitInputActionOngoing
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFinishOnComplete                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitInputActionOngoing*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitInputActionOngoing* UAbilityTask_WaitInputActionOngoing::WaitInputActionOngoing(class UGameplayAbility* OwningAbility, class UInputAction* InputAction, bool bFinishOnComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitInputActionOngoing", "WaitInputActionOngoing");

	Params::AbilityTask_WaitInputActionOngoing_WaitInputActionOngoing Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InputAction = InputAction;
	Parms.bFinishOnComplete = bFinishOnComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.AbilityTask_WaitInputActionOngoing.WaitInputOngoingDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// float                                   ElapsedTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_WaitInputActionOngoing::WaitInputOngoingDelegate__DelegateSignature(float ElapsedTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_WaitInputActionOngoing", "WaitInputOngoingDelegate__DelegateSignature");

	Params::AbilityTask_WaitInputActionOngoing_WaitInputOngoingDelegate__DelegateSignature Parms{};

	Parms.ElapsedTime = ElapsedTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.PlayerLocationTrackingVolume.ComponentBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void APlayerLocationTrackingVolume::ComponentBeginOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLocationTrackingVolume", "ComponentBeginOverlap");

	Params::PlayerLocationTrackingVolume_ComponentBeginOverlap Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerLocationTrackingVolume.ComponentEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerLocationTrackingVolume::ComponentEndOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLocationTrackingVolume", "ComponentEndOverlap");

	Params::PlayerLocationTrackingVolume_ComponentEndOverlap Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AbilityTask_WaitInputActionTriggered_Bool.WaitInputActionTriggered
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFinishOnComplete                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFinishOnTriggered                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitInputActionTriggered_Bool*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitInputActionTriggered_Bool* UAbilityTask_WaitInputActionTriggered_Bool::WaitInputActionTriggered(class UGameplayAbility* OwningAbility, class UInputAction* InputAction, bool bFinishOnComplete, bool bFinishOnTriggered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitInputActionTriggered_Bool", "WaitInputActionTriggered");

	Params::AbilityTask_WaitInputActionTriggered_Bool_WaitInputActionTriggered Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InputAction = InputAction;
	Parms.bFinishOnComplete = bFinishOnComplete;
	Parms.bFinishOnTriggered = bFinishOnTriggered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.AbilityTask_WaitInputActionTriggered_Bool.WaitInputTriggeredDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ElapsedTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TriggeredSeconds                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_WaitInputActionTriggered_Bool::WaitInputTriggeredDelegate__DelegateSignature(bool Value, float ElapsedTime, float TriggeredSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_WaitInputActionTriggered_Bool", "WaitInputTriggeredDelegate__DelegateSignature");

	Params::AbilityTask_WaitInputActionTriggered_Bool_WaitInputTriggeredDelegate__DelegateSignature Parms{};

	Parms.Value = Value;
	Parms.ElapsedTime = ElapsedTime;
	Parms.TriggeredSeconds = TriggeredSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.AbilityTask_WaitInputActionTriggered_Float.WaitInputActionTriggered
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFinishOnComplete                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFinishOnTriggered                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitInputActionTriggered_Float*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitInputActionTriggered_Float* UAbilityTask_WaitInputActionTriggered_Float::WaitInputActionTriggered(class UGameplayAbility* OwningAbility, class UInputAction* InputAction, bool bFinishOnComplete, bool bFinishOnTriggered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitInputActionTriggered_Float", "WaitInputActionTriggered");

	Params::AbilityTask_WaitInputActionTriggered_Float_WaitInputActionTriggered Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InputAction = InputAction;
	Parms.bFinishOnComplete = bFinishOnComplete;
	Parms.bFinishOnTriggered = bFinishOnTriggered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.AbilityTask_WaitInputActionTriggered_Float.WaitInputTriggeredDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ElapsedTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TriggeredSeconds                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_WaitInputActionTriggered_Float::WaitInputTriggeredDelegate__DelegateSignature(float Value, float ElapsedTime, float TriggeredSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_WaitInputActionTriggered_Float", "WaitInputTriggeredDelegate__DelegateSignature");

	Params::AbilityTask_WaitInputActionTriggered_Float_WaitInputTriggeredDelegate__DelegateSignature Parms{};

	Parms.Value = Value;
	Parms.ElapsedTime = ElapsedTime;
	Parms.TriggeredSeconds = TriggeredSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.AbilityTask_WaitInputActionTriggered_Vector2D.WaitInputActionTriggered
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     InputAction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFinishOnComplete                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFinishOnTriggered                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitInputActionTriggered_Vector2D*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitInputActionTriggered_Vector2D* UAbilityTask_WaitInputActionTriggered_Vector2D::WaitInputActionTriggered(class UGameplayAbility* OwningAbility, class UInputAction* InputAction, bool bFinishOnComplete, bool bFinishOnTriggered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitInputActionTriggered_Vector2D", "WaitInputActionTriggered");

	Params::AbilityTask_WaitInputActionTriggered_Vector2D_WaitInputActionTriggered Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InputAction = InputAction;
	Parms.bFinishOnComplete = bFinishOnComplete;
	Parms.bFinishOnTriggered = bFinishOnTriggered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.AbilityTask_WaitInputActionTriggered_Vector2D.WaitInputTriggeredDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasDefaults)
// Parameters:
// struct FVector2D                        Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ElapsedTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TriggeredSeconds                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_WaitInputActionTriggered_Vector2D::WaitInputTriggeredDelegate__DelegateSignature(const struct FVector2D& Value, float ElapsedTime, float TriggeredSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_WaitInputActionTriggered_Vector2D", "WaitInputTriggeredDelegate__DelegateSignature");

	Params::AbilityTask_WaitInputActionTriggered_Vector2D_WaitInputTriggeredDelegate__DelegateSignature Parms{};

	Parms.Value = std::move(Value);
	Parms.ElapsedTime = ElapsedTime;
	Parms.TriggeredSeconds = TriggeredSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.AchievementSubSystem.CompleteAchievement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     AchievementTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAchievementSubSystem::CompleteAchievement(const struct FGameplayTag& AchievementTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementSubSystem", "CompleteAchievement");

	Params::AchievementSubSystem_CompleteAchievement Parms{};

	Parms.AchievementTag = std::move(AchievementTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AchievementSubSystem.GetAchievementInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     AchievementTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAchievementInfo           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FAchievementInfo UAchievementSubSystem::GetAchievementInfo(const struct FGameplayTag& AchievementTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementSubSystem", "GetAchievementInfo");

	Params::AchievementSubSystem_GetAchievementInfo Parms{};

	Parms.AchievementTag = std::move(AchievementTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AchievementSubSystem.GetAchievementProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     AchievementTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAchievementSubSystem::GetAchievementProgress(const struct FGameplayTag& AchievementTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementSubSystem", "GetAchievementProgress");

	Params::AchievementSubSystem_GetAchievementProgress Parms{};

	Parms.AchievementTag = std::move(AchievementTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AchievementSubSystem.GetStatValueFloat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     StatTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAchievementSubSystem::GetStatValueFloat(const struct FGameplayTag& StatTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementSubSystem", "GetStatValueFloat");

	Params::AchievementSubSystem_GetStatValueFloat Parms{};

	Parms.StatTag = std::move(StatTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AchievementSubSystem.GetStatValueInt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     StatTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAchievementSubSystem::GetStatValueInt(const struct FGameplayTag& StatTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementSubSystem", "GetStatValueInt");

	Params::AchievementSubSystem_GetStatValueInt Parms{};

	Parms.StatTag = std::move(StatTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AchievementSubSystem.ProgressAchievement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     AchievementTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAchievementSubSystem::ProgressAchievement(const struct FGameplayTag& AchievementTag, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementSubSystem", "ProgressAchievement");

	Params::AchievementSubSystem_ProgressAchievement Parms{};

	Parms.AchievementTag = std::move(AchievementTag);
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AchievementSubSystem.ResetAchievements
// (Final, Native, Public, BlueprintCallable)

void UAchievementSubSystem::ResetAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementSubSystem", "ResetAchievements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AchievementSubSystem.UpdateStatFloat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     StatTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAchievementSubSystem::UpdateStatFloat(const struct FGameplayTag& StatTag, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementSubSystem", "UpdateStatFloat");

	Params::AchievementSubSystem_UpdateStatFloat Parms{};

	Parms.StatTag = std::move(StatTag);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AchievementSubSystem.UpdateStatInt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     StatTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAchievementSubSystem::UpdateStatInt(const struct FGameplayTag& StatTag, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementSubSystem", "UpdateStatInt");

	Params::AchievementSubSystem_UpdateStatInt Parms{};

	Parms.StatTag = std::move(StatTag);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObsidianFoxCharacter.AddWeapon
// (Native, Public, BlueprintCallable)
// Parameters:
// class AOFWeaponActor*                   NewWeapon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::AddWeapon(class AOFWeaponActor* NewWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "AddWeapon");

	Params::ObsidianFoxCharacter_AddWeapon Parms{};

	Parms.NewWeapon = NewWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.ObsidianFoxCharacter.AimingSignature__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bIsAiming                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::AimingSignature__DelegateSignature(bool bIsAiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "AimingSignature__DelegateSignature");

	Params::ObsidianFoxCharacter_AimingSignature__DelegateSignature Parms{};

	Parms.bIsAiming = bIsAiming;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.ObsidianFoxCharacter.AttributeChange__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// float                                   AttributeValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            EventTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::AttributeChange__DelegateSignature(float AttributeValue, float DeltaValue, const struct FGameplayTagContainer& EventTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "AttributeChange__DelegateSignature");

	Params::ObsidianFoxCharacter_AttributeChange__DelegateSignature Parms{};

	Parms.AttributeValue = AttributeValue;
	Parms.DeltaValue = DeltaValue;
	Parms.EventTags = std::move(EventTags);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.ObsidianFoxCharacter.BeginWeaponAttack
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            AttackingWeaponsTags                                   (Parm, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::BeginWeaponAttack(const struct FGameplayTag& EventTag, const struct FGameplayTagContainer& AttackingWeaponsTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "BeginWeaponAttack");

	Params::ObsidianFoxCharacter_BeginWeaponAttack Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.AttackingWeaponsTags = std::move(AttackingWeaponsTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObsidianFoxCharacter.BeginWeaponAttacks
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::BeginWeaponAttacks(const struct FGameplayTag& EventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "BeginWeaponAttacks");

	Params::ObsidianFoxCharacter_BeginWeaponAttacks Parms{};

	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObsidianFoxCharacter.CancelAbilitiesWithTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            AbilityTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::CancelAbilitiesWithTag(const struct FGameplayTagContainer& AbilityTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "CancelAbilitiesWithTag");

	Params::ObsidianFoxCharacter_CancelAbilitiesWithTag Parms{};

	Parms.AbilityTag = std::move(AbilityTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObsidianFoxCharacter.Death
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayTagContainer            EventTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::Death(const struct FGameplayTagContainer& EventTags, const struct FGameplayEffectContextHandle& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "Death");

	Params::ObsidianFoxCharacter_Death Parms{};

	Parms.EventTags = std::move(EventTags);
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.ObsidianFoxCharacter.DodgingSignature__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bIsDodging                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::DodgingSignature__DelegateSignature(bool bIsDodging)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "DodgingSignature__DelegateSignature");

	Params::ObsidianFoxCharacter_DodgingSignature__DelegateSignature Parms{};

	Parms.bIsDodging = bIsDodging;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.ObsidianFoxCharacter.EndWeaponAttack
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            AttackingWeaponsTags                                   (Parm, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::EndWeaponAttack(const struct FGameplayTagContainer& AttackingWeaponsTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "EndWeaponAttack");

	Params::ObsidianFoxCharacter_EndWeaponAttack Parms{};

	Parms.AttackingWeaponsTags = std::move(AttackingWeaponsTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObsidianFoxCharacter.EndWeaponAttacks
// (Native, Public, BlueprintCallable)

void AObsidianFoxCharacter::EndWeaponAttacks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "EndWeaponAttacks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObsidianFoxCharacter.EquipWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOFWeaponActor*                   Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachSocket                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AObsidianFoxCharacter::EquipWeapon(class AOFWeaponActor* Weapon, class FName AttachSocket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "EquipWeapon");

	Params::ObsidianFoxCharacter_EquipWeapon Parms{};

	Parms.Weapon = Weapon;
	Parms.AttachSocket = AttachSocket;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ObsidianFoxCharacter.GetInvicibillity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AObsidianFoxCharacter::GetInvicibillity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "GetInvicibillity");

	Params::ObsidianFoxCharacter_GetInvicibillity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ObsidianFoxCharacter.GrantAbility
// (Native, Protected, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayAbility>     NewAbility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::GrantAbility(TSubclassOf<class UGameplayAbility> NewAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "GrantAbility");

	Params::ObsidianFoxCharacter_GrantAbility Parms{};

	Parms.NewAbility = NewAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObsidianFoxCharacter.GrantAbilityBySpec
// (Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayAbilitySpec             NewAbilitySpec                                         (Parm, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::GrantAbilityBySpec(const struct FGameplayAbilitySpec& NewAbilitySpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "GrantAbilityBySpec");

	Params::ObsidianFoxCharacter_GrantAbilityBySpec Parms{};

	Parms.NewAbilitySpec = std::move(NewAbilitySpec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.ObsidianFoxCharacter.HealthChangeSignature__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// float                                   NewCurrentHealth                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            EventTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::HealthChangeSignature__DelegateSignature(float NewCurrentHealth, float DeltaValue, const struct FGameplayTagContainer& EventTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "HealthChangeSignature__DelegateSignature");

	Params::ObsidianFoxCharacter_HealthChangeSignature__DelegateSignature Parms{};

	Parms.NewCurrentHealth = NewCurrentHealth;
	Parms.DeltaValue = DeltaValue;
	Parms.EventTags = std::move(EventTags);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.ObsidianFoxCharacter.InitializeAttributeSet
// (Native, Protected)

void AObsidianFoxCharacter::InitializeAttributeSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "InitializeAttributeSet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObsidianFoxCharacter.K2_OnCinematicModeChange
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInCinematicMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::K2_OnCinematicModeChange(bool bInCinematicMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "K2_OnCinematicModeChange");

	Params::ObsidianFoxCharacter_K2_OnCinematicModeChange Parms{};

	Parms.bInCinematicMode = bInCinematicMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.ObsidianFoxCharacter.OnEquipWeaponAnimationNotify
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AObsidianFoxCharacter::OnEquipWeaponAnimationNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "OnEquipWeaponAnimationNotify");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.ObsidianFoxCharacter.OnPlayStateChanged
// (Final, Native, Protected)
// Parameters:
// EGameMainState                          OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameMainState                          NewGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::OnPlayStateChanged(EGameMainState OldState, EGameMainState NewGameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "OnPlayStateChanged");

	Params::ObsidianFoxCharacter_OnPlayStateChanged Parms{};

	Parms.OldState = OldState;
	Parms.NewGameState = NewGameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObsidianFoxCharacter.OnUnequipWeaponAnimationNotify
// (Event, Public, BlueprintCallable, BlueprintEvent)

void AObsidianFoxCharacter::OnUnequipWeaponAnimationNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "OnUnequipWeaponAnimationNotify");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.ObsidianFoxCharacter.OnWeaponAttackHit
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// float                                   HitStrength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HitForce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitDirection                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitDirectionNormalAdjusted                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECardinalDirection                      HitQuadrant                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            DamageTags                                             (ConstParm, Parm, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::OnWeaponAttackHit(float HitStrength, float HitForce, float Duration, const struct FVector& HitDirection, const struct FVector& HitDirectionNormalAdjusted, ECardinalDirection HitQuadrant, const struct FHitResult& HitInfo, const struct FGameplayTagContainer& DamageTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "OnWeaponAttackHit");

	Params::ObsidianFoxCharacter_OnWeaponAttackHit Parms{};

	Parms.HitStrength = HitStrength;
	Parms.HitForce = HitForce;
	Parms.Duration = Duration;
	Parms.HitDirection = std::move(HitDirection);
	Parms.HitDirectionNormalAdjusted = std::move(HitDirectionNormalAdjusted);
	Parms.HitQuadrant = HitQuadrant;
	Parms.HitInfo = std::move(HitInfo);
	Parms.DamageTags = std::move(DamageTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObsidianFoxCharacter.RemoveWeapon
// (Native, Public, BlueprintCallable)
// Parameters:
// class AOFWeaponActor*                   WeaponToRemove                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::RemoveWeapon(class AOFWeaponActor* WeaponToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "RemoveWeapon");

	Params::ObsidianFoxCharacter_RemoveWeapon Parms{};

	Parms.WeaponToRemove = WeaponToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObsidianFoxCharacter.ResetHealthToMax
// (Final, Native, Protected, BlueprintCallable)

void AObsidianFoxCharacter::ResetHealthToMax()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "ResetHealthToMax");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObsidianFoxCharacter.SetCinematicMode
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldBeInCinematicMode                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::SetCinematicMode(bool bShouldBeInCinematicMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "SetCinematicMode");

	Params::ObsidianFoxCharacter_SetCinematicMode Parms{};

	Parms.bShouldBeInCinematicMode = bShouldBeInCinematicMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObsidianFoxCharacter.SetInvicibillity
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AObsidianFoxCharacter::SetInvicibillity(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "SetInvicibillity");

	Params::ObsidianFoxCharacter_SetInvicibillity Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObsidianFoxCharacter.UnequipWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOFWeaponActor*                   Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDestroyWeaponActor                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AttachSocket                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AObsidianFoxCharacter::UnequipWeapon(class AOFWeaponActor* Weapon, bool bDestroyWeaponActor, class FName AttachSocket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "UnequipWeapon");

	Params::ObsidianFoxCharacter_UnequipWeapon Parms{};

	Parms.Weapon = Weapon;
	Parms.bDestroyWeaponActor = bDestroyWeaponActor;
	Parms.AttachSocket = AttachSocket;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ObsidianFoxCharacter.GetActiveMeleeWeapon
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AOFWeaponActor*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOFWeaponActor* AObsidianFoxCharacter::GetActiveMeleeWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "GetActiveMeleeWeapon");

	Params::ObsidianFoxCharacter_GetActiveMeleeWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ObsidianFoxCharacter.GetActiveWeapon
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AOFWeaponActor*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOFWeaponActor* AObsidianFoxCharacter::GetActiveWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "GetActiveWeapon");

	Params::ObsidianFoxCharacter_GetActiveWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ObsidianFoxCharacter.GetEquippedWeapons
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AOFWeaponActor*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AOFWeaponActor*> AObsidianFoxCharacter::GetEquippedWeapons() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "GetEquippedWeapons");

	Params::ObsidianFoxCharacter_GetEquippedWeapons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ObsidianFoxCharacter.IsCharacterDead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AObsidianFoxCharacter::IsCharacterDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "IsCharacterDead");

	Params::ObsidianFoxCharacter_IsCharacterDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ObsidianFoxCharacter.IsInCinematicMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AObsidianFoxCharacter::IsInCinematicMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxCharacter", "IsInCinematicMode");

	Params::ObsidianFoxCharacter_IsInCinematicMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFFLevelUtils.GetStreamingLevelFromWorld
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>            InWorld                                                (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelStreaming*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelStreaming* UOFFLevelUtils::GetStreamingLevelFromWorld(const class UObject* WorldContextObject, const TSoftObjectPtr<class UWorld> InWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFFLevelUtils", "GetStreamingLevelFromWorld");

	Params::OFFLevelUtils_GetStreamingLevelFromWorld Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InWorld = InWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFFLevelUtils.GetWorldAssetName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UWorld>            InWorld                                                (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UOFFLevelUtils::GetWorldAssetName(const TSoftObjectPtr<class UWorld> InWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFFLevelUtils", "GetWorldAssetName");

	Params::OFFLevelUtils_GetWorldAssetName Parms{};

	Parms.InWorld = InWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ActorMoodComponent.OnCombatStatusChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    InCombat                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorMoodComponent::OnCombatStatusChanged(bool InCombat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMoodComponent", "OnCombatStatusChanged");

	Params::ActorMoodComponent_OnCombatStatusChanged Parms{};

	Parms.InCombat = InCombat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ActorMoodComponent.OnEnterGauntlet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    FirstTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorMoodComponent::OnEnterGauntlet(bool FirstTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMoodComponent", "OnEnterGauntlet");

	Params::ActorMoodComponent_OnEnterGauntlet Parms{};

	Parms.FirstTime = FirstTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ActorMoodComponent.OnExitGauntlet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    FirstTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorMoodComponent::OnExitGauntlet(bool FirstTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMoodComponent", "OnExitGauntlet");

	Params::ActorMoodComponent_OnExitGauntlet Parms{};

	Parms.FirstTime = FirstTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ActorMoodComponent.OnHealthChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// float                                   NewCurrentHealth                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            EventTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UActorMoodComponent::OnHealthChanged(float NewCurrentHealth, float DeltaValue, const struct FGameplayTagContainer& EventTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMoodComponent", "OnHealthChanged");

	Params::ActorMoodComponent_OnHealthChanged Parms{};

	Parms.NewCurrentHealth = NewCurrentHealth;
	Parms.DeltaValue = DeltaValue;
	Parms.EventTags = std::move(EventTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ActorMoodComponent.OnNewRoomExplored
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayTag                     NewRoomTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorMoodComponent::OnNewRoomExplored(const struct FGameplayTag& NewRoomTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMoodComponent", "OnNewRoomExplored");

	Params::ActorMoodComponent_OnNewRoomExplored Parms{};

	Parms.NewRoomTag = std::move(NewRoomTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ActorMoodComponent.OnSprintStateChange
// (Final, Native, Protected)
// Parameters:
// bool                                    IsSprinting                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorMoodComponent::OnSprintStateChange(bool IsSprinting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMoodComponent", "OnSprintStateChange");

	Params::ActorMoodComponent_OnSprintStateChange Parms{};

	Parms.IsSprinting = IsSprinting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ActorMoodComponent.RequestEmotionChange
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<EEmotion, float>                   EmotionDeltas                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UActorMoodComponent::RequestEmotionChange(const TMap<EEmotion, float>& EmotionDeltas)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMoodComponent", "RequestEmotionChange");

	Params::ActorMoodComponent_RequestEmotionChange Parms{};

	Parms.EmotionDeltas = std::move(EmotionDeltas);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ActorMoodComponent.GetBreathRecoveryTimer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCurveFloat*                      TransformationCurve                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UActorMoodComponent::GetBreathRecoveryTimer(class UCurveFloat* TransformationCurve) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorMoodComponent", "GetBreathRecoveryTimer");

	Params::ActorMoodComponent_GetBreathRecoveryTimer Parms{};

	Parms.TransformationCurve = TransformationCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ActorTransformComponent.ForceStop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    StopTranslation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    StopRotation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SnapCharacterToTargetLocation                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SnapCharacterToTargetRotation                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorTransformComponent::ForceStop(bool StopTranslation, bool StopRotation, bool SnapCharacterToTargetLocation, bool SnapCharacterToTargetRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorTransformComponent", "ForceStop");

	Params::ActorTransformComponent_ForceStop Parms{};

	Parms.StopTranslation = StopTranslation;
	Parms.StopRotation = StopRotation;
	Parms.SnapCharacterToTargetLocation = SnapCharacterToTargetLocation;
	Parms.SnapCharacterToTargetRotation = SnapCharacterToTargetRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ActorTransformComponent.StartTransform
// (Native, Public, BlueprintCallable)

void UActorTransformComponent::StartTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorTransformComponent", "StartTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.ActorTransformComponent.TransformCompleted__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AActor*                           TransformedActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorTransformComponent*         TransformingComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorTransformComponent::TransformCompleted__DelegateSignature(class AActor* TransformedActor, class UActorTransformComponent* TransformingComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorTransformComponent", "TransformCompleted__DelegateSignature");

	Params::ActorTransformComponent_TransformCompleted__DelegateSignature Parms{};

	Parms.TransformedActor = TransformedActor;
	Parms.TransformingComponent = TransformingComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OFPickupIncrementWidget.PlayEyeCatcherAnimation
// (Event, Public, BlueprintEvent)

void UOFPickupIncrementWidget::PlayEyeCatcherAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPickupIncrementWidget", "PlayEyeCatcherAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.OFPostProcessAnimInstance.CopyDynamicsAlphaFromOwnerABP
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   DestinationVariable                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     DynamicsKey                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFPostProcessAnimInstance::CopyDynamicsAlphaFromOwnerABP(float& DestinationVariable, const struct FGameplayTag& DynamicsKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPostProcessAnimInstance", "CopyDynamicsAlphaFromOwnerABP");

	Params::OFPostProcessAnimInstance_CopyDynamicsAlphaFromOwnerABP Parms{};

	Parms.DestinationVariable = DestinationVariable;
	Parms.DynamicsKey = std::move(DynamicsKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	DestinationVariable = Parms.DestinationVariable;
}


// Function ObsidianFox.OFPostProcessAnimInstance.GetParentAnimInstance
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimInstance>        Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* UOFPostProcessAnimInstance::GetParentAnimInstance(TSubclassOf<class UAnimInstance> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPostProcessAnimInstance", "GetParentAnimInstance");

	Params::OFPostProcessAnimInstance_GetParentAnimInstance Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ActWorldSubSystem.GetCurrentActWorldIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UActWorldSubSystem::GetCurrentActWorldIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActWorldSubSystem", "GetCurrentActWorldIndex");

	Params::ActWorldSubSystem_GetCurrentActWorldIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ActWorldSubSystem.GetCurrentActWorldName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UActWorldSubSystem::GetCurrentActWorldName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActWorldSubSystem", "GetCurrentActWorldName");

	Params::ActWorldSubSystem_GetCurrentActWorldName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AIEmotePointInterface.IsActive
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAIEmotePointInterface::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIEmotePointInterface", "IsActive");

	Params::AIEmotePointInterface_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFPlayerCameraManager.OnSettingsChangedHandler
// (Final, Native, Protected)
// Parameters:
// class UOFGameUserSettings*              Settings                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFPlayerCameraManager::OnSettingsChangedHandler(class UOFGameUserSettings* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCameraManager", "OnSettingsChangedHandler");

	Params::OFPlayerCameraManager_OnSettingsChangedHandler Parms{};

	Parms.Settings = Settings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AimAssistInterface.GetAimAssistMainSocket
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName IAimAssistInterface::GetAimAssistMainSocket()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistInterface", "GetAimAssistMainSocket");

	Params::AimAssistInterface_GetAimAssistMainSocket Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AimAssistInterface.GetAimAssistSocketComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class USceneComponent*            ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class USceneComponent* IAimAssistInterface::GetAimAssistSocketComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistInterface", "GetAimAssistSocketComponent");

	Params::AimAssistInterface_GetAimAssistSocketComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AimAssistInterface.GetAimAssistSockets
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIncludeMainAimSocket                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class FName> IAimAssistInterface::GetAimAssistSockets(const bool bIncludeMainAimSocket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AimAssistInterface", "GetAimAssistSockets");

	Params::AimAssistInterface_GetAimAssistSockets Parms{};

	Parms.bIncludeMainAimSocket = bIncludeMainAimSocket;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFPerfSampleBlueprintGauntletController.OnActorFinished
// (Final, Native, Protected)

void UOFPerfSampleBlueprintGauntletController::OnActorFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPerfSampleBlueprintGauntletController", "OnActorFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPerfSampleBlueprintGauntletController.StartTest
// (Native, Protected)

void UOFPerfSampleBlueprintGauntletController::StartTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPerfSampleBlueprintGauntletController", "StartTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPerfSampleBlueprintGauntletController.StopTest
// (Native, Protected)

void UOFPerfSampleBlueprintGauntletController::StopTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPerfSampleBlueprintGauntletController", "StopTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerController.CloseInGameMenu
// (Final, Native, Public, BlueprintCallable)

void AOFPlayerController::CloseInGameMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "CloseInGameMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerController.ClosePauseMenu
// (Final, Native, Public, BlueprintCallable)

void AOFPlayerController::ClosePauseMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "ClosePauseMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.OFPlayerController.InputIgnoredDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void AOFPlayerController::InputIgnoredDelegate__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "InputIgnoredDelegate__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction ObsidianFox.OFPlayerController.InputTypeChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    IsGamepadType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFPlayerController::InputTypeChanged__DelegateSignature(bool IsGamepadType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "InputTypeChanged__DelegateSignature");

	Params::OFPlayerController_InputTypeChanged__DelegateSignature Parms{};

	Parms.IsGamepadType = IsGamepadType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OFPlayerController.IsGameplayInputIgnoredBranched
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EInputIgnoreBranch                      Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFPlayerController::IsGameplayInputIgnoredBranched(EInputIgnoreBranch* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "IsGameplayInputIgnoredBranched");

	Params::OFPlayerController_IsGameplayInputIgnoredBranched Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function ObsidianFox.OFPlayerController.OnCharacterPosessed
// (Final, Native, Protected)
// Parameters:
// class AOFPlayerCharacter*               PossesedCharacter                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFPlayerController::OnCharacterPosessed(const class AOFPlayerCharacter* PossesedCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "OnCharacterPosessed");

	Params::OFPlayerController_OnCharacterPosessed Parms{};

	Parms.PossesedCharacter = PossesedCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerController.OnSettingsChanged
// (Final, Native, Protected)
// Parameters:
// class UOFGameUserSettings*              Settings                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFPlayerController::OnSettingsChanged(class UOFGameUserSettings* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "OnSettingsChanged");

	Params::OFPlayerController_OnSettingsChanged Parms{};

	Parms.Settings = Settings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerController.OpenInGameMenu
// (Final, Native, Public, BlueprintCallable)

void AOFPlayerController::OpenInGameMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "OpenInGameMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerController.OpenPauseMenu
// (Final, Native, Public, BlueprintCallable)

void AOFPlayerController::OpenPauseMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "OpenPauseMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerController.ResetIgnoreGameplayInput
// (Final, Native, Public, BlueprintCallable)

void AOFPlayerController::ResetIgnoreGameplayInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "ResetIgnoreGameplayInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerController.SetIgnoreGameplayInput
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewGameplayInput                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFPlayerController::SetIgnoreGameplayInput(bool bNewGameplayInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "SetIgnoreGameplayInput");

	Params::OFPlayerController_SetIgnoreGameplayInput Parms{};

	Parms.bNewGameplayInput = bNewGameplayInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerController.SetOptionsWhenClosingAMenu
// (Final, Native, Public, BlueprintCallable)

void AOFPlayerController::SetOptionsWhenClosingAMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "SetOptionsWhenClosingAMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerController.SetOptionsWhenOpeningANewMenu
// (Final, Native, Public, BlueprintCallable)

void AOFPlayerController::SetOptionsWhenOpeningANewMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "SetOptionsWhenOpeningANewMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerController.GetInGameUIWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* AOFPlayerController::GetInGameUIWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "GetInGameUIWidget");

	Params::OFPlayerController_GetInGameUIWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFPlayerController.IsGamepadLastInputTypeUsed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOFPlayerController::IsGamepadLastInputTypeUsed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "IsGamepadLastInputTypeUsed");

	Params::OFPlayerController_IsGamepadLastInputTypeUsed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFPlayerController.IsGameplayInputIgnored
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOFPlayerController::IsGameplayInputIgnored() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "IsGameplayInputIgnored");

	Params::OFPlayerController_IsGameplayInputIgnored Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFPlayerController.IsInCinematicMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOFPlayerController::IsInCinematicMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerController", "IsInCinematicMode");

	Params::OFPlayerController_IsInCinematicMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AlternativeEndingCharacterAnimInstance.OnTransitionAnimationFinished
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    PlayAlternativeEnding                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAlternativeEndingCharacterAnimInstance::OnTransitionAnimationFinished(bool PlayAlternativeEnding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AlternativeEndingCharacterAnimInstance", "OnTransitionAnimationFinished");

	Params::AlternativeEndingCharacterAnimInstance_OnTransitionAnimationFinished Parms{};

	Parms.PlayAlternativeEnding = PlayAlternativeEnding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBFL_Math.AbsMax_FloatFloat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_Math::AbsMax_FloatFloat(float A, float B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Math", "AbsMax_FloatFloat");

	Params::OFBFL_Math_AbsMax_FloatFloat Parms{};

	Parms.A = A;
	Parms.B = B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_Math.DebugDrawFrustum
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFrustumData                     FrustumData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBFL_Math::DebugDrawFrustum(const class UObject* WorldContextObject, const struct FFrustumData& FrustumData, const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Math", "DebugDrawFrustum");

	Params::OFBFL_Math_DebugDrawFrustum Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.FrustumData = std::move(FrustumData);
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBFL_Math.DoesFrustumIntersectPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FFrustumData                     FrustumData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          Point                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFBFL_Math::DoesFrustumIntersectPoint(const struct FFrustumData& FrustumData, const struct FVector& Point)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Math", "DoesFrustumIntersectPoint");

	Params::OFBFL_Math_DoesFrustumIntersectPoint Parms{};

	Parms.FrustumData = std::move(FrustumData);
	Parms.Point = std::move(Point);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_Math.DrawDebugCircleSegment
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngleDegrees                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Resolution                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          AngleAxis                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   DepthPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thickness                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRenderClockWise                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRenderEdges                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBFL_Math::DrawDebugCircleSegment(const class UObject* WorldContextObject, const struct FVector& Origin, float AngleDegrees, float Resolution, const struct FVector& AngleAxis, const struct FVector& StartDirection, float Radius, const struct FLinearColor& Color, float Lifetime, uint8 DepthPriority, float Thickness, bool bRenderClockWise, bool bRenderEdges)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Math", "DrawDebugCircleSegment");

	Params::OFBFL_Math_DrawDebugCircleSegment Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Origin = std::move(Origin);
	Parms.AngleDegrees = AngleDegrees;
	Parms.Resolution = Resolution;
	Parms.AngleAxis = std::move(AngleAxis);
	Parms.StartDirection = std::move(StartDirection);
	Parms.Radius = Radius;
	Parms.Color = std::move(Color);
	Parms.Lifetime = Lifetime;
	Parms.DepthPriority = DepthPriority;
	Parms.Thickness = Thickness;
	Parms.bRenderClockWise = bRenderClockWise;
	Parms.bRenderEdges = bRenderEdges;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBFL_Math.FindAngleBetweenVectors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          A                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          B                                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_Math::FindAngleBetweenVectors(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Math", "FindAngleBetweenVectors");

	Params::OFBFL_Math_FindAngleBetweenVectors Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_Math.GetAngleToVector2D
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          OriginDirection                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          DestinationDirection                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_Math::GetAngleToVector2D(const struct FVector& OriginDirection, const struct FVector& DestinationDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Math", "GetAngleToVector2D");

	Params::OFBFL_Math_GetAngleToVector2D Parms{};

	Parms.OriginDirection = std::move(OriginDirection);
	Parms.DestinationDirection = std::move(DestinationDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_Math.GetFrustumData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FFrustumSettings                 FrustumSettings                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator                         FrustumRotation                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          FrustumLocation                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFrustumData                     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FFrustumData UOFBFL_Math::GetFrustumData(const struct FFrustumSettings& FrustumSettings, const struct FRotator& FrustumRotation, const struct FVector& FrustumLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Math", "GetFrustumData");

	Params::OFBFL_Math_GetFrustumData Parms{};

	Parms.FrustumSettings = std::move(FrustumSettings);
	Parms.FrustumRotation = std::move(FrustumRotation);
	Parms.FrustumLocation = std::move(FrustumLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_Math.GetHitQuadrantFromHitResult
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ECardinalDirection                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECardinalDirection UOFBFL_Math::GetHitQuadrantFromHitResult(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Math", "GetHitQuadrantFromHitResult");

	Params::OFBFL_Math_GetHitQuadrantFromHitResult Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_Math.GetQuadrantFromDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Forward                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECardinalDirection                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECardinalDirection UOFBFL_Math::GetQuadrantFromDirection(const struct FVector& Direction, const struct FVector& Forward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Math", "GetQuadrantFromDirection");

	Params::OFBFL_Math_GetQuadrantFromDirection Parms{};

	Parms.Direction = std::move(Direction);
	Parms.Forward = std::move(Forward);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_Math.RotateAroundObject
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ObjectToRotate                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ObjectToRotateAround                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Degrees                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBFL_Math::RotateAroundObject(class AActor* ObjectToRotate, const class USceneComponent* ObjectToRotateAround, float Degrees)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Math", "RotateAroundObject");

	Params::OFBFL_Math_RotateAroundObject Parms{};

	Parms.ObjectToRotate = ObjectToRotate;
	Parms.ObjectToRotateAround = ObjectToRotateAround;
	Parms.Degrees = Degrees;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBFL_Math.SmoothStep
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   B                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_Math::SmoothStep(const float A, const float B, const float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Math", "SmoothStep");

	Params::OFBFL_Math_SmoothStep Parms{};

	Parms.A = A;
	Parms.B = B;
	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AnimationHitReactionInterface.TriggerAnimationBlueprintHitReaction
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitReactionData                 HitReactionData                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void IAnimationHitReactionInterface::TriggerAnimationBlueprintHitReaction(const struct FHitReactionData& HitReactionData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationHitReactionInterface", "TriggerAnimationBlueprintHitReaction");

	Params::AnimationHitReactionInterface_TriggerAnimationBlueprintHitReaction Parms{};

	Parms.HitReactionData = std::move(HitReactionData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBlueprintUtils.GetBestPointForAttacking
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          CurrentPos                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetPos                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  PointsArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOFBlueprintUtils::GetBestPointForAttacking(const struct FVector& CurrentPos, const struct FVector& TargetPos, const TArray<struct FVector>& PointsArray, const float Tolerance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintUtils", "GetBestPointForAttacking");

	Params::OFBlueprintUtils_GetBestPointForAttacking Parms{};

	Parms.CurrentPos = std::move(CurrentPos);
	Parms.TargetPos = std::move(TargetPos);
	Parms.PointsArray = std::move(PointsArray);
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintUtils.GetGameVersion
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOFBlueprintUtils::GetGameVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintUtils", "GetGameVersion");

	Params::OFBlueprintUtils_GetGameVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintUtils.GetGlobalListOfLevelsToIgnoreForPreStreaming
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<TSoftObjectPtr<class UWorld>>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSoftObjectPtr<class UWorld>> UOFBlueprintUtils::GetGlobalListOfLevelsToIgnoreForPreStreaming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintUtils", "GetGlobalListOfLevelsToIgnoreForPreStreaming");

	Params::OFBlueprintUtils_GetGlobalListOfLevelsToIgnoreForPreStreaming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintUtils.IsWithEditor
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFBlueprintUtils::IsWithEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintUtils", "IsWithEditor");

	Params::OFBlueprintUtils_IsWithEditor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintUtils.RebuildNavmesh
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBlueprintUtils::RebuildNavmesh(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintUtils", "RebuildNavmesh");

	Params::OFBlueprintUtils_RebuildNavmesh Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBlueprintUtils.WaitForAssetStreamingToComplete
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOFBlueprintUtils::WaitForAssetStreamingToComplete(float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintUtils", "WaitForAssetStreamingToComplete");

	Params::OFBlueprintUtils_WaitForAssetStreamingToComplete Parms{};

	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AnimationRagdollInterface.BeginBasicRagdoll
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          SessionOwner                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RootBoneName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRagdollWeightCurves             WeightCurveNames                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void IAnimationRagdollInterface::BeginBasicRagdoll(class UObject* SessionOwner, class FName RootBoneName, class FName ProfileName, const struct FRagdollWeightCurves& WeightCurveNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationRagdollInterface", "BeginBasicRagdoll");

	Params::AnimationRagdollInterface_BeginBasicRagdoll Parms{};

	Parms.SessionOwner = SessionOwner;
	Parms.RootBoneName = RootBoneName;
	Parms.ProfileName = ProfileName;
	Parms.WeightCurveNames = std::move(WeightCurveNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimationRagdollInterface.BeginVelocityBlendOutRagdoll
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          SessionOwner                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RootBoneName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRagdollWeightCurves             WeightCurveNames                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FRagdollAutoBlendOutParameters   ExtraParameters                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void()>                       BlendOutBeginEvent                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IAnimationRagdollInterface::BeginVelocityBlendOutRagdoll(class UObject* SessionOwner, class FName RootBoneName, class FName ProfileName, const struct FRagdollWeightCurves& WeightCurveNames, const struct FRagdollAutoBlendOutParameters& ExtraParameters, const TDelegate<void()>& BlendOutBeginEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationRagdollInterface", "BeginVelocityBlendOutRagdoll");

	Params::AnimationRagdollInterface_BeginVelocityBlendOutRagdoll Parms{};

	Parms.SessionOwner = SessionOwner;
	Parms.RootBoneName = RootBoneName;
	Parms.ProfileName = ProfileName;
	Parms.WeightCurveNames = std::move(WeightCurveNames);
	Parms.ExtraParameters = std::move(ExtraParameters);
	Parms.BlendOutBeginEvent = BlendOutBeginEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimationRagdollInterface.EndRagdoll
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          SessionOwner                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SnapshotName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimationRagdollInterface::EndRagdoll(class UObject* SessionOwner, class FName SnapshotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationRagdollInterface", "EndRagdoll");

	Params::AnimationRagdollInterface_EndRagdoll Parms{};

	Parms.SessionOwner = SessionOwner;
	Parms.SnapshotName = SnapshotName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimationRagdollInterface.OnRagdollNotifyBegin
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          SessionOwner                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RagdollRootBone                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ProfileName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRagdollWeightCurves             WeightCurveNames                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IAnimationRagdollInterface::OnRagdollNotifyBegin(class UObject* SessionOwner, const class FName& RagdollRootBone, const class FName& ProfileName, const struct FRagdollWeightCurves& WeightCurveNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationRagdollInterface", "OnRagdollNotifyBegin");

	Params::AnimationRagdollInterface_OnRagdollNotifyBegin Parms{};

	Parms.SessionOwner = SessionOwner;
	Parms.RagdollRootBone = RagdollRootBone;
	Parms.ProfileName = ProfileName;
	Parms.WeightCurveNames = std::move(WeightCurveNames);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimationRagdollInterface.OnRagdollNotifyEnd
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          SessionOwner                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SnapshotName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKeepRagdollAfterNotifyEnd                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimationRagdollInterface::OnRagdollNotifyEnd(class UObject* SessionOwner, class FName SnapshotName, bool bKeepRagdollAfterNotifyEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationRagdollInterface", "OnRagdollNotifyEnd");

	Params::AnimationRagdollInterface_OnRagdollNotifyEnd Parms{};

	Parms.SessionOwner = SessionOwner;
	Parms.SnapshotName = SnapshotName;
	Parms.bKeepRagdollAfterNotifyEnd = bKeepRagdollAfterNotifyEnd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimComponent.ActualBeginPlay
// (Final, Native, Protected)

void UAnimComponent::ActualBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponent", "ActualBeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimComponent.Blueprint_Initialize
// (Event, Public, BlueprintEvent)

void UAnimComponent::Blueprint_Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponent", "Blueprint_Initialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.AnimComponent.Blueprint_Update
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimComponent::Blueprint_Update(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponent", "Blueprint_Update");

	Params::AnimComponent_Blueprint_Update Parms{};

	Parms.DeltaTime = DeltaTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.AnimComponent.OnPreSave
// (Final, Native, Private)
// Parameters:
// ESaveTypePolicy                         SaveTypePolicy                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimComponent::OnPreSave(ESaveTypePolicy SaveTypePolicy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponent", "OnPreSave");

	Params::AnimComponent_OnPreSave Parms{};

	Parms.SaveTypePolicy = SaveTypePolicy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimComponentArmIK.GetEffectorData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FKLocationBoneName                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FArmIKEffectorData               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FArmIKEffectorData UAnimComponentArmIK::GetEffectorData(const class FName BoneName, const class FName FKLocationBoneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentArmIK", "GetEffectorData");

	Params::AnimComponentArmIK_GetEffectorData Parms{};

	Parms.BoneName = BoneName;
	Parms.FKLocationBoneName = FKLocationBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFSpringArmComponent.OnAiming
// (Final, Native, Public)
// Parameters:
// bool                                    bInIsAiming                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFSpringArmComponent::OnAiming(bool bInIsAiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSpringArmComponent", "OnAiming");

	Params::OFSpringArmComponent_OnAiming Parms{};

	Parms.bInIsAiming = bInIsAiming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFSpringArmComponent.ResetCameraLag
// (Final, Native, Protected)

void UOFSpringArmComponent::ResetCameraLag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSpringArmComponent", "ResetCameraLag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFSpringArmComponent.StepLag
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsRunning                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFSpringArmComponent::StepLag(bool bIsRunning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSpringArmComponent", "StepLag");

	Params::OFSpringArmComponent_StepLag Parms{};

	Parms.bIsRunning = bIsRunning;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimComponentDismemberment.TriggerDismemberment
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   HitMagnitude                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsKillingHit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimComponentDismemberment::TriggerDismemberment(const struct FHitResult& Hit, const float HitMagnitude, bool IsKillingHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentDismemberment", "TriggerDismemberment");

	Params::AnimComponentDismemberment_TriggerDismemberment Parms{};

	Parms.Hit = std::move(Hit);
	Parms.HitMagnitude = HitMagnitude;
	Parms.IsKillingHit = IsKillingHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimComponentDismemberment.GetDismemberPointDataFromIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDismemberPointData              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDismemberPointData UAnimComponentDismemberment::GetDismemberPointDataFromIndex(const int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentDismemberment", "GetDismemberPointDataFromIndex");

	Params::AnimComponentDismemberment_GetDismemberPointDataFromIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PauseInterface.OnPauseChanged
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bPaused                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IPauseInterface::OnPauseChanged(bool bPaused)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseInterface", "OnPauseChanged");

	Params::PauseInterface_OnPauseChanged Parms{};

	Parms.bPaused = bPaused;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseInterface.GetRunningTimers
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TArray<struct FTimerHandle>             OutTimers                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void IPauseInterface::GetRunningTimers(TArray<struct FTimerHandle>* OutTimers) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseInterface", "GetRunningTimers");

	Params::PauseInterface_GetRunningTimers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTimers != nullptr)
		*OutTimers = std::move(Parms.OutTimers);
}


// Function ObsidianFox.AnimComponentFootIK.AddIKModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UFootIKModifier>      ModifierClass                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFootIKModifier*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFootIKModifier* UAnimComponentFootIK::AddIKModifier(const class FName BoneName, TSubclassOf<class UFootIKModifier> ModifierClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentFootIK", "AddIKModifier");

	Params::AnimComponentFootIK_AddIKModifier Parms{};

	Parms.BoneName = BoneName;
	Parms.ModifierClass = ModifierClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AnimComponentFootIK.OnFootDown
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          StepLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFootType                               FootStepType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimComponentFootIK::OnFootDown(const struct FVector& StepLocation, EFootType FootStepType, const class FName& BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentFootIK", "OnFootDown");

	Params::AnimComponentFootIK_OnFootDown Parms{};

	Parms.StepLocation = std::move(StepLocation);
	Parms.FootStepType = FootStepType;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimComponentFootIK.OnFootUp
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          StepLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFootType                               FootStepType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimComponentFootIK::OnFootUp(const struct FVector& StepLocation, EFootType FootStepType, const class FName& BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentFootIK", "OnFootUp");

	Params::AnimComponentFootIK_OnFootUp Parms{};

	Parms.StepLocation = std::move(StepLocation);
	Parms.FootStepType = FootStepType;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimComponentFootIK.RemoveIKModifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFootIKModifier*                  Modifier                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimComponentFootIK::RemoveIKModifier(const class FName BoneName, class UFootIKModifier* Modifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentFootIK", "RemoveIKModifier");

	Params::AnimComponentFootIK_RemoveIKModifier Parms{};

	Parms.BoneName = BoneName;
	Parms.Modifier = Modifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimComponentFootIK.GetEffectorLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAnimComponentFootIK::GetEffectorLocation(const class FName BoneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentFootIK", "GetEffectorLocation");

	Params::AnimComponentFootIK_GetEffectorLocation Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AnimComponentFootIK.GetEffectorRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UAnimComponentFootIK::GetEffectorRotation(const class FName BoneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentFootIK", "GetEffectorRotation");

	Params::AnimComponentFootIK_GetEffectorRotation Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AnimComponentFootIK.GetEffectorSurfaceType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPhysicalSurface                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPhysicalSurface UAnimComponentFootIK::GetEffectorSurfaceType(const class FName BoneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentFootIK", "GetEffectorSurfaceType");

	Params::AnimComponentFootIK_GetEffectorSurfaceType Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AnimComponentFootIK.GetEffectorTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAnimComponentFootIK::GetEffectorTargetLocation(const class FName BoneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentFootIK", "GetEffectorTargetLocation");

	Params::AnimComponentFootIK_GetEffectorTargetLocation Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AnimComponentFootIK.GetEffectorTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UAnimComponentFootIK::GetEffectorTransform(const class FName BoneName, struct FTransform* OutTransform) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentFootIK", "GetEffectorTransform");

	Params::AnimComponentFootIK_GetEffectorTransform Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);
}


// Function ObsidianFox.AnimComponentFootIK.GetFeetPlantData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FFeetPlantData                   FeetPlantData                                          (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimComponentFootIK::GetFeetPlantData(struct FFeetPlantData* FeetPlantData, const class FName BoneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentFootIK", "GetFeetPlantData");

	Params::AnimComponentFootIK_GetFeetPlantData Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FeetPlantData != nullptr)
		*FeetPlantData = std::move(Parms.FeetPlantData);
}


// Function ObsidianFox.AnimComponentFootIK.GetPoleVectorLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAnimComponentFootIK::GetPoleVectorLocation(const class FName BoneName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentFootIK", "GetPoleVectorLocation");

	Params::AnimComponentFootIK_GetPoleVectorLocation Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InGameUIWidget.HideShowUI
// (Final, Native, Public, BlueprintCallable)

void UInGameUIWidget::HideShowUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget", "HideShowUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget.HUDVisibilityChanged
// (Native, Protected)
// Parameters:
// bool                                    bNewHUDVisbility                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget::HUDVisibilityChanged(bool bNewHUDVisbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget", "HUDVisibilityChanged");

	Params::InGameUIWidget_HUDVisibilityChanged Parms{};

	Parms.bNewHUDVisbility = bNewHUDVisbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.InGameUIWidget.PlayerHUDVisibilitySignature__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bNewHUDVisibility                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget::PlayerHUDVisibilitySignature__DelegateSignature(bool bNewHUDVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget", "PlayerHUDVisibilitySignature__DelegateSignature");

	Params::InGameUIWidget_PlayerHUDVisibilitySignature__DelegateSignature Parms{};

	Parms.bNewHUDVisibility = bNewHUDVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.InGameUIWidget.GetIsVisibilityAllowed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInGameUIWidget::GetIsVisibilityAllowed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget", "GetIsVisibilityAllowed");

	Params::InGameUIWidget_GetIsVisibilityAllowed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OF_HUDCrosshair.OnHasTargetChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    SetHasTarget                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOF_HUDCrosshair::OnHasTargetChanged(bool SetHasTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OF_HUDCrosshair", "OnHasTargetChanged");

	Params::OF_HUDCrosshair_OnHasTargetChanged Parms{};

	Parms.SetHasTarget = SetHasTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OF_HUDCrosshair.OnTrackedWeaponHitHandler
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayEventData               EventPayload                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOF_HUDCrosshair::OnTrackedWeaponHitHandler(const struct FGameplayEventData& EventPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OF_HUDCrosshair", "OnTrackedWeaponHitHandler");

	Params::OF_HUDCrosshair_OnTrackedWeaponHitHandler Parms{};

	Parms.EventPayload = std::move(EventPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OF_HUDCrosshair.OnTrackedWeaponSet
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AHitscanWeaponActor*              InTrackedWeapon                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOF_HUDCrosshair::OnTrackedWeaponSet(class AHitscanWeaponActor* InTrackedWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OF_HUDCrosshair", "OnTrackedWeaponSet");

	Params::OF_HUDCrosshair_OnTrackedWeaponSet Parms{};

	Parms.InTrackedWeapon = InTrackedWeapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OF_HUDCrosshair.OnWeaponAimStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsAimingWeapon                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOF_HUDCrosshair::OnWeaponAimStateChanged(bool IsAimingWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OF_HUDCrosshair", "OnWeaponAimStateChanged");

	Params::OF_HUDCrosshair_OnWeaponAimStateChanged Parms{};

	Parms.IsAimingWeapon = IsAimingWeapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OF_HUDCrosshair.OnWeaponHit
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayEventData               EventPayload                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Hits                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOF_HUDCrosshair::OnWeaponHit(const struct FGameplayEventData& EventPayload, int32 Hits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OF_HUDCrosshair", "OnWeaponHit");

	Params::OF_HUDCrosshair_OnWeaponHit Parms{};

	Parms.EventPayload = std::move(EventPayload);
	Parms.Hits = Hits;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OF_HUDCrosshair.SetTrackedWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHitscanWeaponActor*              WeaponToTrack                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOF_HUDCrosshair::SetTrackedWeapon(class AHitscanWeaponActor* WeaponToTrack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OF_HUDCrosshair", "SetTrackedWeapon");

	Params::OF_HUDCrosshair_SetTrackedWeapon Parms{};

	Parms.WeaponToTrack = WeaponToTrack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimationLockedTurnInPlaceInterface.RequestManualLockedTurnInPlace
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   AngleDegrees                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimationLockedTurnInPlaceInterface::RequestManualLockedTurnInPlace(float AngleDegrees)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimationLockedTurnInPlaceInterface", "RequestManualLockedTurnInPlace");

	Params::AnimationLockedTurnInPlaceInterface_RequestManualLockedTurnInPlace Parms{};

	Parms.AngleDegrees = AngleDegrees;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimComponentLockedTurnInPlace.ForceUpdateFastTurnAngle
// (Final, Native, Public, BlueprintCallable)

void UAnimComponentLockedTurnInPlace::ForceUpdateFastTurnAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentLockedTurnInPlace", "ForceUpdateFastTurnAngle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimComponentLockedTurnInPlace.OnTurnInPlaceEnded
// (Final, Native, Public, BlueprintCallable)

void UAnimComponentLockedTurnInPlace::OnTurnInPlaceEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentLockedTurnInPlace", "OnTurnInPlaceEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimComponentLockedTurnInPlace.OnTurnInPlaceStarted
// (Final, Native, Public, BlueprintCallable)

void UAnimComponentLockedTurnInPlace::OnTurnInPlaceStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentLockedTurnInPlace", "OnTurnInPlaceStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ParticleEffectSpawnerVolume.ComponentBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AParticleEffectSpawnerVolume::ComponentBeginOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParticleEffectSpawnerVolume", "ComponentBeginOverlap");

	Params::ParticleEffectSpawnerVolume_ComponentBeginOverlap Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ParticleEffectSpawnerVolume.ComponentEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AParticleEffectSpawnerVolume::ComponentEndOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParticleEffectSpawnerVolume", "ComponentEndOverlap");

	Params::ParticleEffectSpawnerVolume_ComponentEndOverlap Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ParticleEffectSpawnerVolume.SpawnParticleEffect
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UWorld*                           WorldContext                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UNiagaraSystem>    ParticleSystem                                         (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AParticleEffectSpawnerVolume::SpawnParticleEffect(const class UWorld* WorldContext, const TSoftObjectPtr<class UNiagaraSystem>& ParticleSystem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParticleEffectSpawnerVolume", "SpawnParticleEffect");

	Params::ParticleEffectSpawnerVolume_SpawnParticleEffect Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ParticleSystem = ParticleSystem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ParticleEffectSpawnerVolume.SpawnParticleEffects
// (Native, Event, Protected, BlueprintEvent)

void AParticleEffectSpawnerVolume::SpawnParticleEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParticleEffectSpawnerVolume", "SpawnParticleEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ParticleEffectSpawnerVolume.VolumeActorBeginOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AParticleEffectSpawnerVolume::VolumeActorBeginOverlap(class AActor* OverlappedActor, class AActor* InOtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParticleEffectSpawnerVolume", "VolumeActorBeginOverlap");

	Params::ParticleEffectSpawnerVolume_VolumeActorBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.InOtherActor = InOtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ParticleEffectSpawnerVolume.VolumeActorEndOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AParticleEffectSpawnerVolume::VolumeActorEndOverlap(class AActor* OverlappedActor, class AActor* InOtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParticleEffectSpawnerVolume", "VolumeActorEndOverlap");

	Params::ParticleEffectSpawnerVolume_VolumeActorEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.InOtherActor = InOtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimComponentRailingFinder.StartIKMontage
// (Final, Native, Public)
// Parameters:
// class FName                             Bone                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimComponentRailingFinder::StartIKMontage(const class FName Bone, bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimComponentRailingFinder", "StartIKMontage");

	Params::AnimComponentRailingFinder_StartIKMontage Parms{};

	Parms.Bone = Bone;
	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerCharactersEngineSubsystem.CacheCurrentPlayerCharacters
// (Final, Native, Public)
// Parameters:
// class AController*                      InController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerCharactersEngineSubsystem::CacheCurrentPlayerCharacters(class AController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharactersEngineSubsystem", "CacheCurrentPlayerCharacters");

	Params::PlayerCharactersEngineSubsystem_CacheCurrentPlayerCharacters Parms{};

	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerCharactersEngineSubsystem.GetPlayerCharacterType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerCharacterType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerCharacterType UPlayerCharactersEngineSubsystem::GetPlayerCharacterType(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharactersEngineSubsystem", "GetPlayerCharacterType");

	Params::PlayerCharactersEngineSubsystem_GetPlayerCharacterType Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.PlayerCharactersEngineSubsystem.OnCharacterPosessed__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AOFPlayerCharacter*               Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerCharactersEngineSubsystem::OnCharacterPosessed__DelegateSignature(const class AOFPlayerCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharactersEngineSubsystem", "OnCharacterPosessed__DelegateSignature");

	Params::PlayerCharactersEngineSubsystem_OnCharacterPosessed__DelegateSignature Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.PlayerCharactersEngineSubsystem.PossessPlayerCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      InController                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerCharacterType                    PlayerCharacterType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisableCurrentCharacter                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOFPlayerCharacter*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOFPlayerCharacter* UPlayerCharactersEngineSubsystem::PossessPlayerCharacter(class AController* InController, EPlayerCharacterType PlayerCharacterType, bool bDisableCurrentCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharactersEngineSubsystem", "PossessPlayerCharacter");

	Params::PlayerCharactersEngineSubsystem_PossessPlayerCharacter Parms{};

	Parms.InController = InController;
	Parms.PlayerCharacterType = PlayerCharacterType;
	Parms.bDisableCurrentCharacter = bDisableCurrentCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PlayerCharactersEngineSubsystem.SetCharacterToUse
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerCharacterType                    PlayerCharacterType                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerCharactersEngineSubsystem::SetCharacterToUse(EPlayerCharacterType PlayerCharacterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharactersEngineSubsystem", "SetCharacterToUse");

	Params::PlayerCharactersEngineSubsystem_SetCharacterToUse Parms{};

	Parms.PlayerCharacterType = PlayerCharacterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.DisableAnimationFeature
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Feature                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::DisableAnimationFeature(const struct FGameplayTag& Feature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "DisableAnimationFeature");

	Params::AnimInterface_DisableAnimationFeature Parms{};

	Parms.Feature = std::move(Feature);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.DisableBodyFocus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          LockReference                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ResetSpeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::DisableBodyFocus(const class UObject* LockReference, float ResetSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "DisableBodyFocus");

	Params::AnimInterface_DisableBodyFocus Parms{};

	Parms.LockReference = LockReference;
	Parms.ResetSpeed = ResetSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.DisableFootIK
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          CallerReference                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    KeepHipOffsetEnabled                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::DisableFootIK(const class UObject* CallerReference, bool KeepHipOffsetEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "DisableFootIK");

	Params::AnimInterface_DisableFootIK Parms{};

	Parms.CallerReference = CallerReference;
	Parms.KeepHipOffsetEnabled = KeepHipOffsetEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.EnableAnimationFeature
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Feature                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::EnableAnimationFeature(const struct FGameplayTag& Feature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "EnableAnimationFeature");

	Params::AnimInterface_EnableAnimationFeature Parms{};

	Parms.Feature = std::move(Feature);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.EnableBodyFocus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          LockReference                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::EnableBodyFocus(const class UObject* LockReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "EnableBodyFocus");

	Params::AnimInterface_EnableBodyFocus Parms{};

	Parms.LockReference = LockReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.EnableFootIK
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          CallerReference                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::EnableFootIK(const class UObject* CallerReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "EnableFootIK");

	Params::AnimInterface_EnableFootIK Parms{};

	Parms.CallerReference = CallerReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.EndContextualTraverse
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IAnimInterface::EndContextualTraverse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "EndContextualTraverse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.GetCurrentLocomotionState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EAnimationLocomotionState               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAnimationLocomotionState IAnimInterface::GetCurrentLocomotionState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "GetCurrentLocomotionState");

	Params::AnimInterface_GetCurrentLocomotionState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AnimInterface.GetFocusPointOnCharacter
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector IAnimInterface::GetFocusPointOnCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "GetFocusPointOnCharacter");

	Params::AnimInterface_GetFocusPointOnCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.AnimInterface.OnFootStepEvent
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EFootType                               FootStepType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::OnFootStepEvent(EFootType FootStepType, const class FName& BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "OnFootStepEvent");

	Params::AnimInterface_OnFootStepEvent Parms{};

	Parms.FootStepType = FootStepType;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.OnFootUpEvent
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EFootType                               FootStepType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::OnFootUpEvent(EFootType FootStepType, const class FName& BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "OnFootUpEvent");

	Params::AnimInterface_OnFootUpEvent Parms{};

	Parms.FootStepType = FootStepType;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.OnWeaponAttackHit
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   HitStrength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HitForce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CharacterIsDead                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitDirection                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECardinalDirection                      HitQuadrant                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FHitReactionData                 HitReactionData                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FGameplayEventData               EventData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void IAnimInterface::OnWeaponAttackHit(float HitStrength, float HitForce, bool CharacterIsDead, const struct FVector& HitDirection, ECardinalDirection HitQuadrant, const struct FHitResult& HitInfo, const struct FHitReactionData& HitReactionData, const struct FGameplayEventData& EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "OnWeaponAttackHit");

	Params::AnimInterface_OnWeaponAttackHit Parms{};

	Parms.HitStrength = HitStrength;
	Parms.HitForce = HitForce;
	Parms.CharacterIsDead = CharacterIsDead;
	Parms.HitDirection = std::move(HitDirection);
	Parms.HitQuadrant = HitQuadrant;
	Parms.HitInfo = std::move(HitInfo);
	Parms.HitReactionData = std::move(HitReactionData);
	Parms.EventData = std::move(EventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.PlayHitReactionMontage
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitDirection                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             HitBoneName                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::PlayHitReactionMontage(class UAnimMontage* Montage, const struct FVector& HitDirection, const class FName& HitBoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "PlayHitReactionMontage");

	Params::AnimInterface_PlayHitReactionMontage Parms{};

	Parms.Montage = Montage;
	Parms.HitDirection = std::move(HitDirection);
	Parms.HitBoneName = HitBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.QueueArmIKData
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          SessionOwner                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpToSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpFromSpeed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIKHandParameters                HandParameters                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EOFTransformSpace                       LocationSpace                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::QueueArmIKData(const class UObject* SessionOwner, const struct FVector& TargetLocation, float InterpToSpeed, float InterpFromSpeed, const struct FIKHandParameters& HandParameters, EOFTransformSpace LocationSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "QueueArmIKData");

	Params::AnimInterface_QueueArmIKData Parms{};

	Parms.SessionOwner = SessionOwner;
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.InterpToSpeed = InterpToSpeed;
	Parms.InterpFromSpeed = InterpFromSpeed;
	Parms.HandParameters = std::move(HandParameters);
	Parms.LocationSpace = LocationSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.RagdollMeshAtHit
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitDirection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HitImpactStrength                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HitForce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SimulationDuration                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InitialBlendWeight                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::RagdollMeshAtHit(class FName BoneName, const struct FVector& HitDirection, float HitImpactStrength, float HitForce, float SimulationDuration, float InitialBlendWeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "RagdollMeshAtHit");

	Params::AnimInterface_RagdollMeshAtHit Parms{};

	Parms.BoneName = BoneName;
	Parms.HitDirection = std::move(HitDirection);
	Parms.HitImpactStrength = HitImpactStrength;
	Parms.HitForce = HitForce;
	Parms.SimulationDuration = SimulationDuration;
	Parms.InitialBlendWeight = InitialBlendWeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.ReleaseHoldWalkState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IAnimInterface::ReleaseHoldWalkState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "ReleaseHoldWalkState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.RequestHoldWalkState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IAnimInterface::RequestHoldWalkState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "RequestHoldWalkState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.RequestMoveToStopState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IAnimInterface::RequestMoveToStopState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "RequestMoveToStopState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.RootMotionEnd
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          LockOwner                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::RootMotionEnd(const class UObject* LockOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "RootMotionEnd");

	Params::AnimInterface_RootMotionEnd Parms{};

	Parms.LockOwner = LockOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.RootMotionStart
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          LockOwner                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ApplyTranslation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ApplyRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsRotationAbsolute                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::RootMotionStart(const class UObject* LockOwner, bool ApplyTranslation, bool ApplyRotation, bool IsRotationAbsolute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "RootMotionStart");

	Params::AnimInterface_RootMotionStart Parms{};

	Parms.LockOwner = LockOwner;
	Parms.ApplyTranslation = ApplyTranslation;
	Parms.ApplyRotation = ApplyRotation;
	Parms.IsRotationAbsolute = IsRotationAbsolute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.SetArmIKData
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          SessionOwner                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpToSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpFromSpeed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIKHandParameters                HandParameters                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EOFTransformSpace                       LocationSpace                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::SetArmIKData(const class UObject* SessionOwner, class FName BoneName, const struct FVector& TargetLocation, float InterpToSpeed, float InterpFromSpeed, const struct FIKHandParameters& HandParameters, EOFTransformSpace LocationSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "SetArmIKData");

	Params::AnimInterface_SetArmIKData Parms{};

	Parms.SessionOwner = SessionOwner;
	Parms.BoneName = BoneName;
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.InterpToSpeed = InterpToSpeed;
	Parms.InterpFromSpeed = InterpFromSpeed;
	Parms.HandParameters = std::move(HandParameters);
	Parms.LocationSpace = LocationSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.SetFootIKInterpolationMultiplier
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Multiplier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::SetFootIKInterpolationMultiplier(const class FName BoneName, const float Multiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "SetFootIKInterpolationMultiplier");

	Params::AnimInterface_SetFootIKInterpolationMultiplier Parms{};

	Parms.BoneName = BoneName;
	Parms.Multiplier = Multiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.StartArmIK
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          SessionOwner                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FArmIKReferenceTarget            TargetReference                                        (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FArmIKCompensationData           LocationCompensationData                               (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             WeightCurveName                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::StartArmIK(const class UObject* SessionOwner, class FName BoneName, const struct FArmIKReferenceTarget& TargetReference, const struct FArmIKCompensationData& LocationCompensationData, const class FName WeightCurveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "StartArmIK");

	Params::AnimInterface_StartArmIK Parms{};

	Parms.SessionOwner = SessionOwner;
	Parms.BoneName = BoneName;
	Parms.TargetReference = std::move(TargetReference);
	Parms.LocationCompensationData = std::move(LocationCompensationData);
	Parms.WeightCurveName = WeightCurveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.StartContextualTraverse
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     TraverseTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::StartContextualTraverse(const struct FGameplayTag& TraverseTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "StartContextualTraverse");

	Params::AnimInterface_StartContextualTraverse Parms{};

	Parms.TraverseTag = std::move(TraverseTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.StopArmIK
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          SessionOwner                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             WeightCurveName                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::StopArmIK(const class UObject* SessionOwner, class FName BoneName, const class FName WeightCurveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "StopArmIK");

	Params::AnimInterface_StopArmIK Parms{};

	Parms.SessionOwner = SessionOwner;
	Parms.BoneName = BoneName;
	Parms.WeightCurveName = WeightCurveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.TrySetBlockFlagForRailingFinderForBone
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          CallerReference                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldBeBlocked                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstantBlock                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::TrySetBlockFlagForRailingFinderForBone(const class UObject* CallerReference, class FName BoneName, bool bShouldBeBlocked, bool bInstantBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "TrySetBlockFlagForRailingFinderForBone");

	Params::AnimInterface_TrySetBlockFlagForRailingFinderForBone Parms{};

	Parms.CallerReference = CallerReference;
	Parms.BoneName = BoneName;
	Parms.bShouldBeBlocked = bShouldBeBlocked;
	Parms.bInstantBlock = bInstantBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.WholebodyRagdoll
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Activate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAnimInterface::WholebodyRagdoll(bool Activate, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "WholebodyRagdoll");

	Params::AnimInterface_WholebodyRagdoll Parms{};

	Parms.Activate = Activate;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AnimInterface.GetDynamicsAlpha
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     Key                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IAnimInterface::GetDynamicsAlpha(const struct FGameplayTag& Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimInterface", "GetDynamicsAlpha");

	Params::AnimInterface_GetDynamicsAlpha Parms{};

	Parms.Key = std::move(Key);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ObsidianFox.PlatformSpecificKeyWidget.SetInputAction
// (Event, Public, BlueprintEvent)
// Parameters:
// class UInputAction*                     InInputAction                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlatformSpecificKeyWidget::SetInputAction(class UInputAction* InInputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformSpecificKeyWidget", "SetInputAction");

	Params::PlatformSpecificKeyWidget_SetInputAction Parms{};

	Parms.InInputAction = InInputAction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.PlatformSpecificKeyWidget.SetInputMappingContext
// (Event, Public, BlueprintEvent)
// Parameters:
// class UPiecesInputMappingContext*       InInputMappingContext                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlatformSpecificKeyWidget::SetInputMappingContext(class UPiecesInputMappingContext* InInputMappingContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformSpecificKeyWidget", "SetInputMappingContext");

	Params::PlatformSpecificKeyWidget_SetInputMappingContext Parms{};

	Parms.InInputMappingContext = InInputMappingContext;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.PlatformSpecificKeyWidget.SetKeyImageAndText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             KeyString                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPlatformSpecificKeyWidget::SetKeyImageAndText(class UTexture2D* Texture, const class FText& KeyString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlatformSpecificKeyWidget", "SetKeyImageAndText");

	Params::PlatformSpecificKeyWidget_SetKeyImageAndText Parms{};

	Parms.Texture = Texture;
	Parms.KeyString = std::move(KeyString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.BackToStartScreen
// (Event, Protected, BlueprintEvent)

void UOptionsControlsPT::BackToStartScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "BackToStartScreen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.OptionsControlsPT.CancelButtonPressed
// (Final, Native, Protected)

void UOptionsControlsPT::CancelButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "CancelButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.ChangeActiveButton
// (Final, Native, Protected)

void UOptionsControlsPT::ChangeActiveButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "ChangeActiveButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.ControllerSensitivityHoveredCallback
// (Final, Native, Protected)

void UOptionsControlsPT::ControllerSensitivityHoveredCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "ControllerSensitivityHoveredCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.DecreaseAimSensitiveButtonPressedCallback
// (Final, Native, Private)

void UOptionsControlsPT::DecreaseAimSensitiveButtonPressedCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "DecreaseAimSensitiveButtonPressedCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.IncreaseAimSensitiveButtonPressedCallback
// (Final, Native, Private)

void UOptionsControlsPT::IncreaseAimSensitiveButtonPressedCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "IncreaseAimSensitiveButtonPressedCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.InteractButtonPressed
// (Final, Native, Protected)

void UOptionsControlsPT::InteractButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "InteractButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.InvertedCheckBoxPressed
// (Final, Native, Private)
// Parameters:
// bool                                    bInvertedValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsControlsPT::InvertedCheckBoxPressed(bool bInvertedValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "InvertedCheckBoxPressed");

	Params::OptionsControlsPT_InvertedCheckBoxPressed Parms{};

	Parms.bInvertedValue = bInvertedValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.InvertedHoveredCallback
// (Final, Native, Protected)

void UOptionsControlsPT::InvertedHoveredCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "InvertedHoveredCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.LeftStickX
// (Final, Native, Protected)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsControlsPT::LeftStickX(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "LeftStickX");

	Params::OptionsControlsPT_LeftStickX Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.LeftStickY
// (Final, Native, Protected)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOptionsControlsPT::LeftStickY(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "LeftStickY");

	Params::OptionsControlsPT_LeftStickY Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.OnInitalize
// (Final, Native, Protected, BlueprintCallable)

void UOptionsControlsPT::OnInitalize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "OnInitalize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.SelectDownPressed
// (Final, Native, Protected)

void UOptionsControlsPT::SelectDownPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "SelectDownPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.SelectNextPressed
// (Final, Native, Protected)

void UOptionsControlsPT::SelectNextPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "SelectNextPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.SelectPreviousPressed
// (Final, Native, Protected)

void UOptionsControlsPT::SelectPreviousPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "SelectPreviousPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.SelectUpPressed
// (Final, Native, Protected)

void UOptionsControlsPT::SelectUpPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "SelectUpPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.SetCanMoveWithLeftStickXToTrue
// (Final, Native, Private)

void UOptionsControlsPT::SetCanMoveWithLeftStickXToTrue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "SetCanMoveWithLeftStickXToTrue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.SetCanMoveWithLeftStickYToTrue
// (Final, Native, Private)

void UOptionsControlsPT::SetCanMoveWithLeftStickYToTrue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "SetCanMoveWithLeftStickYToTrue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.SetupInput
// (Final, Native, Private)

void UOptionsControlsPT::SetupInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "SetupInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OptionsControlsPT.WidgetSetActive
// (Final, Native, Public, BlueprintCallable)

void UOptionsControlsPT::WidgetSetActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionsControlsPT", "WidgetSetActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerCharacterAnimInterface.ForceCombatState
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void IPlayerCharacterAnimInterface::ForceCombatState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacterAnimInterface", "ForceCombatState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerCharacterAnimInterface.ReleaseForceCombatState
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void IPlayerCharacterAnimInterface::ReleaseForceCombatState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacterAnimInterface", "ReleaseForceCombatState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerCharacterAnimInterface.SetLowAttack
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsLowAttack                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IPlayerCharacterAnimInterface::SetLowAttack(bool bIsLowAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacterAnimInterface", "SetLowAttack");

	Params::PlayerCharacterAnimInterface_SetLowAttack Parms{};

	Parms.bIsLowAttack = bIsLowAttack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerAsyncTaskBlueprintProxy.AbortMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ResetInputVectors                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerAsyncTaskBlueprintProxy::AbortMovement(bool ResetInputVectors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerAsyncTaskBlueprintProxy", "AbortMovement");

	Params::PlayerAsyncTaskBlueprintProxy_AbortMovement Parms{};

	Parms.ResetInputVectors = ResetInputVectors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerAsyncTaskBlueprintProxy.OnMoveCompleted
// (Final, Native, Public)
// Parameters:
// struct FAIRequestID                     RequestID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPathFollowingResult                    MovementResult                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerAsyncTaskBlueprintProxy::OnMoveCompleted(const struct FAIRequestID& RequestID, EPathFollowingResult MovementResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerAsyncTaskBlueprintProxy", "OnMoveCompleted");

	Params::PlayerAsyncTaskBlueprintProxy_OnMoveCompleted Parms{};

	Parms.RequestID = std::move(RequestID);
	Parms.MovementResult = MovementResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PreStreamTexturesWorldSubsystem.AddPreStreamTexturesJob
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       OnPreStreamTextureDone                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             InTag                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInForceTextureLoad                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPreStreamTexturesWorldSubsystem::AddPreStreamTexturesJob(const TDelegate<void()>& OnPreStreamTextureDone, const class FName InTag, const bool bInForceTextureLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreStreamTexturesWorldSubsystem", "AddPreStreamTexturesJob");

	Params::PreStreamTexturesWorldSubsystem_AddPreStreamTexturesJob Parms{};

	Parms.OnPreStreamTextureDone = OnPreStreamTextureDone;
	Parms.InTag = InTag;
	Parms.bInForceTextureLoad = bInForceTextureLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ArchiveButton.SetStatus
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UArchiveButton::SetStatus(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArchiveButton", "SetStatus");

	Params::ArchiveButton_SetStatus Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ArchiveButton.UpdateStatus
// (Event, Public, BlueprintEvent)

void UArchiveButton::UpdateStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArchiveButton", "UpdateStatus");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.OFButtonUserWidget.OnButtonHovered
// (Final, Native, Private)

void UOFButtonUserWidget::OnButtonHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFButtonUserWidget", "OnButtonHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFButtonUserWidget.OnButtonUnHovered
// (Final, Native, Private)
// Parameters:
// class UButton*                          Button                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFButtonUserWidget::OnButtonUnHovered(class UButton* Button)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFButtonUserWidget", "OnButtonUnHovered");

	Params::OFButtonUserWidget_OnButtonUnHovered Parms{};

	Parms.Button = Button;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.OFButtonUserWidget.OnWidgetHover__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFButtonUserWidget::OnWidgetHover__DelegateSignature(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFButtonUserWidget", "OnWidgetHover__DelegateSignature");

	Params::OFButtonUserWidget_OnWidgetHover__DelegateSignature Parms{};

	Parms.Widget = Widget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.RebindKeyWidget.ChangePrimaryKey
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FKey                             InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URebindKeyWidget::ChangePrimaryKey(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RebindKeyWidget", "ChangePrimaryKey");

	Params::RebindKeyWidget_ChangePrimaryKey Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.RebindKeyWidget.ChangeSecondaryKey
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FKey                             InKey                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URebindKeyWidget::ChangeSecondaryKey(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RebindKeyWidget", "ChangeSecondaryKey");

	Params::RebindKeyWidget_ChangeSecondaryKey Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.RebindKeyWidget.ConfirmationPopupOnSuccessHandler
// (Final, Native, Protected)
// Parameters:
// bool                                    bChange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URebindKeyWidget::ConfirmationPopupOnSuccessHandler(bool bChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RebindKeyWidget", "ConfirmationPopupOnSuccessHandler");

	Params::RebindKeyWidget_ConfirmationPopupOnSuccessHandler Parms{};

	Parms.bChange = bChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.RebindKeyWidget.HandlePrimaryKeyPressed
// (Final, Native, Protected)

void URebindKeyWidget::HandlePrimaryKeyPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RebindKeyWidget", "HandlePrimaryKeyPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.RebindKeyWidget.HandlePrimaryKeySelected
// (Final, Native, Protected)
// Parameters:
// struct FKey                             InKey                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URebindKeyWidget::HandlePrimaryKeySelected(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RebindKeyWidget", "HandlePrimaryKeySelected");

	Params::RebindKeyWidget_HandlePrimaryKeySelected Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.RebindKeyWidget.HandleSecondaryKeyPressed
// (Final, Native, Protected)

void URebindKeyWidget::HandleSecondaryKeyPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RebindKeyWidget", "HandleSecondaryKeyPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.RebindKeyWidget.HandleSecondaryKeySelected
// (Final, Native, Protected)
// Parameters:
// struct FKey                             InKey                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URebindKeyWidget::HandleSecondaryKeySelected(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RebindKeyWidget", "HandleSecondaryKeySelected");

	Params::RebindKeyWidget_HandleSecondaryKeySelected Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.RebindKeyWidget.PostBindingUpdated
// (Event, Public, BlueprintEvent)

void URebindKeyWidget::PostBindingUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RebindKeyWidget", "PostBindingUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.RebindKeyWidget.PreBindingUpdated
// (Event, Public, BlueprintEvent)

void URebindKeyWidget::PreBindingUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RebindKeyWidget", "PreBindingUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.RebindKeyWidget.SetupWidget
// (Event, Public, BlueprintEvent)

void URebindKeyWidget::SetupWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RebindKeyWidget", "SetupWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.ASyncActionCommitSave.AsyncCommitSave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject_0                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UASyncActionCommitSave*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UASyncActionCommitSave* UASyncActionCommitSave::AsyncCommitSave(class UObject* WorldContextObject_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ASyncActionCommitSave", "AsyncCommitSave");

	Params::ASyncActionCommitSave_AsyncCommitSave Parms{};

	Parms.WorldContextObject_0 = WorldContextObject_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ASyncActionCommitSave.OnSaveDone
// (Final, Native, Private)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UASyncActionCommitSave::OnSaveDone(bool Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ASyncActionCommitSave", "OnSaveDone");

	Params::ASyncActionCommitSave_OnSaveDone Parms{};

	Parms.Success = Success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.AbilityTask_PlayMontageAndWaitForEvent.PlayMontageAndWaitForEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     MontageToPlay_0                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            EventTags_0                                            (Parm, NativeAccessSpecifierPublic)
// float                                   Rate_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartSection_0                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAbilityEnds_0                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimRootMotionTranslationScale_0                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_PlayMontageAndWaitForEvent*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_PlayMontageAndWaitForEvent* UAbilityTask_PlayMontageAndWaitForEvent::PlayMontageAndWaitForEvent(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* MontageToPlay_0, const struct FGameplayTagContainer& EventTags_0, float Rate_0, class FName StartSection_0, bool bStopWhenAbilityEnds_0, float AnimRootMotionTranslationScale_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_PlayMontageAndWaitForEvent", "PlayMontageAndWaitForEvent");

	Params::AbilityTask_PlayMontageAndWaitForEvent_PlayMontageAndWaitForEvent Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.MontageToPlay_0 = MontageToPlay_0;
	Parms.EventTags_0 = std::move(EventTags_0);
	Parms.Rate_0 = Rate_0;
	Parms.StartSection_0 = StartSection_0;
	Parms.bStopWhenAbilityEnds_0 = bStopWhenAbilityEnds_0;
	Parms.AnimRootMotionTranslationScale_0 = AnimRootMotionTranslationScale_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProjectileLibrary.CalculateBallisticRange
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InitialHeight                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Gravity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UProjectileLibrary::CalculateBallisticRange(float Speed, float InitialHeight, float Gravity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileLibrary", "CalculateBallisticRange");

	Params::ProjectileLibrary_CalculateBallisticRange Parms{};

	Parms.Speed = Speed;
	Parms.InitialHeight = InitialHeight;
	Parms.Gravity = Gravity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProjectileLibrary.SuggestProjectileVelocityByProfile
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TossVelocity                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LaunchSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideGravityZ                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCollisionProfileName            TraceProfile                                           (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// ESuggestProjVelocityTraceOption         TraceOption                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CollisionRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFavorHighArc                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDrawDebug                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UProjectileLibrary::SuggestProjectileVelocityByProfile(const class UObject* WorldContextObject, struct FVector* TossVelocity, const struct FVector& StartLocation, const struct FVector& EndLocation, float LaunchSpeed, float OverrideGravityZ, const struct FCollisionProfileName& TraceProfile, ESuggestProjVelocityTraceOption TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug, const TArray<class AActor*>& ActorsToIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileLibrary", "SuggestProjectileVelocityByProfile");

	Params::ProjectileLibrary_SuggestProjectileVelocityByProfile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.LaunchSpeed = LaunchSpeed;
	Parms.OverrideGravityZ = OverrideGravityZ;
	Parms.TraceProfile = std::move(TraceProfile);
	Parms.TraceOption = TraceOption;
	Parms.CollisionRadius = CollisionRadius;
	Parms.bFavorHighArc = bFavorHighArc;
	Parms.bDrawDebug = bDrawDebug;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TossVelocity != nullptr)
		*TossVelocity = std::move(Parms.TossVelocity);

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProjectileLibrary.SuggestProjectileVelocityFiltered
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TossVelocity                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          StartLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          EndLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LaunchSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideGravityZ                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESuggestProjVelocityTraceOption         TraceOption                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CollisionRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFavorHighArc                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDrawDebug                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UProjectileLibrary::SuggestProjectileVelocityFiltered(const class UObject* WorldContextObject, struct FVector* TossVelocity, const struct FVector& StartLocation, const struct FVector& EndLocation, float LaunchSpeed, float OverrideGravityZ, ESuggestProjVelocityTraceOption TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug, const TArray<class AActor*>& ActorsToIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectileLibrary", "SuggestProjectileVelocityFiltered");

	Params::ProjectileLibrary_SuggestProjectileVelocityFiltered Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.LaunchSpeed = LaunchSpeed;
	Parms.OverrideGravityZ = OverrideGravityZ;
	Parms.TraceOption = TraceOption;
	Parms.CollisionRadius = CollisionRadius;
	Parms.bFavorHighArc = bFavorHighArc;
	Parms.bDrawDebug = bDrawDebug;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TossVelocity != nullptr)
		*TossVelocity = std::move(Parms.TossVelocity);

	return Parms.ReturnValue;
}


// Function ObsidianFox.BFL_PlayerMovement.CreateMoveToProxyObject
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Destination                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AcceptanceRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopOnOverlap                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisableInput                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIgnoreLookInput                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayerAsyncTaskBlueprintProxy*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayerAsyncTaskBlueprintProxy* UBFL_PlayerMovement::CreateMoveToProxyObject(class UObject* WorldContextObject, class APawn* Pawn, const struct FVector& Destination, class AActor* TargetActor, float AcceptanceRadius, bool bStopOnOverlap, bool bDisableInput, bool bIgnoreLookInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_PlayerMovement", "CreateMoveToProxyObject");

	Params::BFL_PlayerMovement_CreateMoveToProxyObject Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Pawn = Pawn;
	Parms.Destination = std::move(Destination);
	Parms.TargetActor = TargetActor;
	Parms.AcceptanceRadius = AcceptanceRadius;
	Parms.bStopOnOverlap = bStopOnOverlap;
	Parms.bDisableInput = bDisableInput;
	Parms.bIgnoreLookInput = bIgnoreLookInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.BFL_PlayerMovement.SimpleMoveToLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EPlayerMoveToLocationAsyncMode          AsyncMode                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOFPlayerController*              Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          GoalLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInDisableInput                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIgnoreLookInput                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBFL_PlayerMovement::SimpleMoveToLocation(const struct FLatentActionInfo& LatentInfo, EPlayerMoveToLocationAsyncMode* AsyncMode, class AOFPlayerController* Controller, const struct FVector& GoalLocation, const bool bInDisableInput, const bool bInIgnoreLookInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_PlayerMovement", "SimpleMoveToLocation");

	Params::BFL_PlayerMovement_SimpleMoveToLocation Parms{};

	Parms.LatentInfo = std::move(LatentInfo);
	Parms.Controller = Controller;
	Parms.GoalLocation = std::move(GoalLocation);
	Parms.bInDisableInput = bInDisableInput;
	Parms.bInIgnoreLookInput = bInIgnoreLookInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AsyncMode != nullptr)
		*AsyncMode = Parms.AsyncMode;
}


// Function ObsidianFox.BPAsyncAction_ChunkInstallWaitPopup.DisplayChunkInstallWaitPopup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject_0                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Title                                                  (Parm, NativeAccessSpecifierPublic)
// class FText                             Description                                            (Parm, NativeAccessSpecifierPublic)
// int32                                   ChunkIndex_0                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UOFChunkInstallPopupWidget>ConfirmationPopupClass                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBPAsyncAction_ChunkInstallWaitPopup*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBPAsyncAction_ChunkInstallWaitPopup* UBPAsyncAction_ChunkInstallWaitPopup::DisplayChunkInstallWaitPopup(const class UObject* WorldContextObject_0, const class FText& Title, const class FText& Description, int32 ChunkIndex_0, TSubclassOf<class UOFChunkInstallPopupWidget> ConfirmationPopupClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPAsyncAction_ChunkInstallWaitPopup", "DisplayChunkInstallWaitPopup");

	Params::BPAsyncAction_ChunkInstallWaitPopup_DisplayChunkInstallWaitPopup Parms{};

	Parms.WorldContextObject_0 = WorldContextObject_0;
	Parms.Title = std::move(Title);
	Parms.Description = std::move(Description);
	Parms.ChunkIndex_0 = ChunkIndex_0;
	Parms.ConfirmationPopupClass = ConfirmationPopupClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.BPAsyncAction_ChunkInstallWaitPopup.OnConfirmationEndEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UBPAsyncAction_ChunkInstallWaitPopup::OnConfirmationEndEvent__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_ChunkInstallWaitPopup", "OnConfirmationEndEvent__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.BPAsyncAction_ChunkInstallWaitPopup.OnConfirmationResultEnded
// (Final, Native, Public)
// Parameters:
// bool                                    bResult                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_ChunkInstallWaitPopup::OnConfirmationResultEnded(bool bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_ChunkInstallWaitPopup", "OnConfirmationResultEnded");

	Params::BPAsyncAction_ChunkInstallWaitPopup_OnConfirmationResultEnded Parms{};

	Parms.bResult = bResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PreloadLevelsActor.OnOverlapBegin
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APreloadLevelsActor::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreloadLevelsActor", "OnOverlapBegin");

	Params::PreloadLevelsActor_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PreloadLevelsActor.OnOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APreloadLevelsActor::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreloadLevelsActor", "OnOverlapEnd");

	Params::PreloadLevelsActor_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BPAsyncAction_ConfirmationPopup.DisplayConfirmationPopup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject_0                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Title                                                  (Parm, NativeAccessSpecifierPublic)
// class FText                             Description                                            (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class UOFConfirmationPopupWidget>ConfirmationPopupClass                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBPAsyncAction_ConfirmationPopup* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBPAsyncAction_ConfirmationPopup* UBPAsyncAction_ConfirmationPopup::DisplayConfirmationPopup(const class UObject* WorldContextObject_0, const class FText& Title, const class FText& Description, TSubclassOf<class UOFConfirmationPopupWidget> ConfirmationPopupClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPAsyncAction_ConfirmationPopup", "DisplayConfirmationPopup");

	Params::BPAsyncAction_ConfirmationPopup_DisplayConfirmationPopup Parms{};

	Parms.WorldContextObject_0 = WorldContextObject_0;
	Parms.Title = std::move(Title);
	Parms.Description = std::move(Description);
	Parms.ConfirmationPopupClass = ConfirmationPopupClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.BPAsyncAction_ConfirmationPopup.OnConfirmationEndEvent__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UBPAsyncAction_ConfirmationPopup::OnConfirmationEndEvent__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_ConfirmationPopup", "OnConfirmationEndEvent__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.BPAsyncAction_ConfirmationPopup.OnConfirmationResultEnded
// (Final, Native, Public)
// Parameters:
// bool                                    bResult                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_ConfirmationPopup::OnConfirmationResultEnded(bool bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_ConfirmationPopup", "OnConfirmationResultEnded");

	Params::BPAsyncAction_ConfirmationPopup_OnConfirmationResultEnded Parms{};

	Parms.bResult = bResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BPAsyncAction_GetMontageByTag.GetMontageByTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComp                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     MontageTag_0                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBPAsyncAction_GetMontageByTag*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBPAsyncAction_GetMontageByTag* UBPAsyncAction_GetMontageByTag::GetMontageByTag(const class USkeletalMeshComponent* SkeletalMeshComp, const struct FGameplayTag& MontageTag_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPAsyncAction_GetMontageByTag", "GetMontageByTag");

	Params::BPAsyncAction_GetMontageByTag_GetMontageByTag Parms{};

	Parms.SkeletalMeshComp = SkeletalMeshComp;
	Parms.MontageTag_0 = std::move(MontageTag_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.BPAsyncAction_GetMontageByTag.GetAnimationMontageAsyncBaseSignature__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_GetMontageByTag::GetAnimationMontageAsyncBaseSignature__DelegateSignature(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_GetMontageByTag", "GetAnimationMontageAsyncBaseSignature__DelegateSignature");

	Params::BPAsyncAction_GetMontageByTag_GetAnimationMontageAsyncBaseSignature__DelegateSignature Parms{};

	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.PuzzleHelperHud.SetupInput
// (Final, Native, Public, BlueprintCallable)

void UPuzzleHelperHud::SetupInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleHelperHud", "SetupInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PuzzleHelperHud.ShowHideText
// (Event, Public, BlueprintEvent)

void UPuzzleHelperHud::ShowHideText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleHelperHud", "ShowHideText");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.BPAsyncAction_GetTextureAssociatedWithInputAction.GetTextureAssociatedWithInputAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputAction*                     InInputAction                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPiecesInputMappingContext*       InInputMappingContext                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBPAsyncAction_GetTextureAssociatedWithInputAction*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBPAsyncAction_GetTextureAssociatedWithInputAction* UBPAsyncAction_GetTextureAssociatedWithInputAction::GetTextureAssociatedWithInputAction(const class UObject* WorldContextObject, const class UInputAction* InInputAction, const class UPiecesInputMappingContext* InInputMappingContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPAsyncAction_GetTextureAssociatedWithInputAction", "GetTextureAssociatedWithInputAction");

	Params::BPAsyncAction_GetTextureAssociatedWithInputAction_GetTextureAssociatedWithInputAction Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InInputAction = InInputAction;
	Parms.InInputMappingContext = InInputMappingContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.BPAsyncAction_GetTextureAssociatedWithInputAction.OnAsyncActionCompletePin__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UTexture2D*                       Texture                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             KeyString                                              (Parm, NativeAccessSpecifierPublic)

void UBPAsyncAction_GetTextureAssociatedWithInputAction::OnAsyncActionCompletePin__DelegateSignature(class UTexture2D* Texture, const class FText& KeyString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_GetTextureAssociatedWithInputAction", "OnAsyncActionCompletePin__DelegateSignature");

	Params::BPAsyncAction_GetTextureAssociatedWithInputAction_OnAsyncActionCompletePin__DelegateSignature Parms{};

	Parms.Texture = Texture;
	Parms.KeyString = std::move(KeyString);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.BPAsyncAction_PlayIKMontage.PlayIKMontage
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InSkeletalMesh                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FIKParameters>            IKParameters                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartingPosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartingSection                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBPAsyncAction_PlayIKMontage*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBPAsyncAction_PlayIKMontage* UBPAsyncAction_PlayIKMontage::PlayIKMontage(class USkeletalMeshComponent* InSkeletalMesh, class UAnimMontage* MontageToPlay, const TArray<struct FIKParameters>& IKParameters, float PlayRate, float StartingPosition, const class FName StartingSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPAsyncAction_PlayIKMontage", "PlayIKMontage");

	Params::BPAsyncAction_PlayIKMontage_PlayIKMontage Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;
	Parms.MontageToPlay = MontageToPlay;
	Parms.IKParameters = std::move(IKParameters);
	Parms.PlayRate = PlayRate;
	Parms.StartingPosition = StartingPosition;
	Parms.StartingSection = StartingSection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.SaveSlotWidget.LoadGame
// (Final, Native, Protected, BlueprintCallable)

void USaveSlotWidget::LoadGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSlotWidget", "LoadGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SaveSlotWidget.OnLoadLevelPressed
// (Event, Protected, BlueprintEvent)

void USaveSlotWidget::OnLoadLevelPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSlotWidget", "OnLoadLevelPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.SaveSlotWidget.OnLoadSaveButtonPressed
// (Final, Native, Protected)

void USaveSlotWidget::OnLoadSaveButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSlotWidget", "OnLoadSaveButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SaveSlotWidget.OnSaveConfirmationDone
// (Final, Native, Protected)
// Parameters:
// bool                                    bAccepted                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveSlotWidget::OnSaveConfirmationDone(bool bAccepted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSlotWidget", "OnSaveConfirmationDone");

	Params::SaveSlotWidget_OnSaveConfirmationDone Parms{};

	Parms.bAccepted = bAccepted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SaveSlotWidget.OnSaveFinished
// (Final, Native, Protected)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveSlotWidget::OnSaveFinished(bool Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSlotWidget", "OnSaveFinished");

	Params::SaveSlotWidget_OnSaveFinished Parms{};

	Parms.Success = Success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SaveSlotWidget.OnSaveUpdateCompleted
// (Event, Protected, BlueprintEvent)

void USaveSlotWidget::OnSaveUpdateCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSlotWidget", "OnSaveUpdateCompleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.SaveSlotWidget.SaveGameInSlot
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   SaveGameSlot                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveSlotWidget::SaveGameInSlot(int32 SaveGameSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSlotWidget", "SaveGameInSlot");

	Params::SaveSlotWidget_SaveGameInSlot Parms{};

	Parms.SaveGameSlot = SaveGameSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SaveSlotWidget.GetProgression
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag USaveSlotWidget::GetProgression() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveSlotWidget", "GetProgression");

	Params::SaveSlotWidget_GetProgression Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.BPAsyncAction_PlayNearestSectionMontage.PlayNearestSectionMontage
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InSkeletalMesh                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          GoalLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SetGoalLocationAsIKTarget                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreXY                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBPAsyncAction_PlayNearestSectionMontage*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBPAsyncAction_PlayNearestSectionMontage* UBPAsyncAction_PlayNearestSectionMontage::PlayNearestSectionMontage(class USkeletalMeshComponent* InSkeletalMesh, const struct FVector& GoalLocation, class UAnimMontage* MontageToPlay, bool SetGoalLocationAsIKTarget, float PlayRate, bool IgnoreXY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPAsyncAction_PlayNearestSectionMontage", "PlayNearestSectionMontage");

	Params::BPAsyncAction_PlayNearestSectionMontage_PlayNearestSectionMontage Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;
	Parms.GoalLocation = std::move(GoalLocation);
	Parms.MontageToPlay = MontageToPlay;
	Parms.SetGoalLocationAsIKTarget = SetGoalLocationAsIKTarget;
	Parms.PlayRate = PlayRate;
	Parms.IgnoreXY = IgnoreXY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.BPAsyncAction_RepositionAndReorient.RepositionAndReorient
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERepositionMethod                       RepositionMethod                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EReorientMethod                         ReorientMethod                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  SceneComponentTransformGoal                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBPAsyncAction_RepositionAndReorient*OutActionProxy                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETransformCalculationMethod             TransformBehaviour                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    LerpAsFallback_0                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    RepositionBeforeReorientation_0                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreZ_0                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MoveCloseEnough_0                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TravelTime_0                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEasingFunc                             EasingFunction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EasingExponent                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AngleCloseEnough_0                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBPAsyncAction_RepositionAndReorient*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBPAsyncAction_RepositionAndReorient* UBPAsyncAction_RepositionAndReorient::RepositionAndReorient(class ACharacter* Character, ERepositionMethod RepositionMethod, EReorientMethod ReorientMethod, class USceneComponent* SceneComponentTransformGoal, class UBPAsyncAction_RepositionAndReorient** OutActionProxy, ETransformCalculationMethod TransformBehaviour, bool LerpAsFallback_0, bool RepositionBeforeReorientation_0, bool IgnoreZ_0, float MoveCloseEnough_0, float TravelTime_0, EEasingFunc EasingFunction, float EasingExponent, float AngleCloseEnough_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPAsyncAction_RepositionAndReorient", "RepositionAndReorient");

	Params::BPAsyncAction_RepositionAndReorient_RepositionAndReorient Parms{};

	Parms.Character = Character;
	Parms.RepositionMethod = RepositionMethod;
	Parms.ReorientMethod = ReorientMethod;
	Parms.SceneComponentTransformGoal = SceneComponentTransformGoal;
	Parms.TransformBehaviour = TransformBehaviour;
	Parms.LerpAsFallback_0 = LerpAsFallback_0;
	Parms.RepositionBeforeReorientation_0 = RepositionBeforeReorientation_0;
	Parms.IgnoreZ_0 = IgnoreZ_0;
	Parms.MoveCloseEnough_0 = MoveCloseEnough_0;
	Parms.TravelTime_0 = TravelTime_0;
	Parms.EasingFunction = EasingFunction;
	Parms.EasingExponent = EasingExponent;
	Parms.AngleCloseEnough_0 = AngleCloseEnough_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActionProxy != nullptr)
		*OutActionProxy = Parms.OutActionProxy;

	return Parms.ReturnValue;
}


// Function ObsidianFox.BPAsyncAction_RepositionAndReorient.CharacterMoveToCompleted
// (Final, Native, Private)
// Parameters:
// EPathFollowingResult                    MovementResult                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIRequestID                     RequestID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_RepositionAndReorient::CharacterMoveToCompleted(EPathFollowingResult MovementResult, const struct FAIRequestID& RequestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_RepositionAndReorient", "CharacterMoveToCompleted");

	Params::BPAsyncAction_RepositionAndReorient_CharacterMoveToCompleted Parms{};

	Parms.MovementResult = MovementResult;
	Parms.RequestID = std::move(RequestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BPAsyncAction_RepositionAndReorient.CharacterMoveToFailed
// (Final, Native, Private)
// Parameters:
// EPathFollowingResult                    MovementResult                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIRequestID                     RequestID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_RepositionAndReorient::CharacterMoveToFailed(EPathFollowingResult MovementResult, const struct FAIRequestID& RequestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_RepositionAndReorient", "CharacterMoveToFailed");

	Params::BPAsyncAction_RepositionAndReorient_CharacterMoveToFailed Parms{};

	Parms.MovementResult = MovementResult;
	Parms.RequestID = std::move(RequestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BPAsyncAction_RepositionAndReorient.CharacterTurnInPlaceCompleted
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsBlendOutToWalk                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_RepositionAndReorient::CharacterTurnInPlaceCompleted(class ACharacter* Character, bool bIsBlendOutToWalk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_RepositionAndReorient", "CharacterTurnInPlaceCompleted");

	Params::BPAsyncAction_RepositionAndReorient_CharacterTurnInPlaceCompleted Parms{};

	Parms.Character = Character;
	Parms.bIsBlendOutToWalk = bIsBlendOutToWalk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BPAsyncAction_RepositionAndReorient.CharacterTurnInPlaceFailedAngleTooSmall
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_RepositionAndReorient::CharacterTurnInPlaceFailedAngleTooSmall(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_RepositionAndReorient", "CharacterTurnInPlaceFailedAngleTooSmall");

	Params::BPAsyncAction_RepositionAndReorient_CharacterTurnInPlaceFailedAngleTooSmall Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BPAsyncAction_RepositionAndReorient.LerpDoneFailure
// (Final, Native, Private)
// Parameters:
// class AActor*                           TransformedActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorTransformComponent*         TransformingComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_RepositionAndReorient::LerpDoneFailure(class AActor* TransformedActor, class UActorTransformComponent* TransformingComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_RepositionAndReorient", "LerpDoneFailure");

	Params::BPAsyncAction_RepositionAndReorient_LerpDoneFailure Parms{};

	Parms.TransformedActor = TransformedActor;
	Parms.TransformingComponent = TransformingComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BPAsyncAction_RepositionAndReorient.LerpDoneSuccess
// (Final, Native, Private)
// Parameters:
// class AActor*                           TransformedActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorTransformComponent*         TransformingComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_RepositionAndReorient::LerpDoneSuccess(class AActor* TransformedActor, class UActorTransformComponent* TransformingComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_RepositionAndReorient", "LerpDoneSuccess");

	Params::BPAsyncAction_RepositionAndReorient_LerpDoneSuccess Parms{};

	Parms.TransformedActor = TransformedActor;
	Parms.TransformingComponent = TransformingComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BPAsyncAction_RepositionAndReorient.LerpOnCloseEnough
// (Final, Native, Private)
// Parameters:
// class AActor*                           TransformedActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UActorTransformComponent*         TransformingComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_RepositionAndReorient::LerpOnCloseEnough(class AActor* TransformedActor, class UActorTransformComponent* TransformingComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_RepositionAndReorient", "LerpOnCloseEnough");

	Params::BPAsyncAction_RepositionAndReorient_LerpOnCloseEnough Parms{};

	Parms.TransformedActor = TransformedActor;
	Parms.TransformingComponent = TransformingComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.BPAsyncAction_RepositionAndReorient.OnAsyncActionCompletePin__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ACharacter*                       TransformedCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_RepositionAndReorient::OnAsyncActionCompletePin__DelegateSignature(class ACharacter* TransformedCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_RepositionAndReorient", "OnAsyncActionCompletePin__DelegateSignature");

	Params::BPAsyncAction_RepositionAndReorient_OnAsyncActionCompletePin__DelegateSignature Parms{};

	Parms.TransformedCharacter = TransformedCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.BPAsyncAction_RepositionAndReorient.ForceStopTransform
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                                    SnapCharacterToTargetLocation                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_RepositionAndReorient::ForceStopTransform(bool SnapCharacterToTargetLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_RepositionAndReorient", "ForceStopTransform");

	Params::BPAsyncAction_RepositionAndReorient_ForceStopTransform Parms{};

	Parms.SnapCharacterToTargetLocation = SnapCharacterToTargetLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BPAsyncAction_RepositionAndReorient.ForceStopTransformLocation
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                                    SnapCharacterToTargetLocation                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_RepositionAndReorient::ForceStopTransformLocation(bool SnapCharacterToTargetLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_RepositionAndReorient", "ForceStopTransformLocation");

	Params::BPAsyncAction_RepositionAndReorient_ForceStopTransformLocation Parms{};

	Parms.SnapCharacterToTargetLocation = SnapCharacterToTargetLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BPAsyncAction_RepositionAndReorient.ForceStopTransformRotation
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                                    SnapCharacterToTargetRotation                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_RepositionAndReorient::ForceStopTransformRotation(bool SnapCharacterToTargetRotation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_RepositionAndReorient", "ForceStopTransformRotation");

	Params::BPAsyncAction_RepositionAndReorient_ForceStopTransformRotation Parms{};

	Parms.SnapCharacterToTargetRotation = SnapCharacterToTargetRotation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BPAsyncAction_SpawnEnemy.SpawnEnemy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AEnemySpawner*                    EnemySpawner                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBPAsyncAction_SpawnEnemy*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBPAsyncAction_SpawnEnemy* UBPAsyncAction_SpawnEnemy::SpawnEnemy(class AEnemySpawner* EnemySpawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPAsyncAction_SpawnEnemy", "SpawnEnemy");

	Params::BPAsyncAction_SpawnEnemy_SpawnEnemy Parms{};

	Parms.EnemySpawner = EnemySpawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.BPAsyncAction_SpawnEnemy.OnAsyncSpawnCompletePin__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AOFEnemyCharacter*                SpawnedEnemy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAIController*                    SpawnedAICOntroller                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEnemySpawner*                    Spawner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_SpawnEnemy::OnAsyncSpawnCompletePin__DelegateSignature(class AOFEnemyCharacter* SpawnedEnemy, class AAIController* SpawnedAICOntroller, class AEnemySpawner* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_SpawnEnemy", "OnAsyncSpawnCompletePin__DelegateSignature");

	Params::BPAsyncAction_SpawnEnemy_OnAsyncSpawnCompletePin__DelegateSignature Parms{};

	Parms.SpawnedEnemy = SpawnedEnemy;
	Parms.SpawnedAICOntroller = SpawnedAICOntroller;
	Parms.Spawner = Spawner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.BPAsyncAction_SpawnEnemy.OnSpawnerComplete
// (Final, Native, Protected)
// Parameters:
// class AOFEnemyCharacter*                SpawnedEnemy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAIController*                    SpawnedAICOntroller                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEnemySpawner*                    Spawner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_SpawnEnemy::OnSpawnerComplete(class AOFEnemyCharacter* SpawnedEnemy, class AAIController* SpawnedAICOntroller, class AEnemySpawner* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_SpawnEnemy", "OnSpawnerComplete");

	Params::BPAsyncAction_SpawnEnemy_OnSpawnerComplete Parms{};

	Parms.SpawnedEnemy = SpawnedEnemy;
	Parms.SpawnedAICOntroller = SpawnedAICOntroller;
	Parms.Spawner = Spawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BPAsyncAction_SpawnEnemies.SpawnEnemies
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AEnemySpawner*>            EnemySpawners                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UBPAsyncAction_SpawnEnemies*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBPAsyncAction_SpawnEnemies* UBPAsyncAction_SpawnEnemies::SpawnEnemies(const TArray<class AEnemySpawner*>& EnemySpawners)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPAsyncAction_SpawnEnemies", "SpawnEnemies");

	Params::BPAsyncAction_SpawnEnemies_SpawnEnemies Parms{};

	Parms.EnemySpawners = std::move(EnemySpawners);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.BPAsyncAction_SpawnEnemies.OnAsyncSpawnCompletePin__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AOFEnemyCharacter*                SpawnedEnemy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAIController*                    SpawnedAICOntroller                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEnemySpawner*                    Spawner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_SpawnEnemies::OnAsyncSpawnCompletePin__DelegateSignature(class AOFEnemyCharacter* SpawnedEnemy, class AAIController* SpawnedAICOntroller, class AEnemySpawner* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_SpawnEnemies", "OnAsyncSpawnCompletePin__DelegateSignature");

	Params::BPAsyncAction_SpawnEnemies_OnAsyncSpawnCompletePin__DelegateSignature Parms{};

	Parms.SpawnedEnemy = SpawnedEnemy;
	Parms.SpawnedAICOntroller = SpawnedAICOntroller;
	Parms.Spawner = Spawner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.BPAsyncAction_SpawnEnemies.OnSpawnerComplete
// (Final, Native, Protected)
// Parameters:
// class AOFEnemyCharacter*                SpawnedEnemy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAIController*                    SpawnedAICOntroller                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEnemySpawner*                    Spawner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_SpawnEnemies::OnSpawnerComplete(class AOFEnemyCharacter* SpawnedEnemy, class AAIController* SpawnedAICOntroller, class AEnemySpawner* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_SpawnEnemies", "OnSpawnerComplete");

	Params::BPAsyncAction_SpawnEnemies_OnSpawnerComplete Parms{};

	Parms.SpawnedEnemy = SpawnedEnemy;
	Parms.SpawnedAICOntroller = SpawnedAICOntroller;
	Parms.Spawner = Spawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BPAsyncAction_SplineMove.MoveDirectionOnSpline
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USplineMovementComponent*         MovementComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineMovementDirection                MovementDirection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBPAsyncAction_SplineMove*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBPAsyncAction_SplineMove* UBPAsyncAction_SplineMove::MoveDirectionOnSpline(class USplineMovementComponent* MovementComponent, ESplineMovementDirection MovementDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPAsyncAction_SplineMove", "MoveDirectionOnSpline");

	Params::BPAsyncAction_SplineMove_MoveDirectionOnSpline Parms{};

	Parms.MovementComponent = MovementComponent;
	Parms.MovementDirection = MovementDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.BPFL_PlayState.GetIsInCombat
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBPFL_PlayState::GetIsInCombat(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFL_PlayState", "GetIsInCombat");

	Params::BPFL_PlayState_GetIsInCombat Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.BPFL_PlayState.GetMainState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameMainState                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameMainState UBPFL_PlayState::GetMainState(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFL_PlayState", "GetMainState");

	Params::BPFL_PlayState_GetMainState Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.BPFL_PlayState.GetPlayerHealthState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerHealthState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerHealthState UBPFL_PlayState::GetPlayerHealthState(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFL_PlayState", "GetPlayerHealthState");

	Params::BPFL_PlayState_GetPlayerHealthState Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.BPFL_PlayState.PopMainState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          StateOwner                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPFL_PlayState::PopMainState(const class UObject* WorldContextObject, const class UObject* StateOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFL_PlayState", "PopMainState");

	Params::BPFL_PlayState_PopMainState Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StateOwner = StateOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BPFL_PlayState.PushMainSate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          StateOwner                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameMainState                          NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPFL_PlayState::PushMainSate(const class UObject* WorldContextObject, const class UObject* StateOwner, EGameMainState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPFL_PlayState", "PushMainSate");

	Params::BPFL_PlayState_PushMainSate Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StateOwner = StateOwner;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPropAnimInstance.OnCharacterPossessed
// (Final, Native, Protected)
// Parameters:
// class AOFPlayerCharacter*               NewCharacter                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFPropAnimInstance::OnCharacterPossessed(const class AOFPlayerCharacter* NewCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPropAnimInstance", "OnCharacterPossessed");

	Params::OFPropAnimInstance_OnCharacterPossessed Parms{};

	Parms.NewCharacter = NewCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SkeletonPuzzleActor.RotateBonePitch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             Bone                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASkeletonPuzzleActor::RotateBonePitch(class UStaticMeshComponent* Bone, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkeletonPuzzleActor", "RotateBonePitch");

	Params::SkeletonPuzzleActor_RotateBonePitch Parms{};

	Parms.Bone = Bone;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SkeletonPuzzleActor.RotateBoneYaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  Bone                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASkeletonPuzzleActor::RotateBoneYaw(class USceneComponent* Bone, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkeletonPuzzleActor", "RotateBoneYaw");

	Params::SkeletonPuzzleActor_RotateBoneYaw Parms{};

	Parms.Bone = Bone;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SkeletonPuzzleActor.SkeletonPuzzleBeginPlay
// (Event, Public, BlueprintEvent)

void ASkeletonPuzzleActor::SkeletonPuzzleBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkeletonPuzzleActor", "SkeletonPuzzleBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.GameSubsystem_DarkMan.FadeInAreaEffects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FadeDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_DarkMan::FadeInAreaEffects(float FadeDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_DarkMan", "FadeInAreaEffects");

	Params::GameSubsystem_DarkMan_FadeInAreaEffects Parms{};

	Parms.FadeDuration = FadeDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_DarkMan.FadeOutAreaEffects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FadeDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_DarkMan::FadeOutAreaEffects(float FadeDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_DarkMan", "FadeOutAreaEffects");

	Params::GameSubsystem_DarkMan_FadeOutAreaEffects Parms{};

	Parms.FadeDuration = FadeDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_DarkMan.OverrideCameraEffectsAllowed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCameraEffectsDisabled                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_DarkMan::OverrideCameraEffectsAllowed(const bool bCameraEffectsDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_DarkMan", "OverrideCameraEffectsAllowed");

	Params::GameSubsystem_DarkMan_OverrideCameraEffectsAllowed Parms{};

	Parms.bCameraEffectsDisabled = bCameraEffectsDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_DarkMan.SetActiveDarkMan
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       NewActiveDarkMan                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSubsystem_DarkMan::SetActiveDarkMan(class ACharacter* NewActiveDarkMan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_DarkMan", "SetActiveDarkMan");

	Params::GameSubsystem_DarkMan_SetActiveDarkMan Parms{};

	Parms.NewActiveDarkMan = NewActiveDarkMan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_DarkMan.GetActiveDarkMan
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UGameSubsystem_DarkMan::GetActiveDarkMan() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_DarkMan", "GetActiveDarkMan");

	Params::GameSubsystem_DarkMan_GetActiveDarkMan Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_DarkMan.GetCurrentObsessionStage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EOFObsessionStage                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EOFObsessionStage UGameSubsystem_DarkMan::GetCurrentObsessionStage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_DarkMan", "GetCurrentObsessionStage");

	Params::GameSubsystem_DarkMan_GetCurrentObsessionStage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_DarkMan.GetObsession
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSubsystem_DarkMan::GetObsession() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_DarkMan", "GetObsession");

	Params::GameSubsystem_DarkMan_GetObsession Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_DarkMan.GetObsessionDecayMin
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSubsystem_DarkMan::GetObsessionDecayMin() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_DarkMan", "GetObsessionDecayMin");

	Params::GameSubsystem_DarkMan_GetObsessionDecayMin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_DarkMan.GetObsessionDecayMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSubsystem_DarkMan::GetObsessionDecayMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_DarkMan", "GetObsessionDecayMultiplier");

	Params::GameSubsystem_DarkMan_GetObsessionDecayMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_DarkMan.GetObsessionRaw
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSubsystem_DarkMan::GetObsessionRaw() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_DarkMan", "GetObsessionRaw");

	Params::GameSubsystem_DarkMan_GetObsessionRaw Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_DarkMan.GetObsessionStage2Threshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSubsystem_DarkMan::GetObsessionStage2Threshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_DarkMan", "GetObsessionStage2Threshold");

	Params::GameSubsystem_DarkMan_GetObsessionStage2Threshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_DarkMan.GetObsessionStage3Threshold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameSubsystem_DarkMan::GetObsessionStage3Threshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_DarkMan", "GetObsessionStage3Threshold");

	Params::GameSubsystem_DarkMan_GetObsessionStage3Threshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.AverageLinetraceByChannel
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ExtraTraces                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DrawDebug                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UOFAnimInstance::AverageLinetraceByChannel(const struct FVector& Start, const struct FVector& End, float Radius, int32 ExtraTraces, ECollisionChannel TraceChannel, bool DrawDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "AverageLinetraceByChannel");

	Params::OFAnimInstance_AverageLinetraceByChannel Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.ExtraTraces = ExtraTraces;
	Parms.TraceChannel = TraceChannel;
	Parms.DrawDebug = DrawDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.ChangeIKState
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// EIKState                                StateToUpdate                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EIKState                                NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAnimInstance::ChangeIKState(EIKState* StateToUpdate, EIKState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "ChangeIKState");

	Params::OFAnimInstance_ChangeIKState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (StateToUpdate != nullptr)
		*StateToUpdate = Parms.StateToUpdate;
}


// Function ObsidianFox.OFAnimInstance.CheckSaveDataChanges
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UOFAnimInstance::CheckSaveDataChanges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "CheckSaveDataChanges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAnimInstance.CreateAnimationComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimComponent>       Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimComponent* UOFAnimInstance::CreateAnimationComponent(TSubclassOf<class UAnimComponent> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "CreateAnimationComponent");

	Params::OFAnimInstance_CreateAnimationComponent Parms{};

	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.DebugLinetrace
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FHitResult                       HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   LineThickness                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAnimInstance::DebugLinetrace(const struct FHitResult& HitResult, float LineThickness, float Lifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "DebugLinetrace");

	Params::OFAnimInstance_DebugLinetrace Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.LineThickness = LineThickness;
	Parms.Lifetime = Lifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAnimInstance.DebugLocationInterpolation
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          TargetLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ChasingLocation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   WantedProximity                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAnimInstance::DebugLocationInterpolation(const struct FVector& TargetLocation, const struct FVector& ChasingLocation, float WantedProximity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "DebugLocationInterpolation");

	Params::OFAnimInstance_DebugLocationInterpolation Parms{};

	Parms.TargetLocation = std::move(TargetLocation);
	Parms.ChasingLocation = std::move(ChasingLocation);
	Parms.WantedProximity = WantedProximity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAnimInstance.FreezeRagdollPosition
// (Final, Native, Protected, BlueprintCallable)

void UOFAnimInstance::FreezeRagdollPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "FreezeRagdollPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAnimInstance.FreezeTurnAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          LockOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAnimInstance::FreezeTurnAngle(class UObject* LockOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "FreezeTurnAngle");

	Params::OFAnimInstance_FreezeTurnAngle Parms{};

	Parms.LockOwner = LockOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAnimInstance.GetFocusPointOnCharacter
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOFAnimInstance::GetFocusPointOnCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "GetFocusPointOnCharacter");

	Params::OFAnimInstance_GetFocusPointOnCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.GetRagdollState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ERagdollState                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERagdollState UOFAnimInstance::GetRagdollState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "GetRagdollState");

	Params::OFAnimInstance_GetRagdollState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.GetStateMachineStateWeight
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             StateMachineName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StateName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFAnimInstance::GetStateMachineStateWeight(const class FName& StateMachineName, const class FName& StateName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "GetStateMachineStateWeight");

	Params::OFAnimInstance_GetStateMachineStateWeight Parms{};

	Parms.StateMachineName = StateMachineName;
	Parms.StateName = StateName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.LinetraceByChannelWDebug
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECollisionChannel                       TraceChannel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DrawDebug                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LineThickness                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugLifetime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UOFAnimInstance::LinetraceByChannelWDebug(const struct FVector& Start, const struct FVector& End, ECollisionChannel TraceChannel, bool DrawDebug, float LineThickness, float DebugLifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "LinetraceByChannelWDebug");

	Params::OFAnimInstance_LinetraceByChannelWDebug Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.TraceChannel = TraceChannel;
	Parms.DrawDebug = DrawDebug;
	Parms.LineThickness = LineThickness;
	Parms.DebugLifetime = DebugLifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.OnDeath
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            EventTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOFAnimInstance::OnDeath(const struct FGameplayTagContainer& EventTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "OnDeath");

	Params::OFAnimInstance_OnDeath Parms{};

	Parms.EventTags = std::move(EventTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.OFAnimInstance.OnFootStep__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          StepLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFootType                               FootStepType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAnimInstance::OnFootStep__DelegateSignature(const struct FVector& StepLocation, EFootType FootStepType, const class FName& BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "OnFootStep__DelegateSignature");

	Params::OFAnimInstance_OnFootStep__DelegateSignature Parms{};

	Parms.StepLocation = std::move(StepLocation);
	Parms.FootStepType = FootStepType;
	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OFAnimInstance.PlayFootStepAudio
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAnimInstance::PlayFootStepAudio(const class FName& BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "PlayFootStepAudio");

	Params::OFAnimInstance_PlayFootStepAudio Parms{};

	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAnimInstance.PredictStopLocation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FMovePrediction                  ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMovePrediction UOFAnimInstance::PredictStopLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "PredictStopLocation");

	Params::OFAnimInstance_PredictStopLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.RagdollEndRecovery
// (Final, Native, Protected, BlueprintCallable)

void UOFAnimInstance::RagdollEndRecovery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "RagdollEndRecovery");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAnimInstance.UnfreezeTurnAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          LockOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAnimInstance::UnfreezeTurnAngle(class UObject* LockOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "UnfreezeTurnAngle");

	Params::OFAnimInstance_UnfreezeTurnAngle Parms{};

	Parms.LockOwner = LockOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAnimInstance.WholebodyRagdoll
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Activate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAnimInstance::WholebodyRagdoll(bool Activate, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "WholebodyRagdoll");

	Params::OFAnimInstance_WholebodyRagdoll Parms{};

	Parms.Activate = Activate;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAnimInstance.BoneIsParent
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ParentBone                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ChildBone                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFAnimInstance::BoneIsParent(class FName ParentBone, class FName ChildBone, int32* Distance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "BoneIsParent");

	Params::OFAnimInstance_BoneIsParent Parms{};

	Parms.ParentBone = ParentBone;
	Parms.ChildBone = ChildBone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Distance != nullptr)
		*Distance = Parms.Distance;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.CheckFocusPointValidity
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FFocusPointData                  FocusPoint                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFAnimInstance::CheckFocusPointValidity(const struct FFocusPointData& FocusPoint) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "CheckFocusPointValidity");

	Params::OFAnimInstance_CheckFocusPointValidity Parms{};

	Parms.FocusPoint = std::move(FocusPoint);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.ForceStopRootMotion
// (Final, Native, Public, BlueprintCallable, Const)

void UOFAnimInstance::ForceStopRootMotion() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "ForceStopRootMotion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAnimInstance.GetAnimationComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAnimComponent>       ClassType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimComponent*                   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimComponent* UOFAnimInstance::GetAnimationComponent(TSubclassOf<class UAnimComponent> ClassType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "GetAnimationComponent");

	Params::OFAnimInstance_GetAnimationComponent Parms{};

	Parms.ClassType = ClassType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.GetCurveValueForBlueprint
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             CurveName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCurveExists                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFAnimInstance::GetCurveValueForBlueprint(class FName CurveName, bool* bCurveExists) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "GetCurveValueForBlueprint");

	Params::OFAnimInstance_GetCurveValueForBlueprint Parms{};

	Parms.CurveName = CurveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bCurveExists != nullptr)
		*bCurveExists = Parms.bCurveExists;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.GetLimbReach
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HeirarchyLength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFAnimInstance::GetLimbReach(class FName BoneName, int32 HeirarchyLength) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "GetLimbReach");

	Params::OFAnimInstance_GetLimbReach Parms{};

	Parms.BoneName = BoneName;
	Parms.HeirarchyLength = HeirarchyLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.GetParentBoneName
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HeirarchyHeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UOFAnimInstance::GetParentBoneName(class FName BoneName, int32 HeirarchyHeight) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "GetParentBoneName");

	Params::OFAnimInstance_GetParentBoneName Parms{};

	Parms.BoneName = BoneName;
	Parms.HeirarchyHeight = HeirarchyHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.HasAnyGameplayTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            Container                                              (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFAnimInstance::HasAnyGameplayTags(const struct FGameplayTagContainer& Container) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "HasAnyGameplayTags");

	Params::OFAnimInstance_HasAnyGameplayTags Parms{};

	Parms.Container = std::move(Container);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.IsIKTargetWithinReach
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReachLength                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HeirarchyLength                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFAnimInstance::IsIKTargetWithinReach(const struct FVector& Target, float ReachLength, class FName BoneName, int32 HeirarchyLength) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "IsIKTargetWithinReach");

	Params::OFAnimInstance_IsIKTargetWithinReach Parms{};

	Parms.Target = std::move(Target);
	Parms.ReachLength = ReachLength;
	Parms.BoneName = BoneName;
	Parms.HeirarchyLength = HeirarchyLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.IsPreviewWorld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFAnimInstance::IsPreviewWorld() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "IsPreviewWorld");

	Params::OFAnimInstance_IsPreviewWorld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimInstance.IsWithinVisionCone
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          PointToCheck                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VisionConeDegrees                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFAnimInstance::IsWithinVisionCone(const struct FVector& PointToCheck, float VisionConeDegrees) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAnimInstance", "IsWithinVisionCone");

	Params::OFAnimInstance_IsWithinVisionCone Parms{};

	Parms.PointToCheck = std::move(PointToCheck);
	Parms.VisionConeDegrees = VisionConeDegrees;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PuzzleActor.CancelExitsPuzzle
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APuzzleActor::CancelExitsPuzzle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "CancelExitsPuzzle");

	Params::PuzzleActor_CancelExitsPuzzle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PuzzleActor.EnteringPuzzle
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleActor::EnteringPuzzle(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "EnteringPuzzle");

	Params::PuzzleActor_EnteringPuzzle Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.PuzzleActor.EnterPuzzle
// (Native, Protected, BlueprintCallable)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleActor::EnterPuzzle(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "EnterPuzzle");

	Params::PuzzleActor_EnterPuzzle Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PuzzleActor.ExitingPuzzle
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AOFPlayerController*              InteractingPlayerController                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleActor::ExitingPuzzle(class AOFPlayerController* InteractingPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "ExitingPuzzle");

	Params::PuzzleActor_ExitingPuzzle Parms{};

	Parms.InteractingPlayerController = InteractingPlayerController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.PuzzleActor.ExitPuzzle
// (Native, Protected, BlueprintCallable)

void APuzzleActor::ExitPuzzle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "ExitPuzzle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PuzzleActor.GetRequiredItems
// (Event, Protected, BlueprintEvent)
// Parameters:
// TSet<class UItemData*>                  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TSet<class UItemData*> APuzzleActor::GetRequiredItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "GetRequiredItems");

	Params::PuzzleActor_GetRequiredItems Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ObsidianFox.PuzzleActor.ItemAddedHandler
// (Final, Native, Protected)
// Parameters:
// class UItemData*                        ItemData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleActor::ItemAddedHandler(const class UItemData* ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "ItemAddedHandler");

	Params::PuzzleActor_ItemAddedHandler Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PuzzleActor.PuzzleBeginPlay
// (Event, Protected, BlueprintEvent)

void APuzzleActor::PuzzleBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "PuzzleBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction ObsidianFox.PuzzleActor.PuzzleEnter__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class APuzzleActor*                     PuzzleActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleActor::PuzzleEnter__DelegateSignature(class APuzzleActor* PuzzleActor, class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "PuzzleEnter__DelegateSignature");

	Params::PuzzleActor_PuzzleEnter__DelegateSignature Parms{};

	Parms.PuzzleActor = PuzzleActor;
	Parms.InteractingCharacter = InteractingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.PuzzleActor.PuzzleExit__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class APuzzleActor*                     PuzzleActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOFPlayerController*              InteractingController                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleActor::PuzzleExit__DelegateSignature(class APuzzleActor* PuzzleActor, class AOFPlayerController* InteractingController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "PuzzleExit__DelegateSignature");

	Params::PuzzleActor_PuzzleExit__DelegateSignature Parms{};

	Parms.PuzzleActor = PuzzleActor;
	Parms.InteractingController = InteractingController;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.PuzzleActor.PuzzleSolve__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class APuzzleActor*                     PuzzleActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOFPlayerController*              InteractingController                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleActor::PuzzleSolve__DelegateSignature(class APuzzleActor* PuzzleActor, class AOFPlayerController* InteractingController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "PuzzleSolve__DelegateSignature");

	Params::PuzzleActor_PuzzleSolve__DelegateSignature Parms{};

	Parms.PuzzleActor = PuzzleActor;
	Parms.InteractingController = InteractingController;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.PuzzleActor.PuzzleUpdateSolvableState__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bSolvable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleActor::PuzzleUpdateSolvableState__DelegateSignature(bool bSolvable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "PuzzleUpdateSolvableState__DelegateSignature");

	Params::PuzzleActor_PuzzleUpdateSolvableState__DelegateSignature Parms{};

	Parms.bSolvable = bSolvable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.PuzzleActor.RestoringFromChapterSelect
// (Event, Protected, BlueprintEvent)

void APuzzleActor::RestoringFromChapterSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "RestoringFromChapterSelect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.PuzzleActor.SetManualSolvableCondition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSolvable                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleActor::SetManualSolvableCondition(const bool bSolvable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "SetManualSolvableCondition");

	Params::PuzzleActor_SetManualSolvableCondition Parms{};

	Parms.bSolvable = bSolvable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PuzzleActor.SetPuzzleIsSolvableRaw
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSolvable                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleActor::SetPuzzleIsSolvableRaw(const bool bSolvable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "SetPuzzleIsSolvableRaw");

	Params::PuzzleActor_SetPuzzleIsSolvableRaw Parms{};

	Parms.bSolvable = bSolvable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PuzzleActor.ShowPuzzleUI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ZOrder                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCtrlButtonWidget*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCtrlButtonWidget* APuzzleActor::ShowPuzzleUI(int32 ZOrder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "ShowPuzzleUI");

	Params::PuzzleActor_ShowPuzzleUI Parms{};

	Parms.ZOrder = ZOrder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PuzzleActor.SolvePuzzle
// (Native, Protected, BlueprintCallable)

void APuzzleActor::SolvePuzzle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "SolvePuzzle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PuzzleActor.SolvingPuzzle
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AOFPlayerController*              InteractingPlayerController                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APuzzleActor::SolvingPuzzle(class AOFPlayerController* InteractingPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "SolvingPuzzle");

	Params::PuzzleActor_SolvingPuzzle Parms{};

	Parms.InteractingPlayerController = InteractingPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PuzzleActor.GetIsSolvable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APuzzleActor::GetIsSolvable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "GetIsSolvable");

	Params::PuzzleActor_GetIsSolvable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PuzzleActor.GetIsSolved
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APuzzleActor::GetIsSolved() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "GetIsSolved");

	Params::PuzzleActor_GetIsSolved Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PuzzleActor.RemovePuzzleUI
// (Final, Native, Public, BlueprintCallable, Const)

void APuzzleActor::RemovePuzzleUI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PuzzleActor", "RemovePuzzleUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InventoryPuzzle.SelectionTrace
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bBlockingHit                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* AInventoryPuzzle::SelectionTrace(struct FHitResult* OutHit, bool* bBlockingHit, float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryPuzzle", "SelectionTrace");

	Params::InventoryPuzzle_SelectionTrace Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	if (bBlockingHit != nullptr)
		*bBlockingHit = Parms.bBlockingHit;

	return Parms.ReturnValue;
}


// Function ObsidianFox.BurrowerAnimInstance.OnAirMultiBoolChanged
// (Final, Native, Public)
// Parameters:
// bool                                    bNewState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBurrowerAnimInstance::OnAirMultiBoolChanged(bool bNewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BurrowerAnimInstance", "OnAirMultiBoolChanged");

	Params::BurrowerAnimInstance_OnAirMultiBoolChanged Parms{};

	Parms.bNewState = bNewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BurrowerAnimInstance.OnAirStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bNewState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBurrowerAnimInstance::OnAirStateChanged(bool bNewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BurrowerAnimInstance", "OnAirStateChanged");

	Params::BurrowerAnimInstance_OnAirStateChanged Parms{};

	Parms.bNewState = bNewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.BurrowerAnimInstance.SetIsInAir
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          CallerReference                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRequestedState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBurrowerAnimInstance::SetIsInAir(class UObject* CallerReference, bool bRequestedState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BurrowerAnimInstance", "SetIsInAir");

	Params::BurrowerAnimInstance_SetIsInAir Parms{};

	Parms.CallerReference = CallerReference;
	Parms.bRequestedState = bRequestedState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_ChapterSelect.OnLevelLoaded
// (Final, Native, Private)
// Parameters:
// class ULevel*                           InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_ChapterSelect::OnLevelLoaded(class ULevel* InLevel, class UWorld* InWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_ChapterSelect", "OnLevelLoaded");

	Params::GameSubsystem_ChapterSelect_OnLevelLoaded Parms{};

	Parms.InLevel = InLevel;
	Parms.InWorld = InWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_ChapterSelect.OpenLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UChapterSelectDataAsset*          InChapterSelectDataAsset                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_ChapterSelect::OpenLevel(const class UChapterSelectDataAsset* InChapterSelectDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_ChapterSelect", "OpenLevel");

	Params::GameSubsystem_ChapterSelect_OpenLevel Parms{};

	Parms.InChapterSelectDataAsset = InChapterSelectDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CameraAbductorComponent.ApplyCameraEffects
// (Native, Public, BlueprintCallable)

void UCameraAbductorComponent::ApplyCameraEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraAbductorComponent", "ApplyCameraEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.CameraAbductorComponent.CameraAbductionDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AActor*                           AbductingActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                InteractingController                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraAbductorComponent::CameraAbductionDelegate__DelegateSignature(class AActor* AbductingActor, class APlayerController* InteractingController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraAbductorComponent", "CameraAbductionDelegate__DelegateSignature");

	Params::CameraAbductorComponent_CameraAbductionDelegate__DelegateSignature Parms{};

	Parms.AbductingActor = AbductingActor;
	Parms.InteractingController = InteractingController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.CameraAbductorComponent.CleanUpCameraModifiers
// (Final, Native, Private)

void UCameraAbductorComponent::CleanUpCameraModifiers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraAbductorComponent", "CleanUpCameraModifiers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CameraAbductorComponent.EnterActor
// (Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraAbductorComponent::EnterActor(class APlayerController* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraAbductorComponent", "EnterActor");

	Params::CameraAbductorComponent_EnterActor Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CameraAbductorComponent.EnteringActor
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraAbductorComponent::EnteringActor(class APlayerController* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraAbductorComponent", "EnteringActor");

	Params::CameraAbductorComponent_EnteringActor Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.CameraAbductorComponent.ExitActor
// (Native, Public, BlueprintCallable)

void UCameraAbductorComponent::ExitActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraAbductorComponent", "ExitActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CameraAbductorComponent.ExitingActor
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                InteractingPlayerController                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraAbductorComponent::ExitingActor(class APlayerController* InteractingPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraAbductorComponent", "ExitingActor");

	Params::CameraAbductorComponent_ExitingActor Parms{};

	Parms.InteractingPlayerController = InteractingPlayerController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.CameraAbductorComponent.InteractionEnter
// (Native, Public)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCameraAbductorComponent::InteractionEnter(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraAbductorComponent", "InteractionEnter");

	Params::CameraAbductorComponent_InteractionEnter Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CameraAbductorComponent.RemoveCameraEffects
// (Native, Public, BlueprintCallable)

void UCameraAbductorComponent::RemoveCameraEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraAbductorComponent", "RemoveCameraEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubSystem_MenuHud.CanFadeAwayAll
// (Final, Native, Public)

void UGameSubSystem_MenuHud::CanFadeAwayAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubSystem_MenuHud", "CanFadeAwayAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubSystem_MenuHud.FadeEnemyBar50Percent
// (Final, Native, Public)

void UGameSubSystem_MenuHud::FadeEnemyBar50Percent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubSystem_MenuHud", "FadeEnemyBar50Percent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubSystem_MenuHud.IsInGameUIHidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSubSystem_MenuHud::IsInGameUIHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubSystem_MenuHud", "IsInGameUIHidden");

	Params::GameSubSystem_MenuHud_IsInGameUIHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubSystem_MenuHud.IsObjectiveDone
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EObjectives                             Objective                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSubSystem_MenuHud::IsObjectiveDone(EObjectives Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubSystem_MenuHud", "IsObjectiveDone");

	Params::GameSubSystem_MenuHud_IsObjectiveDone Parms{};

	Parms.Objective = Objective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubSystem_MenuHud.NewHelpText
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EHelptText                              HelpText                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSubSystem_MenuHud::NewHelpText(EHelptText HelpText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubSystem_MenuHud", "NewHelpText");

	Params::GameSubSystem_MenuHud_NewHelpText Parms{};

	Parms.HelpText = HelpText;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubSystem_MenuHud.SetInGameUIVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESlateVisibility                        NewState                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubSystem_MenuHud::SetInGameUIVisibility(const ESlateVisibility NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubSystem_MenuHud", "SetInGameUIVisibility");

	Params::GameSubSystem_MenuHud_SetInGameUIVisibility Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubSystem_MenuHud.UpdateEnemyHealthbar
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AObsidianFoxCharacter*            Enemy                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubSystem_MenuHud::UpdateEnemyHealthbar(class AObsidianFoxCharacter* Enemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubSystem_MenuHud", "UpdateEnemyHealthbar");

	Params::GameSubSystem_MenuHud_UpdateEnemyHealthbar Parms{};

	Parms.Enemy = Enemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubSystem_MenuHud.UpdateInteractWidget
// (Final, Native, Public)
// Parameters:
// class FText                             InfoText                                               (Parm, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        InfoImage                                              (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubSystem_MenuHud::UpdateInteractWidget(const class FText& InfoText, TSoftObjectPtr<class UTexture2D> InfoImage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubSystem_MenuHud", "UpdateInteractWidget");

	Params::GameSubSystem_MenuHud_UpdateInteractWidget Parms{};

	Parms.InfoText = std::move(InfoText);
	Parms.InfoImage = InfoImage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubSystem_MenuHud.UpdateObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EObjectives                             NewObjective                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubSystem_MenuHud::UpdateObjective(EObjectives NewObjective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubSystem_MenuHud", "UpdateObjective");

	Params::GameSubSystem_MenuHud_UpdateObjective Parms{};

	Parms.NewObjective = NewObjective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubSystem_MenuHud.UpdateObjectiveFromCurrent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EObjectives                             OldObjective                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectives                             NewObjective                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSubSystem_MenuHud::UpdateObjectiveFromCurrent(EObjectives OldObjective, EObjectives NewObjective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubSystem_MenuHud", "UpdateObjectiveFromCurrent");

	Params::GameSubSystem_MenuHud_UpdateObjectiveFromCurrent Parms{};

	Parms.OldObjective = OldObjective;
	Parms.NewObjective = NewObjective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.CemetaryCreatureAnimInstance.SetUpperBodyTiltEnabled
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCemetaryCreatureAnimInstance::SetUpperBodyTiltEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CemetaryCreatureAnimInstance", "SetUpperBodyTiltEnabled");

	Params::CemetaryCreatureAnimInstance_SetUpperBodyTiltEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_AnimationAssetManager.GetAllLookupEntriesForTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     MontageTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAnimationLookupTableEntry>OutEntries                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EAnimationLookupTableLookupMethod       LookupMethod                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_AnimationAssetManager::GetAllLookupEntriesForTag(const class ACharacter* Character, const struct FGameplayTag& MontageTag, TArray<struct FAnimationLookupTableEntry>* OutEntries, EAnimationLookupTableLookupMethod LookupMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_AnimationAssetManager", "GetAllLookupEntriesForTag");

	Params::GameSubsystem_AnimationAssetManager_GetAllLookupEntriesForTag Parms{};

	Parms.Character = Character;
	Parms.MontageTag = std::move(MontageTag);
	Parms.LookupMethod = LookupMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutEntries != nullptr)
		*OutEntries = std::move(Parms.OutEntries);
}


// Function ObsidianFox.GameSubsystem_AnimationAssetManager.GetAllLookupEntriesForTagSkeleton
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     MontageTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAnimationLookupTableEntry>OutEntries                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EAnimationLookupTableLookupMethod       LookupMethod                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_AnimationAssetManager::GetAllLookupEntriesForTagSkeleton(class USkeletalMeshComponent* SkeletalMeshComponent, const struct FGameplayTag& MontageTag, TArray<struct FAnimationLookupTableEntry>* OutEntries, EAnimationLookupTableLookupMethod LookupMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_AnimationAssetManager", "GetAllLookupEntriesForTagSkeleton");

	Params::GameSubsystem_AnimationAssetManager_GetAllLookupEntriesForTagSkeleton Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.MontageTag = std::move(MontageTag);
	Parms.LookupMethod = LookupMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutEntries != nullptr)
		*OutEntries = std::move(Parms.OutEntries);
}


// Function ObsidianFox.GameSubsystem_AnimationAssetManager.GetMontageForCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     MontageTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStartAsyncLoad                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UAnimMontage>      ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UAnimMontage> UGameSubsystem_AnimationAssetManager::GetMontageForCharacter(const class ACharacter* Character, const struct FGameplayTag& MontageTag, bool bStartAsyncLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_AnimationAssetManager", "GetMontageForCharacter");

	Params::GameSubsystem_AnimationAssetManager_GetMontageForCharacter Parms{};

	Parms.Character = Character;
	Parms.MontageTag = std::move(MontageTag);
	Parms.bStartAsyncLoad = bStartAsyncLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_AnimationAssetManager.GetMontageForCharacterBlockingLoad
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     MontageTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UGameSubsystem_AnimationAssetManager::GetMontageForCharacterBlockingLoad(class ACharacter* Character, const struct FGameplayTag& MontageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_AnimationAssetManager", "GetMontageForCharacterBlockingLoad");

	Params::GameSubsystem_AnimationAssetManager_GetMontageForCharacterBlockingLoad Parms{};

	Parms.Character = Character;
	Parms.MontageTag = std::move(MontageTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_AnimationAssetManager.GetMontageForSkeleton
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     MontageTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStartAsyncLoad                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UAnimMontage>      ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UAnimMontage> UGameSubsystem_AnimationAssetManager::GetMontageForSkeleton(class USkeletalMeshComponent* SkeletalMeshComponent, const struct FGameplayTag& MontageTag, bool bStartAsyncLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_AnimationAssetManager", "GetMontageForSkeleton");

	Params::GameSubsystem_AnimationAssetManager_GetMontageForSkeleton Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.MontageTag = std::move(MontageTag);
	Parms.bStartAsyncLoad = bStartAsyncLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_AnimationAssetManager.GetMontageForSkeletonBlockingLoad
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     MontageTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UGameSubsystem_AnimationAssetManager::GetMontageForSkeletonBlockingLoad(class USkeletalMeshComponent* SkeletalMeshComponent, const struct FGameplayTag& MontageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_AnimationAssetManager", "GetMontageForSkeletonBlockingLoad");

	Params::GameSubsystem_AnimationAssetManager_GetMontageForSkeletonBlockingLoad Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.MontageTag = std::move(MontageTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ChapterSelectButtonWidget.OnButtonHovered
// (Final, Native, Private)

void UChapterSelectButtonWidget::OnButtonHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChapterSelectButtonWidget", "OnButtonHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.ChapterSelectButtonWidget.OnWidgetHover__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChapterSelectButtonWidget::OnWidgetHover__DelegateSignature(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChapterSelectButtonWidget", "OnWidgetHover__DelegateSignature");

	Params::ChapterSelectButtonWidget_OnWidgetHover__DelegateSignature Parms{};

	Parms.Widget = Widget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.GuantletPerformenceSampler.OnSampleEnd
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AGuantletPerformenceSampler::OnSampleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GuantletPerformenceSampler", "OnSampleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GuantletPerformenceSampler.OnSampleStart
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AGuantletPerformenceSampler::OnSampleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GuantletPerformenceSampler", "OnSampleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CharacterMeshInterpolationComponent.DisableMeshInterpolation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          LockReference                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMeshInterpolationComponent::DisableMeshInterpolation(const class UObject* LockReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMeshInterpolationComponent", "DisableMeshInterpolation");

	Params::CharacterMeshInterpolationComponent_DisableMeshInterpolation Parms{};

	Parms.LockReference = LockReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CharacterMeshInterpolationComponent.OnOwnerCinematicModeChange
// (Final, Native, Protected)
// Parameters:
// bool                                    EnteredCinematicMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMeshInterpolationComponent::OnOwnerCinematicModeChange(bool EnteredCinematicMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMeshInterpolationComponent", "OnOwnerCinematicModeChange");

	Params::CharacterMeshInterpolationComponent_OnOwnerCinematicModeChange Parms{};

	Parms.EnteredCinematicMode = EnteredCinematicMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CharacterMeshInterpolationComponent.RestoreMeshInterpolation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          LockReference                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMeshInterpolationComponent::RestoreMeshInterpolation(const class UObject* LockReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMeshInterpolationComponent", "RestoreMeshInterpolation");

	Params::CharacterMeshInterpolationComponent_RestoreMeshInterpolation Parms{};

	Parms.LockReference = LockReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CharacterSelect.OnLevelAddedToWorld
// (Final, Native, Protected)
// Parameters:
// class ULevel*                           Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterSelect::OnLevelAddedToWorld(class ULevel* Level, class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelect", "OnLevelAddedToWorld");

	Params::CharacterSelect_OnLevelAddedToWorld Parms{};

	Parms.Level = Level;
	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CharacterSelect.RefreshCharacterSelectLights
// (Final, Native, Protected, BlueprintCallable)

void ACharacterSelect::RefreshCharacterSelectLights()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelect", "RefreshCharacterSelectLights");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CharacterSelect.SetAlphaForAllCharacterLights
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterSelect::SetAlphaForAllCharacterLights(float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelect", "SetAlphaForAllCharacterLights");

	Params::CharacterSelect_SetAlphaForAllCharacterLights Parms{};

	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CharacterSelect.SetAlphaForCharacterLight
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EPlayerCharacterType                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterSelect::SetAlphaForCharacterLight(EPlayerCharacterType Character, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSelect", "SetAlphaForCharacterLight");

	Params::CharacterSelect_SetAlphaForCharacterLight Parms{};

	Parms.Character = Character;
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HiddenOptionsPT.ButtonHovered
// (Final, Native, Protected)

void UHiddenOptionsPT::ButtonHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "ButtonHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HiddenOptionsPT.ButtonUnHovered
// (Final, Native, Protected)

void UHiddenOptionsPT::ButtonUnHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "ButtonUnHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HiddenOptionsPT.CancelButtonPressed
// (Event, Protected, BlueprintEvent)

void UHiddenOptionsPT::CancelButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "CancelButtonPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.HiddenOptionsPT.DecreaseOption
// (Final, Native, Private)

void UHiddenOptionsPT::DecreaseOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "DecreaseOption");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HiddenOptionsPT.IncreaseOption
// (Final, Native, Private)

void UHiddenOptionsPT::IncreaseOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "IncreaseOption");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HiddenOptionsPT.InteractButtonPressed
// (Final, Native, Private)

void UHiddenOptionsPT::InteractButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "InteractButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HiddenOptionsPT.LeftStickX
// (Final, Native, Private)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHiddenOptionsPT::LeftStickX(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "LeftStickX");

	Params::HiddenOptionsPT_LeftStickX Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HiddenOptionsPT.LeftStickY
// (Final, Native, Private)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHiddenOptionsPT::LeftStickY(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "LeftStickY");

	Params::HiddenOptionsPT_LeftStickY Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HiddenOptionsPT.QuitGame
// (Event, Protected, BlueprintEvent)

void UHiddenOptionsPT::QuitGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "QuitGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.HiddenOptionsPT.RestartGame
// (Event, Protected, BlueprintEvent)

void UHiddenOptionsPT::RestartGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "RestartGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.HiddenOptionsPT.SelectDownPressed
// (Final, Native, Private)

void UHiddenOptionsPT::SelectDownPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "SelectDownPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HiddenOptionsPT.SelectNextPressed
// (Final, Native, Private)

void UHiddenOptionsPT::SelectNextPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "SelectNextPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HiddenOptionsPT.SelectPreviousPressed
// (Final, Native, Private)

void UHiddenOptionsPT::SelectPreviousPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "SelectPreviousPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HiddenOptionsPT.SelectUpPressed
// (Final, Native, Private)

void UHiddenOptionsPT::SelectUpPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "SelectUpPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HiddenOptionsPT.SetCanMoveWithLeftStickXToTrue
// (Final, Native, Private)

void UHiddenOptionsPT::SetCanMoveWithLeftStickXToTrue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "SetCanMoveWithLeftStickXToTrue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HiddenOptionsPT.SetCanMoveWithLeftStickYToTrue
// (Final, Native, Private)

void UHiddenOptionsPT::SetCanMoveWithLeftStickYToTrue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HiddenOptionsPT", "SetCanMoveWithLeftStickYToTrue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CharacterStateAnimInterface.OnEnterGauntlet
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsFirstTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterStateAnimInterface::OnEnterGauntlet(bool bIsFirstTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStateAnimInterface", "OnEnterGauntlet");

	Params::CharacterStateAnimInterface_OnEnterGauntlet Parms{};

	Parms.bIsFirstTime = bIsFirstTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CharacterStateAnimInterface.OnExitGauntlet
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsFirstTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICharacterStateAnimInterface::OnExitGauntlet(bool bIsFirstTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterStateAnimInterface", "OnExitGauntlet");

	Params::CharacterStateAnimInterface_OnExitGauntlet Parms{};

	Parms.bIsFirstTime = bIsFirstTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GunAnimInterface.OnReloadEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IGunAnimInterface::OnReloadEvent(const struct FGameplayTag& EventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GunAnimInterface", "OnReloadEvent");

	Params::GunAnimInterface_OnReloadEvent Parms{};

	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CheckGroundedAtStartupAC.OnAllowFallingMultiBoolValueChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheckGroundedAtStartupAC::OnAllowFallingMultiBoolValueChanged(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheckGroundedAtStartupAC", "OnAllowFallingMultiBoolValueChanged");

	Params::CheckGroundedAtStartupAC_OnAllowFallingMultiBoolValueChanged Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CheckGroundedAtStartupAC.OnCharacterGameplayTagChanged
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheckGroundedAtStartupAC::OnCharacterGameplayTagChanged(const struct FGameplayTag& Tag, int32 EventType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheckGroundedAtStartupAC", "OnCharacterGameplayTagChanged");

	Params::CheckGroundedAtStartupAC_OnCharacterGameplayTagChanged Parms{};

	Parms.Tag = std::move(Tag);
	Parms.EventType = EventType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CheckGroundedAtStartupAC.OnCharacterMovementModeChanged
// (Final, Native, Protected)
// Parameters:
// EMovementMode                           PreviousMovementMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           NewMovementMode                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheckGroundedAtStartupAC::OnCharacterMovementModeChanged(EMovementMode PreviousMovementMode, EMovementMode NewMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheckGroundedAtStartupAC", "OnCharacterMovementModeChanged");

	Params::CheckGroundedAtStartupAC_OnCharacterMovementModeChanged Parms{};

	Parms.PreviousMovementMode = PreviousMovementMode;
	Parms.NewMovementMode = NewMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CheckGroundedAtStartupAC.OnOwnerCinematicModeChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheckGroundedAtStartupAC::OnOwnerCinematicModeChanged(bool NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheckGroundedAtStartupAC", "OnOwnerCinematicModeChanged");

	Params::CheckGroundedAtStartupAC_OnOwnerCinematicModeChanged Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CheckGroundedAtStartupAC.ResetRestoringPositionAndStartTracing
// (Final, Native, Private)

void UCheckGroundedAtStartupAC::ResetRestoringPositionAndStartTracing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheckGroundedAtStartupAC", "ResetRestoringPositionAndStartTracing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CheckGroundedAtStartupAC.SetAllowFalling
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          LockReference                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheckGroundedAtStartupAC::SetAllowFalling(const class UObject* LockReference, bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheckGroundedAtStartupAC", "SetAllowFalling");

	Params::CheckGroundedAtStartupAC_SetAllowFalling Parms{};

	Parms.LockReference = LockReference;
	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HelpButtonHud.ClearButtons
// (Final, Native, Public, BlueprintCallable)

void UHelpButtonHud::ClearButtons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HelpButtonHud", "ClearButtons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HelpButtonHud.CreateNewHelpButton
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UTexture2D>        buttonTexture                                          (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ButtonText                                             (ConstParm, Parm, NativeAccessSpecifierPublic)
// EFButtonType                            Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHelpButtonHud::CreateNewHelpButton(const TSoftObjectPtr<class UTexture2D> buttonTexture, const class FText& ButtonText, const EFButtonType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HelpButtonHud", "CreateNewHelpButton");

	Params::HelpButtonHud_CreateNewHelpButton Parms{};

	Parms.buttonTexture = buttonTexture;
	Parms.ButtonText = std::move(ButtonText);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HelpButtonHud.PositionButtons
// (Final, Native, Public, BlueprintCallable)

void UHelpButtonHud::PositionButtons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HelpButtonHud", "PositionButtons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HelpButtonHud.SetDefaultButtonPosition
// (Final, Native, Public, BlueprintCallable)

void UHelpButtonHud::SetDefaultButtonPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HelpButtonHud", "SetDefaultButtonPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HelpButtonHud.SetInactive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFButtonType                            Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHelpButtonHud::SetInactive(EFButtonType Type, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HelpButtonHud", "SetInactive");

	Params::HelpButtonHud_SetInactive Parms{};

	Parms.Type = Type;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HelpButtonHud.SetNewName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFButtonType                            Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             NewText                                                (Parm, NativeAccessSpecifierPublic)

void UHelpButtonHud::SetNewName(EFButtonType Type, const class FText& NewText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HelpButtonHud", "SetNewName");

	Params::HelpButtonHud_SetNewName Parms{};

	Parms.Type = Type;
	Parms.NewText = std::move(NewText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HelpButtonHud.SetVisibilityOnAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESlateVisibility                        Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHelpButtonHud::SetVisibilityOnAll(ESlateVisibility Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HelpButtonHud", "SetVisibilityOnAll");

	Params::HelpButtonHud_SetVisibilityOnAll Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CheckpointSubsystem.SetCheckpointTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     CheckpointTag                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheckpointSubsystem::SetCheckpointTag(const struct FGameplayTag& CheckpointTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheckpointSubsystem", "SetCheckpointTag");

	Params::CheckpointSubsystem_SetCheckpointTag Parms{};

	Parms.CheckpointTag = std::move(CheckpointTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CheckpointSubsystem.GetCurrentCheckpoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UCheckpointSubsystem::GetCurrentCheckpoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheckpointSubsystem", "GetCurrentCheckpoint");

	Params::CheckpointSubsystem_GetCurrentCheckpoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.BPAsyncAction_HitReaction.PlayHitReaction
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UHitReactionComponent*            HitReactionComponent_0                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitReactionData                 HitReactionData                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// EHitReactionType                        HitReactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOverrideDirection                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECardinalDirection                      DirectionToPlay                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBPAsyncAction_HitReaction*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBPAsyncAction_HitReaction* UBPAsyncAction_HitReaction::PlayHitReaction(class UHitReactionComponent* HitReactionComponent_0, const struct FHitReactionData& HitReactionData, EHitReactionType HitReactionType, bool bOverrideDirection, ECardinalDirection DirectionToPlay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BPAsyncAction_HitReaction", "PlayHitReaction");

	Params::BPAsyncAction_HitReaction_PlayHitReaction Parms{};

	Parms.HitReactionComponent_0 = HitReactionComponent_0;
	Parms.HitReactionData = std::move(HitReactionData);
	Parms.HitReactionType = HitReactionType;
	Parms.bOverrideDirection = bOverrideDirection;
	Parms.DirectionToPlay = DirectionToPlay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.BPAsyncAction_HitReaction.OnHitReactionFinished__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EHitReactionType                        HitReactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_HitReaction::OnHitReactionFinished__DelegateSignature(EHitReactionType HitReactionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_HitReaction", "OnHitReactionFinished__DelegateSignature");

	Params::BPAsyncAction_HitReaction_OnHitReactionFinished__DelegateSignature Parms{};

	Parms.HitReactionType = HitReactionType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.BPAsyncAction_HitReaction.OnInteractionBegin
// (Final, Native, Private)
// Parameters:
// EHitReactionType                        HitReactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_HitReaction::OnInteractionBegin(EHitReactionType HitReactionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_HitReaction", "OnInteractionBegin");

	Params::BPAsyncAction_HitReaction_OnInteractionBegin Parms{};

	Parms.HitReactionType = HitReactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.BPAsyncAction_HitReaction.OnInteractionDone
// (Final, Native, Private)
// Parameters:
// EHitReactionType                        HitReactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFailed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasInterrupted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBPAsyncAction_HitReaction::OnInteractionDone(EHitReactionType HitReactionType, bool bFailed, bool bWasInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BPAsyncAction_HitReaction", "OnInteractionDone");

	Params::BPAsyncAction_HitReaction_OnInteractionDone Parms{};

	Parms.HitReactionType = HitReactionType;
	Parms.bFailed = bFailed;
	Parms.bWasInterrupted = bWasInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CircuitBreaker.ResetBreakerState
// (Final, Native, Protected, BlueprintCallable)

void ACircuitBreaker::ResetBreakerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CircuitBreaker", "ResetBreakerState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CircuitBreaker.SetBreakerLeverComponent
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  LeverComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACircuitBreaker::SetBreakerLeverComponent(int32 Index_0, class USceneComponent* LeverComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CircuitBreaker", "SetBreakerLeverComponent");

	Params::CircuitBreaker_SetBreakerLeverComponent Parms{};

	Parms.Index_0 = Index_0;
	Parms.LeverComponent = LeverComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CircuitBreaker.StoreDefaultBreakerState
// (Final, Native, Protected)

void ACircuitBreaker::StoreDefaultBreakerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CircuitBreaker", "StoreDefaultBreakerState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CircuitBreaker.ToggleBreakerByLever
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class USceneComponent*                  LeverComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACircuitBreaker::ToggleBreakerByLever(const class USceneComponent* LeverComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CircuitBreaker", "ToggleBreakerByLever");

	Params::CircuitBreaker_ToggleBreakerByLever Parms{};

	Parms.LeverComponent = LeverComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CircuitBreaker.UpdateSolvedState
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACircuitBreaker::UpdateSolvedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CircuitBreaker", "UpdateSolvedState");

	Params::CircuitBreaker_UpdateSolvedState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.CircuitBreaker.GetAffectedBreakersByLever
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  LeverComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPuzzleBreaker>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FPuzzleBreaker> ACircuitBreaker::GetAffectedBreakersByLever(const class USceneComponent* LeverComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CircuitBreaker", "GetAffectedBreakersByLever");

	Params::CircuitBreaker_GetAffectedBreakersByLever Parms{};

	Parms.LeverComponent = LeverComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ExaminationViewBaseWidget.PlaySound_Internal
// (Native, Protected)

void UExaminationViewBaseWidget::PlaySound_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExaminationViewBaseWidget", "PlaySound_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ExaminationViewBaseWidget.StopSound
// (Native, Public, BlueprintCallable)

void UExaminationViewBaseWidget::StopSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ExaminationViewBaseWidget", "StopSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CollectibleLoreTextExamination.MoveScrollBoxInputHandler
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FInputActionValue                InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCollectibleLoreTextExamination::MoveScrollBoxInputHandler(const struct FInputActionValue& InputActionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectibleLoreTextExamination", "MoveScrollBoxInputHandler");

	Params::CollectibleLoreTextExamination_MoveScrollBoxInputHandler Parms{};

	Parms.InputActionValue = std::move(InputActionValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CollectibleLoreTextExamination.OnCloseDownWidgetPressedHandler
// (Event, Public, BlueprintEvent)

void UCollectibleLoreTextExamination::OnCloseDownWidgetPressedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectibleLoreTextExamination", "OnCloseDownWidgetPressedHandler");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.CollectibleLoreTextExamination.OnClosePressedHandler
// (Event, Public, BlueprintEvent)

void UCollectibleLoreTextExamination::OnClosePressedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectibleLoreTextExamination", "OnClosePressedHandler");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.CollectibleLoreTextExamination.OnPlayVOHandler
// (Final, Native, Private)

void UCollectibleLoreTextExamination::OnPlayVOHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectibleLoreTextExamination", "OnPlayVOHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CollectibleLoreTextExamination.SetupInput
// (Final, Native, Public, BlueprintCallable)

void UCollectibleLoreTextExamination::SetupInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectibleLoreTextExamination", "SetupInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CollectibleManager.CollectibleSetCompletedHandler
// (Final, Native, Private)
// Parameters:
// class UCollectibleSet*                  CollectibleSet                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCollectibleManager::CollectibleSetCompletedHandler(const class UCollectibleSet* CollectibleSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectibleManager", "CollectibleSetCompletedHandler");

	Params::CollectibleManager_CollectibleSetCompletedHandler Parms{};

	Parms.CollectibleSet = CollectibleSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CollectibleManager.GetAllCollectiblesLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCollectibleManager::GetAllCollectiblesLoaded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectibleManager", "GetAllCollectiblesLoaded");

	Params::CollectibleManager_GetAllCollectiblesLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.CollectibleManager.GetCollectibleSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UCollectiblesDataAsset>InCollectiblesDataAsset                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCollectibleSet*            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UCollectibleSet* UCollectibleManager::GetCollectibleSet(TSoftObjectPtr<class UCollectiblesDataAsset> InCollectiblesDataAsset) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectibleManager", "GetCollectibleSet");

	Params::CollectibleManager_GetCollectibleSet Parms{};

	Parms.InCollectiblesDataAsset = InCollectiblesDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.CollectibleManager.GetCollectibleSets
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UCollectibleSet*>    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class UCollectibleSet*> UCollectibleManager::GetCollectibleSets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectibleManager", "GetCollectibleSets");

	Params::CollectibleManager_GetCollectibleSets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.CollectibleManager.HaveGatheredItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UCollectiblesDataAsset>InCollectiblesDataAsset                                (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UItemData>         InItemData                                             (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCollectibleManager::HaveGatheredItem(const TSoftObjectPtr<class UCollectiblesDataAsset>& InCollectiblesDataAsset, const TSoftObjectPtr<class UItemData>& InItemData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectibleManager", "HaveGatheredItem");

	Params::CollectibleManager_HaveGatheredItem Parms{};

	Parms.InCollectiblesDataAsset = InCollectiblesDataAsset;
	Parms.InItemData = InItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.CollectibleManager.HaveGatheredItemInAnySet
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UItemData>         InItemData                                             (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCollectibleManager::HaveGatheredItemInAnySet(const TSoftObjectPtr<class UItemData>& InItemData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectibleManager", "HaveGatheredItemInAnySet");

	Params::CollectibleManager_HaveGatheredItemInAnySet Parms{};

	Parms.InItemData = InItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HealthHistoryComponent.GetHealthDifference
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   SecondsBackInTime                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthHistoryComponent::GetHealthDifference(const float SecondsBackInTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthHistoryComponent", "GetHealthDifference");

	Params::HealthHistoryComponent_GetHealthDifference Parms{};

	Parms.SecondsBackInTime = SecondsBackInTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HealthHistoryComponent.OnHealthChanged
// (Final, Native, Public, HasOutParams)
// Parameters:
// float                                   NewCurrentHealth                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            EventTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHealthHistoryComponent::OnHealthChanged(float NewCurrentHealth, float DeltaValue, const struct FGameplayTagContainer& EventTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthHistoryComponent", "OnHealthChanged");

	Params::HealthHistoryComponent_OnHealthChanged Parms{};

	Parms.NewCurrentHealth = NewCurrentHealth;
	Parms.DeltaValue = DeltaValue;
	Parms.EventTags = std::move(EventTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HealthHistoryComponent.GetHealthBackInTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   SecondsBackInTime                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UHealthHistoryComponent::GetHealthBackInTime(const float SecondsBackInTime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthHistoryComponent", "GetHealthBackInTime");

	Params::HealthHistoryComponent_GetHealthBackInTime Parms{};

	Parms.SecondsBackInTime = SecondsBackInTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.CollectibleSet.IsCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCollectibleSet::IsCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectibleSet", "IsCompleted");

	Params::CollectibleSet_IsCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.WidgetInputHandlingBase.CancelPressed
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void UWidgetInputHandlingBase::CancelPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "CancelPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WidgetInputHandlingBase.CategoryNextHandler
// (Event, Protected, BlueprintEvent)

void UWidgetInputHandlingBase::CategoryNextHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "CategoryNextHandler");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.WidgetInputHandlingBase.CategoryPreviousHandler
// (Event, Protected, BlueprintEvent)

void UWidgetInputHandlingBase::CategoryPreviousHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "CategoryPreviousHandler");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.WidgetInputHandlingBase.GetWidgets
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class UWidget*>                  Widgets                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UWidgetInputHandlingBase::GetWidgets(TArray<class UWidget*>* Widgets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "GetWidgets");

	Params::WidgetInputHandlingBase_GetWidgets Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Widgets != nullptr)
		*Widgets = std::move(Parms.Widgets);
}


// Function ObsidianFox.WidgetInputHandlingBase.HoverNewWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetInputHandlingBase::HoverNewWidget(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "HoverNewWidget");

	Params::WidgetInputHandlingBase_HoverNewWidget Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WidgetInputHandlingBase.MoveWidgetInputActionTriggeredHandler
// (Native, Protected, HasOutParams)
// Parameters:
// struct FInputActionValue                InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UWidgetInputHandlingBase::MoveWidgetInputActionTriggeredHandler(const struct FInputActionValue& InputActionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "MoveWidgetInputActionTriggeredHandler");

	Params::WidgetInputHandlingBase_MoveWidgetInputActionTriggeredHandler Parms{};

	Parms.InputActionValue = std::move(InputActionValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WidgetInputHandlingBase.OnAcceptPressed
// (Native, Event, Protected, BlueprintEvent)

void UWidgetInputHandlingBase::OnAcceptPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "OnAcceptPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WidgetInputHandlingBase.OnButtonWidgetHovered
// (Final, Native, Private)
// Parameters:
// class UButton*                          ButtonWidget                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetInputHandlingBase::OnButtonWidgetHovered(class UButton* ButtonWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "OnButtonWidgetHovered");

	Params::WidgetInputHandlingBase_OnButtonWidgetHovered Parms{};

	Parms.ButtonWidget = ButtonWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.WidgetInputHandlingBase.OnCancelPressed__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetInputHandlingBase::OnCancelPressed__DelegateSignature(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "OnCancelPressed__DelegateSignature");

	Params::WidgetInputHandlingBase_OnCancelPressed__DelegateSignature Parms{};

	Parms.Widget = Widget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.WidgetInputHandlingBase.OnCultureChanged
// (Event, Protected, BlueprintEvent)

void UWidgetInputHandlingBase::OnCultureChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "OnCultureChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.WidgetInputHandlingBase.OnInteractPressedHandler
// (Native, Protected, BlueprintCallable)

void UWidgetInputHandlingBase::OnInteractPressedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "OnInteractPressedHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.WidgetInputHandlingBase.OnNewWidgetHovered__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UWidget*                          NewWidget                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetInputHandlingBase::OnNewWidgetHovered__DelegateSignature(class UWidget* NewWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "OnNewWidgetHovered__DelegateSignature");

	Params::WidgetInputHandlingBase_OnNewWidgetHovered__DelegateSignature Parms{};

	Parms.NewWidget = NewWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.WidgetInputHandlingBase.OnResetPressed
// (Native, Event, Protected, BlueprintEvent)

void UWidgetInputHandlingBase::OnResetPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "OnResetPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WidgetInputHandlingBase.OnWidgetHovered
// (Final, Native, Private)
// Parameters:
// class UWidget*                          NewWidget                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetInputHandlingBase::OnWidgetHovered(class UWidget* NewWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "OnWidgetHovered");

	Params::WidgetInputHandlingBase_OnWidgetHovered Parms{};

	Parms.NewWidget = NewWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WidgetInputHandlingBase.OpenMenuPressedHandler
// (Event, Protected, BlueprintEvent)

void UWidgetInputHandlingBase::OpenMenuPressedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "OpenMenuPressedHandler");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.WidgetInputHandlingBase.OpenPauseMenuPressed
// (Event, Protected, BlueprintEvent)

void UWidgetInputHandlingBase::OpenPauseMenuPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "OpenPauseMenuPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.WidgetInputHandlingBase.SelectNextPressed
// (Native, Event, Protected, BlueprintEvent)

void UWidgetInputHandlingBase::SelectNextPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "SelectNextPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WidgetInputHandlingBase.SelectNextPressed_Implementation
// (Native, Protected)

void UWidgetInputHandlingBase::SelectNextPressed_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "SelectNextPressed_Implementation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WidgetInputHandlingBase.SelectPreviousPressed
// (Native, Event, Protected, BlueprintEvent)

void UWidgetInputHandlingBase::SelectPreviousPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "SelectPreviousPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WidgetInputHandlingBase.SelectPreviousPressed_Implementation
// (Native, Protected)

void UWidgetInputHandlingBase::SelectPreviousPressed_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "SelectPreviousPressed_Implementation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WidgetInputHandlingBase.SetupInput
// (Native, Public, BlueprintCallable)

void UWidgetInputHandlingBase::SetupInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "SetupInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WidgetInputHandlingBase.SetUpWidgets
// (Final, Native, Public, BlueprintCallable)

void UWidgetInputHandlingBase::SetUpWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "SetUpWidgets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WidgetInputHandlingBase.HasBeenSetup
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetInputHandlingBase::HasBeenSetup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetInputHandlingBase", "HasBeenSetup");

	Params::WidgetInputHandlingBase_HasBeenSetup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.CollectiblesListWidget.MoveBetweenCollectiblesVertical
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bUp                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCollectiblesListWidget::MoveBetweenCollectiblesVertical(const bool bUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectiblesListWidget", "MoveBetweenCollectiblesVertical");

	Params::CollectiblesListWidget_MoveBetweenCollectiblesVertical Parms{};

	Parms.bUp = bUp;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.CollectiblesListWidget.OnCollectibleItemSlotPressed
// (Event, Protected, BlueprintEvent)

void UCollectiblesListWidget::OnCollectibleItemSlotPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectiblesListWidget", "OnCollectibleItemSlotPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.CollectiblesSlotButtonWidget.SetImageAndItemName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UItemData>         ItemData                                               (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCollectiblesSlotButtonWidget::SetImageAndItemName(TSoftObjectPtr<class UItemData> ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectiblesSlotButtonWidget", "SetImageAndItemName");

	Params::CollectiblesSlotButtonWidget_SetImageAndItemName Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CollectiblesSlotButtonWidget.UpdateCollectibleItemImageMaterial
// (Event, Protected, BlueprintEvent)

void UCollectiblesSlotButtonWidget::UpdateCollectibleItemImageMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectiblesSlotButtonWidget", "UpdateCollectibleItemImageMaterial");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.CollectiblesWidget.CancelPressedHandler
// (Event, Protected, BlueprintEvent)

void UCollectiblesWidget::CancelPressedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectiblesWidget", "CancelPressedHandler");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.CollectiblesWidget.MoveWidgetInputActionTriggeredHandler
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FInputActionValue                InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCollectiblesWidget::MoveWidgetInputActionTriggeredHandler(const struct FInputActionValue& InputActionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectiblesWidget", "MoveWidgetInputActionTriggeredHandler");

	Params::CollectiblesWidget_MoveWidgetInputActionTriggeredHandler Parms{};

	Parms.InputActionValue = std::move(InputActionValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CollectiblesWidget.OnInteractPressedHandler
// (Final, Native, Protected)

void UCollectiblesWidget::OnInteractPressedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectiblesWidget", "OnInteractPressedHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CollectiblesWidget.OpenMenuPressedHandlerHandler
// (Event, Protected, BlueprintEvent)

void UCollectiblesWidget::OpenMenuPressedHandlerHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectiblesWidget", "OpenMenuPressedHandlerHandler");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.CollectiblesWidget.OpenPauseMenuPressedHandler
// (Event, Protected, BlueprintEvent)

void UCollectiblesWidget::OpenPauseMenuPressedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectiblesWidget", "OpenPauseMenuPressedHandler");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.CollectiblesWidget.SetupInput
// (Final, Native, Public, BlueprintCallable)

void UCollectiblesWidget::SetupInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectiblesWidget", "SetupInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerSubGraphAnimInstance.GetLinkedOwner
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPlayerAnimInstance*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayerAnimInstance* UPlayerSubGraphAnimInstance::GetLinkedOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerSubGraphAnimInstance", "GetLinkedOwner");

	Params::PlayerSubGraphAnimInstance_GetLinkedOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PlayerSubGraphAnimInstance.HasAnyGameplayTags
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            Container                                              (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerSubGraphAnimInstance::HasAnyGameplayTags(const struct FGameplayTagContainer& Container) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerSubGraphAnimInstance", "HasAnyGameplayTags");

	Params::PlayerSubGraphAnimInstance_HasAnyGameplayTags Parms{};

	Parms.Container = std::move(Container);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ContextualTraverseAnimInstance.GetInputTriggeredEarlyBlendOut
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TransitionIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UContextualTraverseAnimInstance::GetInputTriggeredEarlyBlendOut(int32 MachineIndex, int32 TransitionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualTraverseAnimInstance", "GetInputTriggeredEarlyBlendOut");

	Params::ContextualTraverseAnimInstance_GetInputTriggeredEarlyBlendOut Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.TransitionIndex = TransitionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HumanoidAnimInterface.GetHandBoneName
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsRightHand                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName IHumanoidAnimInterface::GetHandBoneName(bool bIsRightHand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidAnimInterface", "GetHandBoneName");

	Params::HumanoidAnimInterface_GetHandBoneName Parms{};

	Parms.bIsRightHand = bIsRightHand;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ContextualTraverseAnimInterface.OnRestart
// (Native, Event, Public, BlueprintEvent)

void IContextualTraverseAnimInterface::OnRestart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualTraverseAnimInterface", "OnRestart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ContextualTraverseAnimInterface.ResetShouldBlendOutOfEntryState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IContextualTraverseAnimInterface::ResetShouldBlendOutOfEntryState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualTraverseAnimInterface", "ResetShouldBlendOutOfEntryState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ContextualTraverseAnimInterface.SetShouldBlendOutOfEntryState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IContextualTraverseAnimInterface::SetShouldBlendOutOfEntryState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextualTraverseAnimInterface", "SetShouldBlendOutOfEntryState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FocusPointComponent.ActivateStartle
// (Final, Native, Public, BlueprintCallable)

void UFocusPointComponent::ActivateStartle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FocusPointComponent", "ActivateStartle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionComponentBase.InitiateInteraction
// (Native, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponentBase::InitiateInteraction(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponentBase", "InitiateInteraction");

	Params::InteractionComponentBase_InitiateInteraction Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.InteractionComponentBase.OnShowSelectionExtraIconStatusChangedDone__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bShowSelectionExtraIcon_0                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponentBase::OnShowSelectionExtraIconStatusChangedDone__DelegateSignature(bool bShowSelectionExtraIcon_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponentBase", "OnShowSelectionExtraIconStatusChangedDone__DelegateSignature");

	Params::InteractionComponentBase_OnShowSelectionExtraIconStatusChangedDone__DelegateSignature Parms{};

	Parms.bShowSelectionExtraIcon_0 = bShowSelectionExtraIcon_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.InteractionComponentBase.SetBeginActivated
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponentBase::SetBeginActivated(bool Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponentBase", "SetBeginActivated");

	Params::InteractionComponentBase_SetBeginActivated Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionComponentBase.SetShowSelectionExtraIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInShowSelectionExtraIcon                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponentBase::SetShowSelectionExtraIcon(const bool bInShowSelectionExtraIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponentBase", "SetShowSelectionExtraIcon");

	Params::InteractionComponentBase_SetShowSelectionExtraIcon Parms{};

	Parms.bInShowSelectionExtraIcon = bInShowSelectionExtraIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionComponentBase.CurrentlyInteracting
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionComponentBase::CurrentlyInteracting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponentBase", "CurrentlyInteracting");

	Params::InteractionComponentBase_CurrentlyInteracting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InteractionComponentBase.GetInteractingChar
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacter*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacter* UInteractionComponentBase::GetInteractingChar() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponentBase", "GetInteractingChar");

	Params::InteractionComponentBase_GetInteractingChar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InteractionComponentBase.GetInteractionIconWorldLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FVector UInteractionComponentBase::GetInteractionIconWorldLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponentBase", "GetInteractionIconWorldLocation");

	Params::InteractionComponentBase_GetInteractionIconWorldLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InteractionComponentBase.GetShowSelectionExtraIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionComponentBase::GetShowSelectionExtraIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponentBase", "GetShowSelectionExtraIcon");

	Params::InteractionComponentBase_GetShowSelectionExtraIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InteractionComponentBase.GetTagsUserShouldHave
// (Native, Protected, Const)
// Parameters:
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UInteractionComponentBase::GetTagsUserShouldHave() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponentBase", "GetTagsUserShouldHave");

	Params::InteractionComponentBase_GetTagsUserShouldHave Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InteractionComponentBase.GetTagsUserShouldNotHave
// (Native, Protected, Const)
// Parameters:
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UInteractionComponentBase::GetTagsUserShouldNotHave() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponentBase", "GetTagsUserShouldNotHave");

	Params::InteractionComponentBase_GetTagsUserShouldNotHave Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.CtrlButtonWidget.AddCtrlButton
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UInputAction*                     InputAction                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    Enabled                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Shown                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCtrlButtonWidget::AddCtrlButton(const class UInputAction* InputAction, const class FText& Description, const bool Enabled, const bool Shown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CtrlButtonWidget", "AddCtrlButton");

	Params::CtrlButtonWidget_AddCtrlButton Parms{};

	Parms.InputAction = InputAction;
	Parms.Description = std::move(Description);
	Parms.Enabled = Enabled;
	Parms.Shown = Shown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CtrlButtonWidget.ChangeTextOnCtrlButton
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UInputAction*                     InputAction                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Description                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCtrlButtonWidget::ChangeTextOnCtrlButton(const class UInputAction* InputAction, const class FText& Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CtrlButtonWidget", "ChangeTextOnCtrlButton");

	Params::CtrlButtonWidget_ChangeTextOnCtrlButton Parms{};

	Parms.InputAction = InputAction;
	Parms.Description = std::move(Description);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CtrlButtonWidget.ClearCtrlButtons
// (Final, Native, Public, BlueprintCallable)

void UCtrlButtonWidget::ClearCtrlButtons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CtrlButtonWidget", "ClearCtrlButtons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CtrlButtonWidget.EnableAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInputAction*                     InputAction                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCtrlButtonWidget::EnableAction(const class UInputAction* InputAction, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CtrlButtonWidget", "EnableAction");

	Params::CtrlButtonWidget_EnableAction Parms{};

	Parms.InputAction = InputAction;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CtrlButtonWidget.HideInputAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInputAction*                     InputAction                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCtrlButtonWidget::HideInputAction(const class UInputAction* InputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CtrlButtonWidget", "HideInputAction");

	Params::CtrlButtonWidget_HideInputAction Parms{};

	Parms.InputAction = InputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CtrlButtonWidget.InputTypeChangedHandler
// (Final, Native, Private)
// Parameters:
// bool                                    IsGamepad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCtrlButtonWidget::InputTypeChangedHandler(bool IsGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CtrlButtonWidget", "InputTypeChangedHandler");

	Params::CtrlButtonWidget_InputTypeChangedHandler Parms{};

	Parms.IsGamepad = IsGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.CtrlButtonWidget.ShowInputAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInputAction*                     InputAction                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCtrlButtonWidget::ShowInputAction(const class UInputAction* InputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CtrlButtonWidget", "ShowInputAction");

	Params::CtrlButtonWidget_ShowInputAction Parms{};

	Parms.InputAction = InputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.IncreaseDecreaseOption.CalculateNewValue
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   CurrentValue                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAdding                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UIncreaseDecreaseOption::CalculateNewValue(const float CurrentValue, const bool bAdding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IncreaseDecreaseOption", "CalculateNewValue");

	Params::IncreaseDecreaseOption_CalculateNewValue Parms{};

	Parms.CurrentValue = CurrentValue;
	Parms.bAdding = bAdding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.IncreaseDecreaseOption.SetButtonText
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIncreaseDecreaseOption::SetButtonText(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IncreaseDecreaseOption", "SetButtonText");

	Params::IncreaseDecreaseOption_SetButtonText Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.IncreaseDecreaseCustomTextOption.GetTextfromValue
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UIncreaseDecreaseCustomTextOption::GetTextfromValue(const float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IncreaseDecreaseCustomTextOption", "GetTextfromValue");

	Params::IncreaseDecreaseCustomTextOption_GetTextfromValue Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DamagePoint.CheckIfHit
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          LineOrigin                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LineDirection                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamagePoint::CheckIfHit(const struct FVector& LineOrigin, const struct FVector& LineDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePoint", "CheckIfHit");

	Params::DamagePoint_CheckIfHit Parms{};

	Parms.LineOrigin = std::move(LineOrigin);
	Parms.LineDirection = std::move(LineDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DamagePoint.OnHit
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            DamageTags                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   WeakPointsDamage                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamagePoint::OnHit(const struct FGameplayTagContainer& DamageTags, float WeakPointsDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePoint", "OnHit");

	Params::DamagePoint_OnHit Parms{};

	Parms.DamageTags = std::move(DamageTags);
	Parms.WeakPointsDamage = WeakPointsDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DamagePoint.Reset
// (Native, Public, BlueprintCallable)

void UDamagePoint::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePoint", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DamagePoint.ReviveDamagePoint
// (Final, Native, Public, BlueprintCallable)

void UDamagePoint::ReviveDamagePoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePoint", "ReviveDamagePoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DamagePoint.SetCanBeHit
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InCanBeHit                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamagePoint::SetCanBeHit(const bool InCanBeHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePoint", "SetCanBeHit");

	Params::DamagePoint_SetCanBeHit Parms{};

	Parms.InCanBeHit = InCanBeHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DamagePoint.CanBeHit
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamagePoint::CanBeHit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePoint", "CanBeHit");

	Params::DamagePoint_CanBeHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DamagePoint.GetDamagePointName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UDamagePoint::GetDamagePointName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePoint", "GetDamagePointName");

	Params::DamagePoint_GetDamagePointName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DamagePoint.GetGamePlayEffectsWhenDestroyed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<TSubclassOf<class UGameplayEffect>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class UGameplayEffect>> UDamagePoint::GetGamePlayEffectsWhenDestroyed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePoint", "GetGamePlayEffectsWhenDestroyed");

	Params::DamagePoint_GetGamePlayEffectsWhenDestroyed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DamagePoint.GetGameplayTags
// (Final, Native, Public, Const)
// Parameters:
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UDamagePoint::GetGameplayTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePoint", "GetGameplayTags");

	Params::DamagePoint_GetGameplayTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DamagePoint.GetOrderSequenceNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDamagePoint::GetOrderSequenceNumber() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePoint", "GetOrderSequenceNumber");

	Params::DamagePoint_GetOrderSequenceNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DamagePoint.IsDamagePointDestroyed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDamagePoint::IsDamagePointDestroyed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePoint", "IsDamagePointDestroyed");

	Params::DamagePoint_IsDamagePointDestroyed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DamagePointHighlight.OnParentActivation
// (Final, Native, Private)
// Parameters:
// class UActorComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamagePointHighlight::OnParentActivation(class UActorComponent* Component, bool bReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePointHighlight", "OnParentActivation");

	Params::DamagePointHighlight_OnParentActivation Parms{};

	Parms.Component = Component;
	Parms.bReset = bReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DamagePointHighlight.OnParentDeactivation
// (Final, Native, Private)
// Parameters:
// class UActorComponent*                  Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamagePointHighlight::OnParentDeactivation(class UActorComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePointHighlight", "OnParentDeactivation");

	Params::DamagePointHighlight_OnParentDeactivation Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.DamagePointSequence.DamagePointInSequenceDestroyed__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSequenceComplete                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDamagePointSequence::DamagePointInSequenceDestroyed__DelegateSignature(class FName Name_0, bool bSequenceComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePointSequence", "DamagePointInSequenceDestroyed__DelegateSignature");

	Params::DamagePointSequence_DamagePointInSequenceDestroyed__DelegateSignature Parms{};

	Parms.Name_0 = Name_0;
	Parms.bSequenceComplete = bSequenceComplete;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.DamagePointSequence.DamagePointSequenceIsDone__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UDamagePointSequence::DamagePointSequenceIsDone__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePointSequence", "DamagePointSequenceIsDone__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.DamagePointSequence.GetActiveDamagePointLine
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          End                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamagePoint*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDamagePoint* UDamagePointSequence::GetActiveDamagePointLine(const struct FVector& Start, const struct FVector& End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePointSequence", "GetActiveDamagePointLine");

	Params::DamagePointSequence_GetActiveDamagePointLine Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DamagePointSequence.OnDamagePointDestroyed
// (Final, Native, Protected)

void UDamagePointSequence::OnDamagePointDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePointSequence", "OnDamagePointDestroyed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DamagePointSequence.OnDamagePointTakeDamage
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AmountOfDamage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGotDestroyed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            DamageTags                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDamagePointSequence::OnDamagePointTakeDamage(class FName Name_0, float AmountOfDamage, bool bGotDestroyed, const struct FGameplayTagContainer& DamageTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePointSequence", "OnDamagePointTakeDamage");

	Params::DamagePointSequence_OnDamagePointTakeDamage Parms{};

	Parms.Name_0 = Name_0;
	Parms.AmountOfDamage = AmountOfDamage;
	Parms.bGotDestroyed = bGotDestroyed;
	Parms.DamageTags = std::move(DamageTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DamagePointSequence.ResetSequence
// (Final, Native, Public, BlueprintCallable)

void UDamagePointSequence::ResetSequence()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePointSequence", "ResetSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DamagePointSequence.GetActiveDamagePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDamagePoint*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDamagePoint* UDamagePointSequence::GetActiveDamagePoint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DamagePointSequence", "GetActiveDamagePoint");

	Params::DamagePointSequence_GetActiveDamagePoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InGameUIWidget_QuickSlotWidget.OnAmmoChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   CurrentAmmo                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxAmmo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget_QuickSlotWidget::OnAmmoChanged(int32 CurrentAmmo, int32 MaxAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_QuickSlotWidget", "OnAmmoChanged");

	Params::InGameUIWidget_QuickSlotWidget_OnAmmoChanged Parms{};

	Parms.CurrentAmmo = CurrentAmmo;
	Parms.MaxAmmo = MaxAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_QuickSlotWidget.OnAmmoUpdated
// (Final, Native, Protected)
// Parameters:
// class UPanelWidget*                     PanelWidget                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextBlock*                       AmmoText                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AmmoCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget_QuickSlotWidget::OnAmmoUpdated(class UPanelWidget* PanelWidget, class UTextBlock* AmmoText, int32 AmmoCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_QuickSlotWidget", "OnAmmoUpdated");

	Params::InGameUIWidget_QuickSlotWidget_OnAmmoUpdated Parms{};

	Parms.PanelWidget = PanelWidget;
	Parms.AmmoText = AmmoText;
	Parms.AmmoCount = AmmoCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_QuickSlotWidget.OnEquipmentChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FWeaponInfo                      EquippedWeapon                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FWeaponInfo                      UnequippedWeapon                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UInGameUIWidget_QuickSlotWidget::OnEquipmentChanged(const struct FWeaponInfo& EquippedWeapon, const struct FWeaponInfo& UnequippedWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_QuickSlotWidget", "OnEquipmentChanged");

	Params::InGameUIWidget_QuickSlotWidget_OnEquipmentChanged Parms{};

	Parms.EquippedWeapon = std::move(EquippedWeapon);
	Parms.UnequippedWeapon = std::move(UnequippedWeapon);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.InGameUIWidget_QuickSlotWidget.OnPistolSlotChanged
// (Final, Native, Protected)
// Parameters:
// class UItemData_Equippable*             NewWeapon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemData_Equippable*             OldWeapon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget_QuickSlotWidget::OnPistolSlotChanged(class UItemData_Equippable* NewWeapon, class UItemData_Equippable* OldWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_QuickSlotWidget", "OnPistolSlotChanged");

	Params::InGameUIWidget_QuickSlotWidget_OnPistolSlotChanged Parms{};

	Parms.NewWeapon = NewWeapon;
	Parms.OldWeapon = OldWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_QuickSlotWidget.OnPlayerEquipmentUpdated
// (Final, Native, Protected)
// Parameters:
// struct FWeaponInfo                      EquippedWeapon                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FWeaponInfo                      UnequippedWeapon                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UInGameUIWidget_QuickSlotWidget::OnPlayerEquipmentUpdated(const struct FWeaponInfo& EquippedWeapon, const struct FWeaponInfo& UnequippedWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_QuickSlotWidget", "OnPlayerEquipmentUpdated");

	Params::InGameUIWidget_QuickSlotWidget_OnPlayerEquipmentUpdated Parms{};

	Parms.EquippedWeapon = std::move(EquippedWeapon);
	Parms.UnequippedWeapon = std::move(UnequippedWeapon);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_QuickSlotWidget.OnPlayerLootItem
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UItemData*                        ItemData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget_QuickSlotWidget::OnPlayerLootItem(const class UItemData* ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_QuickSlotWidget", "OnPlayerLootItem");

	Params::InGameUIWidget_QuickSlotWidget_OnPlayerLootItem Parms{};

	Parms.ItemData = ItemData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.InGameUIWidget_QuickSlotWidget.OnPlayerLootItemUpdated
// (Final, Native, Protected)
// Parameters:
// class UItemData*                        ItemData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget_QuickSlotWidget::OnPlayerLootItemUpdated(const class UItemData* ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_QuickSlotWidget", "OnPlayerLootItemUpdated");

	Params::InGameUIWidget_QuickSlotWidget_OnPlayerLootItemUpdated Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_QuickSlotWidget.OnShowItemIncrement
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UItemData*                        ItemData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemDisplayInfo                 ItemInfo                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget_QuickSlotWidget::OnShowItemIncrement(const class UItemData* ItemData, const struct FItemDisplayInfo& ItemInfo, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_QuickSlotWidget", "OnShowItemIncrement");

	Params::InGameUIWidget_QuickSlotWidget_OnShowItemIncrement Parms{};

	Parms.ItemData = ItemData;
	Parms.ItemInfo = std::move(ItemInfo);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_QuickSlotWidget.TryingToPickUpMaxStackItemHandler
// (Final, Native, Private)
// Parameters:
// class UItemData*                        ItemData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget_QuickSlotWidget::TryingToPickUpMaxStackItemHandler(const class UItemData* ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_QuickSlotWidget", "TryingToPickUpMaxStackItemHandler");

	Params::InGameUIWidget_QuickSlotWidget_TryingToPickUpMaxStackItemHandler Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HumanoidAnimInstance.ArmIKEnd
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    IsRightSide                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanoidAnimInstance::ArmIKEnd(bool IsRightSide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidAnimInstance", "ArmIKEnd");

	Params::HumanoidAnimInstance_ArmIKEnd Parms{};

	Parms.IsRightSide = IsRightSide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HumanoidAnimInstance.ArmIKStart
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    IsRightSide                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             IKTargetCompensationBoneName                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             WeightCurveName                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanoidAnimInstance::ArmIKStart(bool IsRightSide, const class FName IKTargetCompensationBoneName, const class FName WeightCurveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidAnimInstance", "ArmIKStart");

	Params::HumanoidAnimInstance_ArmIKStart Parms{};

	Parms.IsRightSide = IsRightSide;
	Parms.IKTargetCompensationBoneName = IKTargetCompensationBoneName;
	Parms.WeightCurveName = WeightCurveName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HumanoidAnimInstance.DebugWantedLookAt
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Origin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LookAtLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          CurrentForward                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Lifetime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanoidAnimInstance::DebugWantedLookAt(const struct FVector& Origin, const struct FVector& LookAtLocation, const struct FVector& CurrentForward, float Lifetime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidAnimInstance", "DebugWantedLookAt");

	Params::HumanoidAnimInstance_DebugWantedLookAt Parms{};

	Parms.Origin = std::move(Origin);
	Parms.LookAtLocation = std::move(LookAtLocation);
	Parms.CurrentForward = std::move(CurrentForward);
	Parms.Lifetime = Lifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.HumanoidAnimInstance.FootStepDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bRunning                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanoidAnimInstance::FootStepDelegate__DelegateSignature(bool bRunning)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidAnimInstance", "FootStepDelegate__DelegateSignature");

	Params::HumanoidAnimInstance_FootStepDelegate__DelegateSignature Parms{};

	Parms.bRunning = bRunning;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.HumanoidAnimInstance.GetBodyFocusMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EBodyFocusMode                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBodyFocusMode UHumanoidAnimInstance::GetBodyFocusMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidAnimInstance", "GetBodyFocusMode");

	Params::HumanoidAnimInstance_GetBodyFocusMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HumanoidAnimInstance.OnBodyFocusMultiBoolValueChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanoidAnimInstance::OnBodyFocusMultiBoolValueChanged(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidAnimInstance", "OnBodyFocusMultiBoolValueChanged");

	Params::HumanoidAnimInstance_OnBodyFocusMultiBoolValueChanged Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HumanoidAnimInstance.RailingIKBlocked
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             IKBoneName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutIsBlocked                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOutIsInstantBlock                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanoidAnimInstance::RailingIKBlocked(class FName IKBoneName, bool* bOutIsBlocked, bool* bOutIsInstantBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidAnimInstance", "RailingIKBlocked");

	Params::HumanoidAnimInstance_RailingIKBlocked Parms{};

	Parms.IKBoneName = IKBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutIsBlocked != nullptr)
		*bOutIsBlocked = Parms.bOutIsBlocked;

	if (bOutIsInstantBlock != nullptr)
		*bOutIsInstantBlock = Parms.bOutIsInstantBlock;
}


// Function ObsidianFox.HumanoidAnimInstance.ResetArmIKData
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FArmIKData                       ArmIKData                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UHumanoidAnimInstance::ResetArmIKData(struct FArmIKData* ArmIKData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidAnimInstance", "ResetArmIKData");

	Params::HumanoidAnimInstance_ResetArmIKData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ArmIKData != nullptr)
		*ArmIKData = std::move(Parms.ArmIKData);
}


// Function ObsidianFox.HumanoidAnimInstance.SetManualHipOffsetInterpolationSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanoidAnimInstance::SetManualHipOffsetInterpolationSpeed(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidAnimInstance", "SetManualHipOffsetInterpolationSpeed");

	Params::HumanoidAnimInstance_SetManualHipOffsetInterpolationSpeed Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HumanoidAnimInstance.UpdateArmIK
// (Final, Native, Protected)
// Parameters:
// float                                   DeltaTimeX                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanoidAnimInstance::UpdateArmIK(float DeltaTimeX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidAnimInstance", "UpdateArmIK");

	Params::HumanoidAnimInstance_UpdateArmIK Parms{};

	Parms.DeltaTimeX = DeltaTimeX;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HumanoidAnimInstance.UpdateArmIKState
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FArmIKData                       ArmIKData                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UHumanoidAnimInstance::UpdateArmIKState(struct FArmIKData* ArmIKData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidAnimInstance", "UpdateArmIKState");

	Params::HumanoidAnimInstance_UpdateArmIKState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ArmIKData != nullptr)
		*ArmIKData = std::move(Parms.ArmIKData);
}


// Function ObsidianFox.HumanoidAnimInstance.UpdateHandIKRotation
// (Final, Native, Protected, HasOutParams)
// Parameters:
// float                                   DeltaTimeX                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FArmIKData                       ArmIKData                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UHumanoidAnimInstance::UpdateHandIKRotation(float DeltaTimeX, struct FArmIKData* ArmIKData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidAnimInstance", "UpdateHandIKRotation");

	Params::HumanoidAnimInstance_UpdateHandIKRotation Parms{};

	Parms.DeltaTimeX = DeltaTimeX;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ArmIKData != nullptr)
		*ArmIKData = std::move(Parms.ArmIKData);
}


// Function ObsidianFox.HumanoidAnimInstance.UpdateHipsIK
// (Final, Native, Protected)
// Parameters:
// float                                   DeltaTimeX                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHumanoidAnimInstance::UpdateHipsIK(float DeltaTimeX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidAnimInstance", "UpdateHipsIK");

	Params::HumanoidAnimInstance_UpdateHipsIK Parms{};

	Parms.DeltaTimeX = DeltaTimeX;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Inventory.AddItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UItemData*                        InItemData                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFInventoryPopUp                        PopUp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::AddItem(const class UItemData* InItemData, int32 Amount, EFInventoryPopUp PopUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "AddItem");

	Params::Inventory_AddItem Parms{};

	Parms.InItemData = InItemData;
	Parms.Amount = Amount;
	Parms.PopUp = PopUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Inventory.GetAllItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const TMap<TSoftObjectPtr<class UItemData>, struct FItemInfo>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<TSoftObjectPtr<class UItemData>, struct FItemInfo> UInventory::GetAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetAllItems");

	Params::Inventory_GetAllItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Inventory.GetArchivedItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<TSoftObjectPtr<class UItemData>, struct FArchivedItemInfo>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<TSoftObjectPtr<class UItemData>, struct FArchivedItemInfo> UInventory::GetArchivedItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetArchivedItems");

	Params::Inventory_GetArchivedItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Inventory.GetItemPickedUpHistory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSet<TSoftObjectPtr<class UItemData>>   ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TSet<TSoftObjectPtr<class UItemData>> UInventory::GetItemPickedUpHistory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetItemPickedUpHistory");

	Params::Inventory_GetItemPickedUpHistory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Inventory.HasItemBeenLookedAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UItemData>         ItemData                                               (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::HasItemBeenLookedAt(const TSoftObjectPtr<class UItemData> ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "HasItemBeenLookedAt");

	Params::Inventory_HasItemBeenLookedAt Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Inventory.OnProgressionUpdated
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     NewProgressionState                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     OldProgressionState                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::OnProgressionUpdated(const struct FGameplayTag& NewProgressionState, const struct FGameplayTag& OldProgressionState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "OnProgressionUpdated");

	Params::Inventory_OnProgressionUpdated Parms{};

	Parms.NewProgressionState = std::move(NewProgressionState);
	Parms.OldProgressionState = std::move(OldProgressionState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Inventory.RemoveAllItems
// (Final, Native, Public, BlueprintCallable)

void UInventory::RemoveAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "RemoveAllItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Inventory.RemoveItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UItemData*                        ItemData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::RemoveItem(const class UItemData* ItemData, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "RemoveItem");

	Params::Inventory_RemoveItem Parms{};

	Parms.ItemData = ItemData;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Inventory.SetArchiveTutorialShown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::SetArchiveTutorialShown(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "SetArchiveTutorialShown");

	Params::Inventory_SetArchiveTutorialShown Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Inventory.SetItemLookedAt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UItemData>         ItemData                                               (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bItemLookedAt                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::SetItemLookedAt(const TSoftObjectPtr<class UItemData> ItemData, bool bItemLookedAt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "SetItemLookedAt");

	Params::Inventory_SetItemLookedAt Parms{};

	Parms.ItemData = ItemData;
	Parms.bItemLookedAt = bItemLookedAt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Inventory.UseItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UItemData*                        ItemData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::UseItem(const class UItemData* ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "UseItem");

	Params::Inventory_UseItem Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Inventory.GetCollectibleManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UCollectibleManager*        ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UCollectibleManager* UInventory::GetCollectibleManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetCollectibleManager");

	Params::Inventory_GetCollectibleManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Inventory.GetItemAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UItemData*                        ItemData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventory::GetItemAmount(const class UItemData* ItemData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetItemAmount");

	Params::Inventory_GetItemAmount Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Inventory.HasAnyItemNotBeenLookedAt
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<TSoftObjectPtr<class UItemData>> Items                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::HasAnyItemNotBeenLookedAt(const TArray<TSoftObjectPtr<class UItemData>>& Items) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "HasAnyItemNotBeenLookedAt");

	Params::Inventory_HasAnyItemNotBeenLookedAt Parms{};

	Parms.Items = std::move(Items);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Inventory.HaveArchiveTutorialBeenShown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::HaveArchiveTutorialBeenShown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "HaveArchiveTutorialBeenShown");

	Params::Inventory_HaveArchiveTutorialBeenShown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Inventory.HaveItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UItemData>         ItemData                                               (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::HaveItem(TSoftObjectPtr<class UItemData> ItemData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "HaveItem");

	Params::Inventory_HaveItem Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Inventory.IsItemInPickupHistory
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UItemData>         ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::IsItemInPickupHistory(const TSoftObjectPtr<class UItemData>& ItemData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "IsItemInPickupHistory");

	Params::Inventory_IsItemInPickupHistory Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DarkManAnimInstance.BPEndEmote
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           AlertTargetActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarkManAnimInstance::BPEndEmote(class AActor* AlertTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkManAnimInstance", "BPEndEmote");

	Params::DarkManAnimInstance_BPEndEmote Parms{};

	Parms.AlertTargetActor = AlertTargetActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.DarkManAnimInstance.BPStartEmote
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UDarkManEmoteDataAsset*           Emote                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarkManAnimInstance::BPStartEmote(class UDarkManEmoteDataAsset* Emote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkManAnimInstance", "BPStartEmote");

	Params::DarkManAnimInstance_BPStartEmote Parms{};

	Parms.Emote = Emote;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.DarkManAnimInstance.MontageBlendingOut
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDarkManAnimInstance::MontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkManAnimInstance", "MontageBlendingOut");

	Params::DarkManAnimInstance_MontageBlendingOut Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DarkManAnimInstance.OnABPEmoteDone
// (Final, Native, Public, BlueprintCallable)

void UDarkManAnimInstance::OnABPEmoteDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkManAnimInstance", "OnABPEmoteDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DarkManEmoteInterface.EndEmote
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AlertTargetActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDarkManEmoteInterface::EndEmote(class AActor* AlertTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkManEmoteInterface", "EndEmote");

	Params::DarkManEmoteInterface_EndEmote Parms{};

	Parms.AlertTargetActor = AlertTargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DarkManEmoteInterface.RegisterEmoteDoneListener
// (Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       Event                                                  (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void IDarkManEmoteInterface::RegisterEmoteDoneListener(TDelegate<void()> Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkManEmoteInterface", "RegisterEmoteDoneListener");

	Params::DarkManEmoteInterface_RegisterEmoteDoneListener Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DarkManEmoteInterface.StartEmote
// (Native, Public, BlueprintCallable)
// Parameters:
// class UDarkManEmoteDataAsset*           Emote                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDarkManEmoteInterface::StartEmote(class UDarkManEmoteDataAsset* Emote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkManEmoteInterface", "StartEmote");

	Params::DarkManEmoteInterface_StartEmote Parms{};

	Parms.Emote = Emote;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DarkManEmoteInterface.UnregisterEmoteDoneListener
// (Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void()>                       Event                                                  (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void IDarkManEmoteInterface::UnregisterEmoteDoneListener(TDelegate<void()> Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkManEmoteInterface", "UnregisterEmoteDoneListener");

	Params::DarkManEmoteInterface_UnregisterEmoteDoneListener Parms{};

	Parms.Event = Event;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_Equipment.OnAmmoChanged
// (Final, Native, Protected)
// Parameters:
// int32                                   CurrentAmmo                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxAmmo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget_Equipment::OnAmmoChanged(int32 CurrentAmmo, int32 MaxAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_Equipment", "OnAmmoChanged");

	Params::InGameUIWidget_Equipment_OnAmmoChanged Parms{};

	Parms.CurrentAmmo = CurrentAmmo;
	Parms.MaxAmmo = MaxAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_Equipment.OnPlayerEquipmentUpdated
// (Final, Native, Protected)
// Parameters:
// struct FWeaponInfo                      EquippedWeapon                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FWeaponInfo                      UnequippedWeapon                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UInGameUIWidget_Equipment::OnPlayerEquipmentUpdated(const struct FWeaponInfo& EquippedWeapon, const struct FWeaponInfo& UnequippedWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_Equipment", "OnPlayerEquipmentUpdated");

	Params::InGameUIWidget_Equipment_OnPlayerEquipmentUpdated Parms{};

	Parms.EquippedWeapon = std::move(EquippedWeapon);
	Parms.UnequippedWeapon = std::move(UnequippedWeapon);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_Equipment.OnPlayerLootItemUpdated
// (Final, Native, Protected)
// Parameters:
// class UItemData*                        ItemData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget_Equipment::OnPlayerLootItemUpdated(const class UItemData* ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_Equipment", "OnPlayerLootItemUpdated");

	Params::InGameUIWidget_Equipment_OnPlayerLootItemUpdated Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_Equipment.UpdateBreakingImageMeleeWeaponWithNewWeapon
// (Event, Public, BlueprintEvent)
// Parameters:
// class AMeleeWeaponActor*                NewWeaponActor                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget_Equipment::UpdateBreakingImageMeleeWeaponWithNewWeapon(const class AMeleeWeaponActor* NewWeaponActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_Equipment", "UpdateBreakingImageMeleeWeaponWithNewWeapon");

	Params::InGameUIWidget_Equipment_UpdateBreakingImageMeleeWeaponWithNewWeapon Parms{};

	Parms.NewWeaponActor = NewWeaponActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.DEZInteractionComponent.GetDEZReference
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDynamicEnvironmentZoneComponent* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDynamicEnvironmentZoneComponent* UDEZInteractionComponent::GetDEZReference() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DEZInteractionComponent", "GetDEZReference");

	Params::DEZInteractionComponent_GetDEZReference Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InteractionFlowComponent.EndInteraction
// (Final, Native, Public, BlueprintCallable)

void UInteractionFlowComponent::EndInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionFlowComponent", "EndInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.InteractionFlowComponent.InteractionSignature__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ACharacter*                       InteractionCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionFlowComponent::InteractionSignature__DelegateSignature(class ACharacter* InteractionCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionFlowComponent", "InteractionSignature__DelegateSignature");

	Params::InteractionFlowComponent_InteractionSignature__DelegateSignature Parms{};

	Parms.InteractionCharacter = InteractionCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.InteractionFlowComponent.SetLockDuringInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    LockMoveInput                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    LockLookInput                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    LockGameplayInput                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    LockInteractable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionFlowComponent::SetLockDuringInteraction(bool LockMoveInput, bool LockLookInput, bool LockGameplayInput, bool LockInteractable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionFlowComponent", "SetLockDuringInteraction");

	Params::InteractionFlowComponent_SetLockDuringInteraction Parms{};

	Parms.LockMoveInput = LockMoveInput;
	Parms.LockLookInput = LockLookInput;
	Parms.LockGameplayInput = LockGameplayInput;
	Parms.LockInteractable = LockInteractable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionFlowComponent.SetLockGameplayInputDuringInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ShouldIgnore                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionFlowComponent::SetLockGameplayInputDuringInteraction(bool ShouldIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionFlowComponent", "SetLockGameplayInputDuringInteraction");

	Params::InteractionFlowComponent_SetLockGameplayInputDuringInteraction Parms{};

	Parms.ShouldIgnore = ShouldIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionFlowComponent.SetLockInteractableDuringInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ShouldIgnore                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionFlowComponent::SetLockInteractableDuringInteraction(bool ShouldIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionFlowComponent", "SetLockInteractableDuringInteraction");

	Params::InteractionFlowComponent_SetLockInteractableDuringInteraction Parms{};

	Parms.ShouldIgnore = ShouldIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionFlowComponent.SetLockLookInputDuringInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ShouldIgnore                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionFlowComponent::SetLockLookInputDuringInteraction(bool ShouldIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionFlowComponent", "SetLockLookInputDuringInteraction");

	Params::InteractionFlowComponent_SetLockLookInputDuringInteraction Parms{};

	Parms.ShouldIgnore = ShouldIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionFlowComponent.SetLockMovementInputDuringInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ShouldIgnore                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionFlowComponent::SetLockMovementInputDuringInteraction(bool ShouldIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionFlowComponent", "SetLockMovementInputDuringInteraction");

	Params::InteractionFlowComponent_SetLockMovementInputDuringInteraction Parms{};

	Parms.ShouldIgnore = ShouldIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DifficultyDependantSubsystem.OnDifficultyUpdatedHandler
// (Final, Native, Protected)
// Parameters:
// EDifficulty                             NewDifficulty                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDifficultyDependantSubsystem::OnDifficultyUpdatedHandler(EDifficulty NewDifficulty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DifficultyDependantSubsystem", "OnDifficultyUpdatedHandler");

	Params::DifficultyDependantSubsystem_OnDifficultyUpdatedHandler Parms{};

	Parms.NewDifficulty = NewDifficulty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFGridPanel.OnSlotHovered
// (Native, Public, BlueprintCallable)
// Parameters:
// class UOFSlotWidget*                    InArchiveSlot                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFGridPanel::OnSlotHovered(class UOFSlotWidget* InArchiveSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFGridPanel", "OnSlotHovered");

	Params::OFGridPanel_OnSlotHovered Parms{};

	Parms.InArchiveSlot = InArchiveSlot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFGridPanel.SetFirstSlotAsActive
// (Final, Native, Public, BlueprintCallable)

void UOFGridPanel::SetFirstSlotAsActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFGridPanel", "SetFirstSlotAsActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationSelectionWidget.OpenArchive
// (Event, Protected, BlueprintEvent)

void UInvestigationSelectionWidget::OpenArchive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationSelectionWidget", "OpenArchive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InvestigationSelectionWidget.ReloadPressedHandler
// (Event, Protected, BlueprintEvent)

void UInvestigationSelectionWidget::ReloadPressedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationSelectionWidget", "ReloadPressedHandler");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InvestigationSelectionWidget.UpdateLabelBox
// (Final, Native, Protected, BlueprintCallable)

void UInvestigationSelectionWidget::UpdateLabelBox()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationSelectionWidget", "UpdateLabelBox");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationSelectionWidget.GetSelectedInvestigationSlotWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInvestigationSlotWidget*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInvestigationSlotWidget* UInvestigationSelectionWidget::GetSelectedInvestigationSlotWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationSelectionWidget", "GetSelectedInvestigationSlotWidget");

	Params::InvestigationSelectionWidget_GetSelectedInvestigationSlotWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryItemPicker.CheckIfRightItem
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UItemData*                        ItemData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IInventoryItemPicker::CheckIfRightItem(class UItemData* ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryItemPicker", "CheckIfRightItem");

	Params::InventoryItemPicker_CheckIfRightItem Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryItemPicker.GetTargetName
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText IInventoryItemPicker::GetTargetName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryItemPicker", "GetTargetName");

	Params::InventoryItemPicker_GetTargetName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryItemPicker.OnWindowClose
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IInventoryItemPicker::OnWindowClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryItemPicker", "OnWindowClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InventoryItemPicker.GetItemCategoryGameplayTag
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag IInventoryItemPicker::GetItemCategoryGameplayTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryItemPicker", "GetItemCategoryGameplayTag");

	Params::InventoryItemPicker_GetItemCategoryGameplayTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DismembermentInterface.DismemberAtHit
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       HitResult                                              (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   HitMagnitude                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsKillingHit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IDismembermentInterface::DismemberAtHit(const struct FHitResult& HitResult, float HitMagnitude, bool IsKillingHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DismembermentInterface", "DismemberAtHit");

	Params::DismembermentInterface_DismemberAtHit Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.HitMagnitude = HitMagnitude;
	Parms.IsKillingHit = IsKillingHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DismemberMeshParticleActor.AddAngularImpulseInDegrees
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Impulse                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipQueueIfPhysicsAreDisabled                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADismemberMeshParticleActor::AddAngularImpulseInDegrees(const struct FVector& Impulse, class FName BoneName, bool bSkipQueueIfPhysicsAreDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DismemberMeshParticleActor", "AddAngularImpulseInDegrees");

	Params::DismemberMeshParticleActor_AddAngularImpulseInDegrees Parms{};

	Parms.Impulse = std::move(Impulse);
	Parms.BoneName = BoneName;
	Parms.bSkipQueueIfPhysicsAreDisabled = bSkipQueueIfPhysicsAreDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DismemberMeshParticleActor.AddRadialImpulse
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipQueueIfPhysicsAreDisabled                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADismemberMeshParticleActor::AddRadialImpulse(const struct FVector& Origin, float Radius, float Strength, bool bSkipQueueIfPhysicsAreDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DismemberMeshParticleActor", "AddRadialImpulse");

	Params::DismemberMeshParticleActor_AddRadialImpulse Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Radius = Radius;
	Parms.Strength = Strength;
	Parms.bSkipQueueIfPhysicsAreDisabled = bSkipQueueIfPhysicsAreDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DismemberMeshParticleActor.OnSpawnEvent
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UDismemberSkeletalMeshComponent*  SpawningComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDismembermentExtraParameters*    OptionalObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADismemberMeshParticleActor::OnSpawnEvent(class UDismemberSkeletalMeshComponent* SpawningComponent, const class UDismembermentExtraParameters* OptionalObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DismemberMeshParticleActor", "OnSpawnEvent");

	Params::DismemberMeshParticleActor_OnSpawnEvent Parms{};

	Parms.SpawningComponent = SpawningComponent;
	Parms.OptionalObject = OptionalObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DismemberMeshParticleActor.DisablePhysics
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class FName                             SimulationRootBone                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADismemberMeshParticleActor::DisablePhysics(class FName SimulationRootBone) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DismemberMeshParticleActor", "DisablePhysics");

	Params::DismemberMeshParticleActor_DisablePhysics Parms{};

	Parms.SimulationRootBone = SimulationRootBone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DismemberMeshParticleActor.EnablePhysics
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class FName                             SimulationRootBone                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PhysicsProfileName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADismemberMeshParticleActor::EnablePhysics(class FName SimulationRootBone, class FName PhysicsProfileName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DismemberMeshParticleActor", "EnablePhysics");

	Params::DismemberMeshParticleActor_EnablePhysics Parms{};

	Parms.SimulationRootBone = SimulationRootBone;
	Parms.PhysicsProfileName = PhysicsProfileName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.VectorFieldInteractionComponent.VectorFieldInteraction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVectorFieldInteractionComponent::VectorFieldInteraction(float Radius, float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VectorFieldInteractionComponent", "VectorFieldInteraction");

	Params::VectorFieldInteractionComponent_VectorFieldInteraction Parms{};

	Parms.Radius = Radius;
	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DismemberSkeletalMeshComponent.DetachMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDismembermentExtraParameters*    OptionalObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADismemberMeshParticleActor*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADismemberMeshParticleActor* UDismemberSkeletalMeshComponent::DetachMesh(class UDismembermentExtraParameters* OptionalObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DismemberSkeletalMeshComponent", "DetachMesh");

	Params::DismemberSkeletalMeshComponent_DetachMesh Parms{};

	Parms.OptionalObject = OptionalObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DismemberSkeletalMeshComponent.DetachMeshWithForce
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UDismembermentExtraParameters*    OptionalObject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          RadialForceOrigin                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ForceRadius                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ForceStrength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          AngularImpulse                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AngularImpulseBone                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADismemberMeshParticleActor*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADismemberMeshParticleActor* UDismemberSkeletalMeshComponent::DetachMeshWithForce(class UDismembermentExtraParameters* OptionalObject, const struct FVector& RadialForceOrigin, float ForceRadius, float ForceStrength, const struct FVector& AngularImpulse, class FName AngularImpulseBone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DismemberSkeletalMeshComponent", "DetachMeshWithForce");

	Params::DismemberSkeletalMeshComponent_DetachMeshWithForce Parms{};

	Parms.OptionalObject = OptionalObject;
	Parms.RadialForceOrigin = std::move(RadialForceOrigin);
	Parms.ForceRadius = ForceRadius;
	Parms.ForceStrength = ForceStrength;
	Parms.AngularImpulse = std::move(AngularImpulse);
	Parms.AngularImpulseBone = AngularImpulseBone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Door.AreLevelsLoaded
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADoor::AreLevelsLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "AreLevelsLoaded");

	Params::Door_AreLevelsLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Door.BoltDraggingCallbackFunction
// (Final, Native, Protected)
// Parameters:
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::BoltDraggingCallbackFunction(float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "BoltDraggingCallbackFunction");

	Params::Door_BoltDraggingCallbackFunction Parms{};

	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.CheckDistanceForClosing
// (Native, Protected)

void ADoor::CheckDistanceForClosing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "CheckDistanceForClosing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.CloseDoor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInstantClose                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::CloseDoor(bool bInstantClose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "CloseDoor");

	Params::Door_CloseDoor Parms{};

	Parms.bInstantClose = bInstantClose;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.CloseDoorTimelineCallback
// (Native, Protected)
// Parameters:
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::CloseDoorTimelineCallback(float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "CloseDoorTimelineCallback");

	Params::Door_CloseDoorTimelineCallback Parms{};

	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.DoorHandleCounterClockwiseRotationTimelineCallback
// (Native, Protected)
// Parameters:
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::DoorHandleCounterClockwiseRotationTimelineCallback(float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "DoorHandleCounterClockwiseRotationTimelineCallback");

	Params::Door_DoorHandleCounterClockwiseRotationTimelineCallback Parms{};

	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.DoorHandleRotationTimelineCallback
// (Native, Protected)
// Parameters:
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::DoorHandleRotationTimelineCallback(float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "DoorHandleRotationTimelineCallback");

	Params::Door_DoorHandleRotationTimelineCallback Parms{};

	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.DoorRotationTimeLineCallback
// (Native, Protected)
// Parameters:
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::DoorRotationTimeLineCallback(float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "DoorRotationTimeLineCallback");

	Params::Door_DoorRotationTimeLineCallback Parms{};

	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.GetDoorOpenState
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDoorOpenState                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDoorOpenState ADoor::GetDoorOpenState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "GetDoorOpenState");

	Params::Door_GetDoorOpenState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Door.InteractingWithDoor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       InteractionCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::InteractingWithDoor(class ACharacter* InteractionCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "InteractingWithDoor");

	Params::Door_InteractingWithDoor Parms{};

	Parms.InteractionCharacter = InteractionCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.IsLocked
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADoor::IsLocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "IsLocked");

	Params::Door_IsLocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Door.ItemAddedHandler
// (Final, Native, Protected)
// Parameters:
// class UItemData*                        ItemData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::ItemAddedHandler(const class UItemData* ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "ItemAddedHandler");

	Params::Door_ItemAddedHandler Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.MoveToInteraction
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  MoveToLocation                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::MoveToInteraction(class ACharacter* InteractingCharacter, const class USceneComponent* MoveToLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "MoveToInteraction");

	Params::Door_MoveToInteraction Parms{};

	Parms.InteractingCharacter = InteractingCharacter;
	Parms.MoveToLocation = MoveToLocation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.Door.MoveToInteractionDone
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::MoveToInteractionDone(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "MoveToInteractionDone");

	Params::Door_MoveToInteractionDone Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.OnCharacterPossessed
// (Final, Native, Protected)
// Parameters:
// class AOFPlayerCharacter*               PlayerCharacter                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::OnCharacterPossessed(const class AOFPlayerCharacter* PlayerCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnCharacterPossessed");

	Params::Door_OnCharacterPossessed Parms{};

	Parms.PlayerCharacter = PlayerCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.OnCharacterUnPossessed
// (Final, Native, Protected)
// Parameters:
// class AOFPlayerCharacter*               PlayerCharacter                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::OnCharacterUnPossessed(const class AOFPlayerCharacter* PlayerCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnCharacterUnPossessed");

	Params::Door_OnCharacterUnPossessed Parms{};

	Parms.PlayerCharacter = PlayerCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.OnDoorCloseFinishedCallBack
// (Final, Native, Private)

void ADoor::OnDoorCloseFinishedCallBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnDoorCloseFinishedCallBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.OnDoorUnboltFinished
// (Event, Protected, BlueprintEvent)

void ADoor::OnDoorUnboltFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnDoorUnboltFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.Door.OnInteractingCharacterReachDoorHandleCallback
// (Final, Native, Public, BlueprintCallable)

void ADoor::OnInteractingCharacterReachDoorHandleCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnInteractingCharacterReachDoorHandleCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.OnLevelsLoaded_InteractingWithDoor_Handler
// (Final, Native, Public)

void ADoor::OnLevelsLoaded_InteractingWithDoor_Handler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnLevelsLoaded_InteractingWithDoor_Handler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.OnLevelsLoaded_UnlockDoorAnimation_Handler
// (Final, Native, Protected)

void ADoor::OnLevelsLoaded_UnlockDoorAnimation_Handler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnLevelsLoaded_UnlockDoorAnimation_Handler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.OnPreSaveGame
// (Final, Native, Protected)
// Parameters:
// ESaveTypePolicy                         SaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::OnPreSaveGame(ESaveTypePolicy SaveType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnPreSaveGame");

	Params::Door_OnPreSaveGame Parms{};

	Parms.SaveType = SaveType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.OnUnBoltFinishedCallBack
// (Final, Native, Private)

void ADoor::OnUnBoltFinishedCallBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnUnBoltFinishedCallBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.OpenDoor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCounterClockwise                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::OpenDoor(const bool bCounterClockwise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OpenDoor");

	Params::Door_OpenDoor Parms{};

	Parms.bCounterClockwise = bCounterClockwise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.OpenItemPicker
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::OpenItemPicker(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OpenItemPicker");

	Params::Door_OpenItemPicker Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.Door.OverrideTimelineCurve
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDoorTimelineActions                    InAction                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      InCurve                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::OverrideTimelineCurve(const EDoorTimelineActions InAction, class UCurveFloat* InCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OverrideTimelineCurve");

	Params::Door_OverrideTimelineCurve Parms{};

	Parms.InAction = InAction;
	Parms.InCurve = InCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.PlayerGuidanceSystemUpdatedHandler
// (Final, Native, Protected)
// Parameters:
// EPlayerGuidanceSystem                   System                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bState                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::PlayerGuidanceSystemUpdatedHandler(EPlayerGuidanceSystem System, bool bState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "PlayerGuidanceSystemUpdatedHandler");

	Params::Door_PlayerGuidanceSystemUpdatedHandler Parms{};

	Parms.System = System;
	Parms.bState = bState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.PlayerOverlappedTriggerBox
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADoor::PlayerOverlappedTriggerBox(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "PlayerOverlappedTriggerBox");

	Params::Door_PlayerOverlappedTriggerBox Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.PlayFirstTimeOpening
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void ADoor::PlayFirstTimeOpening()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "PlayFirstTimeOpening");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.Door.PlayMontage
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USkeletalMeshComponent*           InSkeletalMesh                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     MontageToPlay                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartingSection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::PlayMontage(const class USkeletalMeshComponent* InSkeletalMesh, const class UAnimMontage* MontageToPlay, class FName StartingSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "PlayMontage");

	Params::Door_PlayMontage Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;
	Parms.MontageToPlay = MontageToPlay;
	Parms.StartingSection = StartingSection;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.Door.PlayOpenAnimation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     AnimationTagOpen_0                                     (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::PlayOpenAnimation(const class ACharacter* InteractingCharacter, const struct FGameplayTag& AnimationTagOpen_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "PlayOpenAnimation");

	Params::Door_PlayOpenAnimation Parms{};

	Parms.InteractingCharacter = InteractingCharacter;
	Parms.AnimationTagOpen_0 = std::move(AnimationTagOpen_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.PlayTimeline
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EDoorTimelineActions                    InTimeLineAction                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::PlayTimeline(EDoorTimelineActions InTimeLineAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "PlayTimeline");

	Params::Door_PlayTimeline Parms{};

	Parms.InTimeLineAction = InTimeLineAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.PlayUnboltAnimation
// (Final, Native, Protected, BlueprintCallable)

void ADoor::PlayUnboltAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "PlayUnboltAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetAnimationPlayRate
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetAnimationPlayRate(float PlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetAnimationPlayRate");

	Params::Door_SetAnimationPlayRate Parms{};

	Parms.PlayRate = PlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetClockWiseOpening
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bClockwise                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetClockWiseOpening(const bool bClockwise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetClockWiseOpening");

	Params::Door_SetClockWiseOpening Parms{};

	Parms.bClockwise = bClockwise;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetCosmeticsForLockState
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EDoorLockState                          InLockState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetCosmeticsForLockState(EDoorLockState InLockState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetCosmeticsForLockState");

	Params::Door_SetCosmeticsForLockState Parms{};

	Parms.InLockState = InLockState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetDoorAsCameraOwner
// (Final, Native, Protected, BlueprintCallable)

void ADoor::SetDoorAsCameraOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetDoorAsCameraOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetDoorBoltSound
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UFMODEvent>        Value                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetDoorBoltSound(TSoftObjectPtr<class UFMODEvent> Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetDoorBoltSound");

	Params::Door_SetDoorBoltSound Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetDoorClosedEndSound
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UFMODEvent>        Value                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetDoorClosedEndSound(TSoftObjectPtr<class UFMODEvent> Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetDoorClosedEndSound");

	Params::Door_SetDoorClosedEndSound Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetDoorClosingSound
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UFMODEvent>        Value                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetDoorClosingSound(TSoftObjectPtr<class UFMODEvent> Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetDoorClosingSound");

	Params::Door_SetDoorClosingSound Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetDoorKeySound
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UFMODEvent>        Value                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetDoorKeySound(TSoftObjectPtr<class UFMODEvent> Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetDoorKeySound");

	Params::Door_SetDoorKeySound Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetDoorLockedSound
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UFMODEvent>        Value                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetDoorLockedSound(TSoftObjectPtr<class UFMODEvent> Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetDoorLockedSound");

	Params::Door_SetDoorLockedSound Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetDoorOpenSound
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UFMODEvent>        Value                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetDoorOpenSound(TSoftObjectPtr<class UFMODEvent> Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetDoorOpenSound");

	Params::Door_SetDoorOpenSound Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetDoorSprintOpenSound
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UFMODEvent>        Value                                                  (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetDoorSprintOpenSound(TSoftObjectPtr<class UFMODEvent> Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetDoorSprintOpenSound");

	Params::Door_SetDoorSprintOpenSound Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetDoorStartLerpRotationToCurrentRotation
// (Native, Protected)

void ADoor::SetDoorStartLerpRotationToCurrentRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetDoorStartLerpRotationToCurrentRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetEnableSprintOpen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSprintOpenEnable                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetEnableSprintOpen(const bool bSprintOpenEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetEnableSprintOpen");

	Params::Door_SetEnableSprintOpen Parms{};

	Parms.bSprintOpenEnable = bSprintOpenEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetLockState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDoorLockState                          NewLockState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetLockState(EDoorLockState NewLockState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetLockState");

	Params::Door_SetLockState Parms{};

	Parms.NewLockState = NewLockState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetLockState_Direct_Deprecated
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EDoorLockState                          NewLockState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetLockState_Direct_Deprecated(EDoorLockState NewLockState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetLockState_Direct_Deprecated");

	Params::Door_SetLockState_Direct_Deprecated Parms{};

	Parms.NewLockState = NewLockState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetOpenCurve
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FDoorCurveDataPair               NewOpenCurve                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADoor::SetOpenCurve(const struct FDoorCurveDataPair& NewOpenCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetOpenCurve");

	Params::Door_SetOpenCurve Parms{};

	Parms.NewOpenCurve = std::move(NewOpenCurve);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetPlayerCameraOwner
// (Final, Native, Protected, BlueprintCallable)

void ADoor::SetPlayerCameraOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetPlayerCameraOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetSprintOpenCurve
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCurveFloat*                      NewSprintOpenCurve                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetSprintOpenCurve(class UCurveFloat* NewSprintOpenCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetSprintOpenCurve");

	Params::Door_SetSprintOpenCurve Parms{};

	Parms.NewSprintOpenCurve = NewSprintOpenCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetupTimelineAction
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EDoorTimelineActions                    TimelineAction                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InTimelineName                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      InCurve                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetupTimelineAction(const EDoorTimelineActions TimelineAction, const class FName InTimelineName, class UCurveFloat* InCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetupTimelineAction");

	Params::Door_SetupTimelineAction Parms{};

	Parms.TimelineAction = TimelineAction;
	Parms.InTimelineName = InTimelineName;
	Parms.InCurve = InCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetUseAsTrigger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInUseAsTrigger                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetUseAsTrigger(const bool bInUseAsTrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetUseAsTrigger");

	Params::Door_SetUseAsTrigger Parms{};

	Parms.bInUseAsTrigger = bInUseAsTrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.SetUseClosingTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInUseClosingTimer                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::SetUseClosingTimer(const bool bInUseClosingTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "SetUseClosingTimer");

	Params::Door_SetUseClosingTimer Parms{};

	Parms.bInUseClosingTimer = bInUseClosingTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.StartDoorHandleTimeLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDoorOpenType                           OpenType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       InteractingCharacter                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDoorIsLocked                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::StartDoorHandleTimeLine(EDoorOpenType OpenType, const class ACharacter* InteractingCharacter, bool bDoorIsLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "StartDoorHandleTimeLine");

	Params::Door_StartDoorHandleTimeLine Parms{};

	Parms.OpenType = OpenType;
	Parms.InteractingCharacter = InteractingCharacter;
	Parms.bDoorIsLocked = bDoorIsLocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.StartLockedDoorTimeline
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDoorOpenType                           OpenType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       InteractingCharacter                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayHandleAnimations                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::StartLockedDoorTimeline(EDoorOpenType OpenType, const class ACharacter* InteractingCharacter, bool bPlayHandleAnimations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "StartLockedDoorTimeline");

	Params::Door_StartLockedDoorTimeline Parms{};

	Parms.OpenType = OpenType;
	Parms.InteractingCharacter = InteractingCharacter;
	Parms.bPlayHandleAnimations = bPlayHandleAnimations;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.StartOpenDoorTimeLine
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDoorOpenType                           OpenType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       InteractingCharacter                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayHandleAnimations                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::StartOpenDoorTimeLine(EDoorOpenType OpenType, const class ACharacter* InteractingCharacter, bool bPlayHandleAnimations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "StartOpenDoorTimeLine");

	Params::Door_StartOpenDoorTimeLine Parms{};

	Parms.OpenType = OpenType;
	Parms.InteractingCharacter = InteractingCharacter;
	Parms.bPlayHandleAnimations = bPlayHandleAnimations;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.StartWaitingForLevelsToLoad
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   SlowDownTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UUserWidget>          LoadingThrobberWidgetClass                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::StartWaitingForLevelsToLoad(float SlowDownTime, TSubclassOf<class UUserWidget> LoadingThrobberWidgetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "StartWaitingForLevelsToLoad");

	Params::Door_StartWaitingForLevelsToLoad Parms{};

	Parms.SlowDownTime = SlowDownTime;
	Parms.LoadingThrobberWidgetClass = LoadingThrobberWidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.StopDoorTimeline
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDoorTimelineActions                    TimelineToStop                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::StopDoorTimeline(EDoorTimelineActions TimelineToStop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "StopDoorTimeline");

	Params::Door_StopDoorTimeline Parms{};

	Parms.TimelineToStop = TimelineToStop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.StopTimeline
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EDoorTimelineActions                    InTimeLineAction                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::StopTimeline(EDoorTimelineActions InTimeLineAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "StopTimeline");

	Params::Door_StopTimeline Parms{};

	Parms.InTimeLineAction = InTimeLineAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.TimeLineFunctionDone
// (Final, Native, Protected)

void ADoor::TimeLineFunctionDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "TimeLineFunctionDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.UnBoltDoor
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::UnBoltDoor(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "UnBoltDoor");

	Params::Door_UnBoltDoor Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.Door.UnlockDoor
// (Final, Native, Public, BlueprintCallable)

void ADoor::UnlockDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "UnlockDoor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.UnlockDoorAnimation
// (Final, Native, Protected, BlueprintCallable)

void ADoor::UnlockDoorAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "UnlockDoorAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.UpdateClockwiseOpening
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bClockwiseOpeningPosition                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADoor::UpdateClockwiseOpening(bool bClockwiseOpeningPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "UpdateClockwiseOpening");

	Params::Door_UpdateClockwiseOpening Parms{};

	Parms.bClockwiseOpeningPosition = bClockwiseOpeningPosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.UpdateKeyCameraTransform
// (Final, Native, Protected, BlueprintCallable)

void ADoor::UpdateKeyCameraTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "UpdateKeyCameraTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.IsDoorClosing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADoor::IsDoorClosing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "IsDoorClosing");

	Params::Door_IsDoorClosing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Door.IsDoorOpen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADoor::IsDoorOpen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "IsDoorOpen");

	Params::Door_IsDoorOpen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Door.IsPlayingTimeline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDoorTimelineActions                    InTimeLineAction                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADoor::IsPlayingTimeline(EDoorTimelineActions InTimeLineAction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "IsPlayingTimeline");

	Params::Door_IsPlayingTimeline Parms{};

	Parms.InTimeLineAction = InTimeLineAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Door.OnDoorOpenFinishedCallBack
// (Final, Native, Private, Const)

void ADoor::OnDoorOpenFinishedCallBack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "OnDoorOpenFinishedCallBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Door.ShouldLevelsBeLoadedBeforeOpeningDoor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADoor::ShouldLevelsBeLoadedBeforeOpeningDoor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Door", "ShouldLevelsBeLoadedBeforeOpeningDoor");

	Params::Door_ShouldLevelsBeLoadedBeforeOpeningDoor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ItemData.GetTextureSizeFromDisplayInfo
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FItemDisplayInfo                 Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UItemData::GetTextureSizeFromDisplayInfo(const struct FItemDisplayInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemData", "GetTextureSizeFromDisplayInfo");

	Params::ItemData_GetTextureSizeFromDisplayInfo Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ItemData.GetMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMesh*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMesh* UItemData::GetMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemData", "GetMesh");

	Params::ItemData_GetMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ItemData.GetPickupSoundEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UFMODEvent*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFMODEvent* UItemData::GetPickupSoundEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemData", "GetPickupSoundEvent");

	Params::ItemData_GetPickupSoundEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ItemData.GetDisplayInfoAtIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FItemDisplayInfo           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FItemDisplayInfo UItemData::GetDisplayInfoAtIndex(const int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemData", "GetDisplayInfoAtIndex");

	Params::ItemData_GetDisplayInfoAtIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ItemData.GetFirstItemDisplayInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FItemDisplayInfo           ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FItemDisplayInfo UItemData::GetFirstItemDisplayInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemData", "GetFirstItemDisplayInfo");

	Params::ItemData_GetFirstItemDisplayInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ItemData.GetNextDisplayInfoIndexOfASet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UItemData::GetNextDisplayInfoIndexOfASet(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemData", "GetNextDisplayInfoIndexOfASet");

	Params::ItemData_GetNextDisplayInfoIndexOfASet Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ItemData.GetNumItemDisplayInfos
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UItemData::GetNumItemDisplayInfos() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemData", "GetNumItemDisplayInfos");

	Params::ItemData_GetNumItemDisplayInfos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ItemData.GetPreviousDisplayInfoIndexOfASet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UItemData::GetPreviousDisplayInfoIndexOfASet(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemData", "GetPreviousDisplayInfoIndexOfASet");

	Params::ItemData_GetPreviousDisplayInfoIndexOfASet Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ItemData.IsPartOfItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemData::IsPartOfItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemData", "IsPartOfItems");

	Params::ItemData_IsPartOfItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ItemData.IsSetOfItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemData::IsSetOfItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemData", "IsSetOfItems");

	Params::ItemData_IsSetOfItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ItemData.LifetimeIncludesProgressionTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ProgressionTag                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemData::LifetimeIncludesProgressionTag(const struct FGameplayTag& ProgressionTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemData", "LifetimeIncludesProgressionTag");

	Params::ItemData_LifetimeIncludesProgressionTag Parms{};

	Parms.ProgressionTag = std::move(ProgressionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DynamicConsumableSpawner.GetAmountOfItems
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADynamicConsumableSpawner::GetAmountOfItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicConsumableSpawner", "GetAmountOfItems");

	Params::DynamicConsumableSpawner_GetAmountOfItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DynamicConsumableSpawner.ItemPickedUp
// (Final, Native, Protected, BlueprintCallable)

void ADynamicConsumableSpawner::ItemPickedUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicConsumableSpawner", "ItemPickedUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicConsumableSpawner.OnItemSpawned
// (Event, Protected, BlueprintEvent)

void ADynamicConsumableSpawner::OnItemSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicConsumableSpawner", "OnItemSpawned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.DynamicEnvironmentZoneComponent.ActivateInteractionType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEnvironmentInteractionType             Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicEnvironmentZoneComponent::ActivateInteractionType(const EEnvironmentInteractionType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicEnvironmentZoneComponent", "ActivateInteractionType");

	Params::DynamicEnvironmentZoneComponent_ActivateInteractionType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicEnvironmentZoneComponent.ClearLayerRenderTargets
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInteractionLayer                InteractionLayer                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDynamicEnvironmentZoneComponent::ClearLayerRenderTargets(const struct FInteractionLayer& InteractionLayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicEnvironmentZoneComponent", "ClearLayerRenderTargets");

	Params::DynamicEnvironmentZoneComponent_ClearLayerRenderTargets Parms{};

	Parms.InteractionLayer = std::move(InteractionLayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicEnvironmentZoneComponent.DeactivateInteractionType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEnvironmentInteractionType             Type                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicEnvironmentZoneComponent::DeactivateInteractionType(const EEnvironmentInteractionType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicEnvironmentZoneComponent", "DeactivateInteractionType");

	Params::DynamicEnvironmentZoneComponent_DeactivateInteractionType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicEnvironmentZoneComponent.DEZInteraction
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnvironmentInteractionType             Type                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Size                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HeightAboveGround                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           EventTag                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DrawPerPixel                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicEnvironmentZoneComponent::DEZInteraction(const struct FVector& WorldLocation, const EEnvironmentInteractionType& Type, const struct FVector& Velocity, const float Duration, const float Size, const float Strength, const float HeightAboveGround, const class FString& EventTag, const bool DrawPerPixel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicEnvironmentZoneComponent", "DEZInteraction");

	Params::DynamicEnvironmentZoneComponent_DEZInteraction Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.Type = Type;
	Parms.Velocity = std::move(Velocity);
	Parms.Duration = Duration;
	Parms.Size = Size;
	Parms.Strength = Strength;
	Parms.HeightAboveGround = HeightAboveGround;
	Parms.EventTag = std::move(EventTag);
	Parms.DrawPerPixel = DrawPerPixel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicEnvironmentZoneComponent.DEZInteractionWithCustomMaterial
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               InteractionMat                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnvironmentInteractionType             Type                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Velocity                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Size                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HeightAboveGround                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           EventTag                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DrawPerPixel                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicEnvironmentZoneComponent::DEZInteractionWithCustomMaterial(const struct FVector& WorldLocation, class UMaterialInterface* InteractionMat, const EEnvironmentInteractionType& Type, const struct FVector& Velocity, const float Duration, const float Size, const float Strength, const float HeightAboveGround, const class FString& EventTag, const bool DrawPerPixel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicEnvironmentZoneComponent", "DEZInteractionWithCustomMaterial");

	Params::DynamicEnvironmentZoneComponent_DEZInteractionWithCustomMaterial Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.InteractionMat = InteractionMat;
	Parms.Type = Type;
	Parms.Velocity = std::move(Velocity);
	Parms.Duration = Duration;
	Parms.Size = Size;
	Parms.Strength = Strength;
	Parms.HeightAboveGround = HeightAboveGround;
	Parms.EventTag = std::move(EventTag);
	Parms.DrawPerPixel = DrawPerPixel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicEnvironmentZoneComponent.DrawMaterialToCanvas
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UCanvas*                          Canvas                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        RelativeLocation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        Size                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CanvasWorldSize                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicEnvironmentZoneComponent::DrawMaterialToCanvas(class UCanvas* Canvas, class UMaterialInterface* Material, const struct FVector2D& RelativeLocation, const struct FVector2D& Size, const float& CanvasWorldSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicEnvironmentZoneComponent", "DrawMaterialToCanvas");

	Params::DynamicEnvironmentZoneComponent_DrawMaterialToCanvas Parms{};

	Parms.Canvas = Canvas;
	Parms.Material = Material;
	Parms.RelativeLocation = std::move(RelativeLocation);
	Parms.Size = std::move(Size);
	Parms.CanvasWorldSize = CanvasWorldSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicEnvironmentZoneComponent.OnSwitchPlayerCharacter
// (Final, Native, Protected)
// Parameters:
// class AOFPlayerCharacter*               Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicEnvironmentZoneComponent::OnSwitchPlayerCharacter(const class AOFPlayerCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicEnvironmentZoneComponent", "OnSwitchPlayerCharacter");

	Params::DynamicEnvironmentZoneComponent_OnSwitchPlayerCharacter Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicEnvironmentZoneComponent.SetTerrainType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ETerrainMaterialType                    NewTerrainType                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicEnvironmentZoneComponent::SetTerrainType(const ETerrainMaterialType NewTerrainType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicEnvironmentZoneComponent", "SetTerrainType");

	Params::DynamicEnvironmentZoneComponent_SetTerrainType Parms{};

	Parms.NewTerrainType = NewTerrainType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicEnvironmentZoneComponent.UpdateInteractionLayerRenderTargets
// (Native, Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInteractionLayer                InteractionLayer                                       (Parm, OutParm, NativeAccessSpecifierPublic)

void UDynamicEnvironmentZoneComponent::UpdateInteractionLayerRenderTargets(float DeltaTime, struct FInteractionLayer* InteractionLayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicEnvironmentZoneComponent", "UpdateInteractionLayerRenderTargets");

	Params::DynamicEnvironmentZoneComponent_UpdateInteractionLayerRenderTargets Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InteractionLayer != nullptr)
		*InteractionLayer = std::move(Parms.InteractionLayer);
}


// Function ObsidianFox.DynamicEnvironmentZoneComponent.GetTerrainType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ETerrainMaterialType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETerrainMaterialType UDynamicEnvironmentZoneComponent::GetTerrainType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicEnvironmentZoneComponent", "GetTerrainType");

	Params::DynamicEnvironmentZoneComponent_GetTerrainType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_Abilities.AddLooseGameplayTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AObsidianFoxCharacter*            InOFCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InGameplayTag                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBFL_Abilities::AddLooseGameplayTag(class AObsidianFoxCharacter* InOFCharacter, const struct FGameplayTag& InGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Abilities", "AddLooseGameplayTag");

	Params::OFBFL_Abilities_AddLooseGameplayTag Parms{};

	Parms.InOFCharacter = InOFCharacter;
	Parms.InGameplayTag = std::move(InGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBFL_Abilities.GetPlayerAbilitySystemComponent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayAbilityActorInfo        ActorInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilitySystemComponent* UOFBFL_Abilities::GetPlayerAbilitySystemComponent(const struct FGameplayAbilityActorInfo& ActorInfo, const int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Abilities", "GetPlayerAbilitySystemComponent");

	Params::OFBFL_Abilities_GetPlayerAbilitySystemComponent Parms{};

	Parms.ActorInfo = std::move(ActorInfo);
	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_Abilities.HandleWeakPoints
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AOFEnemyCharacter*                EnemyCharacter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     ContextHandle                                          (ConstParm, Parm, NativeAccessSpecifierPublic)
// float                                   WeakPointDamage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            SourceTags                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOFBFL_Abilities::HandleWeakPoints(class AOFEnemyCharacter* EnemyCharacter, const struct FGameplayEffectContextHandle& ContextHandle, float WeakPointDamage, const struct FGameplayTagContainer& SourceTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Abilities", "HandleWeakPoints");

	Params::OFBFL_Abilities_HandleWeakPoints Parms{};

	Parms.EnemyCharacter = EnemyCharacter;
	Parms.ContextHandle = std::move(ContextHandle);
	Parms.WeakPointDamage = WeakPointDamage;
	Parms.SourceTags = std::move(SourceTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBFL_Abilities.RemoveLooseGameplayTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AObsidianFoxCharacter*            InOFCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InGameplayTag                                          (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBFL_Abilities::RemoveLooseGameplayTag(class AObsidianFoxCharacter* InOFCharacter, const struct FGameplayTag& InGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Abilities", "RemoveLooseGameplayTag");

	Params::OFBFL_Abilities_RemoveLooseGameplayTag Parms{};

	Parms.InOFCharacter = InOFCharacter;
	Parms.InGameplayTag = std::move(InGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicMaterialEffectsComponent.ChangeMaterialParameterOverTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ChangeDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicMaterialEffectsComponent::ChangeMaterialParameterOverTime(class FName Name_0, float TargetValue, float ChangeDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMaterialEffectsComponent", "ChangeMaterialParameterOverTime");

	Params::DynamicMaterialEffectsComponent_ChangeMaterialParameterOverTime Parms{};

	Parms.Name_0 = Name_0;
	Parms.TargetValue = TargetValue;
	Parms.ChangeDuration = ChangeDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicMaterialEffectsComponent.InitializeDynamicMaterials
// (Final, Native, Public, BlueprintCallable)

void UDynamicMaterialEffectsComponent::InitializeDynamicMaterials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMaterialEffectsComponent", "InitializeDynamicMaterials");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicMaterialEffectsComponent.InterpScalarParameterOnMaterials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMaterialParameterInfo           ParameterInfo                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ChangeDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicMaterialEffectsComponent::InterpScalarParameterOnMaterials(const struct FMaterialParameterInfo& ParameterInfo, float TargetValue, float ChangeDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMaterialEffectsComponent", "InterpScalarParameterOnMaterials");

	Params::DynamicMaterialEffectsComponent_InterpScalarParameterOnMaterials Parms{};

	Parms.ParameterInfo = std::move(ParameterInfo);
	Parms.TargetValue = TargetValue;
	Parms.ChangeDuration = ChangeDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicMaterialEffectsComponent.SetParameterOnMaterials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicMaterialEffectsComponent::SetParameterOnMaterials(class FName Name_0, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMaterialEffectsComponent", "SetParameterOnMaterials");

	Params::DynamicMaterialEffectsComponent_SetParameterOnMaterials Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicMaterialEffectsComponent.SetScalarParameterOnMaterials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMaterialParameterInfo           ParameterInfo                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicMaterialEffectsComponent::SetScalarParameterOnMaterials(const struct FMaterialParameterInfo& ParameterInfo, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMaterialEffectsComponent", "SetScalarParameterOnMaterials");

	Params::DynamicMaterialEffectsComponent_SetScalarParameterOnMaterials Parms{};

	Parms.ParameterInfo = std::move(ParameterInfo);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicMaterialEffectsComponent.SetVectorParameterOnMaterial
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicMaterialEffectsComponent::SetVectorParameterOnMaterial(class FName Name_0, const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMaterialEffectsComponent", "SetVectorParameterOnMaterial");

	Params::DynamicMaterialEffectsComponent_SetVectorParameterOnMaterial Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicMaterialEffectsComponent.SetVectorParameterOnMaterials
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FMaterialParameterInfo           ParameterInfo                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicMaterialEffectsComponent::SetVectorParameterOnMaterials(const struct FMaterialParameterInfo& ParameterInfo, const struct FLinearColor& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMaterialEffectsComponent", "SetVectorParameterOnMaterials");

	Params::DynamicMaterialEffectsComponent_SetVectorParameterOnMaterials Parms{};

	Parms.ParameterInfo = std::move(ParameterInfo);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicMaterialEffectsComponent.StopChangesToParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicMaterialEffectsComponent::StopChangesToParameter(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMaterialEffectsComponent", "StopChangesToParameter");

	Params::DynamicMaterialEffectsComponent_StopChangesToParameter Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicMaterialEffectsComponent.StopParameterInterpolation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMaterialParameterInfo           ParameterInfo                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicMaterialEffectsComponent::StopParameterInterpolation(const struct FMaterialParameterInfo& ParameterInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicMaterialEffectsComponent", "StopParameterInterpolation");

	Params::DynamicMaterialEffectsComponent_StopParameterInterpolation Parms{};

	Parms.ParameterInfo = std::move(ParameterInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicVectorFieldManager.AddBurstForceToVectorField
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ForceCenter                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDynamicVectorFieldManager::AddBurstForceToVectorField(const struct FVector& ForceCenter, float Strength, float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicVectorFieldManager", "AddBurstForceToVectorField");

	Params::DynamicVectorFieldManager_AddBurstForceToVectorField Parms{};

	Parms.ForceCenter = std::move(ForceCenter);
	Parms.Strength = Strength;
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DynamicVectorFieldManager.GetIsSystemEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDynamicVectorFieldManager::GetIsSystemEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicVectorFieldManager", "GetIsSystemEnabled");

	Params::DynamicVectorFieldManager_GetIsSystemEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DynamicVectorFieldManager.GetVectorField
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FVector>            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FVector> UDynamicVectorFieldManager::GetVectorField() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicVectorFieldManager", "GetVectorField");

	Params::DynamicVectorFieldManager_GetVectorField Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EmoteComponent.AddRandomDecoratorToParameter
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEmoteMontageDataParameter       Parameter                                              (Parm, NativeAccessSpecifierPublic)
// struct FEmoteMontageDataParameter       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEmoteMontageDataParameter UEmoteComponent::AddRandomDecoratorToParameter(const struct FEmoteMontageDataParameter& Parameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EmoteComponent", "AddRandomDecoratorToParameter");

	Params::EmoteComponent_AddRandomDecoratorToParameter Parms{};

	Parms.Parameter = std::move(Parameter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EmoteComponent.AddSectionDecoratorToParameter
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FEmoteMontageDataParameter       Parameter                                              (Parm, NativeAccessSpecifierPublic)
// class FName                             Section                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEmoteMontageDataParameter       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEmoteMontageDataParameter UEmoteComponent::AddSectionDecoratorToParameter(const struct FEmoteMontageDataParameter& Parameter, class FName Section)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EmoteComponent", "AddSectionDecoratorToParameter");

	Params::EmoteComponent_AddSectionDecoratorToParameter Parms{};

	Parms.Parameter = std::move(Parameter);
	Parms.Section = Section;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EmoteComponent.MakeListEmoteMontageData
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UAnimMontage*>             Montages                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FEmoteMontageDataParameter       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEmoteMontageDataParameter UEmoteComponent::MakeListEmoteMontageData(const TArray<class UAnimMontage*>& Montages)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EmoteComponent", "MakeListEmoteMontageData");

	Params::EmoteComponent_MakeListEmoteMontageData Parms{};

	Parms.Montages = std::move(Montages);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EmoteComponent.MakeSingleEmoteMontageData
// (Final, Native, Static, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEmoteMontageDataParameter       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEmoteMontageDataParameter UEmoteComponent::MakeSingleEmoteMontageData(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EmoteComponent", "MakeSingleEmoteMontageData");

	Params::EmoteComponent_MakeSingleEmoteMontageData Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EmoteComponent.EmoteDone
// (Native, Public, BlueprintCallable)

void UEmoteComponent::EmoteDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteComponent", "EmoteDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EmoteComponent.GetEmote
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FEmotePlayData                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEmotePlayData UEmoteComponent::GetEmote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteComponent", "GetEmote");

	Params::EmoteComponent_GetEmote Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EmoteComponent.GetEmoteShouldOnlyPlayWhenIdle
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEmoteComponent::GetEmoteShouldOnlyPlayWhenIdle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteComponent", "GetEmoteShouldOnlyPlayWhenIdle");

	Params::EmoteComponent_GetEmoteShouldOnlyPlayWhenIdle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EmoteComponent.OnEmoteDone
// (Final, Native, Protected)

void UEmoteComponent::OnEmoteDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteComponent", "OnEmoteDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EmoteComponent.OnMontageBlendingOut
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmoteComponent::OnMontageBlendingOut(class UAnimMontage* AnimMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteComponent", "OnMontageBlendingOut");

	Params::EmoteComponent_OnMontageBlendingOut Parms{};

	Parms.AnimMontage = AnimMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EmoteComponent.OnOwnerCinematicModeChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    NewCinematicMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmoteComponent::OnOwnerCinematicModeChanged(bool NewCinematicMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteComponent", "OnOwnerCinematicModeChanged");

	Params::EmoteComponent_OnOwnerCinematicModeChanged Parms{};

	Parms.NewCinematicMode = NewCinematicMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EmoteComponent.PlayRandomEmoteFromMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmoteComponent::PlayRandomEmoteFromMontage(class UAnimMontage* AnimMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteComponent", "PlayRandomEmoteFromMontage");

	Params::EmoteComponent_PlayRandomEmoteFromMontage Parms{};

	Parms.AnimMontage = AnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EmoteComponent.PlayRandomEmoteMontageFromList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UAnimMontage*>             AnimMontages                                           (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bPickRandomSection                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmoteComponent::PlayRandomEmoteMontageFromList(const TArray<class UAnimMontage*>& AnimMontages, bool bPickRandomSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteComponent", "PlayRandomEmoteMontageFromList");

	Params::EmoteComponent_PlayRandomEmoteMontageFromList Parms{};

	Parms.AnimMontages = std::move(AnimMontages);
	Parms.bPickRandomSection = bPickRandomSection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EmoteComponent.SetDisabled
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEmoteComponent::SetDisabled(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmoteComponent", "SetDisabled");

	Params::EmoteComponent_SetDisabled Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SubtitleTextWidget.OnSubtitleDoneHandler
// (Final, Native, Private)

void USubtitleTextWidget::OnSubtitleDoneHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitleTextWidget", "OnSubtitleDoneHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SubtitleTextWidget.OnSubtitleSizeChanged
// (Final, Native, Private)
// Parameters:
// ESubtitleSizes                          NewSubtitleSize                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USubtitleTextWidget::OnSubtitleSizeChanged(ESubtitleSizes NewSubtitleSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitleTextWidget", "OnSubtitleSizeChanged");

	Params::SubtitleTextWidget_OnSubtitleSizeChanged Parms{};

	Parms.NewSubtitleSize = NewSubtitleSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.LocationTrackingVolume.ComponentBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALocationTrackingVolume::ComponentBeginOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTrackingVolume", "ComponentBeginOverlap");

	Params::LocationTrackingVolume_ComponentBeginOverlap Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.LocationTrackingVolume.ComponentEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALocationTrackingVolume::ComponentEndOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTrackingVolume", "ComponentEndOverlap");

	Params::LocationTrackingVolume_ComponentEndOverlap Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EnemeyHealthBarHud.FadeBar50Percent
// (Event, Public, BlueprintEvent)

void UEnemeyHealthBarHud::FadeBar50Percent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemeyHealthBarHud", "FadeBar50Percent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.EnemeyHealthBarHud.FadeIn
// (Event, Public, BlueprintEvent)

void UEnemeyHealthBarHud::FadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemeyHealthBarHud", "FadeIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.EnemeyHealthBarHud.FadeIn50pPercent
// (Event, Public, BlueprintEvent)

void UEnemeyHealthBarHud::FadeIn50pPercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemeyHealthBarHud", "FadeIn50pPercent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.EnemeyHealthBarHud.FadeOut
// (Event, Public, BlueprintEvent)

void UEnemeyHealthBarHud::FadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemeyHealthBarHud", "FadeOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.EnemeyHealthBarHud.UpdateHealthBar
// (Event, Public, BlueprintEvent)

void UEnemeyHealthBarHud::UpdateHealthBar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemeyHealthBarHud", "UpdateHealthBar");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.WorldSubsystem_MusicPlayer.NewMusic
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UFMODEvent>        Music                                                  (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldSubsystem_MusicPlayer::NewMusic(const TSoftObjectPtr<class UFMODEvent> Music)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldSubsystem_MusicPlayer", "NewMusic");

	Params::WorldSubsystem_MusicPlayer_NewMusic Parms{};

	Parms.Music = Music;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WorldSubsystem_MusicPlayer.PauseMusic
// (Final, Native, Public, BlueprintCallable)

void UWorldSubsystem_MusicPlayer::PauseMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldSubsystem_MusicPlayer", "PauseMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WorldSubsystem_MusicPlayer.PlayerIsInCombat
// (Final, Native, Private)
// Parameters:
// bool                                    bInCombat                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldSubsystem_MusicPlayer::PlayerIsInCombat(const bool bInCombat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldSubsystem_MusicPlayer", "PlayerIsInCombat");

	Params::WorldSubsystem_MusicPlayer_PlayerIsInCombat Parms{};

	Parms.bInCombat = bInCombat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WorldSubsystem_MusicPlayer.ResumeMusic
// (Final, Native, Public, BlueprintCallable)

void UWorldSubsystem_MusicPlayer::ResumeMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldSubsystem_MusicPlayer", "ResumeMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WorldSubsystem_MusicPlayer.SetParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ParamterName                                           (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ParamterValue                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldSubsystem_MusicPlayer::SetParameter(const class FString& ParamterName, const float ParamterValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldSubsystem_MusicPlayer", "SetParameter");

	Params::WorldSubsystem_MusicPlayer_SetParameter Parms{};

	Parms.ParamterName = std::move(ParamterName);
	Parms.ParamterValue = ParamterValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WorldSubsystem_MusicPlayer.StopMusic
// (Final, Native, Public, BlueprintCallable)

void UWorldSubsystem_MusicPlayer::StopMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldSubsystem_MusicPlayer", "StopMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EnemiesWithinRangeComponent.GetEnemiesWithinDistance
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// float                                   Distance                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AOFEnemyCharacter*>        OutList                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UEnemiesWithinRangeComponent::GetEnemiesWithinDistance(const float Distance, TArray<class AOFEnemyCharacter*>* OutList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemiesWithinRangeComponent", "GetEnemiesWithinDistance");

	Params::EnemiesWithinRangeComponent_GetEnemiesWithinDistance Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutList != nullptr)
		*OutList = std::move(Parms.OutList);
}


// DelegateFunction ObsidianFox.EnemiesWithinRangeComponent.OnCombatStatusChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bEnterCombat                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnemiesWithinRangeComponent::OnCombatStatusChanged__DelegateSignature(bool bEnterCombat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemiesWithinRangeComponent", "OnCombatStatusChanged__DelegateSignature");

	Params::EnemiesWithinRangeComponent_OnCombatStatusChanged__DelegateSignature Parms{};

	Parms.bEnterCombat = bEnterCombat;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.EnemiesWithinRangeComponent.GetClosestEnemyCharacterWithinCombatRange
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AOFEnemyCharacter*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOFEnemyCharacter* UEnemiesWithinRangeComponent::GetClosestEnemyCharacterWithinCombatRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemiesWithinRangeComponent", "GetClosestEnemyCharacterWithinCombatRange");

	Params::EnemiesWithinRangeComponent_GetClosestEnemyCharacterWithinCombatRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EnemiesWithinRangeComponent.GetEnemiesWithinCombatRange
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class AOFEnemyCharacter*>  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<class AOFEnemyCharacter*> UEnemiesWithinRangeComponent::GetEnemiesWithinCombatRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemiesWithinRangeComponent", "GetEnemiesWithinCombatRange");

	Params::EnemiesWithinRangeComponent_GetEnemiesWithinCombatRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EnemyAnimInterface.EndEnemyIntro
// (Event, Public, BlueprintCallable, BlueprintEvent)

void IEnemyAnimInterface::EndEnemyIntro()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAnimInterface", "EndEnemyIntro");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.EnemyAnimInterface.SkipSpawnAnimation
// (Event, Public, BlueprintCallable, BlueprintEvent)

void IEnemyAnimInterface::SkipSpawnAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAnimInterface", "SkipSpawnAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.EnemyAnimInterface.StartEnemyIntro
// (Event, Public, BlueprintCallable, BlueprintEvent)

void IEnemyAnimInterface::StartEnemyIntro()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemyAnimInterface", "StartEnemyIntro");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.EnemySpawner.DespawnManually
// (Final, Native, Public, BlueprintCallable)

void AEnemySpawner::DespawnManually()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "DespawnManually");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.EnemySpawner.OnSpawnCompleted__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AOFEnemyCharacter*                SpawnedEnemy_0                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAIController*                    SpawnedAICOntroller                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEnemySpawner*                    Spawner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEnemySpawner::OnSpawnCompleted__DelegateSignature(class AOFEnemyCharacter* SpawnedEnemy_0, class AAIController* SpawnedAICOntroller, class AEnemySpawner* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "OnSpawnCompleted__DelegateSignature");

	Params::EnemySpawner_OnSpawnCompleted__DelegateSignature Parms{};

	Parms.SpawnedEnemy_0 = SpawnedEnemy_0;
	Parms.SpawnedAICOntroller = SpawnedAICOntroller;
	Parms.Spawner = Spawner;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.EnemySpawner.SpawnEnemy
// (Event, Public, BlueprintEvent)

void AEnemySpawner::SpawnEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "SpawnEnemy");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.EnemySpawner.SpawnManually
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOFEnemyCharacter*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOFEnemyCharacter* AEnemySpawner::SpawnManually()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "SpawnManually");

	Params::EnemySpawner_SpawnManually Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EnemySpawner.GetSpawnTransform
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform AEnemySpawner::GetSpawnTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnemySpawner", "GetSpawnTransform");

	Params::EnemySpawner_GetSpawnTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.WeaponAnimationDataAsset.GetAnimationDataForCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AOFPlayerCharacter*               Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnsureAnimationsAreLoaded                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeaponAnimationData             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FWeaponAnimationData UWeaponAnimationDataAsset::GetAnimationDataForCharacter(const class AOFPlayerCharacter* Character, bool bEnsureAnimationsAreLoaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationDataAsset", "GetAnimationDataForCharacter");

	Params::WeaponAnimationDataAsset_GetAnimationDataForCharacter Parms{};

	Parms.Character = Character;
	Parms.bEnsureAnimationsAreLoaded = bEnsureAnimationsAreLoaded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EnvironmentGameSubSystem.CharacterInWater
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AObsidianFoxCharacter*            Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentGameSubSystem::CharacterInWater(const class AObsidianFoxCharacter* Character, float Percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentGameSubSystem", "CharacterInWater");

	Params::EnvironmentGameSubSystem_CharacterInWater Parms{};

	Parms.Character = Character;
	Parms.Percentage = Percentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EnvironmentGameSubSystem.CharacterNotInWater
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AObsidianFoxCharacter*            Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentGameSubSystem::CharacterNotInWater(const class AObsidianFoxCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentGameSubSystem", "CharacterNotInWater");

	Params::EnvironmentGameSubSystem_CharacterNotInWater Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EnvironmentGameSubSystem.SetMaterialParamterCollection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialParameterCollection*     NewMaterialCollection                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentGameSubSystem::SetMaterialParamterCollection(class UMaterialParameterCollection* NewMaterialCollection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentGameSubSystem", "SetMaterialParamterCollection");

	Params::EnvironmentGameSubSystem_SetMaterialParamterCollection Parms{};

	Parms.NewMaterialCollection = NewMaterialCollection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EnvironmentGameSubSystem.SetNiagaraParamterCollection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNiagaraParameterCollectionInstance*NewNiagaraCollection                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentGameSubSystem::SetNiagaraParamterCollection(class UNiagaraParameterCollectionInstance* NewNiagaraCollection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentGameSubSystem", "SetNiagaraParamterCollection");

	Params::EnvironmentGameSubSystem_SetNiagaraParamterCollection Parms{};

	Parms.NewNiagaraCollection = NewNiagaraCollection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EnvironmentGameSubSystem.GetDegreeCelsius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEnvironmentGameSubSystem::GetDegreeCelsius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentGameSubSystem", "GetDegreeCelsius");

	Params::EnvironmentGameSubSystem_GetDegreeCelsius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EnvironmentGameSubSystem.GetWeatherStruct
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEnvironmentStruct               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEnvironmentStruct UEnvironmentGameSubSystem::GetWeatherStruct() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentGameSubSystem", "GetWeatherStruct");

	Params::EnvironmentGameSubSystem_GetWeatherStruct Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EnvironmentGameSubSystem.GetWeatherTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UEnvironmentGameSubSystem::GetWeatherTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentGameSubSystem", "GetWeatherTag");

	Params::EnvironmentGameSubSystem_GetWeatherTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EnvironmentGameSubSystem.GetWindSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEnvironmentGameSubSystem::GetWindSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentGameSubSystem", "GetWindSpeed");

	Params::EnvironmentGameSubSystem_GetWindSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.MapMarkerActorComponent.AddComponentToMap
// (Final, Native, Public, BlueprintCallable)

void UMapMarkerActorComponent::AddComponentToMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapMarkerActorComponent", "AddComponentToMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MapMarkerActorComponent.AddOrUpdateComponent
// (Final, Native, Public, BlueprintCallable)

void UMapMarkerActorComponent::AddOrUpdateComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapMarkerActorComponent", "AddOrUpdateComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MapMarkerActorComponent.CreateMapMarkerUnqiueID
// (Final, Native, Public)

void UMapMarkerActorComponent::CreateMapMarkerUnqiueID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapMarkerActorComponent", "CreateMapMarkerUnqiueID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MapMarkerActorComponent.RemoveFromMap
// (Final, Native, Public, BlueprintCallable)

void UMapMarkerActorComponent::RemoveFromMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapMarkerActorComponent", "RemoveFromMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MapMarkerActorComponent.SetUseRoomMarker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InUseRoomMarker                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapMarkerActorComponent::SetUseRoomMarker(const bool InUseRoomMarker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapMarkerActorComponent", "SetUseRoomMarker");

	Params::MapMarkerActorComponent_SetUseRoomMarker Parms{};

	Parms.InUseRoomMarker = InUseRoomMarker;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MapMarkerActorComponent.UpdateMapData
// (Final, Native, Public, BlueprintCallable)

void UMapMarkerActorComponent::UpdateMapData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapMarkerActorComponent", "UpdateMapData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EnvironmentWorldSubSystem.CharacterInWater
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AObsidianFoxCharacter*            Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentWorldSubSystem::CharacterInWater(const class AObsidianFoxCharacter* Character, float Percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentWorldSubSystem", "CharacterInWater");

	Params::EnvironmentWorldSubSystem_CharacterInWater Parms{};

	Parms.Character = Character;
	Parms.Percentage = Percentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EnvironmentWorldSubSystem.CharacterNotInWater
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AObsidianFoxCharacter*            Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentWorldSubSystem::CharacterNotInWater(const class AObsidianFoxCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentWorldSubSystem", "CharacterNotInWater");

	Params::EnvironmentWorldSubSystem_CharacterNotInWater Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EnvironmentWorldSubSystem.GustEvaluate
// (Final, Native, Private)
// Parameters:
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentWorldSubSystem::GustEvaluate(float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentWorldSubSystem", "GustEvaluate");

	Params::EnvironmentWorldSubSystem_GustEvaluate Parms{};

	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EnvironmentWorldSubSystem.OnWorldBeginTearDown
// (Final, Native, Private)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentWorldSubSystem::OnWorldBeginTearDown(class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentWorldSubSystem", "OnWorldBeginTearDown");

	Params::EnvironmentWorldSubSystem_OnWorldBeginTearDown Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EnvironmentWorldSubSystem.SetMaterialParameterCollection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialParameterCollection*     NewMaterialCollection                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentWorldSubSystem::SetMaterialParameterCollection(class UMaterialParameterCollection* NewMaterialCollection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentWorldSubSystem", "SetMaterialParameterCollection");

	Params::EnvironmentWorldSubSystem_SetMaterialParameterCollection Parms{};

	Parms.NewMaterialCollection = NewMaterialCollection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EnvironmentWorldSubSystem.SetNiagaraParameterCollection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNiagaraParameterCollectionInstance*NewNiagaraCollection                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEnvironmentWorldSubSystem::SetNiagaraParameterCollection(class UNiagaraParameterCollectionInstance* NewNiagaraCollection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentWorldSubSystem", "SetNiagaraParameterCollection");

	Params::EnvironmentWorldSubSystem_SetNiagaraParameterCollection Parms{};

	Parms.NewNiagaraCollection = NewNiagaraCollection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EnvironmentWorldSubSystem.GetDegreeCelsius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEnvironmentWorldSubSystem::GetDegreeCelsius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentWorldSubSystem", "GetDegreeCelsius");

	Params::EnvironmentWorldSubSystem_GetDegreeCelsius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EnvironmentWorldSubSystem.GetEnvironmentSettingAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FEnvironmentStruct               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEnvironmentStruct UEnvironmentWorldSubSystem::GetEnvironmentSettingAtLocation(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentWorldSubSystem", "GetEnvironmentSettingAtLocation");

	Params::EnvironmentWorldSubSystem_GetEnvironmentSettingAtLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EnvironmentWorldSubSystem.GetWeatherStruct
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEnvironmentStruct               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEnvironmentStruct UEnvironmentWorldSubSystem::GetWeatherStruct() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentWorldSubSystem", "GetWeatherStruct");

	Params::EnvironmentWorldSubSystem_GetWeatherStruct Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EnvironmentWorldSubSystem.GetWeatherTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UEnvironmentWorldSubSystem::GetWeatherTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentWorldSubSystem", "GetWeatherTag");

	Params::EnvironmentWorldSubSystem_GetWeatherTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EnvironmentWorldSubSystem.GetWindSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEnvironmentWorldSubSystem::GetWindSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentWorldSubSystem", "GetWindSpeed");

	Params::EnvironmentWorldSubSystem_GetWindSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.LocomotionStateAnimComponent.ForceCombatState
// (Final, Native, Public, BlueprintCallable)

void ULocomotionStateAnimComponent::ForceCombatState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocomotionStateAnimComponent", "ForceCombatState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.LocomotionStateAnimComponent.ReleaseForceCombatState
// (Final, Native, Public, BlueprintCallable)

void ULocomotionStateAnimComponent::ReleaseForceCombatState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocomotionStateAnimComponent", "ReleaseForceCombatState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.LocomotionStateAnimComponent.IsForcedCombatState
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULocomotionStateAnimComponent::IsForcedCombatState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocomotionStateAnimComponent", "IsForcedCombatState");

	Params::LocomotionStateAnimComponent_IsForcedCombatState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.Lever.AttachLeverMesh
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class USceneComponent*                  InParentComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALever::AttachLeverMesh(class USceneComponent* InParentComponent, class FName InSocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lever", "AttachLeverMesh");

	Params::Lever_AttachLeverMesh Parms{};

	Parms.InParentComponent = InParentComponent;
	Parms.InSocketName = InSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.Lever.LeverFinishedDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALever::LeverFinishedDelegate__DelegateSignature(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lever", "LeverFinishedDelegate__DelegateSignature");

	Params::Lever_LeverFinishedDelegate__DelegateSignature Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.Lever.OnFlowBeginInteract
// (Final, Native, Protected)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALever::OnFlowBeginInteract(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lever", "OnFlowBeginInteract");

	Params::Lever_OnFlowBeginInteract Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Lever.OnLeverBeginInteraction
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALever::OnLeverBeginInteraction(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lever", "OnLeverBeginInteraction");

	Params::Lever_OnLeverBeginInteraction Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.Lever.OnLeverMoveDone
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void ALever::OnLeverMoveDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lever", "OnLeverMoveDone");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.Lever.OnMontageDone
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALever::OnMontageDone(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lever", "OnMontageDone");

	Params::Lever_OnMontageDone Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.Lever.OnRepositionDone
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALever::OnRepositionDone(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lever", "OnRepositionDone");

	Params::Lever_OnRepositionDone Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.Lever.StartMontage
// (Event, Protected, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     MontageTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Section                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FIKParameters>            IKParameters                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALever::StartMontage(class ACharacter* InteractingCharacter, const struct FGameplayTag& MontageTag, class FName Section, const TArray<struct FIKParameters>& IKParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lever", "StartMontage");

	Params::Lever_StartMontage Parms{};

	Parms.InteractingCharacter = InteractingCharacter;
	Parms.MontageTag = std::move(MontageTag);
	Parms.Section = Section;
	Parms.IKParameters = std::move(IKParameters);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.Lever.StartMoveLever
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void ALever::StartMoveLever()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lever", "StartMoveLever");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.Lever.StartReposition
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALever::StartReposition(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Lever", "StartReposition");

	Params::Lever_StartReposition Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.MenuInventorySectionHud.FindNewActiveSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   RowNumberToAdd                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ColumnNumberToAdd                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMenuInventorySectionHud::FindNewActiveSlot(int32 RowNumberToAdd, int32 ColumnNumberToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuInventorySectionHud", "FindNewActiveSlot");

	Params::MenuInventorySectionHud_FindNewActiveSlot Parms{};

	Parms.RowNumberToAdd = RowNumberToAdd;
	Parms.ColumnNumberToAdd = ColumnNumberToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MenuInventorySectionHud.SetActiveSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   IndexNumber                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMenuInventorySectionHud::SetActiveSlot(const int32 IndexNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuInventorySectionHud", "SetActiveSlot");

	Params::MenuInventorySectionHud_SetActiveSlot Parms{};

	Parms.IndexNumber = IndexNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MenuInventorySectionHud.GetActiveMenuSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMenuInventorySelectionSlot*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuInventorySelectionSlot* UMenuInventorySectionHud::GetActiveMenuSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuInventorySectionHud", "GetActiveMenuSlot");

	Params::MenuInventorySectionHud_GetActiveMenuSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EquipmentManager.AttachWeaponToEquipmentSocket
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOFWeaponActor*                   Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEquipmentSocket                        SocketLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentManager::AttachWeaponToEquipmentSocket(class AOFWeaponActor* Weapon, EEquipmentSocket SocketLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManager", "AttachWeaponToEquipmentSocket");

	Params::EquipmentManager_AttachWeaponToEquipmentSocket Parms{};

	Parms.Weapon = Weapon;
	Parms.SocketLocation = SocketLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EquipmentManager.DestroyWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOFWeaponActor*                   WeaponActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentManager::DestroyWeapon(class AOFWeaponActor* WeaponActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManager", "DestroyWeapon");

	Params::EquipmentManager_DestroyWeapon Parms{};

	Parms.WeaponActor = WeaponActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EquipmentManager.EquipNext
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEquipmentType                          WeaponType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPrevious                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeaponInfo                      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FWeaponInfo UEquipmentManager::EquipNext(EEquipmentType WeaponType, bool bPrevious)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManager", "EquipNext");

	Params::EquipmentManager_EquipNext Parms{};

	Parms.WeaponType = WeaponType;
	Parms.bPrevious = bPrevious;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EquipmentManager.EquipWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UItemData_Equippable*             ItemData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeaponInfo                      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FWeaponInfo UEquipmentManager::EquipWeapon(class UItemData_Equippable* ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManager", "EquipWeapon");

	Params::EquipmentManager_EquipWeapon Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EquipmentManager.GetSpawnedWeapons
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FWeaponInfo>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FWeaponInfo> UEquipmentManager::GetSpawnedWeapons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManager", "GetSpawnedWeapons");

	Params::EquipmentManager_GetSpawnedWeapons Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EquipmentManager.GetTotalAmmoByAmmo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TMap<class UItemData*, int32>           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class UItemData*, int32> UEquipmentManager::GetTotalAmmoByAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManager", "GetTotalAmmoByAmmo");

	Params::EquipmentManager_GetTotalAmmoByAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EquipmentManager.GetTotalAmmoByWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TMap<class UItemData_Equippable*, int32>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class UItemData_Equippable*, int32> UEquipmentManager::GetTotalAmmoByWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManager", "GetTotalAmmoByWeapon");

	Params::EquipmentManager_GetTotalAmmoByWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EquipmentManager.SetPistolSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UItemData_Equippable*             ItemData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentManager::SetPistolSlot(class UItemData_Equippable* ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManager", "SetPistolSlot");

	Params::EquipmentManager_SetPistolSlot Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.EquipmentManager.WeaponEquipDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FWeaponInfo                      EquippedWeapon                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FWeaponInfo                      UnequippedWeapon                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UEquipmentManager::WeaponEquipDelegate__DelegateSignature(const struct FWeaponInfo& EquippedWeapon, const struct FWeaponInfo& UnequippedWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManager", "WeaponEquipDelegate__DelegateSignature");

	Params::EquipmentManager_WeaponEquipDelegate__DelegateSignature Parms{};

	Parms.EquippedWeapon = std::move(EquippedWeapon);
	Parms.UnequippedWeapon = std::move(UnequippedWeapon);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.EquipmentManager.WeaponSlotUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UItemData_Equippable*             NewWeapon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemData_Equippable*             OldWeapon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentManager::WeaponSlotUpdated__DelegateSignature(class UItemData_Equippable* NewWeapon, class UItemData_Equippable* OldWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManager", "WeaponSlotUpdated__DelegateSignature");

	Params::EquipmentManager_WeaponSlotUpdated__DelegateSignature Parms{};

	Parms.NewWeapon = NewWeapon;
	Parms.OldWeapon = OldWeapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.EquipmentManager.GetAvailableWeapons
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentType                          Equipment                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UItemData_Equippable*>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UItemData_Equippable*> UEquipmentManager::GetAvailableWeapons(EEquipmentType Equipment) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManager", "GetAvailableWeapons");

	Params::EquipmentManager_GetAvailableWeapons Parms{};

	Parms.Equipment = Equipment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EquipmentManager.GetCurrentWeaponActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentType                          WeaponType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOFWeaponActor*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOFWeaponActor* UEquipmentManager::GetCurrentWeaponActor(EEquipmentType WeaponType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManager", "GetCurrentWeaponActor");

	Params::EquipmentManager_GetCurrentWeaponActor Parms{};

	Parms.WeaponType = WeaponType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EquipmentManager.GetCurrentWeaponInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentType                          WeaponType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeaponInfo                      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FWeaponInfo UEquipmentManager::GetCurrentWeaponInfo(EEquipmentType WeaponType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManager", "GetCurrentWeaponInfo");

	Params::EquipmentManager_GetCurrentWeaponInfo Parms{};

	Parms.WeaponType = WeaponType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EquipmentManager.GetMeleeWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AMeleeWeaponActor*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMeleeWeaponActor* UEquipmentManager::GetMeleeWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManager", "GetMeleeWeapon");

	Params::EquipmentManager_GetMeleeWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.EquipmentManager.GetRangedWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AHitscanWeaponActor*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AHitscanWeaponActor* UEquipmentManager::GetRangedWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManager", "GetRangedWeapon");

	Params::EquipmentManager_GetRangedWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.MansionMap.CloseDown
// (Event, Protected, BlueprintEvent)

void UMansionMap::CloseDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MansionMap", "CloseDown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.MansionMap.HighlightPlayerMarker
// (Final, Native, Private)

void UMansionMap::HighlightPlayerMarker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MansionMap", "HighlightPlayerMarker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MansionMap.OnMarkerDataAddedHandler
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FMapData                         MapDataMaker                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMansionMap::OnMarkerDataAddedHandler(const struct FMapData& MapDataMaker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MansionMap", "OnMarkerDataAddedHandler");

	Params::MansionMap_OnMarkerDataAddedHandler Parms{};

	Parms.MapDataMaker = std::move(MapDataMaker);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MansionMap.OnMarkerDataDeletedHandler
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FMapData                         MapDataMaker                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMansionMap::OnMarkerDataDeletedHandler(const struct FMapData& MapDataMaker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MansionMap", "OnMarkerDataDeletedHandler");

	Params::MansionMap_OnMarkerDataDeletedHandler Parms{};

	Parms.MapDataMaker = std::move(MapDataMaker);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MansionMap.OnNewRoomExploredHandler
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     NewRoomTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMansionMap::OnNewRoomExploredHandler(const struct FGameplayTag& NewRoomTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MansionMap", "OnNewRoomExploredHandler");

	Params::MansionMap_OnNewRoomExploredHandler Parms{};

	Parms.NewRoomTag = std::move(NewRoomTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MansionMap.OpenMenuPressedHandler
// (Event, Protected, BlueprintEvent)

void UMansionMap::OpenMenuPressedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MansionMap", "OpenMenuPressedHandler");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.MansionMap.SetupInput
// (Final, Native, Public, BlueprintCallable)

void UMansionMap::SetupInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MansionMap", "SetupInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MansionMap.ShowMapIsOfNoUseWidget
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bShowWidget                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMansionMap::ShowMapIsOfNoUseWidget(bool bShowWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MansionMap", "ShowMapIsOfNoUseWidget");

	Params::MansionMap_ShowMapIsOfNoUseWidget Parms{};

	Parms.bShowWidget = bShowWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.MansionMap.SwitchFloorHandler
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FInputActionValue                InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMansionMap::SwitchFloorHandler(const struct FInputActionValue& InputActionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MansionMap", "SwitchFloorHandler");

	Params::MansionMap_SwitchFloorHandler Parms{};

	Parms.InputActionValue = std::move(InputActionValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EventTrigger.EndEvent
// (Final, Native, Public, BlueprintCallable)

void AEventTrigger::EndEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventTrigger", "EndEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.EventTrigger.EventBegin__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AEventTrigger*                    EventTrigger                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            PlayerPawn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventTrigger::EventBegin__DelegateSignature(class AEventTrigger* EventTrigger, class APawn* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventTrigger", "EventBegin__DelegateSignature");

	Params::EventTrigger_EventBegin__DelegateSignature Parms{};

	Parms.EventTrigger = EventTrigger;
	Parms.PlayerPawn = PlayerPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.EventTrigger.EventEnd__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AEventTrigger*                    EventTrigger                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            PlayerPawn                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventTrigger::EventEnd__DelegateSignature(class AEventTrigger* EventTrigger, class APawn* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventTrigger", "EventEnd__DelegateSignature");

	Params::EventTrigger_EventEnd__DelegateSignature Parms{};

	Parms.EventTrigger = EventTrigger;
	Parms.PlayerPawn = PlayerPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.EventTrigger.K2_StartEvent
// (Event, Protected, BlueprintEvent)

void AEventTrigger::K2_StartEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventTrigger", "K2_StartEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.EventTrigger.NotifyInteractBegin
// (Final, Native, Protected)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventTrigger::NotifyInteractBegin(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventTrigger", "NotifyInteractBegin");

	Params::EventTrigger_NotifyInteractBegin Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EventTrigger.OnMontageEnded
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventTrigger::OnMontageEnded(class UAnimMontage* InMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventTrigger", "OnMontageEnded");

	Params::EventTrigger_OnMontageEnded Parms{};

	Parms.InMontage = InMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.EventTrigger.SetDisabled
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bSetDisabled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEventTrigger::SetDisabled(bool bSetDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventTrigger", "SetDisabled");

	Params::EventTrigger_SetDisabled Parms{};

	Parms.bSetDisabled = bSetDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FaceAnimInterface.ApplyFaceAnimation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Instigator                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFaceAnimInterface::ApplyFaceAnimation(const class UObject* Instigator, class UAnimSequenceBase* Animation, float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FaceAnimInterface", "ApplyFaceAnimation");

	Params::FaceAnimInterface_ApplyFaceAnimation Parms{};

	Parms.Instigator = Instigator;
	Parms.Animation = Animation;
	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FaceAnimInterface.ApplyMouthAnimation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Instigator                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFaceAnimInterface::ApplyMouthAnimation(const class UObject* Instigator, class UAnimSequenceBase* Animation, float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FaceAnimInterface", "ApplyMouthAnimation");

	Params::FaceAnimInterface_ApplyMouthAnimation Parms{};

	Parms.Instigator = Instigator;
	Parms.Animation = Animation;
	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FaceAnimInterface.RemoveFaceAnimation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Instigator                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFaceAnimInterface::RemoveFaceAnimation(const class UObject* Instigator, float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FaceAnimInterface", "RemoveFaceAnimation");

	Params::FaceAnimInterface_RemoveFaceAnimation Parms{};

	Parms.Instigator = Instigator;
	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FaceAnimInterface.RemoveMouthAnimation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Instigator                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFaceAnimInterface::RemoveMouthAnimation(const class UObject* Instigator, float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FaceAnimInterface", "RemoveMouthAnimation");

	Params::FaceAnimInterface_RemoveMouthAnimation Parms{};

	Parms.Instigator = Instigator;
	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FireSpreadComponent.StartFireAtLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFireSpreadComponent::StartFireAtLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireSpreadComponent", "StartFireAtLocation");

	Params::FireSpreadComponent_StartFireAtLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FlammableInterface.SimpleIgnite
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IFlammableInterface::SimpleIgnite(class APawn* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlammableInterface", "SimpleIgnite");

	Params::FlammableInterface_SimpleIgnite Parms{};

	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveComponent.AddNotes
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             NewNote                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UObjectivesData*                  ObjectivesData                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveComponent::AddNotes(const class FText& NewNote, const class UObjectivesData* ObjectivesData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveComponent", "AddNotes");

	Params::ObjectiveComponent_AddNotes Parms{};

	Parms.NewNote = std::move(NewNote);
	Parms.ObjectivesData = ObjectivesData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveComponent.CompleteObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObjectivesData*                  Data                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveComponent::CompleteObjective(const class UObjectivesData* Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveComponent", "CompleteObjective");

	Params::ObjectiveComponent_CompleteObjective Parms{};

	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveComponent.CompleteSubObjective
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObjectivesData*                  Data                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectiveParts                         Part                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InObjectiveTag                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveComponent::CompleteSubObjective(const class UObjectivesData* Data, const EObjectiveParts Part, const struct FGameplayTag& InObjectiveTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveComponent", "CompleteSubObjective");

	Params::ObjectiveComponent_CompleteSubObjective Parms{};

	Parms.Data = Data;
	Parms.Part = Part;
	Parms.InObjectiveTag = std::move(InObjectiveTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveComponent.IsObjectiveActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UObjectivesData>   ObjectiveData                                          (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObjectiveComponent::IsObjectiveActive(const TSoftObjectPtr<class UObjectivesData> ObjectiveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveComponent", "IsObjectiveActive");

	Params::ObjectiveComponent_IsObjectiveActive Parms{};

	Parms.ObjectiveData = ObjectiveData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ObjectiveComponent.OnNotePlayed
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FText                             Note                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UObjectivesData*                  ObjectivesData                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveComponent::OnNotePlayed(const class FText& Note, const class UObjectivesData* ObjectivesData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveComponent", "OnNotePlayed");

	Params::ObjectiveComponent_OnNotePlayed Parms{};

	Parms.Note = std::move(Note);
	Parms.ObjectivesData = ObjectivesData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveComponent.ReviewObjectiveHistory
// (Final, Native, Public, BlueprintCallable)

void UObjectiveComponent::ReviewObjectiveHistory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveComponent", "ReviewObjectiveHistory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveComponent.SetObjectiveUnSeen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUnSeen                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObjectivesData>   ObjectiveSoftClassPath                                 (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveComponent::SetObjectiveUnSeen(bool bUnSeen, TSoftObjectPtr<class UObjectivesData> ObjectiveSoftClassPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveComponent", "SetObjectiveUnSeen");

	Params::ObjectiveComponent_SetObjectiveUnSeen Parms{};

	Parms.bUnSeen = bUnSeen;
	Parms.ObjectiveSoftClassPath = ObjectiveSoftClassPath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveComponent.StartNewSubObjective
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObjectivesData*                  Data                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectiveParts                         NewPart                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InObjectiveTag                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveComponent::StartNewSubObjective(const class UObjectivesData* Data, EObjectiveParts NewPart, const struct FGameplayTag& InObjectiveTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveComponent", "StartNewSubObjective");

	Params::ObjectiveComponent_StartNewSubObjective Parms{};

	Parms.Data = Data;
	Parms.NewPart = NewPart;
	Parms.InObjectiveTag = std::move(InObjectiveTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveComponent.StartObjective
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObjectivesData*                  Data                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InObjectiveTag                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectiveParts                         NewPart                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveComponent::StartObjective(const class UObjectivesData* Data, const struct FGameplayTag& InObjectiveTag, const EObjectiveParts NewPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveComponent", "StartObjective");

	Params::ObjectiveComponent_StartObjective Parms{};

	Parms.Data = Data;
	Parms.InObjectiveTag = std::move(InObjectiveTag);
	Parms.NewPart = NewPart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveComponent.TimerNoteDoneHandler
// (Final, Native, Private)

void UObjectiveComponent::TimerNoteDoneHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveComponent", "TimerNoteDoneHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveComponent.UpdateObjective
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObjectivesData*                  Data                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectiveParts                         Part                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InObjectiveTag                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveComponent::UpdateObjective(const class UObjectivesData* Data, EObjectiveParts Part, const struct FGameplayTag& InObjectiveTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveComponent", "UpdateObjective");

	Params::ObjectiveComponent_UpdateObjective Parms{};

	Parms.Data = Data;
	Parms.Part = Part;
	Parms.InObjectiveTag = std::move(InObjectiveTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveComponent.CheckIfWeHaveObjective
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObjectivesData*                  Data                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObjectiveComponent::CheckIfWeHaveObjective(const class UObjectivesData* Data) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveComponent", "CheckIfWeHaveObjective");

	Params::ObjectiveComponent_CheckIfWeHaveObjective Parms{};

	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ObjectiveComponent.GetCurrentObjectives
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TMap<int32, struct FObjectiveChapter>ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TMap<int32, struct FObjectiveChapter> UObjectiveComponent::GetCurrentObjectives() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveComponent", "GetCurrentObjectives");

	Params::ObjectiveComponent_GetCurrentObjectives Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.FlowDoorComponent.OnDoorClosedHandler
// (Final, Native, Private)
// Parameters:
// bool                                    bWasInstantClose                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowDoorComponent::OnDoorClosedHandler(bool bWasInstantClose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowDoorComponent", "OnDoorClosedHandler");

	Params::FlowDoorComponent_OnDoorClosedHandler Parms{};

	Parms.bWasInstantClose = bWasInstantClose;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FlowDoorComponent.OnDoorClosingHandler
// (Final, Native, Private)

void UFlowDoorComponent::OnDoorClosingHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowDoorComponent", "OnDoorClosingHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FlowDoorComponent.OnDoorOpenedHandler
// (Final, Native, Private)

void UFlowDoorComponent::OnDoorOpenedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowDoorComponent", "OnDoorOpenedHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FlowDoorComponent.OnDoorUnlockedHandler
// (Final, Native, Private)

void UFlowDoorComponent::OnDoorUnlockedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowDoorComponent", "OnDoorUnlockedHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FlowDoorComponent.OnInteractingCharacterReachDoorHandleHandler
// (Final, Native, Private)

void UFlowDoorComponent::OnInteractingCharacterReachDoorHandleHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowDoorComponent", "OnInteractingCharacterReachDoorHandleHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FlowDoorComponent.OnStartDoorOpeningHandler
// (Final, Native, Private)

void UFlowDoorComponent::OnStartDoorOpeningHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowDoorComponent", "OnStartDoorOpeningHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFWeaponActor.BeginAttack
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     AttackEvent                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFWeaponActor::BeginAttack(const struct FGameplayTag& AttackEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "BeginAttack");

	Params::OFWeaponActor_BeginAttack Parms{};

	Parms.AttackEvent = std::move(AttackEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFWeaponActor.EndAttack
// (Native, Public, BlueprintCallable)

void AOFWeaponActor::EndAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "EndAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.OFWeaponActor.EquipSignature__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AOFWeaponActor*                   Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFWeaponActor::EquipSignature__DelegateSignature(class AOFWeaponActor* Weapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "EquipSignature__DelegateSignature");

	Params::OFWeaponActor_EquipSignature__DelegateSignature Parms{};

	Parms.Weapon = Weapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OFWeaponActor.GetBlockedSockets
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> AOFWeaponActor::GetBlockedSockets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "GetBlockedSockets");

	Params::OFWeaponActor_GetBlockedSockets Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFWeaponActor.GetMesh
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* AOFWeaponActor::GetMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "GetMesh");

	Params::OFWeaponActor_GetMesh Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFWeaponActor.NotifyWeaponHit
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayEventData               EventData                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void AOFWeaponActor::NotifyWeaponHit(struct FGameplayEventData* EventData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "NotifyWeaponHit");

	Params::OFWeaponActor_NotifyWeaponHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (EventData != nullptr)
		*EventData = std::move(Parms.EventData);
}


// Function ObsidianFox.OFWeaponActor.OnEffectImpact
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitResult                       OutHit                                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOFWeaponActor::OnEffectImpact(const struct FHitResult& OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "OnEffectImpact");

	Params::OFWeaponActor_OnEffectImpact Parms{};

	Parms.OutHit = std::move(OutHit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFWeaponActor.OnInstigatorPossesed
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AController*                      NewController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFWeaponActor::OnInstigatorPossesed(class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "OnInstigatorPossesed");

	Params::OFWeaponActor_OnInstigatorPossesed Parms{};

	Parms.NewController = NewController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFWeaponActor.PlayHitSoundEffect
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UWorld*                           WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FSurfaceHitFX                    HitFX                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AOFWeaponActor::PlayHitSoundEffect(class UWorld* WorldContext, const struct FHitResult& Hit, const struct FSurfaceHitFX& HitFX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "PlayHitSoundEffect");

	Params::OFWeaponActor_PlayHitSoundEffect Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Hit = std::move(Hit);
	Parms.HitFX = std::move(HitFX);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFWeaponActor.SetVisibility
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewVisibility                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFWeaponActor::SetVisibility(bool bNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "SetVisibility");

	Params::OFWeaponActor_SetVisibility Parms{};

	Parms.bNewVisibility = bNewVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFWeaponActor.SpawnHitDecal
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UWorld*                           WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FSurfaceHitFX                    HitFX                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AOFWeaponActor::SpawnHitDecal(class UWorld* WorldContext, const struct FHitResult& Hit, const struct FSurfaceHitFX& HitFX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "SpawnHitDecal");

	Params::OFWeaponActor_SpawnHitDecal Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Hit = std::move(Hit);
	Parms.HitFX = std::move(HitFX);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFWeaponActor.SpawnHitFX
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AOFWeaponActor::SpawnHitFX(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "SpawnHitFX");

	Params::OFWeaponActor_SpawnHitFX Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFWeaponActor.SpawnHitParticleSystem
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UWorld*                           WorldContext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FSurfaceHitFX                    HitFX                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AOFWeaponActor::SpawnHitParticleSystem(class UWorld* WorldContext, const struct FHitResult& Hit, const struct FSurfaceHitFX& HitFX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "SpawnHitParticleSystem");

	Params::OFWeaponActor_SpawnHitParticleSystem Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Hit = std::move(Hit);
	Parms.HitFX = std::move(HitFX);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFWeaponActor.StartLoadingWeaponAnimationsAsync
// (Final, Native, Public, BlueprintCallable)

void AOFWeaponActor::StartLoadingWeaponAnimationsAsync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "StartLoadingWeaponAnimationsAsync");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFWeaponActor.GetAnimations
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWeaponAnimationDataAsset*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWeaponAnimationDataAsset* AOFWeaponActor::GetAnimations() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "GetAnimations");

	Params::OFWeaponActor_GetAnimations Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFWeaponActor.GetHandAnimations
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWeaponAnimationHandDataAsset*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWeaponAnimationHandDataAsset* AOFWeaponActor::GetHandAnimations() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "GetHandAnimations");

	Params::OFWeaponActor_GetHandAnimations Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFWeaponActor.GetWeaponUI
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> AOFWeaponActor::GetWeaponUI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "GetWeaponUI");

	Params::OFWeaponActor_GetWeaponUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFWeaponActor.IsUnholstered
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOFWeaponActor::IsUnholstered() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWeaponActor", "IsUnholstered");

	Params::OFWeaponActor_IsUnholstered Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HitscanWeaponActor.ActivateAimAssist
// (Final, Native, Public, BlueprintCallable)

void AHitscanWeaponActor::ActivateAimAssist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "ActivateAimAssist");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.HitscanWeaponActor.AmmoChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// int32                                   CurrentAmmo_0                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxAmmo_0                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHitscanWeaponActor::AmmoChanged__DelegateSignature(int32 CurrentAmmo_0, int32 MaxAmmo_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "AmmoChanged__DelegateSignature");

	Params::HitscanWeaponActor_AmmoChanged__DelegateSignature Parms{};

	Parms.CurrentAmmo_0 = CurrentAmmo_0;
	Parms.MaxAmmo_0 = MaxAmmo_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.HitscanWeaponActor.ApplyRecoil
// (Event, Public, BlueprintEvent)

void AHitscanWeaponActor::ApplyRecoil()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "ApplyRecoil");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.HitscanWeaponActor.CanUseAimAssist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHitscanWeaponActor::CanUseAimAssist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "CanUseAimAssist");

	Params::HitscanWeaponActor_CanUseAimAssist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HitscanWeaponActor.DeactivatedAimAssist
// (Final, Native, Public, BlueprintCallable)

void AHitscanWeaponActor::DeactivatedAimAssist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "DeactivatedAimAssist");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HitscanWeaponActor.LoadAmmo
// (Final, Native, Public, BlueprintCallable)

void AHitscanWeaponActor::LoadAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "LoadAmmo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HitscanWeaponActor.OnEffectFire
// (Native, Event, Public, BlueprintEvent)

void AHitscanWeaponActor::OnEffectFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "OnEffectFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.HitscanWeaponActor.OnFire__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void AHitscanWeaponActor::OnFire__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "OnFire__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction ObsidianFox.HitscanWeaponActor.OnFireFailed__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class AActor*                           ImmuneActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHitscanWeaponActor::OnFireFailed__DelegateSignature(class AActor* ImmuneActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "OnFireFailed__DelegateSignature");

	Params::HitscanWeaponActor_OnFireFailed__DelegateSignature Parms{};

	Parms.ImmuneActor = ImmuneActor;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.HitscanWeaponActor.OnWeaponHit__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FGameplayEventData               EventPayload                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AHitscanWeaponActor::OnWeaponHit__DelegateSignature(const struct FGameplayEventData& EventPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "OnWeaponHit__DelegateSignature");

	Params::HitscanWeaponActor_OnWeaponHit__DelegateSignature Parms{};

	Parms.EventPayload = std::move(EventPayload);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.HitscanWeaponActor.SetCurrentAmmo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHitscanWeaponActor::SetCurrentAmmo(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "SetCurrentAmmo");

	Params::HitscanWeaponActor_SetCurrentAmmo Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HitscanWeaponActor.SetMaxAmmo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHitscanWeaponActor::SetMaxAmmo(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "SetMaxAmmo");

	Params::HitscanWeaponActor_SetMaxAmmo Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HitscanWeaponActor.SetUseAimAssist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHitscanWeaponActor::SetUseAimAssist(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "SetUseAimAssist");

	Params::HitscanWeaponActor_SetUseAimAssist Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HitscanWeaponActor.TriggerWeaponShootVFX
// (Native, Event, Protected, BlueprintEvent)

void AHitscanWeaponActor::TriggerWeaponShootVFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "TriggerWeaponShootVFX");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HitscanWeaponActor.AnyAmmoLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHitscanWeaponActor::AnyAmmoLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "AnyAmmoLeft");

	Params::HitscanWeaponActor_AnyAmmoLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HitscanWeaponActor.CanReload
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHitscanWeaponActor::CanReload() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "CanReload");

	Params::HitscanWeaponActor_CanReload Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HitscanWeaponActor.GetAimTriggerEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UControllerTriggerEffectData*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UControllerTriggerEffectData* AHitscanWeaponActor::GetAimTriggerEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "GetAimTriggerEffect");

	Params::HitscanWeaponActor_GetAimTriggerEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HitscanWeaponActor.GetCurrentAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AHitscanWeaponActor::GetCurrentAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "GetCurrentAmmo");

	Params::HitscanWeaponActor_GetCurrentAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HitscanWeaponActor.GetMaxAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AHitscanWeaponActor::GetMaxAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "GetMaxAmmo");

	Params::HitscanWeaponActor_GetMaxAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HitscanWeaponActor.GetShootTriggerEffect
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UControllerTriggerEffectData*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UControllerTriggerEffectData* AHitscanWeaponActor::GetShootTriggerEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "GetShootTriggerEffect");

	Params::HitscanWeaponActor_GetShootTriggerEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HitscanWeaponActor.GetTraceEnd
// (Native, Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AHitscanWeaponActor::GetTraceEnd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "GetTraceEnd");

	Params::HitscanWeaponActor_GetTraceEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HitscanWeaponActor.GetTraceStart
// (Native, Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AHitscanWeaponActor::GetTraceStart() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "GetTraceStart");

	Params::HitscanWeaponActor_GetTraceStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HitscanWeaponActor.IsFullyLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHitscanWeaponActor::IsFullyLoaded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "IsFullyLoaded");

	Params::HitscanWeaponActor_IsFullyLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HitscanWeaponActor.TraceForTarget
// (Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// TArray<struct FHitResult>               OutHit                                                 (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AHitscanWeaponActor::TraceForTarget(TArray<struct FHitResult>* OutHit) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitscanWeaponActor", "TraceForTarget");

	Params::HitscanWeaponActor_TraceForTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function ObsidianFox.HitMeshDecal.SetDecalMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHitMeshDecal::SetDecalMaterial(class UMaterialInterface* Material)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitMeshDecal", "SetDecalMaterial");

	Params::HitMeshDecal_SetDecalMaterial Parms{};

	Parms.Material = Material;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.NestActor.PickNewNestLocation
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ANestLocationActor*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANestLocationActor* ANestActor::PickNewNestLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NestActor", "PickNewNestLocation");

	Params::NestActor_PickNewNestLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.NestActor.GetCurrentNestLocation
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ANestLocationActor*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ANestLocationActor* ANestActor::GetCurrentNestLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NestActor", "GetCurrentNestLocation");

	Params::NestActor_GetCurrentNestLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.FlowNode_EventCollectible.Callback
// (Final, Native, Protected)

void UFlowNode_EventCollectible::Callback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_EventCollectible", "Callback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FlowNode_EventDoor.OnDoorClosedEventHandler
// (Final, Native, Private)
// Parameters:
// class UFlowDoorComponent*               FlowDoorComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowNode_EventDoor::OnDoorClosedEventHandler(class UFlowDoorComponent* FlowDoorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_EventDoor", "OnDoorClosedEventHandler");

	Params::FlowNode_EventDoor_OnDoorClosedEventHandler Parms{};

	Parms.FlowDoorComponent = FlowDoorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FlowNode_EventDoor.OnDoorClosingEventHandler
// (Final, Native, Private)
// Parameters:
// class UFlowDoorComponent*               FlowDoorComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowNode_EventDoor::OnDoorClosingEventHandler(class UFlowDoorComponent* FlowDoorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_EventDoor", "OnDoorClosingEventHandler");

	Params::FlowNode_EventDoor_OnDoorClosingEventHandler Parms{};

	Parms.FlowDoorComponent = FlowDoorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FlowNode_EventDoor.OnDoorOpenedEventHandler
// (Final, Native, Private)
// Parameters:
// class UFlowDoorComponent*               FlowDoorComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowNode_EventDoor::OnDoorOpenedEventHandler(class UFlowDoorComponent* FlowDoorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_EventDoor", "OnDoorOpenedEventHandler");

	Params::FlowNode_EventDoor_OnDoorOpenedEventHandler Parms{};

	Parms.FlowDoorComponent = FlowDoorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FlowNode_EventDoor.OnDoorUnlockedEventHandler
// (Final, Native, Private)
// Parameters:
// class UFlowDoorComponent*               FlowDoorComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowNode_EventDoor::OnDoorUnlockedEventHandler(class UFlowDoorComponent* FlowDoorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_EventDoor", "OnDoorUnlockedEventHandler");

	Params::FlowNode_EventDoor_OnDoorUnlockedEventHandler Parms{};

	Parms.FlowDoorComponent = FlowDoorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FlowNode_EventDoor.OnInteractingCharacterReachDoorHandleHandler
// (Final, Native, Private)
// Parameters:
// class UFlowDoorComponent*               FlowDoorComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowNode_EventDoor::OnInteractingCharacterReachDoorHandleHandler(class UFlowDoorComponent* FlowDoorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_EventDoor", "OnInteractingCharacterReachDoorHandleHandler");

	Params::FlowNode_EventDoor_OnInteractingCharacterReachDoorHandleHandler Parms{};

	Parms.FlowDoorComponent = FlowDoorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FlowNode_EventDoor.OnStartDoorOpeningEventHandler
// (Final, Native, Private)
// Parameters:
// class UFlowDoorComponent*               FlowDoorComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowNode_EventDoor::OnStartDoorOpeningEventHandler(class UFlowDoorComponent* FlowDoorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_EventDoor", "OnStartDoorOpeningEventHandler");

	Params::FlowNode_EventDoor_OnStartDoorOpeningEventHandler Parms{};

	Parms.FlowDoorComponent = FlowDoorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAbilitySystemBlueprintLibrary.AddTargetDataToEffectContextHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContextHandle                                    (Parm, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)

void UOFAbilitySystemBlueprintLibrary::AddTargetDataToEffectContextHandle(const struct FGameplayEffectContextHandle& EffectContextHandle, const struct FGameplayAbilityTargetDataHandle& TargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAbilitySystemBlueprintLibrary", "AddTargetDataToEffectContextHandle");

	Params::OFAbilitySystemBlueprintLibrary_AddTargetDataToEffectContextHandle Parms{};

	Parms.EffectContextHandle = std::move(EffectContextHandle);
	Parms.TargetData = std::move(TargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAbilitySystemBlueprintLibrary.CanActivateAbilityByTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            GameplayTagContainer                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bAllowRemoteActivation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFAbilitySystemBlueprintLibrary::CanActivateAbilityByTag(class APawn* Target, const struct FGameplayTagContainer& GameplayTagContainer, bool bAllowRemoteActivation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAbilitySystemBlueprintLibrary", "CanActivateAbilityByTag");

	Params::OFAbilitySystemBlueprintLibrary_CanActivateAbilityByTag Parms{};

	Parms.Target = Target;
	Parms.GameplayTagContainer = std::move(GameplayTagContainer);
	Parms.bAllowRemoteActivation = bAllowRemoteActivation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAbilitySystemBlueprintLibrary.EffectContextHandleAddWeakPoint
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContextHandle                                    (Parm, NativeAccessSpecifierPublic)
// class UDamagePoint*                     WeakPoint                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAbilitySystemBlueprintLibrary::EffectContextHandleAddWeakPoint(const struct FGameplayEffectContextHandle& EffectContextHandle, class UDamagePoint* WeakPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAbilitySystemBlueprintLibrary", "EffectContextHandleAddWeakPoint");

	Params::OFAbilitySystemBlueprintLibrary_EffectContextHandleAddWeakPoint Parms{};

	Parms.EffectContextHandle = std::move(EffectContextHandle);
	Parms.WeakPoint = WeakPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAbilitySystemBlueprintLibrary.GetAllHitResultsFromTargetData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FHitResult> UOFAbilitySystemBlueprintLibrary::GetAllHitResultsFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAbilitySystemBlueprintLibrary", "GetAllHitResultsFromTargetData");

	Params::OFAbilitySystemBlueprintLibrary_GetAllHitResultsFromTargetData Parms{};

	Parms.TargetData = std::move(TargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAbilitySystemBlueprintLibrary.GetEnemyDeathReactionTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UOFAbilitySystemBlueprintLibrary::GetEnemyDeathReactionTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAbilitySystemBlueprintLibrary", "GetEnemyDeathReactionTag");

	Params::OFAbilitySystemBlueprintLibrary_GetEnemyDeathReactionTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAbilitySystemBlueprintLibrary.GetPlayerDeathReactionTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UOFAbilitySystemBlueprintLibrary::GetPlayerDeathReactionTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAbilitySystemBlueprintLibrary", "GetPlayerDeathReactionTag");

	Params::OFAbilitySystemBlueprintLibrary_GetPlayerDeathReactionTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAbilitySystemBlueprintLibrary.GetTagMatchingDeathReactionTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            TargetTags                                             (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    bGetPlayerTags                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UOFAbilitySystemBlueprintLibrary::GetTagMatchingDeathReactionTag(const struct FGameplayTagContainer& TargetTags, const bool bGetPlayerTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAbilitySystemBlueprintLibrary", "GetTagMatchingDeathReactionTag");

	Params::OFAbilitySystemBlueprintLibrary_GetTagMatchingDeathReactionTag Parms{};

	Parms.TargetTags = std::move(TargetTags);
	Parms.bGetPlayerTags = bGetPlayerTags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAbilitySystemBlueprintLibrary.GetTargetDataFromEffectContextHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContextHandle                                    (Parm, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayAbilityTargetDataHandle UOFAbilitySystemBlueprintLibrary::GetTargetDataFromEffectContextHandle(const struct FGameplayEffectContextHandle& EffectContextHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAbilitySystemBlueprintLibrary", "GetTargetDataFromEffectContextHandle");

	Params::OFAbilitySystemBlueprintLibrary_GetTargetDataFromEffectContextHandle Parms{};

	Parms.EffectContextHandle = std::move(EffectContextHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAbilitySystemBlueprintLibrary.GetWeakPointsFromEffectContextHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContextHandle                                    (Parm, NativeAccessSpecifierPublic)
// TArray<class UDamagePoint*>             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UDamagePoint*> UOFAbilitySystemBlueprintLibrary::GetWeakPointsFromEffectContextHandle(const struct FGameplayEffectContextHandle& EffectContextHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAbilitySystemBlueprintLibrary", "GetWeakPointsFromEffectContextHandle");

	Params::OFAbilitySystemBlueprintLibrary_GetWeakPointsFromEffectContextHandle Parms{};

	Parms.EffectContextHandle = std::move(EffectContextHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAbilitySystemBlueprintLibrary.IsGamepadLastInputTypeUsed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayAbilityActorInfo        ActorInfo                                              (ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFAbilitySystemBlueprintLibrary::IsGamepadLastInputTypeUsed(const struct FGameplayAbilityActorInfo& ActorInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAbilitySystemBlueprintLibrary", "IsGamepadLastInputTypeUsed");

	Params::OFAbilitySystemBlueprintLibrary_IsGamepadLastInputTypeUsed Parms{};

	Parms.ActorInfo = std::move(ActorInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.FlowNode_ItemExamined.OnItemLookedExaminedHandler
// (Final, Native, Protected)
// Parameters:
// TSoftObjectPtr<class UItemData>         InItemData                                             (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFlowNode_ItemExamined::OnItemLookedExaminedHandler(const TSoftObjectPtr<class UItemData> InItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlowNode_ItemExamined", "OnItemLookedExaminedHandler");

	Params::FlowNode_ItemExamined_OnItemLookedExaminedHandler Parms{};

	Parms.InItemData = InItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveListWidget.CreateWidgets
// (Final, Native, Public, BlueprintCallable)

void UObjectiveListWidget::CreateWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveListWidget", "CreateWidgets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveListWidget.MakeObjectiveUnSeen
// (Event, Public, BlueprintEvent)

void UObjectiveListWidget::MakeObjectiveUnSeen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveListWidget", "MakeObjectiveUnSeen");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.ObjectiveListWidget.UpdateObjectiveWidget
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FObjectiveChapter                ObjectiveChapterInfo                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UObjectiveListWidget::UpdateObjectiveWidget(const struct FObjectiveChapter& ObjectiveChapterInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveListWidget", "UpdateObjectiveWidget");

	Params::ObjectiveListWidget_UpdateObjectiveWidget Parms{};

	Parms.ObjectiveChapterInfo = std::move(ObjectiveChapterInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveListWidget.GetObjectiveInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UObjectiveListWidget::GetObjectiveInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveListWidget", "GetObjectiveInfo");

	Params::ObjectiveListWidget_GetObjectiveInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ObjectiveListWidget.IsUnSeen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObjectiveListWidget::IsUnSeen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveListWidget", "IsUnSeen");

	Params::ObjectiveListWidget_IsUnSeen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.MoodSystemBlueprintLibrary.TriggerMoodStateEventOnNearbyComponents
// (Final, Native, Static, Private, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<EEmotion, float>                   AffectedEmotions                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMoodSystemBlueprintLibrary::TriggerMoodStateEventOnNearbyComponents(class AActor* Instigator, const struct FVector& Origin, float Radius, const TMap<EEmotion, float>& AffectedEmotions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoodSystemBlueprintLibrary", "TriggerMoodStateEventOnNearbyComponents");

	Params::MoodSystemBlueprintLibrary_TriggerMoodStateEventOnNearbyComponents Parms{};

	Parms.Instigator = Instigator;
	Parms.Origin = std::move(Origin);
	Parms.Radius = Radius;
	Parms.AffectedEmotions = std::move(AffectedEmotions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FluidSource.GetFluid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FFluid                           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FFluid AFluidSource::GetFluid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FluidSource", "GetFluid");

	Params::FluidSource_GetFluid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.WorldSubsystem_RailingCompManager.GetNearestSplineData
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxSearchDistance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSplinePointResult               ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FSplinePointResult UWorldSubsystem_RailingCompManager::GetNearestSplineData(const struct FVector& Origin, float MaxSearchDistance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldSubsystem_RailingCompManager", "GetNearestSplineData");

	Params::WorldSubsystem_RailingCompManager_GetNearestSplineData Parms{};

	Parms.Origin = std::move(Origin);
	Parms.MaxSearchDistance = MaxSearchDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ObjectiveWidget.ChangeNoteHandler
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FInputActionValue                InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UObjectiveWidget::ChangeNoteHandler(const struct FInputActionValue& InputActionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWidget", "ChangeNoteHandler");

	Params::ObjectiveWidget_ChangeNoteHandler Parms{};

	Parms.InputActionValue = std::move(InputActionValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveWidget.FmodEventPlayed
// (Final, Native, Private)

void UObjectiveWidget::FmodEventPlayed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWidget", "FmodEventPlayed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveWidget.FmodEventStopped
// (Final, Native, Private)

void UObjectiveWidget::FmodEventStopped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWidget", "FmodEventStopped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveWidget.MoveNoteScrollboxHandler
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FInputActionValue                InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UObjectiveWidget::MoveNoteScrollboxHandler(const struct FInputActionValue& InputActionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWidget", "MoveNoteScrollboxHandler");

	Params::ObjectiveWidget_MoveNoteScrollboxHandler Parms{};

	Parms.InputActionValue = std::move(InputActionValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveWidget.PlayVO
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FInputActionValue                InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UObjectiveWidget::PlayVO(const struct FInputActionValue& InputActionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWidget", "PlayVO");

	Params::ObjectiveWidget_PlayVO Parms{};

	Parms.InputActionValue = std::move(InputActionValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FoliageInteractionComponent.SendInteractionToManager
// (Final, Native, Protected, BlueprintCallable)

void UFoliageInteractionComponent::SendInteractionToManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FoliageInteractionComponent", "SendInteractionToManager");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FoliageInteractionComponent.GetActiveRange
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFoliageInteractionComponent::GetActiveRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FoliageInteractionComponent", "GetActiveRange");

	Params::FoliageInteractionComponent_GetActiveRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.FoliageInteractionComponent.GetFoliageInteractionData
// (Final, Native, Public, Const)
// Parameters:
// struct FFoliageInteraction              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FFoliageInteraction UFoliageInteractionComponent::GetFoliageInteractionData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FoliageInteractionComponent", "GetFoliageInteractionData");

	Params::FoliageInteractionComponent_GetFoliageInteractionData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.FoliageInteractionComponent.GetInteractionPriority
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFoliageInteractionComponent::GetInteractionPriority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FoliageInteractionComponent", "GetInteractionPriority");

	Params::FoliageInteractionComponent_GetInteractionPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.FoliageInteractionManager.Interation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UFoliageInteractionComponent*     Component                                              (ConstParm, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFoliageInteractionManager::Interation(const class UFoliageInteractionComponent*& Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FoliageInteractionManager", "Interation");

	Params::FoliageInteractionManager_Interation Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFActivityPlayChapter.AutosaveOverwriteConfirmed
// (Final, Native, Protected)

void UOFActivityPlayChapter::AutosaveOverwriteConfirmed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFActivityPlayChapter", "AutosaveOverwriteConfirmed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFActivityPlayChapter.ChunkInstallSuccessful
// (Final, Native, Protected)

void UOFActivityPlayChapter::ChunkInstallSuccessful()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFActivityPlayChapter", "ChunkInstallSuccessful");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.IKModifier.OnApply
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIKModifier::OnApply(const class FName BoneName, class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IKModifier", "OnApply");

	Params::IKModifier_OnApply Parms{};

	Parms.BoneName = BoneName;
	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.IKModifier.OnPaused
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIKModifier::OnPaused(const class FName BoneName, class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IKModifier", "OnPaused");

	Params::IKModifier_OnPaused Parms{};

	Parms.BoneName = BoneName;
	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.IKModifier.OnResumed
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIKModifier::OnResumed(const class FName BoneName, class UAnimInstance* AnimInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IKModifier", "OnResumed");

	Params::IKModifier_OnResumed Parms{};

	Parms.BoneName = BoneName;
	Parms.AnimInstance = AnimInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.IKModifier.OnUpdate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class FName                             BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIKModifierUpdateReturnValue     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FIKModifierUpdateReturnValue UIKModifier::OnUpdate(const class FName BoneName, class UAnimInstance* AnimInstance, float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IKModifier", "OnUpdate");

	Params::IKModifier_OnUpdate Parms{};

	Parms.BoneName = BoneName;
	Parms.AnimInstance = AnimInstance;
	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.IKModifier.IsDone
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIKModifier::IsDone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IKModifier", "IsDone");

	Params::IKModifier_IsDone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAchievementTrackingSubsystem.AchievementCompletedHandler
// (Final, Native, Private)
// Parameters:
// class FName                             AchievementId                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAchievementTrackingSubsystem::AchievementCompletedHandler(class FName AchievementId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAchievementTrackingSubsystem", "AchievementCompletedHandler");

	Params::OFAchievementTrackingSubsystem_AchievementCompletedHandler Parms{};

	Parms.AchievementId = AchievementId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAchievementTrackingSubsystem.AllCollectibleSetsCompletedHandler
// (Final, Native, Private)

void UOFAchievementTrackingSubsystem::AllCollectibleSetsCompletedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAchievementTrackingSubsystem", "AllCollectibleSetsCompletedHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAchievementTrackingSubsystem.BanterCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCompletedBanter                 CompletedBanter                                        (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAchievementTrackingSubsystem::BanterCompleted(const struct FCompletedBanter& CompletedBanter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAchievementTrackingSubsystem", "BanterCompleted");

	Params::OFAchievementTrackingSubsystem_BanterCompleted Parms{};

	Parms.CompletedBanter = std::move(CompletedBanter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAchievementTrackingSubsystem.CheckEnemyKilledAchievements
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOFAchievementTrackingSubsystem::CheckEnemyKilledAchievements(const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAchievementTrackingSubsystem", "CheckEnemyKilledAchievements");

	Params::OFAchievementTrackingSubsystem_CheckEnemyKilledAchievements Parms{};

	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAchievementTrackingSubsystem.CollectibleSetCompletedHandler
// (Final, Native, Private)
// Parameters:
// class UCollectibleSet*                  CollectibleSet                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAchievementTrackingSubsystem::CollectibleSetCompletedHandler(const class UCollectibleSet* CollectibleSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAchievementTrackingSubsystem", "CollectibleSetCompletedHandler");

	Params::OFAchievementTrackingSubsystem_CollectibleSetCompletedHandler Parms{};

	Parms.CollectibleSet = CollectibleSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAchievementTrackingSubsystem.CollectibleSetsLoadedHandler
// (Final, Native, Private)

void UOFAchievementTrackingSubsystem::CollectibleSetsLoadedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAchievementTrackingSubsystem", "CollectibleSetsLoadedHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAchievementTrackingSubsystem.DisableNoHealingAchievement
// (Final, Native, Public, BlueprintCallable)

void UOFAchievementTrackingSubsystem::DisableNoHealingAchievement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAchievementTrackingSubsystem", "DisableNoHealingAchievement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAchievementTrackingSubsystem.FactUpdatedHandler
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESubscriptionTagChangeType              ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAchievementTrackingSubsystem::FactUpdatedHandler(const struct FGameplayTag& Tag, ESubscriptionTagChangeType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAchievementTrackingSubsystem", "FactUpdatedHandler");

	Params::OFAchievementTrackingSubsystem_FactUpdatedHandler Parms{};

	Parms.Tag = std::move(Tag);
	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAchievementTrackingSubsystem.GameSessionStartedHandler
// (Final, Native, Private)
// Parameters:
// class UGameplaySession*                 GameplaySession                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAchievementTrackingSubsystem::GameSessionStartedHandler(class UGameplaySession* GameplaySession)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAchievementTrackingSubsystem", "GameSessionStartedHandler");

	Params::OFAchievementTrackingSubsystem_GameSessionStartedHandler Parms{};

	Parms.GameplaySession = GameplaySession;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAchievementTrackingSubsystem.ItemExaminedHandler
// (Final, Native, Private)
// Parameters:
// TSoftObjectPtr<class UItemData>         ItemData                                               (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAchievementTrackingSubsystem::ItemExaminedHandler(const TSoftObjectPtr<class UItemData> ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAchievementTrackingSubsystem", "ItemExaminedHandler");

	Params::OFAchievementTrackingSubsystem_ItemExaminedHandler Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFAchievementTrackingSubsystem.PawnControllerChangedHandler
// (Final, Native, Private)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAchievementTrackingSubsystem::PawnControllerChangedHandler(class APawn* Pawn, class AController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFAchievementTrackingSubsystem", "PawnControllerChangedHandler");

	Params::OFAchievementTrackingSubsystem_PawnControllerChangedHandler Parms{};

	Parms.Pawn = Pawn;
	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FootPrintSpawnerComponent.OnFootDown
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFootType                               FootStepType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFootPrintSpawnerComponent::OnFootDown(const struct FVector& Location, EFootType FootStepType, const class FName& BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootPrintSpawnerComponent", "OnFootDown");

	Params::FootPrintSpawnerComponent_OnFootDown Parms{};

	Parms.Location = std::move(Location);
	Parms.FootStepType = FootStepType;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.FootPrintSpawnerComponent.OnFootUp
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFootType                               FootStepType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFootPrintSpawnerComponent::OnFootUp(const struct FVector& Location, EFootType FootStepType, const class FName& BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FootPrintSpawnerComponent", "OnFootUp");

	Params::FootPrintSpawnerComponent_OnFootUp Parms{};

	Parms.Location = std::move(Location);
	Parms.FootStepType = FootStepType;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameplayAbility_Burrow.SetEnablePawnCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayAbility_Burrow::SetEnablePawnCollision(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbility_Burrow", "SetEnablePawnCollision");

	Params::GameplayAbility_Burrow_SetEnablePawnCollision Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameplayAbility_Burrow.SetFootIKEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayAbility_Burrow::SetFootIKEnable(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbility_Burrow", "SetFootIKEnable");

	Params::GameplayAbility_Burrow_SetFootIKEnable Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameplayAbility_DeathReaction.GetDeathReactionTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FGameplayTag UGameplayAbility_DeathReaction::GetDeathReactionTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbility_DeathReaction", "GetDeathReactionTag");

	Params::GameplayAbility_DeathReaction_GetDeathReactionTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameplayAbility_DeathReaction.GetFirstTagMatchingDeathReactionTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagContainer            TargetTags                                             (ConstParm, Parm, NativeAccessSpecifierPublic)
// const struct FGameplayTag               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FGameplayTag UGameplayAbility_DeathReaction::GetFirstTagMatchingDeathReactionTag(const struct FGameplayTagContainer& TargetTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbility_DeathReaction", "GetFirstTagMatchingDeathReactionTag");

	Params::GameplayAbility_DeathReaction_GetFirstTagMatchingDeathReactionTag Parms{};

	Parms.TargetTags = std::move(TargetTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameplayAbility_HitReaction.GetHitReactionData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayEventData               GameplayEventData                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FHitReactionData                 HitReactionData                                        (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayAbility_HitReaction::GetHitReactionData(const struct FGameplayEventData& GameplayEventData, struct FHitReactionData* HitReactionData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbility_HitReaction", "GetHitReactionData");

	Params::GameplayAbility_HitReaction_GetHitReactionData Parms{};

	Parms.GameplayEventData = std::move(GameplayEventData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HitReactionData != nullptr)
		*HitReactionData = std::move(Parms.HitReactionData);

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimationBlueprintLibrary.GetActorForwardInputDirectionAngle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UOFCharacterMovementComponent*    MovementComponent                                      (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFAnimationBlueprintLibrary::GetActorForwardInputDirectionAngle(const class UOFCharacterMovementComponent* MovementComponent, const class ACharacter* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAnimationBlueprintLibrary", "GetActorForwardInputDirectionAngle");

	Params::OFAnimationBlueprintLibrary_GetActorForwardInputDirectionAngle Parms{};

	Parms.MovementComponent = MovementComponent;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimationBlueprintLibrary.GetAnimationMontageFromAssetManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     AnimationTag                                           (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacter*                       Player                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UAnimMontage>      ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UAnimMontage> UOFAnimationBlueprintLibrary::GetAnimationMontageFromAssetManager(class UObject* WorldContextObject, const struct FGameplayTag& AnimationTag, const class ACharacter* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAnimationBlueprintLibrary", "GetAnimationMontageFromAssetManager");

	Params::OFAnimationBlueprintLibrary_GetAnimationMontageFromAssetManager Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AnimationTag = std::move(AnimationTag);
	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimationBlueprintLibrary.GetBlendInTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFAnimationBlueprintLibrary::GetBlendInTime(const class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAnimationBlueprintLibrary", "GetBlendInTime");

	Params::OFAnimationBlueprintLibrary_GetBlendInTime Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimationBlueprintLibrary.GetBlendspace1DPositionFromAccumulatedCurveValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UBlendSpace1D*                    BlendSpace                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendSpaceInput                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFAnimationBlueprintLibrary::GetBlendspace1DPositionFromAccumulatedCurveValue(const class UBlendSpace1D* BlendSpace, float BlendSpaceInput, const class FName CurveName, float TargetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAnimationBlueprintLibrary", "GetBlendspace1DPositionFromAccumulatedCurveValue");

	Params::OFAnimationBlueprintLibrary_GetBlendspace1DPositionFromAccumulatedCurveValue Parms{};

	Parms.BlendSpace = BlendSpace;
	Parms.BlendSpaceInput = BlendSpaceInput;
	Parms.CurveName = CurveName;
	Parms.TargetValue = TargetValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimationBlueprintLibrary.GetBlendspacePositionFromCurveValue
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UBlendSpaceBase*                  BlendSpace                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          BlendSpaceInput                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             CurveName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFAnimationBlueprintLibrary::GetBlendspacePositionFromCurveValue(const class UBlendSpaceBase* BlendSpace, const struct FVector& BlendSpaceInput, const class FName CurveName, float TargetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAnimationBlueprintLibrary", "GetBlendspacePositionFromCurveValue");

	Params::OFAnimationBlueprintLibrary_GetBlendspacePositionFromCurveValue Parms{};

	Parms.BlendSpace = BlendSpace;
	Parms.BlendSpaceInput = std::move(BlendSpaceInput);
	Parms.CurveName = CurveName;
	Parms.TargetValue = TargetValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimationBlueprintLibrary.GetBoneLocationAt
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           InSkeletalMesh                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                AnimSequenceBase                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOFAnimationBlueprintLibrary::GetBoneLocationAt(class USkeletalMeshComponent* InSkeletalMesh, class UAnimSequenceBase* AnimSequenceBase, class FName BoneName, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAnimationBlueprintLibrary", "GetBoneLocationAt");

	Params::OFAnimationBlueprintLibrary_GetBoneLocationAt Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;
	Parms.AnimSequenceBase = AnimSequenceBase;
	Parms.BoneName = BoneName;
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimationBlueprintLibrary.GetBoneLocationAtNotifyEvent
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkeletalMeshComponent*           InSkeletalMesh                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                AnimSequenceBase                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAnimNotifyEvent                 NotifyEvent                                            (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOFAnimationBlueprintLibrary::GetBoneLocationAtNotifyEvent(class USkeletalMeshComponent* InSkeletalMesh, class UAnimSequenceBase* AnimSequenceBase, class FName BoneName, const struct FAnimNotifyEvent& NotifyEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAnimationBlueprintLibrary", "GetBoneLocationAtNotifyEvent");

	Params::OFAnimationBlueprintLibrary_GetBoneLocationAtNotifyEvent Parms{};

	Parms.InSkeletalMesh = InSkeletalMesh;
	Parms.AnimSequenceBase = AnimSequenceBase;
	Parms.BoneName = BoneName;
	Parms.NotifyEvent = std::move(NotifyEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimationBlueprintLibrary.GetInteractionReachNotifyEvents
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                SequenceBase                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAnimNotifyEvent>         OutNotifyEvents                                        (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             InteractionReachBoneName                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAnimationBlueprintLibrary::GetInteractionReachNotifyEvents(class UAnimSequenceBase* SequenceBase, TArray<struct FAnimNotifyEvent>* OutNotifyEvents, const class FName InteractionReachBoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAnimationBlueprintLibrary", "GetInteractionReachNotifyEvents");

	Params::OFAnimationBlueprintLibrary_GetInteractionReachNotifyEvents Parms{};

	Parms.SequenceBase = SequenceBase;
	Parms.InteractionReachBoneName = InteractionReachBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNotifyEvents != nullptr)
		*OutNotifyEvents = std::move(Parms.OutNotifyEvents);
}


// Function ObsidianFox.OFAnimationBlueprintLibrary.GetInteractionReachNotifyEventsForCurrentSection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                SequenceBase                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimInstance*                    AnimInstance                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAnimNotifyEvent>         OutNotifyEvents                                        (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FName                             InteractionReachBoneName                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFAnimationBlueprintLibrary::GetInteractionReachNotifyEventsForCurrentSection(class UAnimSequenceBase* SequenceBase, const class UAnimInstance* AnimInstance, TArray<struct FAnimNotifyEvent>* OutNotifyEvents, const class FName InteractionReachBoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAnimationBlueprintLibrary", "GetInteractionReachNotifyEventsForCurrentSection");

	Params::OFAnimationBlueprintLibrary_GetInteractionReachNotifyEventsForCurrentSection Parms{};

	Parms.SequenceBase = SequenceBase;
	Parms.AnimInstance = AnimInstance;
	Parms.InteractionReachBoneName = InteractionReachBoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNotifyEvents != nullptr)
		*OutNotifyEvents = std::move(Parms.OutNotifyEvents);
}


// Function ObsidianFox.OFAnimationBlueprintLibrary.GetMontageSections
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UOFAnimationBlueprintLibrary::GetMontageSections(const class UAnimMontage* AnimMontage, TArray<class FName>* OutNames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAnimationBlueprintLibrary", "GetMontageSections");

	Params::OFAnimationBlueprintLibrary_GetMontageSections Parms{};

	Parms.AnimMontage = AnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function ObsidianFox.OFAnimationBlueprintLibrary.GetMontageSectionStartTime
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     Montage                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFAnimationBlueprintLibrary::GetMontageSectionStartTime(const class UAnimMontage* Montage, class FName SectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAnimationBlueprintLibrary", "GetMontageSectionStartTime");

	Params::OFAnimationBlueprintLibrary_GetMontageSectionStartTime Parms{};

	Parms.Montage = Montage;
	Parms.SectionName = SectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimationBlueprintLibrary.GetNotifyEvents
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                SequenceBase                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAnimNotify>          NotifyClass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAnimNotifyEvent>         OutNotifyEvents                                        (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UOFAnimationBlueprintLibrary::GetNotifyEvents(class UAnimSequenceBase* SequenceBase, TSubclassOf<class UAnimNotify> NotifyClass, TArray<struct FAnimNotifyEvent>* OutNotifyEvents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAnimationBlueprintLibrary", "GetNotifyEvents");

	Params::OFAnimationBlueprintLibrary_GetNotifyEvents Parms{};

	Parms.SequenceBase = SequenceBase;
	Parms.NotifyClass = NotifyClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNotifyEvents != nullptr)
		*OutNotifyEvents = std::move(Parms.OutNotifyEvents);
}


// Function ObsidianFox.OFAnimationBlueprintLibrary.GetRandomAnimationStartPosition
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimSequence                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFAnimationBlueprintLibrary::GetRandomAnimationStartPosition(class UAnimSequenceBase* AnimSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAnimationBlueprintLibrary", "GetRandomAnimationStartPosition");

	Params::OFAnimationBlueprintLibrary_GetRandomAnimationStartPosition Parms{};

	Parms.AnimSequence = AnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimationBlueprintLibrary.GetRandomMontageSection
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimMontage*                     AnimMontage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UOFAnimationBlueprintLibrary::GetRandomMontageSection(class UAnimMontage* AnimMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAnimationBlueprintLibrary", "GetRandomMontageSection");

	Params::OFAnimationBlueprintLibrary_GetRandomMontageSection Parms{};

	Parms.AnimMontage = AnimMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFAnimationBlueprintLibrary.GetSequenceLength
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimSequenceBase*                AnimSequence                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFAnimationBlueprintLibrary::GetSequenceLength(class UAnimSequenceBase* AnimSequence)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFAnimationBlueprintLibrary", "GetSequenceLength");

	Params::OFAnimationBlueprintLibrary_GetSequenceLength Parms{};

	Parms.AnimSequence = AnimSequence;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.SubtitleWidget.AddSubtitle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             SubtitleText                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
// float                                   Time                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USubtitleWidget::AddSubtitle(const class FText& SubtitleText, const float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitleWidget", "AddSubtitle");

	Params::SubtitleWidget_AddSubtitle Parms{};

	Parms.SubtitleText = std::move(SubtitleText);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SubtitleWidget.OnDisplaySubtitlesHandler
// (Final, Native, Protected)
// Parameters:
// class FText                             SubtitleText                                           (ConstParm, Parm, NativeAccessSpecifierPublic)
// float                                   Time                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USubtitleWidget::OnDisplaySubtitlesHandler(const class FText& SubtitleText, const float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitleWidget", "OnDisplaySubtitlesHandler");

	Params::SubtitleWidget_OnDisplaySubtitlesHandler Parms{};

	Parms.SubtitleText = std::move(SubtitleText);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SubtitleWidget.OnKillSubtitlesHandler
// (Final, Native, Protected)

void USubtitleWidget::OnKillSubtitlesHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubtitleWidget", "OnKillSubtitlesHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameplayBlueprintLibrary.FindLookAtRotationBetweenActors
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           SourceActor                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UGameplayBlueprintLibrary::FindLookAtRotationBetweenActors(const class AActor* SourceActor, const class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameplayBlueprintLibrary", "FindLookAtRotationBetweenActors");

	Params::GameplayBlueprintLibrary_FindLookAtRotationBetweenActors Parms{};

	Parms.SourceActor = SourceActor;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_BalanceManager.GetRandomizedResourceTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FResourceBalance                 ResourceBalance                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameSubsystem_BalanceManager::GetRandomizedResourceTarget(const struct FResourceBalance& ResourceBalance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSubsystem_BalanceManager", "GetRandomizedResourceTarget");

	Params::GameSubsystem_BalanceManager_GetRandomizedResourceTarget Parms{};

	Parms.ResourceBalance = std::move(ResourceBalance);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_BalanceManager.GetAmountOfHealthPerItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameSubsystem_BalanceManager::GetAmountOfHealthPerItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_BalanceManager", "GetAmountOfHealthPerItem");

	Params::GameSubsystem_BalanceManager_GetAmountOfHealthPerItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_BalanceManager.GetCurrentItemAmountForType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EConsumableType                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameSubsystem_BalanceManager::GetCurrentItemAmountForType(EConsumableType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_BalanceManager", "GetCurrentItemAmountForType");

	Params::GameSubsystem_BalanceManager_GetCurrentItemAmountForType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_BalanceManager.GetMaxPotentialForConsumable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EConsumableType                         ConsumableType                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameSubsystem_BalanceManager::GetMaxPotentialForConsumable(const EConsumableType ConsumableType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_BalanceManager", "GetMaxPotentialForConsumable");

	Params::GameSubsystem_BalanceManager_GetMaxPotentialForConsumable Parms{};

	Parms.ConsumableType = ConsumableType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_BalanceManager.GetResourceBalanceValues
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FResourceBalanceCollection       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FResourceBalanceCollection UGameSubsystem_BalanceManager::GetResourceBalanceValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_BalanceManager", "GetResourceBalanceValues");

	Params::GameSubsystem_BalanceManager_GetResourceBalanceValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_BalanceManager.IncrementEmptyContainersOpened
// (Final, Native, Public, BlueprintCallable)

void UGameSubsystem_BalanceManager::IncrementEmptyContainersOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_BalanceManager", "IncrementEmptyContainersOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_BalanceManager.ResetEmptyContainersOpened
// (Final, Native, Public, BlueprintCallable)

void UGameSubsystem_BalanceManager::ResetEmptyContainersOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_BalanceManager", "ResetEmptyContainersOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.GameSubsystem_BalanceManager.ResourceBalanceValuesUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// struct FResourceBalanceCollection       NewValues                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameSubsystem_BalanceManager::ResourceBalanceValuesUpdated__DelegateSignature(const struct FResourceBalanceCollection& NewValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_BalanceManager", "ResourceBalanceValuesUpdated__DelegateSignature");

	Params::GameSubsystem_BalanceManager_ResourceBalanceValuesUpdated__DelegateSignature Parms{};

	Parms.NewValues = std::move(NewValues);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.GameSubsystem_BalanceManager.SetDefaultResourceBalanceValues
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForceDefaults                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_BalanceManager::SetDefaultResourceBalanceValues(bool bForceDefaults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_BalanceManager", "SetDefaultResourceBalanceValues");

	Params::GameSubsystem_BalanceManager_SetDefaultResourceBalanceValues Parms{};

	Parms.bForceDefaults = bForceDefaults;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_BalanceManager.UpdateResourceBalanceValues
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_BalanceManager::UpdateResourceBalanceValues(class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_BalanceManager", "UpdateResourceBalanceValues");

	Params::GameSubsystem_BalanceManager_UpdateResourceBalanceValues Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_BalanceManager.GetEmptyContainersOpened
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UGameSubsystem_BalanceManager::GetEmptyContainersOpened() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_BalanceManager", "GetEmptyContainersOpened");

	Params::GameSubsystem_BalanceManager_GetEmptyContainersOpened Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_BalanceManager.GetLastSetRowName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UGameSubsystem_BalanceManager::GetLastSetRowName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_BalanceManager", "GetLastSetRowName");

	Params::GameSubsystem_BalanceManager_GetLastSetRowName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DarkManInterface.DeactivateDarkMan
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IDarkManInterface::DeactivateDarkMan()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkManInterface", "DeactivateDarkMan");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.DarkManInterface.GetObsessionRate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDarkManInterface::GetObsessionRate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkManInterface", "GetObsessionRate");

	Params::DarkManInterface_GetObsessionRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DarkManInterface.CanPlayerSeeDarkMan
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDarkManInterface::CanPlayerSeeDarkMan() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkManInterface", "CanPlayerSeeDarkMan");

	Params::DarkManInterface_CanPlayerSeeDarkMan Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.DarkManInterface.IsActive
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDarkManInterface::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DarkManInterface", "IsActive");

	Params::DarkManInterface_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_MapData.CreateMapDataAndAddToMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMapMarkerActorComponent*         MarkerActorComponent                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_MapData::CreateMapDataAndAddToMap(const class UMapMarkerActorComponent* MarkerActorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_MapData", "CreateMapDataAndAddToMap");

	Params::GameSubsystem_MapData_CreateMapDataAndAddToMap Parms{};

	Parms.MarkerActorComponent = MarkerActorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_MapData.RemoveMapDataFromMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMapMarkerActorComponent*         MarkerActorComponent                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_MapData::RemoveMapDataFromMap(const class UMapMarkerActorComponent* MarkerActorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_MapData", "RemoveMapDataFromMap");

	Params::GameSubsystem_MapData_RemoveMapDataFromMap Parms{};

	Parms.MarkerActorComponent = MarkerActorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_MapData.UpdateMapCalculateOffsetSettings
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    bInCalculateOffset                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InMapDercetoActorPosition                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       InMapOffsetActorTransform                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UGameSubsystem_MapData::UpdateMapCalculateOffsetSettings(bool bInCalculateOffset, const struct FVector& InMapDercetoActorPosition, const struct FTransform& InMapOffsetActorTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_MapData", "UpdateMapCalculateOffsetSettings");

	Params::GameSubsystem_MapData_UpdateMapCalculateOffsetSettings Parms{};

	Parms.bInCalculateOffset = bInCalculateOffset;
	Parms.InMapDercetoActorPosition = std::move(InMapDercetoActorPosition);
	Parms.InMapOffsetActorTransform = std::move(InMapOffsetActorTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_MapData.UpdateMapData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMapMarkerActorComponent*         MarkerActorComponent                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_MapData::UpdateMapData(const class UMapMarkerActorComponent* MarkerActorComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_MapData", "UpdateMapData");

	Params::GameSubsystem_MapData_UpdateMapData Parms{};

	Parms.MarkerActorComponent = MarkerActorComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_MapData.GetCurrentRoomVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AMapTrackerVolume*          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class AMapTrackerVolume* UGameSubsystem_MapData::GetCurrentRoomVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_MapData", "GetCurrentRoomVolume");

	Params::GameSubsystem_MapData_GetCurrentRoomVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_PlayState.GetPlayerCharacterType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWorld*                           WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerCharacterType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerCharacterType UGameSubsystem_PlayState::GetPlayerCharacterType(class UWorld* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameSubsystem_PlayState", "GetPlayerCharacterType");

	Params::GameSubsystem_PlayState_GetPlayerCharacterType Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.GameSubsystem_PlayState.CombatStateChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bNewIsInCombat                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_PlayState::CombatStateChanged__DelegateSignature(bool bNewIsInCombat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_PlayState", "CombatStateChanged__DelegateSignature");

	Params::GameSubsystem_PlayState_CombatStateChanged__DelegateSignature Parms{};

	Parms.bNewIsInCombat = bNewIsInCombat;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.GameSubsystem_PlayState.EnemyAggroStateChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bHasAggro                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInCombat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_PlayState::EnemyAggroStateChanged__DelegateSignature(bool bHasAggro, bool bInCombat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_PlayState", "EnemyAggroStateChanged__DelegateSignature");

	Params::GameSubsystem_PlayState_EnemyAggroStateChanged__DelegateSignature Parms{};

	Parms.bHasAggro = bHasAggro;
	Parms.bInCombat = bInCombat;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.GameSubsystem_PlayState.GameMainStateChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EGameMainState                          OldGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameMainState                          NewGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_PlayState::GameMainStateChanged__DelegateSignature(EGameMainState OldGameState, EGameMainState NewGameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_PlayState", "GameMainStateChanged__DelegateSignature");

	Params::GameSubsystem_PlayState_GameMainStateChanged__DelegateSignature Parms{};

	Parms.OldGameState = OldGameState;
	Parms.NewGameState = NewGameState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.GameSubsystem_PlayState.GetMainState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EGameMainState                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EGameMainState UGameSubsystem_PlayState::GetMainState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_PlayState", "GetMainState");

	Params::GameSubsystem_PlayState_GetMainState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_PlayState.LoadingScreenFinishedHandler
// (Final, Native, Private)

void UGameSubsystem_PlayState::LoadingScreenFinishedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_PlayState", "LoadingScreenFinishedHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_PlayState.LoadingScreenStartedHandler
// (Final, Native, Private)

void UGameSubsystem_PlayState::LoadingScreenStartedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_PlayState", "LoadingScreenStartedHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.GameSubsystem_PlayState.PlayerHealthStateChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EPlayerHealthState                      NewHealthState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_PlayState::PlayerHealthStateChanged__DelegateSignature(EPlayerHealthState NewHealthState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_PlayState", "PlayerHealthStateChanged__DelegateSignature");

	Params::GameSubsystem_PlayState_PlayerHealthStateChanged__DelegateSignature Parms{};

	Parms.NewHealthState = NewHealthState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.GameSubsystem_PlayState.PopMainState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          StateOwner                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_PlayState::PopMainState(const class UObject* StateOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_PlayState", "PopMainState");

	Params::GameSubsystem_PlayState_PopMainState Parms{};

	Parms.StateOwner = StateOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_PlayState.PushMainState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          StateOwner                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameMainState                          NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_PlayState::PushMainState(const class UObject* StateOwner, EGameMainState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_PlayState", "PushMainState");

	Params::GameSubsystem_PlayState_PushMainState Parms{};

	Parms.StateOwner = StateOwner;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_PlayState.ReportActOfAggression
// (Final, Native, Public, BlueprintCallable)

void UGameSubsystem_PlayState::ReportActOfAggression()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_PlayState", "ReportActOfAggression");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_PlayState.ResetMainState
// (Final, Native, Public, BlueprintCallable)

void UGameSubsystem_PlayState::ResetMainState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_PlayState", "ResetMainState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_PlayState.UpdatePlayerHealthState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_PlayState::UpdatePlayerHealthState(float NewHealth, float MaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_PlayState", "UpdatePlayerHealthState");

	Params::GameSubsystem_PlayState_UpdatePlayerHealthState Parms{};

	Parms.NewHealth = NewHealth;
	Parms.MaxHealth = MaxHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_PlayState.GetIsInCombat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameSubsystem_PlayState::GetIsInCombat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_PlayState", "GetIsInCombat");

	Params::GameSubsystem_PlayState_GetIsInCombat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_PlayState.GetPlayerHealthState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerHealthState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerHealthState UGameSubsystem_PlayState::GetPlayerHealthState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_PlayState", "GetPlayerHealthState");

	Params::GameSubsystem_PlayState_GetPlayerHealthState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_Talisman.GetCurrentTalismanCombination
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameSubsystem_Talisman::GetCurrentTalismanCombination()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_Talisman", "GetCurrentTalismanCombination");

	Params::GameSubsystem_Talisman_GetCurrentTalismanCombination Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_Talisman.SetActiveRing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewActiveRing                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_Talisman::SetActiveRing(const int32 NewActiveRing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_Talisman", "SetActiveRing");

	Params::GameSubsystem_Talisman_SetActiveRing Parms{};

	Parms.NewActiveRing = NewActiveRing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_Talisman.SetRing0Value
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_Talisman::SetRing0Value(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_Talisman", "SetRing0Value");

	Params::GameSubsystem_Talisman_SetRing0Value Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_Talisman.SetRing1Value
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_Talisman::SetRing1Value(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_Talisman", "SetRing1Value");

	Params::GameSubsystem_Talisman_SetRing1Value Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GameSubsystem_Talisman.SetRing2Value
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_Talisman::SetRing2Value(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_Talisman", "SetRing2Value");

	Params::GameSubsystem_Talisman_SetRing2Value Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.GameSubsystem_Talisman.TalismanCombinationDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// int32                                   NewTalismanCombination                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_Talisman::TalismanCombinationDelegate__DelegateSignature(int32 NewTalismanCombination)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_Talisman", "TalismanCombinationDelegate__DelegateSignature");

	Params::GameSubsystem_Talisman_TalismanCombinationDelegate__DelegateSignature Parms{};

	Parms.NewTalismanCombination = NewTalismanCombination;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.GameSubsystem_Talisman.TalismanNewActiveRingDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// int32                                   NewActiveRing                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameSubsystem_Talisman::TalismanNewActiveRingDelegate__DelegateSignature(int32 NewActiveRing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_Talisman", "TalismanNewActiveRingDelegate__DelegateSignature");

	Params::GameSubsystem_Talisman_TalismanNewActiveRingDelegate__DelegateSignature Parms{};

	Parms.NewActiveRing = NewActiveRing;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.GameSubsystem_Talisman.GetActiveRing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameSubsystem_Talisman::GetActiveRing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_Talisman", "GetActiveRing");

	Params::GameSubsystem_Talisman_GetActiveRing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_Talisman.GetRing0Value
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameSubsystem_Talisman::GetRing0Value() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_Talisman", "GetRing0Value");

	Params::GameSubsystem_Talisman_GetRing0Value Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_Talisman.GetRing1Value
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameSubsystem_Talisman::GetRing1Value() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_Talisman", "GetRing1Value");

	Params::GameSubsystem_Talisman_GetRing1Value Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GameSubsystem_Talisman.GetRing2Value
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameSubsystem_Talisman::GetRing2Value() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameSubsystem_Talisman", "GetRing2Value");

	Params::GameSubsystem_Talisman_GetRing2Value Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.GammaSettingsHud.DpadPressedLeft
// (Final, Native, Protected)

void UGammaSettingsHud::DpadPressedLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GammaSettingsHud", "DpadPressedLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GammaSettingsHud.DpadPressedRight
// (Final, Native, Protected)

void UGammaSettingsHud::DpadPressedRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GammaSettingsHud", "DpadPressedRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GammaSettingsHud.FaceButtonBottomPressed
// (Final, Native, Protected)

void UGammaSettingsHud::FaceButtonBottomPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GammaSettingsHud", "FaceButtonBottomPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GammaSettingsHud.FaceButtonRightPressed
// (Final, Native, Protected)

void UGammaSettingsHud::FaceButtonRightPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GammaSettingsHud", "FaceButtonRightPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.GuantletEditorTest.RunGauntlet
// (Final, Native, Public, BlueprintCallable)

void AGuantletEditorTest::RunGauntlet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GuantletEditorTest", "RunGauntlet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HandPosesAnimInterface.ApplyHandPose
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Instigator                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UAnimSequenceBase> HandPoseSequence                                       (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IHandPosesAnimInterface::ApplyHandPose(const class UObject* Instigator, const TSoftObjectPtr<class UAnimSequenceBase>& HandPoseSequence, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HandPosesAnimInterface", "ApplyHandPose");

	Params::HandPosesAnimInterface_ApplyHandPose Parms{};

	Parms.Instigator = Instigator;
	Parms.HandPoseSequence = HandPoseSequence;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HandPosesAnimInterface.RemoveHandPose
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Instigator                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IHandPosesAnimInterface::RemoveHandPose(const class UObject* Instigator, class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HandPosesAnimInterface", "RemoveHandPose");

	Params::HandPosesAnimInterface_RemoveHandPose Parms{};

	Parms.Instigator = Instigator;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HeavyHitReactionEvaluator.OnHeavyReactionPlayed
// (Native, Event, Public, BlueprintEvent)

void UHeavyHitReactionEvaluator::OnHeavyReactionPlayed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeavyHitReactionEvaluator", "OnHeavyReactionPlayed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HeavyHitReactionEvaluator.OnOwnerHealthChanged
// (Final, Native, Public, HasOutParams)
// Parameters:
// float                                   NewCurrentHealth                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            EventTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHeavyHitReactionEvaluator::OnOwnerHealthChanged(float NewCurrentHealth, float DeltaValue, const struct FGameplayTagContainer& EventTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeavyHitReactionEvaluator", "OnOwnerHealthChanged");

	Params::HeavyHitReactionEvaluator_OnOwnerHealthChanged Parms{};

	Parms.NewCurrentHealth = NewCurrentHealth;
	Parms.DeltaValue = DeltaValue;
	Parms.EventTags = std::move(EventTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HeavyHitReactionEvaluator.OnTimerElapsed
// (Final, Native, Protected)

void UHeavyHitReactionEvaluator::OnTimerElapsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeavyHitReactionEvaluator", "OnTimerElapsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HeavyHitReactionEvaluator.ShouldPlayHeavyReaction
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitReactionData                 HitReactionData                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UObject*                          OptionalObject                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReactionMontage                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHeavyHitReactionEvaluator::ShouldPlayHeavyReaction(const struct FHitReactionData& HitReactionData, const class UObject* OptionalObject, const class UAnimMontage* ReactionMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HeavyHitReactionEvaluator", "ShouldPlayHeavyReaction");

	Params::HeavyHitReactionEvaluator_ShouldPlayHeavyReaction Parms{};

	Parms.HitReactionData = std::move(HitReactionData);
	Parms.OptionalObject = OptionalObject;
	Parms.ReactionMontage = ReactionMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.HelpTextHud.BottomFaceButtonPressed
// (Event, Public, BlueprintEvent)

void UHelpTextHud::BottomFaceButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HelpTextHud", "BottomFaceButtonPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.HelpTextHud.SetupInput
// (Final, Native, Public, BlueprintCallable)

void UHelpTextHud::SetupInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HelpTextHud", "SetupInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HighlightItemPickupHud.CloseDownWidget
// (Final, Native, Private)

void UHighlightItemPickupHud::CloseDownWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HighlightItemPickupHud", "CloseDownWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HighlightItemPickupHud.SetBackKeyPromptVisibility
// (Event, Protected, BlueprintEvent)
// Parameters:
// ESlateVisibility                        NewVisibility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHighlightItemPickupHud::SetBackKeyPromptVisibility(ESlateVisibility NewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HighlightItemPickupHud", "SetBackKeyPromptVisibility");

	Params::HighlightItemPickupHud_SetBackKeyPromptVisibility Parms{};

	Parms.NewVisibility = NewVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.HighlightItemPickupHud.SetInvestigationKeyWidgetVisibility
// (Event, Protected, BlueprintEvent)
// Parameters:
// ESlateVisibility                        NewVisibility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHighlightItemPickupHud::SetInvestigationKeyWidgetVisibility(ESlateVisibility NewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HighlightItemPickupHud", "SetInvestigationKeyWidgetVisibility");

	Params::HighlightItemPickupHud_SetInvestigationKeyWidgetVisibility Parms{};

	Parms.NewVisibility = NewVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.HighlightItemPickupHud.UpdateItemFrameAndText
// (Event, Protected, BlueprintEvent)
// Parameters:
// EItemType                               ItemType                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHighlightItemPickupHud::UpdateItemFrameAndText(const EItemType ItemType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HighlightItemPickupHud", "UpdateItemFrameAndText");

	Params::HighlightItemPickupHud_UpdateItemFrameAndText Parms{};

	Parms.ItemType = ItemType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.HitReactionComponent.EndHitReaction
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bFailed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasInterrupted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHitReactionType                        HitReactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHitReactionComponent::EndHitReaction(bool bFailed, bool bWasInterrupted, EHitReactionType HitReactionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitReactionComponent", "EndHitReaction");

	Params::HitReactionComponent_EndHitReaction Parms{};

	Parms.bFailed = bFailed;
	Parms.bWasInterrupted = bWasInterrupted;
	Parms.HitReactionType = HitReactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HitReactionComponent.OnAnimationBlendingOut
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHitReactionComponent::OnAnimationBlendingOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitReactionComponent", "OnAnimationBlendingOut");

	Params::HitReactionComponent_OnAnimationBlendingOut Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HitReactionComponent.OnHeavyReaction
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitReactionData                 HitReactionData                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AObsidianFoxCharacter*            Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FReactionMontageData             MontageData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHitReactionComponent::OnHeavyReaction(const struct FHitReactionData& HitReactionData, class AObsidianFoxCharacter* Character, const struct FReactionMontageData& MontageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitReactionComponent", "OnHeavyReaction");

	Params::HitReactionComponent_OnHeavyReaction Parms{};

	Parms.HitReactionData = std::move(HitReactionData);
	Parms.Character = Character;
	Parms.MontageData = std::move(MontageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.HitReactionComponent.OnHitreactionBegin__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EHitReactionType                        HitReactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHitReactionComponent::OnHitreactionBegin__DelegateSignature(EHitReactionType HitReactionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitReactionComponent", "OnHitreactionBegin__DelegateSignature");

	Params::HitReactionComponent_OnHitreactionBegin__DelegateSignature Parms{};

	Parms.HitReactionType = HitReactionType;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.HitReactionComponent.OnHitreactionDone__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EHitReactionType                        HitReactionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFailed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasInterrupted                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHitReactionComponent::OnHitreactionDone__DelegateSignature(EHitReactionType HitReactionType, bool bFailed, bool bWasInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitReactionComponent", "OnHitreactionDone__DelegateSignature");

	Params::HitReactionComponent_OnHitreactionDone__DelegateSignature Parms{};

	Parms.HitReactionType = HitReactionType;
	Parms.bFailed = bFailed;
	Parms.bWasInterrupted = bWasInterrupted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.HitReactionComponent.OnLightReaction
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitReactionData                 HitReactionData                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AObsidianFoxCharacter*            Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FReactionMontageData             MontageData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHitReactionComponent::OnLightReaction(const struct FHitReactionData& HitReactionData, class AObsidianFoxCharacter* Character, const struct FReactionMontageData& MontageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitReactionComponent", "OnLightReaction");

	Params::HitReactionComponent_OnLightReaction Parms{};

	Parms.HitReactionData = std::move(HitReactionData);
	Parms.Character = Character;
	Parms.MontageData = std::move(MontageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HitReactionComponent.OnMediumReaction
// (Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHitReactionData                 HitReactionData                                        (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class AObsidianFoxCharacter*            Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FReactionMontageData             MontageData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UHitReactionComponent::OnMediumReaction(const struct FHitReactionData& HitReactionData, class AObsidianFoxCharacter* Character, const struct FReactionMontageData& MontageData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HitReactionComponent", "OnMediumReaction");

	Params::HitReactionComponent_OnMediumReaction Parms{};

	Parms.HitReactionData = std::move(HitReactionData);
	Parms.Character = Character;
	Parms.MontageData = std::move(MontageData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HittableInterface.WeaponHit
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               Payload                                                (Parm, NativeAccessSpecifierPublic)

void IHittableInterface::WeaponHit(class AActor* Weapon, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HittableInterface", "WeaponHit");

	Params::HittableInterface_WeaponHit Parms{};

	Parms.Weapon = Weapon;
	Parms.EventTag = std::move(EventTag);
	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HomeRangeComponent.OnHomeRangeOverlapBegin
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHomeRangeComponent::OnHomeRangeOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HomeRangeComponent", "OnHomeRangeOverlapBegin");

	Params::HomeRangeComponent_OnHomeRangeOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.HomeRangeComponent.OnHomeRangeOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHomeRangeComponent::OnHomeRangeOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HomeRangeComponent", "OnHomeRangeOverlapEnd");

	Params::HomeRangeComponent_OnHomeRangeOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ImpassableTerrainDetectorComponent.OnCharacterPossessed
// (Final, Native, Private)
// Parameters:
// class AOFPlayerCharacter*               Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UImpassableTerrainDetectorComponent::OnCharacterPossessed(const class AOFPlayerCharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpassableTerrainDetectorComponent", "OnCharacterPossessed");

	Params::ImpassableTerrainDetectorComponent_OnCharacterPossessed Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ImpassableTerrainDetectorComponent.OnColliderHit
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UImpassableTerrainDetectorComponent::OnColliderHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ImpassableTerrainDetectorComponent", "OnColliderHit");

	Params::ImpassableTerrainDetectorComponent_OnColliderHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WaterLevelComponent.BlueprintBeginOverlap
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AWaterLevelTriggerVolume*         WaterLevelVolume                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWaterLevelTriggerBoxComponent*   TriggerComponent                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaterLevelComponent::BlueprintBeginOverlap(const class AWaterLevelTriggerVolume* WaterLevelVolume, const class UWaterLevelTriggerBoxComponent* TriggerComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterLevelComponent", "BlueprintBeginOverlap");

	Params::WaterLevelComponent_BlueprintBeginOverlap Parms{};

	Parms.WaterLevelVolume = WaterLevelVolume;
	Parms.TriggerComponent = TriggerComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.WaterLevelComponent.BlueprintEndOverlapAny
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AWaterLevelTriggerVolume*         WaterLevelVolume                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWaterLevelTriggerBoxComponent*   TriggerComponent                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaterLevelComponent::BlueprintEndOverlapAny(const class AWaterLevelTriggerVolume* WaterLevelVolume, const class UWaterLevelTriggerBoxComponent* TriggerComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterLevelComponent", "BlueprintEndOverlapAny");

	Params::WaterLevelComponent_BlueprintEndOverlapAny Parms{};

	Parms.WaterLevelVolume = WaterLevelVolume;
	Parms.TriggerComponent = TriggerComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.WaterLevelComponent.BlueprintEndOverlapCurrent
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AWaterLevelTriggerVolume*         WaterLevelVolume                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWaterLevelTriggerBoxComponent*   TriggerComponent                                       (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaterLevelComponent::BlueprintEndOverlapCurrent(const class AWaterLevelTriggerVolume* WaterLevelVolume, const class UWaterLevelTriggerBoxComponent* TriggerComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterLevelComponent", "BlueprintEndOverlapCurrent");

	Params::WaterLevelComponent_BlueprintEndOverlapCurrent Parms{};

	Parms.WaterLevelVolume = WaterLevelVolume;
	Parms.TriggerComponent = TriggerComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.InGameUIWidget_Combat.OnBeginReload
// (Final, Native, Protected)

void UInGameUIWidget_Combat::OnBeginReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_Combat", "OnBeginReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_Combat.OnCharacterAim
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsAiming                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget_Combat::OnCharacterAim(bool bIsAiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_Combat", "OnCharacterAim");

	Params::InGameUIWidget_Combat_OnCharacterAim Parms{};

	Parms.bIsAiming = bIsAiming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_Combat.OnCombatStateChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bNewIsInCombat                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget_Combat::OnCombatStateChanged(bool bNewIsInCombat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_Combat", "OnCombatStateChanged");

	Params::InGameUIWidget_Combat_OnCombatStateChanged Parms{};

	Parms.bNewIsInCombat = bNewIsInCombat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_Combat.OnEndReload
// (Final, Native, Protected)

void UInGameUIWidget_Combat::OnEndReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_Combat", "OnEndReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_Combat.OnHealthChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// float                                   NewCurrentHealth                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            EventTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInGameUIWidget_Combat::OnHealthChanged(float NewCurrentHealth, float DeltaValue, const struct FGameplayTagContainer& EventTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_Combat", "OnHealthChanged");

	Params::InGameUIWidget_Combat_OnHealthChanged Parms{};

	Parms.NewCurrentHealth = NewCurrentHealth;
	Parms.DeltaValue = DeltaValue;
	Parms.EventTags = std::move(EventTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_Combat.OnItemIncrement
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UItemData*                        ItemData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemDisplayInfo                 ItemDisplayInfo                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget_Combat::OnItemIncrement(const class UItemData* ItemData, const struct FItemDisplayInfo& ItemDisplayInfo, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_Combat", "OnItemIncrement");

	Params::InGameUIWidget_Combat_OnItemIncrement Parms{};

	Parms.ItemData = ItemData;
	Parms.ItemDisplayInfo = std::move(ItemDisplayInfo);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_Combat.OnPlayerEquipmentUpdated
// (Final, Native, Protected)
// Parameters:
// struct FWeaponInfo                      EquippedWeapon                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FWeaponInfo                      UnequippedWeapon                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UInGameUIWidget_Combat::OnPlayerEquipmentUpdated(const struct FWeaponInfo& EquippedWeapon, const struct FWeaponInfo& UnequippedWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_Combat", "OnPlayerEquipmentUpdated");

	Params::InGameUIWidget_Combat_OnPlayerEquipmentUpdated Parms{};

	Parms.EquippedWeapon = std::move(EquippedWeapon);
	Parms.UnequippedWeapon = std::move(UnequippedWeapon);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_Combat.TryingToPickUpMaxStackItemHandler
// (Final, Native, Protected)
// Parameters:
// class UItemData*                        ItemData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget_Combat::TryingToPickUpMaxStackItemHandler(const class UItemData* ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_Combat", "TryingToPickUpMaxStackItemHandler");

	Params::InGameUIWidget_Combat_TryingToPickUpMaxStackItemHandler Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_Combat.WeaponBeginAttack
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     AttackEvent                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInGameUIWidget_Combat::WeaponBeginAttack(const struct FGameplayTag& AttackEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_Combat", "WeaponBeginAttack");

	Params::InGameUIWidget_Combat_WeaponBeginAttack Parms{};

	Parms.AttackEvent = std::move(AttackEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InGameUIWidget_HealthBar.OnHealthChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// float                                   NewCurrentHealth                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            EventTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInGameUIWidget_HealthBar::OnHealthChanged(float NewCurrentHealth, float DeltaValue, const struct FGameplayTagContainer& EventTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InGameUIWidget_HealthBar", "OnHealthChanged");

	Params::InGameUIWidget_HealthBar_OnHealthChanged Parms{};

	Parms.NewCurrentHealth = NewCurrentHealth;
	Parms.DeltaValue = DeltaValue;
	Parms.EventTags = std::move(EventTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractInfoTextHud.CollapseAllObjectiveTextWidget
// (Final, Native, Protected, BlueprintCallable)

void UInteractInfoTextHud::CollapseAllObjectiveTextWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInfoTextHud", "CollapseAllObjectiveTextWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractInfoTextHud.HideNewItemHint
// (Event, Protected, BlueprintEvent)

void UInteractInfoTextHud::HideNewItemHint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInfoTextHud", "HideNewItemHint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InteractInfoTextHud.OnBlendOutObjective
// (Event, Public, BlueprintEvent)

void UInteractInfoTextHud::OnBlendOutObjective()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInfoTextHud", "OnBlendOutObjective");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InteractInfoTextHud.OnBlendOutTimerFinished
// (Final, Native, Public)

void UInteractInfoTextHud::OnBlendOutTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInfoTextHud", "OnBlendOutTimerFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractInfoTextHud.OnItemAddedOrRemoved
// (Final, Native, Protected)
// Parameters:
// class UItemData*                        ItemData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractInfoTextHud::OnItemAddedOrRemoved(const class UItemData* ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInfoTextHud", "OnItemAddedOrRemoved");

	Params::InteractInfoTextHud_OnItemAddedOrRemoved Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractInfoTextHud.OnItemLookedAt
// (Final, Native, Protected)
// Parameters:
// TSoftObjectPtr<class UItemData>         ItemData                                               (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractInfoTextHud::OnItemLookedAt(const TSoftObjectPtr<class UItemData> ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInfoTextHud", "OnItemLookedAt");

	Params::InteractInfoTextHud_OnItemLookedAt Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractInfoTextHud.OnObjectiveCompleted
// (Final, Native, Public)
// Parameters:
// EObjectiveParts                         CompletedPart                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ObjectiveText                                          (Parm, NativeAccessSpecifierPublic)

void UInteractInfoTextHud::OnObjectiveCompleted(EObjectiveParts CompletedPart, const class FText& ObjectiveText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInfoTextHud", "OnObjectiveCompleted");

	Params::InteractInfoTextHud_OnObjectiveCompleted Parms{};

	Parms.CompletedPart = CompletedPart;
	Parms.ObjectiveText = std::move(ObjectiveText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractInfoTextHud.OnObjectiveReview
// (Final, Native, Private)

void UInteractInfoTextHud::OnObjectiveReview()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInfoTextHud", "OnObjectiveReview");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractInfoTextHud.OnObjectiveUpdate
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UObjectivesData*                  ObjectiveData                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FObjectiveInfo                   ObjectiveInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EObjectiveParts                         OldPart                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectiveParts                         NewPart                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractInfoTextHud::OnObjectiveUpdate(const class UObjectivesData* ObjectiveData, const struct FObjectiveInfo& ObjectiveInfo, EObjectiveParts OldPart, EObjectiveParts NewPart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInfoTextHud", "OnObjectiveUpdate");

	Params::InteractInfoTextHud_OnObjectiveUpdate Parms{};

	Parms.ObjectiveData = ObjectiveData;
	Parms.ObjectiveInfo = std::move(ObjectiveInfo);
	Parms.OldPart = OldPart;
	Parms.NewPart = NewPart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractInfoTextHud.OnShowObjective
// (Event, Public, BlueprintEvent)

void UInteractInfoTextHud::OnShowObjective()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInfoTextHud", "OnShowObjective");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InteractInfoTextHud.OnSubObjectiveCompletedHandler
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UObjectivesData*                  ObjectivesData                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FObjectiveInfo                   ObjectiveInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EObjectiveParts                         Part                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractInfoTextHud::OnSubObjectiveCompletedHandler(const class UObjectivesData* ObjectivesData, const struct FObjectiveInfo& ObjectiveInfo, const EObjectiveParts Part)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInfoTextHud", "OnSubObjectiveCompletedHandler");

	Params::InteractInfoTextHud_OnSubObjectiveCompletedHandler Parms{};

	Parms.ObjectivesData = ObjectivesData;
	Parms.ObjectiveInfo = std::move(ObjectiveInfo);
	Parms.Part = Part;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractInfoTextHud.OnSubObjectiveStartedHandler
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UObjectivesData*                  ObjectivesData                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FObjectiveInfo                   ObjectiveInfo                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EObjectiveParts                         Part                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractInfoTextHud::OnSubObjectiveStartedHandler(const class UObjectivesData* ObjectivesData, const struct FObjectiveInfo& ObjectiveInfo, const EObjectiveParts Part)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInfoTextHud", "OnSubObjectiveStartedHandler");

	Params::InteractInfoTextHud_OnSubObjectiveStartedHandler Parms{};

	Parms.ObjectivesData = ObjectivesData;
	Parms.ObjectiveInfo = std::move(ObjectiveInfo);
	Parms.Part = Part;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractInfoTextHud.ShowNewItemHint
// (Event, Protected, BlueprintEvent)

void UInteractInfoTextHud::ShowNewItemHint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInfoTextHud", "ShowNewItemHint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InteractInfoTextHud.UpdateNewItemHintVisibility
// (Event, Public, BlueprintEvent)

void UInteractInfoTextHud::UpdateNewItemHintVisibility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInfoTextHud", "UpdateNewItemHintVisibility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InteractInfoTextHud.IsNewHintTimerActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractInfoTextHud::IsNewHintTimerActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractInfoTextHud", "IsNewHintTimerActive");

	Params::InteractInfoTextHud_IsNewHintTimerActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InteractionComponent.AfterInteractionCleanup
// (Final, Native, Public, BlueprintCallable)

void UInteractionComponent::AfterInteractionCleanup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "AfterInteractionCleanup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionComponent.BeginInteraction
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::BeginInteraction(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "BeginInteraction");

	Params::InteractionComponent_BeginInteraction Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionComponent.ClearTimer
// (Final, Native, Protected)

void UInteractionComponent::ClearTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "ClearTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionComponent.GetCombatOnly
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionComponent::GetCombatOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "GetCombatOnly");

	Params::InteractionComponent_GetCombatOnly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InteractionComponent.HandleInteractButtonReleased
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::HandleInteractButtonReleased(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "HandleInteractButtonReleased");

	Params::InteractionComponent_HandleInteractButtonReleased Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.InteractionComponent.InteractingCharAnimStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacter*                       InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::InteractingCharAnimStart(class ACharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "InteractingCharAnimStart");

	Params::InteractionComponent_InteractingCharAnimStart Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.InteractionComponent.InteractionEndSignature__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ACharacter*                       InteractionCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::InteractionEndSignature__DelegateSignature(class ACharacter* InteractionCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "InteractionEndSignature__DelegateSignature");

	Params::InteractionComponent_InteractionEndSignature__DelegateSignature Parms{};

	Parms.InteractionCharacter = InteractionCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.InteractionComponent.InteractionSignature__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ACharacter*                       InteractionCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::InteractionSignature__DelegateSignature(class ACharacter* InteractionCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "InteractionSignature__DelegateSignature");

	Params::InteractionComponent_InteractionSignature__DelegateSignature Parms{};

	Parms.InteractionCharacter = InteractionCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.InteractionComponent.OnCharacterTurnInPlaceEnd
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsBlendOutToWalk                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::OnCharacterTurnInPlaceEnd(class ACharacter* Character, bool bIsBlendOutToWalk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "OnCharacterTurnInPlaceEnd");

	Params::InteractionComponent_OnCharacterTurnInPlaceEnd Parms{};

	Parms.Character = Character;
	Parms.bIsBlendOutToWalk = bIsBlendOutToWalk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionComponent.OnCharacterTurnInPlaceFailed
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::OnCharacterTurnInPlaceFailed(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "OnCharacterTurnInPlaceFailed");

	Params::InteractionComponent_OnCharacterTurnInPlaceFailed Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.InteractionComponent.OnInitiateInteraction__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::OnInitiateInteraction__DelegateSignature(class ACharacter* InteractingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "OnInitiateInteraction__DelegateSignature");

	Params::InteractionComponent_OnInitiateInteraction__DelegateSignature Parms{};

	Parms.InteractingCharacter = InteractingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.InteractionComponent.OnInteractionMontageStarted__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::OnInteractionMontageStarted__DelegateSignature(class ACharacter* InteractingCharacter, class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "OnInteractionMontageStarted__DelegateSignature");

	Params::InteractionComponent_OnInteractionMontageStarted__DelegateSignature Parms{};

	Parms.InteractingCharacter = InteractingCharacter;
	Parms.Montage = Montage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.InteractionComponent.OnMontageEnded
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "OnMontageEnded");

	Params::InteractionComponent_OnMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionComponent.OnPlayerMoveToComplete
// (Final, Native, Private)
// Parameters:
// EPathFollowingResult                    MovementResult                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIRequestID                     RequestID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::OnPlayerMoveToComplete(EPathFollowingResult MovementResult, const struct FAIRequestID& RequestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "OnPlayerMoveToComplete");

	Params::InteractionComponent_OnPlayerMoveToComplete Parms{};

	Parms.MovementResult = MovementResult;
	Parms.RequestID = std::move(RequestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionComponent.OnPlayerMoveToFail
// (Final, Native, Private)
// Parameters:
// EPathFollowingResult                    MovementResult                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIRequestID                     RequestID                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::OnPlayerMoveToFail(EPathFollowingResult MovementResult, const struct FAIRequestID& RequestID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "OnPlayerMoveToFail");

	Params::InteractionComponent_OnPlayerMoveToFail Parms{};

	Parms.MovementResult = MovementResult;
	Parms.RequestID = std::move(RequestID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionComponent.SetIgnorePlayerInput
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::SetIgnorePlayerInput(class ACharacter* InteractingCharacter, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "SetIgnorePlayerInput");

	Params::InteractionComponent_SetIgnorePlayerInput Parms{};

	Parms.InteractingCharacter = InteractingCharacter;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionComponent.SetSceneComponentTransformGoal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  InSceneComponentTransformGoal                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::SetSceneComponentTransformGoal(class USceneComponent* InSceneComponentTransformGoal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "SetSceneComponentTransformGoal");

	Params::InteractionComponent_SetSceneComponentTransformGoal Parms{};

	Parms.InSceneComponentTransformGoal = InSceneComponentTransformGoal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionComponent.StopWaitingForAnimation
// (Final, Native, Protected)

void UInteractionComponent::StopWaitingForAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "StopWaitingForAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionHUD.AddIcon
// (Event, Public, BlueprintEvent)
// Parameters:
// class UInteractionComponentBase*        InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionHUD::AddIcon(class UInteractionComponentBase* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionHUD", "AddIcon");

	Params::InteractionHUD_AddIcon Parms{};

	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ObsidianFox.InteractionHUD.ClearAllIcons
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionHUD::ClearAllIcons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionHUD", "ClearAllIcons");

	Params::InteractionHUD_ClearAllIcons Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ObsidianFox.InteractionHUD.NativeTickIcons
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionHUD::NativeTickIcons(float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionHUD", "NativeTickIcons");

	Params::InteractionHUD_NativeTickIcons Parms{};

	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionHUD.NativeTranslateIcons
// (Final, Native, Protected, BlueprintCallable)

void UInteractionHUD::NativeTranslateIcons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionHUD", "NativeTranslateIcons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionHUD.NearbyInteractablesChanged
// (Native, Protected)
// Parameters:
// TSet<class UInteractionComponentBase*>  NearbyInteractables                                    (ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSet<class UInteractionComponentBase*>  AddedInteractables                                     (ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSet<class UInteractionComponentBase*>  RemovedInteractables                                   (ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInteractionHUD::NearbyInteractablesChanged(const TSet<class UInteractionComponentBase*>& NearbyInteractables, const TSet<class UInteractionComponentBase*>& AddedInteractables, const TSet<class UInteractionComponentBase*>& RemovedInteractables)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionHUD", "NearbyInteractablesChanged");

	Params::InteractionHUD_NearbyInteractablesChanged Parms{};

	Parms.NearbyInteractables = std::move(NearbyInteractables);
	Parms.AddedInteractables = std::move(AddedInteractables);
	Parms.RemovedInteractables = std::move(RemovedInteractables);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InteractionHUD.OnCombatInteractableSelectionChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UInteractionComponentBase*        SelectedInteractable                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionHUD::OnCombatInteractableSelectionChanged(const class UInteractionComponentBase* SelectedInteractable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionHUD", "OnCombatInteractableSelectionChanged");

	Params::InteractionHUD_OnCombatInteractableSelectionChanged Parms{};

	Parms.SelectedInteractable = SelectedInteractable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.InteractionHUD.OnExaminationInteractableSelectionChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UInteractionComponentBase*        SelectedInteractable                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionHUD::OnExaminationInteractableSelectionChanged(const class UInteractionComponentBase* SelectedInteractable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionHUD", "OnExaminationInteractableSelectionChanged");

	Params::InteractionHUD_OnExaminationInteractableSelectionChanged Parms{};

	Parms.SelectedInteractable = SelectedInteractable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.InteractionHUD.OnStandardInteractableSelectionChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UInteractionComponentBase*        SelectedInteractable                                   (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionHUD::OnStandardInteractableSelectionChanged(const class UInteractionComponentBase* SelectedInteractable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionHUD", "OnStandardInteractableSelectionChanged");

	Params::InteractionHUD_OnStandardInteractableSelectionChanged Parms{};

	Parms.SelectedInteractable = SelectedInteractable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.InteractionHUD.RemoveIcon
// (Event, Public, BlueprintEvent)
// Parameters:
// class UInteractionComponentBase*        InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionHUD::RemoveIcon(class UInteractionComponentBase* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionHUD", "RemoveIcon");

	Params::InteractionHUD_RemoveIcon Parms{};

	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ObsidianFox.InteractionHUD.TickIcons
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionHUD::TickIcons(float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionHUD", "TickIcons");

	Params::InteractionHUD_TickIcons Parms{};

	Parms.Delta = Delta;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ObsidianFox.InteractionHUD.TranslateIcons
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionHUD::TranslateIcons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionHUD", "TranslateIcons");

	Params::InteractionHUD_TranslateIcons Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryBlueprintLibrary.AddItemToInventory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemData*                        ItemData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFInventoryPopUp                        PopUp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryBlueprintLibrary::AddItemToInventory(const class UObject* WorldContextObject, class UItemData* ItemData, int32 Amount, EFInventoryPopUp PopUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryBlueprintLibrary", "AddItemToInventory");

	Params::InventoryBlueprintLibrary_AddItemToInventory Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ItemData = ItemData;
	Parms.Amount = Amount;
	Parms.PopUp = PopUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryBlueprintLibrary.GetAllItems
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<TSoftObjectPtr<class UItemData>>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

const TArray<TSoftObjectPtr<class UItemData>> UInventoryBlueprintLibrary::GetAllItems(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryBlueprintLibrary", "GetAllItems");

	Params::InventoryBlueprintLibrary_GetAllItems Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryBlueprintLibrary.GetAllItemsInSameCategory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayTagItemCategory                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<TSoftObjectPtr<class UItemData>>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

const TArray<TSoftObjectPtr<class UItemData>> UInventoryBlueprintLibrary::GetAllItemsInSameCategory(const class UObject* WorldContextObject, const struct FGameplayTag& GameplayTagItemCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryBlueprintLibrary", "GetAllItemsInSameCategory");

	Params::InventoryBlueprintLibrary_GetAllItemsInSameCategory Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.GameplayTagItemCategory = std::move(GameplayTagItemCategory);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryBlueprintLibrary.GetItemAmount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemData*                        Item                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventoryBlueprintLibrary::GetItemAmount(const class UObject* WorldContextObject, const class UItemData* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryBlueprintLibrary", "GetItemAmount");

	Params::InventoryBlueprintLibrary_GetItemAmount Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryBlueprintLibrary.HasAnyItemNotBeenLookedAt
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UItemData>> Items                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UInventoryBlueprintLibrary::HasAnyItemNotBeenLookedAt(const class UObject* WorldContextObject, const TArray<TSoftObjectPtr<class UItemData>>& Items)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryBlueprintLibrary", "HasAnyItemNotBeenLookedAt");

	Params::InventoryBlueprintLibrary_HasAnyItemNotBeenLookedAt Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Items = std::move(Items);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryBlueprintLibrary.HasItem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemData*                        Item                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryBlueprintLibrary::HasItem(const class UObject* WorldContextObject, const class UItemData* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryBlueprintLibrary", "HasItem");

	Params::InventoryBlueprintLibrary_HasItem Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryBlueprintLibrary.HasItemBeenLookedAt
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UItemData>         Item                                                   (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UInventoryBlueprintLibrary::HasItemBeenLookedAt(const class UObject* WorldContextObject, const TSoftObjectPtr<class UItemData> Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryBlueprintLibrary", "HasItemBeenLookedAt");

	Params::InventoryBlueprintLibrary_HasItemBeenLookedAt Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryBlueprintLibrary.IsCollectibleSetComplete
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UCollectiblesDataAsset>InCollectiblesDataAsset                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryBlueprintLibrary::IsCollectibleSetComplete(const class UObject* WorldContextObject, TSoftObjectPtr<class UCollectiblesDataAsset> InCollectiblesDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryBlueprintLibrary", "IsCollectibleSetComplete");

	Params::InventoryBlueprintLibrary_IsCollectibleSetComplete Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InCollectiblesDataAsset = InCollectiblesDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryBlueprintLibrary.IsCollectibleSetCompleteWithDelegate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UCollectiblesDataAsset>InCollectiblesDataAsset                                (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Callback                                               (Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
// ECollectibleCompletionStatus            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECollectibleCompletionStatus UInventoryBlueprintLibrary::IsCollectibleSetCompleteWithDelegate(const class UObject* WorldContextObject, TSoftObjectPtr<class UCollectiblesDataAsset> InCollectiblesDataAsset, TDelegate<void()> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryBlueprintLibrary", "IsCollectibleSetCompleteWithDelegate");

	Params::InventoryBlueprintLibrary_IsCollectibleSetCompleteWithDelegate Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InCollectiblesDataAsset = InCollectiblesDataAsset;
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryBlueprintLibrary.IsItemImportant
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UItemData*                        Item                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryBlueprintLibrary::IsItemImportant(const class UItemData* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryBlueprintLibrary", "IsItemImportant");

	Params::InventoryBlueprintLibrary_IsItemImportant Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryBlueprintLibrary.RemoveAllItemsFromInventory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryBlueprintLibrary::RemoveAllItemsFromInventory(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryBlueprintLibrary", "RemoveAllItemsFromInventory");

	Params::InventoryBlueprintLibrary_RemoveAllItemsFromInventory Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InventoryBlueprintLibrary.RemoveItemFromInventory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemData*                        ItemData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventoryBlueprintLibrary::RemoveItemFromInventory(const class UObject* WorldContextObject, class UItemData* ItemData, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryBlueprintLibrary", "RemoveItemFromInventory");

	Params::InventoryBlueprintLibrary_RemoveItemFromInventory Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ItemData = ItemData;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryBlueprintLibrary.SetItemLookedAt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UItemData>         Item                                                   (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLookedAt                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryBlueprintLibrary::SetItemLookedAt(const class UObject* WorldContextObject, const TSoftObjectPtr<class UItemData> Item, bool bLookedAt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryBlueprintLibrary", "SetItemLookedAt");

	Params::InventoryBlueprintLibrary_SetItemLookedAt Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Item = Item;
	Parms.bLookedAt = bLookedAt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InventoryBlueprintLibrary.ShowHighlightItemWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemData*                        Item                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHighlightItemPickupHud*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UHighlightItemPickupHud* UInventoryBlueprintLibrary::ShowHighlightItemWidget(const class UObject* WorldContextObject, class UItemData* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryBlueprintLibrary", "ShowHighlightItemWidget");

	Params::InventoryBlueprintLibrary_ShowHighlightItemWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.InventoryBlueprintLibrary.SortItemDataArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UItemData*>                ItemDataArray                                          (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UInventoryBlueprintLibrary::SortItemDataArray(TArray<class UItemData*>& ItemDataArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("InventoryBlueprintLibrary", "SortItemDataArray");

	Params::InventoryBlueprintLibrary_SortItemDataArray Parms{};

	Parms.ItemDataArray = std::move(ItemDataArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ItemDataArray = std::move(Parms.ItemDataArray);
}


// Function ObsidianFox.InventoryPickerHud.Cancel
// (Event, Protected, BlueprintEvent)

void UInventoryPickerHud::Cancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryPickerHud", "Cancel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InventoryPickerHud.Interact
// (Event, Protected, BlueprintEvent)

void UInventoryPickerHud::Interact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryPickerHud", "Interact");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction ObsidianFox.InventoryPickerHud.InventoryPickerCancel__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UInventoryPickerHud::InventoryPickerCancel__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryPickerHud", "InventoryPickerCancel__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InventoryPickerHud.MouseWheelScroll
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FInputActionValue                InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UInventoryPickerHud::MouseWheelScroll(const struct FInputActionValue& InputActionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryPickerHud", "MouseWheelScroll");

	Params::InventoryPickerHud_MouseWheelScroll Parms{};

	Parms.InputActionValue = std::move(InputActionValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InventoryPickerHud.MoveWidgetInputActionTriggeredHandler
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FInputActionValue                InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UInventoryPickerHud::MoveWidgetInputActionTriggeredHandler(const struct FInputActionValue& InputActionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryPickerHud", "MoveWidgetInputActionTriggeredHandler");

	Params::InventoryPickerHud_MoveWidgetInputActionTriggeredHandler Parms{};

	Parms.InputActionValue = std::move(InputActionValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InventoryPickerHud.RotateBetweenItems
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    Clockwise                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventoryPickerHud::RotateBetweenItems(bool Clockwise)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InventoryPickerHud", "RotateBetweenItems");

	Params::InventoryPickerHud_RotateBetweenItems Parms{};

	Parms.Clockwise = Clockwise;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.InvestigationExaminationView.CategoryNextHandler
// (Final, Native, Protected)

void UInvestigationExaminationView::CategoryNextHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "CategoryNextHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationExaminationView.CategoryPreviousHandler
// (Final, Native, Protected)

void UInvestigationExaminationView::CategoryPreviousHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "CategoryPreviousHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationExaminationView.ChangeToInspectionMode
// (Event, Protected, BlueprintEvent)

void UInvestigationExaminationView::ChangeToInspectionMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "ChangeToInspectionMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InvestigationExaminationView.ChangeToItemSelectionMode
// (Event, Protected, BlueprintEvent)

void UInvestigationExaminationView::ChangeToItemSelectionMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "ChangeToItemSelectionMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InvestigationExaminationView.ChangeToReadingMode
// (Event, Protected, BlueprintEvent)

void UInvestigationExaminationView::ChangeToReadingMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "ChangeToReadingMode");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InvestigationExaminationView.ExitExaminationView
// (Event, Protected, BlueprintEvent)

void UInvestigationExaminationView::ExitExaminationView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "ExitExaminationView");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InvestigationExaminationView.FadeIn
// (Event, Protected, BlueprintEvent)

void UInvestigationExaminationView::FadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "FadeIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InvestigationExaminationView.LeftStickYTilt
// (Final, Native, Protected)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvestigationExaminationView::LeftStickYTilt(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "LeftStickYTilt");

	Params::InvestigationExaminationView_LeftStickYTilt Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationExaminationView.OnAcceptPressedHandler
// (Final, Native, Protected)

void UInvestigationExaminationView::OnAcceptPressedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "OnAcceptPressedHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationExaminationView.OnCancelPressedHandler
// (Final, Native, Protected)

void UInvestigationExaminationView::OnCancelPressedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "OnCancelPressedHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationExaminationView.OnExaminationMenuSetUp
// (Event, Protected, BlueprintEvent)

void UInvestigationExaminationView::OnExaminationMenuSetUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "OnExaminationMenuSetUp");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InvestigationExaminationView.OnOpenMenuPressedHandler
// (Final, Native, Protected)

void UInvestigationExaminationView::OnOpenMenuPressedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "OnOpenMenuPressedHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationExaminationView.OnResetPressedHandler
// (Final, Native, Protected)

void UInvestigationExaminationView::OnResetPressedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "OnResetPressedHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationExaminationView.PlayerGuidanceStateUpdatedHandler
// (Final, Native, Private)
// Parameters:
// EPlayerGuidanceSystem                   System                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bState                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvestigationExaminationView::PlayerGuidanceStateUpdatedHandler(EPlayerGuidanceSystem System, bool bState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "PlayerGuidanceStateUpdatedHandler");

	Params::InvestigationExaminationView_PlayerGuidanceStateUpdatedHandler Parms{};

	Parms.System = System;
	Parms.bState = bState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationExaminationView.PlayItemSlideInAnimation
// (Event, Protected, BlueprintEvent)

void UInvestigationExaminationView::PlayItemSlideInAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "PlayItemSlideInAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InvestigationExaminationView.PlaySound_Internal
// (Final, Native, Private)

void UInvestigationExaminationView::PlaySound_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "PlaySound_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationExaminationView.SetExaminationDisplayInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FItemDisplayInfo                 NewDisplayInfo                                         (Parm, NativeAccessSpecifierPublic)
// bool                                    bPlaySound                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvestigationExaminationView::SetExaminationDisplayInfo(const struct FItemDisplayInfo& NewDisplayInfo, bool bPlaySound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "SetExaminationDisplayInfo");

	Params::InvestigationExaminationView_SetExaminationDisplayInfo Parms{};

	Parms.NewDisplayInfo = std::move(NewDisplayInfo);
	Parms.bPlaySound = bPlaySound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationExaminationView.SetUpExaminationView
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FItemDisplayInfo                 NewDisplayInfo                                         (Parm, NativeAccessSpecifierPublic)
// class UOFSlotWidget*                    SourceSlot                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemData*                        NewItemData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PlayExpansionAnimation                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlaySound                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvestigationExaminationView::SetUpExaminationView(const struct FItemDisplayInfo& NewDisplayInfo, class UOFSlotWidget* SourceSlot, class UItemData* NewItemData, bool PlayExpansionAnimation, bool bPlaySound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "SetUpExaminationView");

	Params::InvestigationExaminationView_SetUpExaminationView Parms{};

	Parms.NewDisplayInfo = std::move(NewDisplayInfo);
	Parms.SourceSlot = SourceSlot;
	Parms.NewItemData = NewItemData;
	Parms.PlayExpansionAnimation = PlayExpansionAnimation;
	Parms.bPlaySound = bPlaySound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationExaminationView.StopSound
// (Final, Native, Protected, BlueprintCallable)

void UInvestigationExaminationView::StopSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "StopSound");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationExaminationView.UpdatePageCounter
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// EItemDisplayInfoType                    ItemType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Current                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Total                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvestigationExaminationView::UpdatePageCounter(EItemDisplayInfoType ItemType, int32 Current, int32 Total)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "UpdatePageCounter");

	Params::InvestigationExaminationView_UpdatePageCounter Parms{};

	Parms.ItemType = ItemType;
	Parms.Current = Current;
	Parms.Total = Total;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.InvestigationExaminationView.GetCurrentItemData
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UItemData*                  ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UItemData* UInvestigationExaminationView::GetCurrentItemData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationExaminationView", "GetCurrentItemData");

	Params::InvestigationExaminationView_GetCurrentItemData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFSlotWidget.Interact
// (Final, Native, Public, BlueprintCallable)

void UOFSlotWidget::Interact()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSlotWidget", "Interact");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFSlotWidget.OnButtonHoveredHandler
// (Final, Native, Private)

void UOFSlotWidget::OnButtonHoveredHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSlotWidget", "OnButtonHoveredHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.OFSlotWidget.OnSlotHovered__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UOFSlotWidget*                    SlotWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFSlotWidget::OnSlotHovered__DelegateSignature(class UOFSlotWidget* SlotWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSlotWidget", "OnSlotHovered__DelegateSignature");

	Params::OFSlotWidget_OnSlotHovered__DelegateSignature Parms{};

	Parms.SlotWidget = SlotWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.OFSlotWidget.OnSlotPressed__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UOFSlotWidget*                    SlotWidget                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemData*                        ItemData                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFSlotWidget::OnSlotPressed__DelegateSignature(class UOFSlotWidget* SlotWidget, class UItemData* ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSlotWidget", "OnSlotPressed__DelegateSignature");

	Params::OFSlotWidget_OnSlotPressed__DelegateSignature Parms{};

	Parms.SlotWidget = SlotWidget;
	Parms.ItemData = ItemData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OFSlotWidget.ShowNewItemIcon
// (Event, Protected, BlueprintEvent)

void UOFSlotWidget::ShowNewItemIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSlotWidget", "ShowNewItemIcon");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.OFSlotWidget.ShowNewItemMaterial
// (Event, Protected, BlueprintEvent)

void UOFSlotWidget::ShowNewItemMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSlotWidget", "ShowNewItemMaterial");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.OFSlotWidget.UpdateSlotUsingItemData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UItemData>         ItemData                                               (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFSlotWidget::UpdateSlotUsingItemData(const TSoftObjectPtr<class UItemData> ItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSlotWidget", "UpdateSlotUsingItemData");

	Params::OFSlotWidget_UpdateSlotUsingItemData Parms{};

	Parms.ItemData = ItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFSlotWidget.GetCurrentName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FText                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const class FText UOFSlotWidget::GetCurrentName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSlotWidget", "GetCurrentName");

	Params::OFSlotWidget_GetCurrentName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFSlotWidget.GetCurrentShortDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FText                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const class FText UOFSlotWidget::GetCurrentShortDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSlotWidget", "GetCurrentShortDescription");

	Params::OFSlotWidget_GetCurrentShortDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFSlotWidget.GetImageGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGeometry                        ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FGeometry UOFSlotWidget::GetImageGeometry() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSlotWidget", "GetImageGeometry");

	Params::OFSlotWidget_GetImageGeometry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFSlotWidget.GetSlotItemData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TSoftObjectPtr<class UItemData>   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const TSoftObjectPtr<class UItemData> UOFSlotWidget::GetSlotItemData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSlotWidget", "GetSlotItemData");

	Params::OFSlotWidget_GetSlotItemData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFSlotWidget.Select
// (Final, Native, Public, BlueprintCallable, Const)

void UOFSlotWidget::Select() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSlotWidget", "Select");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationWidget.OnItemLookedAt
// (Final, Native, Public)
// Parameters:
// TSoftObjectPtr<class UItemData>         Item                                                   (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvestigationWidget::OnItemLookedAt(const TSoftObjectPtr<class UItemData> Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationWidget", "OnItemLookedAt");

	Params::InvestigationWidget_OnItemLookedAt Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationWidget.OpenExaminationViewWithItem
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemData*                        ItemData                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutomaticPlaySound                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvestigationWidget::OpenExaminationViewWithItem(const class UItemData* ItemData, const bool bAutomaticPlaySound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationWidget", "OpenExaminationViewWithItem");

	Params::InvestigationWidget_OpenExaminationViewWithItem Parms{};

	Parms.ItemData = ItemData;
	Parms.bAutomaticPlaySound = bAutomaticPlaySound;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.InvestigationWidget.ProcessOnItemLookedAt
// (Event, Public, BlueprintEvent)

void UInvestigationWidget::ProcessOnItemLookedAt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationWidget", "ProcessOnItemLookedAt");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InvestigationWidget.SetOpenObjectives
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvestigationWidget::SetOpenObjectives(const bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationWidget", "SetOpenObjectives");

	Params::InvestigationWidget_SetOpenObjectives Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationWidget.SetToMapMenu
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UInvestigationWidget::SetToMapMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationWidget", "SetToMapMenu");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.InvestigationWidget.SetupInput
// (Final, Native, Public, BlueprintCallable)

void UInvestigationWidget::SetupInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationWidget", "SetupInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationWidget.SwitchBetweenWidgetsHandler
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FInputActionValue                InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UInvestigationWidget::SwitchBetweenWidgetsHandler(const struct FInputActionValue& InputActionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationWidget", "SwitchBetweenWidgetsHandler");

	Params::InvestigationWidget_SwitchBetweenWidgetsHandler Parms{};

	Parms.InputActionValue = std::move(InputActionValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.InvestigationWidget.SwitchWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bMoveRight                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInvestigationWidget::SwitchWidget(const bool bMoveRight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InvestigationWidget", "SwitchWidget");

	Params::InvestigationWidget_SwitchWidget Parms{};

	Parms.bMoveRight = bMoveRight;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.ItemData_Clues.GetClueMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UStaticMesh*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMesh* UItemData_Clues::GetClueMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemData_Clues", "GetClueMesh");

	Params::ItemData_Clues_GetClueMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ItemPickup.TraceForPickupTransform
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class ACharacter*                       InteractingCharacter                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceCapsuleHalfRadius                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceCapsuleHalfHeight                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TraceComplex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TraceProfileName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlockingAngleThreshold                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AItemPickup::TraceForPickupTransform(const class ACharacter* InteractingCharacter, float TraceCapsuleHalfRadius, float TraceCapsuleHalfHeight, bool TraceComplex, const class FName& TraceProfileName, const float BlockingAngleThreshold, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemPickup", "TraceForPickupTransform");

	Params::ItemPickup_TraceForPickupTransform Parms{};

	Parms.InteractingCharacter = InteractingCharacter;
	Parms.TraceCapsuleHalfRadius = TraceCapsuleHalfRadius;
	Parms.TraceCapsuleHalfHeight = TraceCapsuleHalfHeight;
	Parms.TraceComplex = TraceComplex;
	Parms.TraceProfileName = TraceProfileName;
	Parms.BlockingAngleThreshold = BlockingAngleThreshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function ObsidianFox.KeyBindingTextureDataAsset.GetKeyTextures
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWorld*                           World                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FKey, TSoftObjectPtr<class UTexture2D>>ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TMap<struct FKey, TSoftObjectPtr<class UTexture2D>> UKeyBindingTextureDataAsset::GetKeyTextures(const class UWorld* World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeyBindingTextureDataAsset", "GetKeyTextures");

	Params::KeyBindingTextureDataAsset_GetKeyTextures Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.KeyBindingTextureDataAsset.GetNameForKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText                       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const class FText UKeyBindingTextureDataAsset::GetNameForKey(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeyBindingTextureDataAsset", "GetNameForKey");

	Params::KeyBindingTextureDataAsset_GetNameForKey Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.KeyBindingTextureDataAsset.GetUniversalTexture
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             KeyName                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> UKeyBindingTextureDataAsset::GetUniversalTexture(const class FText& KeyName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KeyBindingTextureDataAsset", "GetUniversalTexture");

	Params::KeyBindingTextureDataAsset_GetUniversalTexture Parms{};

	Parms.KeyName = std::move(KeyName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.LocationTrackingSubsystem.OnLocationUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FGameplayTagContainer            LocationTags                                           (Parm, NativeAccessSpecifierPublic)

void ULocationTrackingSubsystem::OnLocationUpdated__DelegateSignature(const struct FGameplayTagContainer& LocationTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTrackingSubsystem", "OnLocationUpdated__DelegateSignature");

	Params::LocationTrackingSubsystem_OnLocationUpdated__DelegateSignature Parms{};

	Parms.LocationTags = std::move(LocationTags);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.LocationTrackingSubsystem.GetCurrentLocationTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer ULocationTrackingSubsystem::GetCurrentLocationTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTrackingSubsystem", "GetCurrentLocationTags");

	Params::LocationTrackingSubsystem_GetCurrentLocationTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.LocationTrackingSubsystem.GetDercetoLocationTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ULocationTrackingSubsystem::GetDercetoLocationTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTrackingSubsystem", "GetDercetoLocationTag");

	Params::LocationTrackingSubsystem_GetDercetoLocationTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.LocationTrackingSubsystem.PlayerIsInDerceto
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULocationTrackingSubsystem::PlayerIsInDerceto() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTrackingSubsystem", "PlayerIsInDerceto");

	Params::LocationTrackingSubsystem_PlayerIsInDerceto Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.LocationTrackingSubsystem.PlayerIsInLocation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     LocationTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULocationTrackingSubsystem::PlayerIsInLocation(const struct FGameplayTag& LocationTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocationTrackingSubsystem", "PlayerIsInLocation");

	Params::LocationTrackingSubsystem_PlayerIsInLocation Parms{};

	Parms.LocationTag = std::move(LocationTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.LockAchievementTrackingComponent.Unlocked
// (Final, Native, Public, BlueprintCallable)

void ULockAchievementTrackingComponent::Unlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LockAchievementTrackingComponent", "Unlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MainMenuPT.ChangeActiveButton
// (Final, Native, Private)

void UMainMenuPT::ChangeActiveButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuPT", "ChangeActiveButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MainMenuPT.InspectButtonPressed
// (Final, Native, Public)

void UMainMenuPT::InspectButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuPT", "InspectButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MainMenuPT.LeftStickY
// (Final, Native, Public)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainMenuPT::LeftStickY(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuPT", "LeftStickY");

	Params::MainMenuPT_LeftStickY Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MainMenuPT.OnInitalize
// (Final, Native, Public, BlueprintCallable)

void UMainMenuPT::OnInitalize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuPT", "OnInitalize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MainMenuPT.OptionsButtonHoveredCallback
// (Final, Native, Protected)

void UMainMenuPT::OptionsButtonHoveredCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuPT", "OptionsButtonHoveredCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MainMenuPT.SetCanMoveWithLeftStickToTrue
// (Final, Native, Private)

void UMainMenuPT::SetCanMoveWithLeftStickToTrue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuPT", "SetCanMoveWithLeftStickToTrue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MainMenuPT.StartButtonHoveredCallback
// (Final, Native, Protected)

void UMainMenuPT::StartButtonHoveredCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuPT", "StartButtonHoveredCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MapMansionRoom.HighlightRoomName
// (Event, Public, BlueprintEvent)

void UMapMansionRoom::HighlightRoomName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapMansionRoom", "HighlightRoomName");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.MapMarkerDoorComponent.AddToMap
// (Final, Native, Public, BlueprintCallable)

void UMapMarkerDoorComponent::AddToMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapMarkerDoorComponent", "AddToMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MapMarkerDoorComponent.InteractingWithDoor
// (Final, Native, Public)
// Parameters:
// class ACharacter*                       InteractionCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapMarkerDoorComponent::InteractingWithDoor(class ACharacter* InteractionCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapMarkerDoorComponent", "InteractingWithDoor");

	Params::MapMarkerDoorComponent_InteractingWithDoor Parms{};

	Parms.InteractionCharacter = InteractionCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MapMarkerDoorComponent.OnDoorStateSetHandler
// (Final, Native, Private)
// Parameters:
// EDoorLockState                          NewLockState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDoorLockState                          OldLockState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapMarkerDoorComponent::OnDoorStateSetHandler(EDoorLockState NewLockState, EDoorLockState OldLockState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapMarkerDoorComponent", "OnDoorStateSetHandler");

	Params::MapMarkerDoorComponent_OnDoorStateSetHandler Parms{};

	Parms.NewLockState = NewLockState;
	Parms.OldLockState = OldLockState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MapMarkerPuzzleComponent.SetIsSolvable
// (Final, Native, Protected)
// Parameters:
// bool                                    bSolvable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMapMarkerPuzzleComponent::SetIsSolvable(bool bSolvable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapMarkerPuzzleComponent", "SetIsSolvable");

	Params::MapMarkerPuzzleComponent_SetIsSolvable Parms{};

	Parms.bSolvable = bSolvable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MapPositionActor.GetDistanceToMapOrthographicCamera
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMapPositionActor::GetDistanceToMapOrthographicCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapPositionActor", "GetDistanceToMapOrthographicCamera");

	Params::MapPositionActor_GetDistanceToMapOrthographicCamera Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ObsidianFox.MapTeleporter.ConvertToLightWeightSoftRef
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UWorld>            OldLevelReference                                      (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMapTeleporter::ConvertToLightWeightSoftRef(TSoftObjectPtr<class UWorld> OldLevelReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapTeleporter", "ConvertToLightWeightSoftRef");

	Params::MapTeleporter_ConvertToLightWeightSoftRef Parms{};

	Parms.OldLevelReference = OldLevelReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MapTeleporter.OnDestinationChanged
// (Event, Public, BlueprintEvent)

void AMapTeleporter::OnDestinationChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapTeleporter", "OnDestinationChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.MapTrackerVolume.ComponentBeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       InSweepResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMapTrackerVolume::ComponentBeginOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex, bool bFromSweep, const struct FHitResult& InSweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapTrackerVolume", "ComponentBeginOverlap");

	Params::MapTrackerVolume_ComponentBeginOverlap Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.InSweepResult = std::move(InSweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MapTrackerVolume.ComponentEndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              InOverlappedComponent                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOtherActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InOtherComp                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InOtherBodyIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMapTrackerVolume::ComponentEndOverlap(class UPrimitiveComponent* InOverlappedComponent, class AActor* InOtherActor, class UPrimitiveComponent* InOtherComp, int32 InOtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MapTrackerVolume", "ComponentEndOverlap");

	Params::MapTrackerVolume_ComponentEndOverlap Parms{};

	Parms.InOverlappedComponent = InOverlappedComponent;
	Parms.InOtherActor = InOtherActor;
	Parms.InOtherComp = InOtherComp;
	Parms.InOtherBodyIndex = InOtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.CancelCurrentHolster
// (Final, Native, Public, BlueprintCallable)

void UWeaponAnimationComponent::CancelCurrentHolster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "CancelCurrentHolster");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.ChangeHeldWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOFWeaponActor*                   NewWeapon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstantSwitch                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponAnimationComponent::ChangeHeldWeapon(class AOFWeaponActor* NewWeapon, bool bInstantSwitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "ChangeHeldWeapon");

	Params::WeaponAnimationComponent_ChangeHeldWeapon Parms{};

	Parms.NewWeapon = NewWeapon;
	Parms.bInstantSwitch = bInstantSwitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.HolsterWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOFWeaponActor*                   WeaponToHolster                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponAnimationComponent::HolsterWeapon(class AOFWeaponActor* WeaponToHolster, bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "HolsterWeapon");

	Params::WeaponAnimationComponent_HolsterWeapon Parms{};

	Parms.WeaponToHolster = WeaponToHolster;
	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.IsHolsterByTimerBlocked
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponAnimationComponent::IsHolsterByTimerBlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "IsHolsterByTimerBlocked");

	Params::WeaponAnimationComponent_IsHolsterByTimerBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.WeaponAnimationComponent.MoveHeldWeaponToSocket
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEquipmentSocket                        SocketLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponAnimationComponent::MoveHeldWeaponToSocket(EEquipmentSocket SocketLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "MoveHeldWeaponToSocket");

	Params::WeaponAnimationComponent_MoveHeldWeaponToSocket Parms{};

	Parms.SocketLocation = SocketLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.MoveWeaponToEquipmentSocket
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOFWeaponActor*                   Weapon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEquipmentSocket                        SocketLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponAnimationComponent::MoveWeaponToEquipmentSocket(class AOFWeaponActor* Weapon, EEquipmentSocket SocketLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "MoveWeaponToEquipmentSocket");

	Params::WeaponAnimationComponent_MoveWeaponToEquipmentSocket Parms{};

	Parms.Weapon = Weapon;
	Parms.SocketLocation = SocketLocation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.OnCombatStatusChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bInCombat                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponAnimationComponent::OnCombatStatusChanged(bool bInCombat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "OnCombatStatusChanged");

	Params::WeaponAnimationComponent_OnCombatStatusChanged Parms{};

	Parms.bInCombat = bInCombat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.OnHolsterDone
// (Final, Native, Protected)

void UWeaponAnimationComponent::OnHolsterDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "OnHolsterDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.OnMontageEndedHandleForHolster
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponAnimationComponent::OnMontageEndedHandleForHolster(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "OnMontageEndedHandleForHolster");

	Params::WeaponAnimationComponent_OnMontageEndedHandleForHolster Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.OnMontageEndedHandleForUnholster
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponAnimationComponent::OnMontageEndedHandleForUnholster(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "OnMontageEndedHandleForUnholster");

	Params::WeaponAnimationComponent_OnMontageEndedHandleForUnholster Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.OnPauseHolsterTimerMultiBoolValueChanged
// (Final, Native, Private)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponAnimationComponent::OnPauseHolsterTimerMultiBoolValueChanged(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "OnPauseHolsterTimerMultiBoolValueChanged");

	Params::WeaponAnimationComponent_OnPauseHolsterTimerMultiBoolValueChanged Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.OnUnHolsterDone
// (Final, Native, Protected)

void UWeaponAnimationComponent::OnUnHolsterDone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "OnUnHolsterDone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.OnWeaponEquip
// (Final, Native, Protected)
// Parameters:
// struct FWeaponInfo                      EquippedWeapon                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FWeaponInfo                      UnequippedWeapon                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UWeaponAnimationComponent::OnWeaponEquip(const struct FWeaponInfo& EquippedWeapon, const struct FWeaponInfo& UnequippedWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "OnWeaponEquip");

	Params::WeaponAnimationComponent_OnWeaponEquip Parms{};

	Parms.EquippedWeapon = std::move(EquippedWeapon);
	Parms.UnequippedWeapon = std::move(UnequippedWeapon);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.ParentCinematicModeStatusChangedHandler
// (Final, Native, Private)
// Parameters:
// bool                                    bIsTransitioningToCinematicMode                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponAnimationComponent::ParentCinematicModeStatusChangedHandler(bool bIsTransitioningToCinematicMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "ParentCinematicModeStatusChangedHandler");

	Params::WeaponAnimationComponent_ParentCinematicModeStatusChangedHandler Parms{};

	Parms.bIsTransitioningToCinematicMode = bIsTransitioningToCinematicMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.PauseHolsterTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          LockOwnerReference                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponAnimationComponent::PauseHolsterTimer(class UObject* LockOwnerReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "PauseHolsterTimer");

	Params::WeaponAnimationComponent_PauseHolsterTimer Parms{};

	Parms.LockOwnerReference = LockOwnerReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.ResumeHolsterTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          LockOwnerReference                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponAnimationComponent::ResumeHolsterTimer(class UObject* LockOwnerReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "ResumeHolsterTimer");

	Params::WeaponAnimationComponent_ResumeHolsterTimer Parms{};

	Parms.LockOwnerReference = LockOwnerReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.StartHolsterTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          LockOwnerReference                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponAnimationComponent::StartHolsterTimer(const class UObject* LockOwnerReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "StartHolsterTimer");

	Params::WeaponAnimationComponent_StartHolsterTimer Parms{};

	Parms.LockOwnerReference = LockOwnerReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.StopHolsterTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          LockOwnerReference                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponAnimationComponent::StopHolsterTimer(const class UObject* LockOwnerReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "StopHolsterTimer");

	Params::WeaponAnimationComponent_StopHolsterTimer Parms{};

	Parms.LockOwnerReference = LockOwnerReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.UnHolsterWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AOFWeaponActor*                   NewWeapon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInstant                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponAnimationComponent::UnHolsterWeapon(class AOFWeaponActor* NewWeapon, bool bInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "UnHolsterWeapon");

	Params::WeaponAnimationComponent_UnHolsterWeapon Parms{};

	Parms.NewWeapon = NewWeapon;
	Parms.bInstant = bInstant;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.UpdateMultiBoolReferences
// (Final, Native, Private)

void UWeaponAnimationComponent::UpdateMultiBoolReferences()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "UpdateMultiBoolReferences");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationComponent.IsHolstering
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponAnimationComponent::IsHolstering() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "IsHolstering");

	Params::WeaponAnimationComponent_IsHolstering Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.WeaponAnimationComponent.IsUnHolstering
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponAnimationComponent::IsUnHolstering() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationComponent", "IsUnHolstering");

	Params::WeaponAnimationComponent_IsUnHolstering Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.MeleeAttackHitZonesComponent.CheckIfHit
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UDamagePoint*                     DamagePoint                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMeleeAttackHitZonesComponent::CheckIfHit(const class UDamagePoint* DamagePoint, const struct FVector& HitLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeleeAttackHitZonesComponent", "CheckIfHit");

	Params::MeleeAttackHitZonesComponent_CheckIfHit Parms{};

	Parms.DamagePoint = DamagePoint;
	Parms.HitLocation = std::move(HitLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.MeleeWeaponActor.OnOverlapEnd
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeleeWeaponActor::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeleeWeaponActor", "OnOverlapEnd");

	Params::MeleeWeaponActor_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MeleeWeaponActor.RemoveImmuneActor
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeleeWeaponActor::RemoveImmuneActor(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeleeWeaponActor", "RemoveImmuneActor");

	Params::MeleeWeaponActor_RemoveImmuneActor Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.MeleeWeaponActor.WeaponAttack__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FGameplayTag                     AttackEvent                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMeleeWeaponActor::WeaponAttack__DelegateSignature(const struct FGameplayTag& AttackEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MeleeWeaponActor", "WeaponAttack__DelegateSignature");

	Params::MeleeWeaponActor_WeaponAttack__DelegateSignature Parms{};

	Parms.AttackEvent = std::move(AttackEvent);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.MenuInventorySelectionSlot.SetAsActiveSlot
// (Final, Native, Public, BlueprintCallable)

void UMenuInventorySelectionSlot::SetAsActiveSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuInventorySelectionSlot", "SetAsActiveSlot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MenuInventorySelectionSlot.SetItemSlotVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESlateVisibility                        NewVisibility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMenuInventorySelectionSlot::SetItemSlotVisibility(ESlateVisibility NewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuInventorySelectionSlot", "SetItemSlotVisibility");

	Params::MenuInventorySelectionSlot_SetItemSlotVisibility Parms{};

	Parms.NewVisibility = NewVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MenuInventorySelectionSlot.UpdateSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UItemData*                        NewItemData                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMenuInventorySelectionSlot::UpdateSlot(const class UItemData* NewItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuInventorySelectionSlot", "UpdateSlot");

	Params::MenuInventorySelectionSlot_UpdateSlot Parms{};

	Parms.NewItemData = NewItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MenuInventorySelectionSlot.UpdateSlotFromSoftReferenceData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UItemData>         NewItemData                                            (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMenuInventorySelectionSlot::UpdateSlotFromSoftReferenceData(const TSoftObjectPtr<class UItemData> NewItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuInventorySelectionSlot", "UpdateSlotFromSoftReferenceData");

	Params::MenuInventorySelectionSlot_UpdateSlotFromSoftReferenceData Parms{};

	Parms.NewItemData = NewItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MetricStatsSystem.OnCharacterDeathHandler
// (Final, Native, Public)
// Parameters:
// class AObsidianFoxCharacter*            InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMetricStatsSystem::OnCharacterDeathHandler(class AObsidianFoxCharacter* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MetricStatsSystem", "OnCharacterDeathHandler");

	Params::MetricStatsSystem_OnCharacterDeathHandler Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MetricStatsSystem.OnItemAddedHandler
// (Final, Native, Public)
// Parameters:
// class UItemData*                        InItemData                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMetricStatsSystem::OnItemAddedHandler(const class UItemData* InItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MetricStatsSystem", "OnItemAddedHandler");

	Params::MetricStatsSystem_OnItemAddedHandler Parms{};

	Parms.InItemData = InItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MetricStatsSystem.OnItemRemovedHandler
// (Final, Native, Public)
// Parameters:
// class UItemData*                        InItemData                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMetricStatsSystem::OnItemRemovedHandler(const class UItemData* InItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MetricStatsSystem", "OnItemRemovedHandler");

	Params::MetricStatsSystem_OnItemRemovedHandler Parms{};

	Parms.InItemData = InItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MetricStatsSystem.OnPuzzleSolvedGenericHandler
// (Final, Native, Public)
// Parameters:
// class APuzzleActor*                     InPuzzleActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMetricStatsSystem::OnPuzzleSolvedGenericHandler(class APuzzleActor* InPuzzleActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MetricStatsSystem", "OnPuzzleSolvedGenericHandler");

	Params::MetricStatsSystem_OnPuzzleSolvedGenericHandler Parms{};

	Parms.InPuzzleActor = InPuzzleActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MetricStatsSystem.OnSettingsChangedDelegate
// (Final, Native, Private)
// Parameters:
// class UOFGameUserSettings*              Settings                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMetricStatsSystem::OnSettingsChangedDelegate(class UOFGameUserSettings* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MetricStatsSystem", "OnSettingsChangedDelegate");

	Params::MetricStatsSystem_OnSettingsChangedDelegate Parms{};

	Parms.Settings = Settings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.MetricStatsSystem.OnWeaponFireHandler
// (Final, Native, Public)
// Parameters:
// class AHitscanWeaponActor*              InWeapon                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMetricStatsSystem::OnWeaponFireHandler(class AHitscanWeaponActor* InWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MetricStatsSystem", "OnWeaponFireHandler");

	Params::MetricStatsSystem_OnWeaponFireHandler Parms{};

	Parms.InWeapon = InWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveNotesWidget.OnActive
// (Final, Native, Public, BlueprintCallable)

void UObjectiveNotesWidget::OnActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveNotesWidget", "OnActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveNotesWidget.PlayCurrentNote
// (Final, Native, Public, BlueprintCallable)

void UObjectiveNotesWidget::PlayCurrentNote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveNotesWidget", "PlayCurrentNote");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveNotesWidget.PlayerGuidanceStateUpdatedHandler
// (Final, Native, Private)
// Parameters:
// EPlayerGuidanceSystem                   System                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bState                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveNotesWidget::PlayerGuidanceStateUpdatedHandler(EPlayerGuidanceSystem System, bool bState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveNotesWidget", "PlayerGuidanceStateUpdatedHandler");

	Params::ObjectiveNotesWidget_PlayerGuidanceStateUpdatedHandler Parms{};

	Parms.System = System;
	Parms.bState = bState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveNotesWidget.SetNewNotes
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FObjectiveChapter                ObjectiveChapterInfo                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UObjectiveNotesWidget::SetNewNotes(const struct FObjectiveChapter& ObjectiveChapterInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveNotesWidget", "SetNewNotes");

	Params::ObjectiveNotesWidget_SetNewNotes Parms{};

	Parms.ObjectiveChapterInfo = std::move(ObjectiveChapterInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObjectiveNotesWidget.SoundStoppedHandler
// (Final, Native, Public)

void UObjectiveNotesWidget::SoundStoppedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveNotesWidget", "SoundStoppedHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ObsidianFoxGameMode.Tweak
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Table                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AObsidianFoxGameMode::Tweak(const class FString& Table, const class FString& Key, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObsidianFoxGameMode", "Tweak");

	Params::ObsidianFoxGameMode_Tweak Parms{};

	Parms.Table = std::move(Table);
	Parms.Key = std::move(Key);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFActivitiesSubsystem.OnAllSavesDeletedHandler
// (Final, Native, Protected)

void UOFActivitiesSubsystem::OnAllSavesDeletedHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFActivitiesSubsystem", "OnAllSavesDeletedHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFActivitiesSubsystem.OnChapterUpdatedHandler
// (Final, Native, Protected)
// Parameters:
// struct FGameplayTag                     NewTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     OldTag                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFActivitiesSubsystem::OnChapterUpdatedHandler(const struct FGameplayTag& NewTag, const struct FGameplayTag& OldTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFActivitiesSubsystem", "OnChapterUpdatedHandler");

	Params::OFActivitiesSubsystem_OnChapterUpdatedHandler Parms{};

	Parms.NewTag = std::move(NewTag);
	Parms.OldTag = std::move(OldTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFActivitiesSubsystem.OnFactUpdatedHandler
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESubscriptionTagChangeType              ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFActivitiesSubsystem::OnFactUpdatedHandler(const struct FGameplayTag& Tag, ESubscriptionTagChangeType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFActivitiesSubsystem", "OnFactUpdatedHandler");

	Params::OFActivitiesSubsystem_OnFactUpdatedHandler Parms{};

	Parms.Tag = std::move(Tag);
	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFActivityLoadLatestSave.ChunkInstallSuccessful
// (Final, Native, Protected)

void UOFActivityLoadLatestSave::ChunkInstallSuccessful()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFActivityLoadLatestSave", "ChunkInstallSuccessful");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFActivityStory.ChunkInstallSuccessful
// (Final, Native, Protected)

void UOFActivityStory::ChunkInstallSuccessful()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFActivityStory", "ChunkInstallSuccessful");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFArchiveGridWidget.GetHasItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFArchiveGridWidget::GetHasItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFArchiveGridWidget", "GetHasItems");

	Params::OFArchiveGridWidget_GetHasItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_ActorUtils.DisableActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InDisable                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBFL_ActorUtils::DisableActor(class AActor* InActor, const bool InDisable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_ActorUtils", "DisableActor");

	Params::OFBFL_ActorUtils_DisableActor Parms{};

	Parms.InActor = InActor;
	Parms.InDisable = InDisable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBFL_ActorUtils.MoveEnemiesToSpawnLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBFL_ActorUtils::MoveEnemiesToSpawnLocation(const class UObject* WorldContextObject, const struct FVector& Origin, const float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_ActorUtils", "MoveEnemiesToSpawnLocation");

	Params::OFBFL_ActorUtils_MoveEnemiesToSpawnLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Origin = std::move(Origin);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBFL_ActorUtils.PreStreamTextures_ActorsWithTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Tag                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceUpdateTextures                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFBFL_ActorUtils::PreStreamTextures_ActorsWithTag(const class UObject* WorldContextObject, const class FName Tag, const bool ForceUpdateTextures)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_ActorUtils", "PreStreamTextures_ActorsWithTag");

	Params::OFBFL_ActorUtils_PreStreamTextures_ActorsWithTag Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Tag = Tag;
	Parms.ForceUpdateTextures = ForceUpdateTextures;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_Input.ApplyInputAxis
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AxisName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AxisValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBFL_Input::ApplyInputAxis(class UObject* Context, const class FName& AxisName, float AxisValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Input", "ApplyInputAxis");

	Params::OFBFL_Input_ApplyInputAxis Parms{};

	Parms.Context = Context;
	Parms.AxisName = AxisName;
	Parms.AxisValue = AxisValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBFL_Input.FakeInputKey
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AmountDepressed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGamepad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBFL_Input::FakeInputKey(class APlayerController* InPlayerController, const struct FKey& Key, EInputEvent EventType, float AmountDepressed, bool bGamepad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_Input", "FakeInputKey");

	Params::OFBFL_Input_FakeInputKey Parms{};

	Parms.InPlayerController = InPlayerController;
	Parms.Key = std::move(Key);
	Parms.EventType = EventType;
	Parms.AmountDepressed = AmountDepressed;
	Parms.bGamepad = bGamepad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBFL_PawnUtils.DisablePawn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APawn*                            InPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InDisable                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBFL_PawnUtils::DisablePawn(class APawn* InPawn, const bool InDisable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_PawnUtils", "DisablePawn");

	Params::OFBFL_PawnUtils_DisablePawn Parms{};

	Parms.InPawn = InPawn;
	Parms.InDisable = InDisable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBFL_UI.ActualValueToDisplayValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ActualValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ActualMaxValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ActualMinValue                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DisplayMaxValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DisplayMinValue                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::ActualValueToDisplayValue(float ActualValue, float ActualMaxValue, float ActualMinValue, float DisplayMaxValue, float DisplayMinValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "ActualValueToDisplayValue");

	Params::OFBFL_UI_ActualValueToDisplayValue Parms{};

	Parms.ActualValue = ActualValue;
	Parms.ActualMaxValue = ActualMaxValue;
	Parms.ActualMinValue = ActualMinValue;
	Parms.DisplayMaxValue = DisplayMaxValue;
	Parms.DisplayMinValue = DisplayMinValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.ActualValueToDisplayValueSens
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ActualValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::ActualValueToDisplayValueSens(const float ActualValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "ActualValueToDisplayValueSens");

	Params::OFBFL_UI_ActualValueToDisplayValueSens Parms{};

	Parms.ActualValue = ActualValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.DecrementAimSens
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::DecrementAimSens()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "DecrementAimSens");

	Params::OFBFL_UI_DecrementAimSens Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.DecrementBrightness
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::DecrementBrightness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "DecrementBrightness");

	Params::OFBFL_UI_DecrementBrightness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.DecrementCameraSens
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::DecrementCameraSens()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "DecrementCameraSens");

	Params::OFBFL_UI_DecrementCameraSens Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.DecrementContrast
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::DecrementContrast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "DecrementContrast");

	Params::OFBFL_UI_DecrementContrast Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.DeleteInGameAndPauseMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBFL_UI::DeleteInGameAndPauseMenu(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "DeleteInGameAndPauseMenu");

	Params::OFBFL_UI_DeleteInGameAndPauseMenu Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBFL_UI.DisplayValueToActualValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   DisplayValue                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ActualMaxValue                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ActualMinValue                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DisplayMaxValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DisplayMinValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::DisplayValueToActualValue(const float DisplayValue, const float ActualMaxValue, const float ActualMinValue, const float DisplayMaxValue, const float DisplayMinValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "DisplayValueToActualValue");

	Params::OFBFL_UI_DisplayValueToActualValue Parms{};

	Parms.DisplayValue = DisplayValue;
	Parms.ActualMaxValue = ActualMaxValue;
	Parms.ActualMinValue = ActualMinValue;
	Parms.DisplayMaxValue = DisplayMaxValue;
	Parms.DisplayMinValue = DisplayMinValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.DisplayValueToActualValueSens
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReadableValue                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::DisplayValueToActualValueSens(const float ReadableValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "DisplayValueToActualValueSens");

	Params::OFBFL_UI_DisplayValueToActualValueSens Parms{};

	Parms.ReadableValue = ReadableValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.GetCurrentAimSensDisplayValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::GetCurrentAimSensDisplayValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "GetCurrentAimSensDisplayValue");

	Params::OFBFL_UI_GetCurrentAimSensDisplayValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.GetCurrentBrightnessDisplayValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::GetCurrentBrightnessDisplayValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "GetCurrentBrightnessDisplayValue");

	Params::OFBFL_UI_GetCurrentBrightnessDisplayValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.GetCurrentCameraSensDisplayValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::GetCurrentCameraSensDisplayValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "GetCurrentCameraSensDisplayValue");

	Params::OFBFL_UI_GetCurrentCameraSensDisplayValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.GetCurrentContrastDisplayValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::GetCurrentContrastDisplayValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "GetCurrentContrastDisplayValue");

	Params::OFBFL_UI_GetCurrentContrastDisplayValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.GetCurrentFontForCulture
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UOFBFL_UI::GetCurrentFontForCulture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "GetCurrentFontForCulture");

	Params::OFBFL_UI_GetCurrentFontForCulture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.GetMaxAllowedFOVUserSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::GetMaxAllowedFOVUserSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "GetMaxAllowedFOVUserSettings");

	Params::OFBFL_UI_GetMaxAllowedFOVUserSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.GetMinAllowedFOVUserSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::GetMinAllowedFOVUserSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "GetMinAllowedFOVUserSettings");

	Params::OFBFL_UI_GetMinAllowedFOVUserSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.GetParentWidgetInputHandlingBase
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          InWidget                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetInputHandlingBase*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetInputHandlingBase* UOFBFL_UI::GetParentWidgetInputHandlingBase(class UWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "GetParentWidgetInputHandlingBase");

	Params::OFBFL_UI_GetParentWidgetInputHandlingBase Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.GetProjectType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EProjectType                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EProjectType UOFBFL_UI::GetProjectType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "GetProjectType");

	Params::OFBFL_UI_GetProjectType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.GetQualitySettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TMap<int32, class FText>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<int32, class FText> UOFBFL_UI::GetQualitySettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "GetQualitySettings");

	Params::OFBFL_UI_GetQualitySettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.GetQualitySettingsValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   QualityLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UOFBFL_UI::GetQualitySettingsValue(int32 QualityLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "GetQualitySettingsValue");

	Params::OFBFL_UI_GetQualitySettingsValue Parms{};

	Parms.QualityLevel = QualityLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.IncrementAimSens
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::IncrementAimSens()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "IncrementAimSens");

	Params::OFBFL_UI_IncrementAimSens Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.IncrementBrightness
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::IncrementBrightness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "IncrementBrightness");

	Params::OFBFL_UI_IncrementBrightness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.IncrementCameraSens
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::IncrementCameraSens()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "IncrementCameraSens");

	Params::OFBFL_UI_IncrementCameraSens Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.IncrementContrast
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFBFL_UI::IncrementContrast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "IncrementContrast");

	Params::OFBFL_UI_IncrementContrast Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.IsModuleLoaded
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             NameModul                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFBFL_UI::IsModuleLoaded(class FName NameModul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "IsModuleLoaded");

	Params::OFBFL_UI_IsModuleLoaded Parms{};

	Parms.NameModul = NameModul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBFL_UI.KillAllSubtitles
// (Final, Native, Static, Public, BlueprintCallable)

void UOFBFL_UI::KillAllSubtitles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBFL_UI", "KillAllSubtitles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.BlendCameraSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EEasingFunc                             Function                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendExp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCameraBlendSettingsInput        A                                                      (Parm, NativeAccessSpecifierPublic)
// struct FCameraBlendSettingsInput        B                                                      (Parm, NativeAccessSpecifierPublic)
// float                                   Alpha                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCameraBlendSettingsInput        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCameraBlendSettingsInput UOFBlueprintFunctionLibrary::BlendCameraSettings(EEasingFunc Function, float BlendExp, const struct FCameraBlendSettingsInput& A, const struct FCameraBlendSettingsInput& B, float Alpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "BlendCameraSettings");

	Params::OFBlueprintFunctionLibrary_BlendCameraSettings Parms{};

	Parms.Function = Function;
	Parms.BlendExp = BlendExp;
	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.Alpha = Alpha;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.DisableCameraModifiers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FCameraModifierCollection        ModifierCollection                                     (Parm, NativeAccessSpecifierPublic)
// bool                                    bImmediate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBlueprintFunctionLibrary::DisableCameraModifiers(const struct FCameraModifierCollection& ModifierCollection, bool bImmediate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "DisableCameraModifiers");

	Params::OFBlueprintFunctionLibrary_DisableCameraModifiers Parms{};

	Parms.ModifierCollection = std::move(ModifierCollection);
	Parms.bImmediate = bImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.DoesSprintRequireHeldInput
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFBlueprintFunctionLibrary::DoesSprintRequireHeldInput(const class UObject* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "DoesSprintRequireHeldInput");

	Params::OFBlueprintFunctionLibrary_DoesSprintRequireHeldInput Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.DoesSprintRequireHeldInput_Gamepad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFBlueprintFunctionLibrary::DoesSprintRequireHeldInput_Gamepad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "DoesSprintRequireHeldInput_Gamepad");

	Params::OFBlueprintFunctionLibrary_DoesSprintRequireHeldInput_Gamepad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.DoesSprintRequireHeldInput_KBM
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFBlueprintFunctionLibrary::DoesSprintRequireHeldInput_KBM()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "DoesSprintRequireHeldInput_KBM");

	Params::OFBlueprintFunctionLibrary_DoesSprintRequireHeldInput_KBM Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.EnableCameraModifier
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ModifierClass                                          (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCameraModifier*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCameraModifier* UOFBlueprintFunctionLibrary::EnableCameraModifier(const class UObject* WorldContextObject, TSoftClassPtr<class UClass> ModifierClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "EnableCameraModifier");

	Params::OFBlueprintFunctionLibrary_EnableCameraModifier Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ModifierClass = ModifierClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.EnableCameraModifiers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftClassPtr<class UClass>>     Modifiers                                              (Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// struct FCameraModifierCollection        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCameraModifierCollection UOFBlueprintFunctionLibrary::EnableCameraModifiers(const class UObject* WorldContextObject, const TArray<TSoftClassPtr<class UClass>>& Modifiers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "EnableCameraModifiers");

	Params::OFBlueprintFunctionLibrary_EnableCameraModifiers Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Modifiers = std::move(Modifiers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.FindSocketLocations
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class USceneComponent*                  Component                                              (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Substring                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  SocketLocations                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bExactMatch                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBlueprintFunctionLibrary::FindSocketLocations(const class USceneComponent* Component, class FName Substring, TArray<struct FVector>* SocketLocations, bool bExactMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "FindSocketLocations");

	Params::OFBlueprintFunctionLibrary_FindSocketLocations Parms{};

	Parms.Component = Component;
	Parms.Substring = Substring;
	Parms.bExactMatch = bExactMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SocketLocations != nullptr)
		*SocketLocations = std::move(Parms.SocketLocations);
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.GetAllActorsOfClassWithinRange
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ActorClass                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBlueprintFunctionLibrary::GetAllActorsOfClassWithinRange(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, TArray<class AActor*>* OutActors, const struct FVector& Origin, float Range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "GetAllActorsOfClassWithinRange");

	Params::OFBlueprintFunctionLibrary_GetAllActorsOfClassWithinRange Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActorClass = ActorClass;
	Parms.Origin = std::move(Origin);
	Parms.Range = Range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.GetClosestLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          OriginLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  Locations                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOFBlueprintFunctionLibrary::GetClosestLocation(const struct FVector& OriginLocation, const TArray<struct FVector>& Locations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "GetClosestLocation");

	Params::OFBlueprintFunctionLibrary_GetClosestLocation Parms{};

	Parms.OriginLocation = std::move(OriginLocation);
	Parms.Locations = std::move(Locations);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.GetGameplayTagChildren
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     Root                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> UOFBlueprintFunctionLibrary::GetGameplayTagChildren(const struct FGameplayTag& Root)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "GetGameplayTagChildren");

	Params::OFBlueprintFunctionLibrary_GetGameplayTagChildren Parms{};

	Parms.Root = std::move(Root);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.GetObsidianFoxPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOFPlayerController*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOFPlayerController* UOFBlueprintFunctionLibrary::GetObsidianFoxPlayerController(const class UObject* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "GetObsidianFoxPlayerController");

	Params::OFBlueprintFunctionLibrary_GetObsidianFoxPlayerController Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.GetOFGameInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UOFGameInstance*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOFGameInstance* UOFBlueprintFunctionLibrary::GetOFGameInstance(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "GetOFGameInstance");

	Params::OFBlueprintFunctionLibrary_GetOFGameInstance Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.GetOFGameUserSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UOFGameUserSettings*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOFGameUserSettings* UOFBlueprintFunctionLibrary::GetOFGameUserSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "GetOFGameUserSettings");

	Params::OFBlueprintFunctionLibrary_GetOFGameUserSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.GetOFPlayerCameraManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOFPlayerCameraManager*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOFPlayerCameraManager* UOFBlueprintFunctionLibrary::GetOFPlayerCameraManager(const class UObject* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "GetOFPlayerCameraManager");

	Params::OFBlueprintFunctionLibrary_GetOFPlayerCameraManager Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.GetSprintTreatAsHoldTag_Gamepad
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UOFBlueprintFunctionLibrary::GetSprintTreatAsHoldTag_Gamepad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "GetSprintTreatAsHoldTag_Gamepad");

	Params::OFBlueprintFunctionLibrary_GetSprintTreatAsHoldTag_Gamepad Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.GetSprintTreatAsHoldTag_KBM
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UOFBlueprintFunctionLibrary::GetSprintTreatAsHoldTag_KBM()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "GetSprintTreatAsHoldTag_KBM");

	Params::OFBlueprintFunctionLibrary_GetSprintTreatAsHoldTag_KBM Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.GetThirdPersonPlayerCameraManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AThirdPersonPlayerCameraManager*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AThirdPersonPlayerCameraManager* UOFBlueprintFunctionLibrary::GetThirdPersonPlayerCameraManager(const class UObject* WorldContextObject, int32 PlayerIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "GetThirdPersonPlayerCameraManager");

	Params::OFBlueprintFunctionLibrary_GetThirdPersonPlayerCameraManager Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerIndex = PlayerIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.GetTimespanAsText
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTimespan                        Timespan                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UOFBlueprintFunctionLibrary::GetTimespanAsText(const struct FTimespan& Timespan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "GetTimespanAsText");

	Params::OFBlueprintFunctionLibrary_GetTimespanAsText Parms{};

	Parms.Timespan = std::move(Timespan);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.HasAnyEndingAchievement
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFBlueprintFunctionLibrary::HasAnyEndingAchievement(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "HasAnyEndingAchievement");

	Params::OFBlueprintFunctionLibrary_HasAnyEndingAchievement Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.IsNewGamePlus
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFBlueprintFunctionLibrary::IsNewGamePlus(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "IsNewGamePlus");

	Params::OFBlueprintFunctionLibrary_IsNewGamePlus Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.IsNewGamePlusAvailable
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFBlueprintFunctionLibrary::IsNewGamePlusAvailable(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "IsNewGamePlusAvailable");

	Params::OFBlueprintFunctionLibrary_IsNewGamePlusAvailable Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.SetGameFinished
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBlueprintFunctionLibrary::SetGameFinished(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "SetGameFinished");

	Params::OFBlueprintFunctionLibrary_SetGameFinished Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.SetSprintRequiresHeldInput_Gamepad
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewRequireHeld                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFBlueprintFunctionLibrary::SetSprintRequiresHeldInput_Gamepad(bool bNewRequireHeld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "SetSprintRequiresHeldInput_Gamepad");

	Params::OFBlueprintFunctionLibrary_SetSprintRequiresHeldInput_Gamepad Parms{};

	Parms.bNewRequireHeld = bNewRequireHeld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.SetSprintRequiresHeldInput_KBM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewRequireHeld                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFBlueprintFunctionLibrary::SetSprintRequiresHeldInput_KBM(bool bNewRequireHeld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "SetSprintRequiresHeldInput_KBM");

	Params::OFBlueprintFunctionLibrary_SetSprintRequiresHeldInput_KBM Parms{};

	Parms.bNewRequireHeld = bNewRequireHeld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.UnloadLevelsForStreamingVolumes
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class ALevelStreamingVolume>>StreamingVolumes                                       (Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    BlockUntilStreamingUpdated                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DisableVolumes                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DisableMinTimeBetweenUnloadRequests                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBlueprintFunctionLibrary::UnloadLevelsForStreamingVolumes(const class UObject* WorldContextObject, const TArray<TSoftObjectPtr<class ALevelStreamingVolume>>& StreamingVolumes, bool BlockUntilStreamingUpdated, bool DisableVolumes, bool DisableMinTimeBetweenUnloadRequests)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "UnloadLevelsForStreamingVolumes");

	Params::OFBlueprintFunctionLibrary_UnloadLevelsForStreamingVolumes Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.StreamingVolumes = std::move(StreamingVolumes);
	Parms.BlockUntilStreamingUpdated = BlockUntilStreamingUpdated;
	Parms.DisableVolumes = DisableVolumes;
	Parms.DisableMinTimeBetweenUnloadRequests = DisableMinTimeBetweenUnloadRequests;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBlueprintFunctionLibrary.WriteErrorToMessageLog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ErrorMessage                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFBlueprintFunctionLibrary::WriteErrorToMessageLog(const class FString& ErrorMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFBlueprintFunctionLibrary", "WriteErrorToMessageLog");

	Params::OFBlueprintFunctionLibrary_WriteErrorToMessageLog Parms{};

	Parms.ErrorMessage = std::move(ErrorMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBoids.ActivateBoids
// (Final, Native, Public, BlueprintCallable)

void AOFBoids::ActivateBoids()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFBoids", "ActivateBoids");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFBoids.DeactivateBoids
// (Final, Native, Public, BlueprintCallable)

void AOFBoids::DeactivateBoids()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFBoids", "DeactivateBoids");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFButton.ButtonOnHovered
// (Final, Native, Private)

void UOFButton::ButtonOnHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFButton", "ButtonOnHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFButton.ButtonUnHovered
// (Final, Native, Private)

void UOFButton::ButtonUnHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFButton", "ButtonUnHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFButton.CallOnHoveredEvent
// (Final, Native, Public, BlueprintCallable)

void UOFButton::CallOnHoveredEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFButton", "CallOnHoveredEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.TurnInPlaceAsyncAction.RequestTurnInPlace
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AObsidianFoxCharacter*            Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RequestedAngleDegrees                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTurnInPlaceAsyncAction*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTurnInPlaceAsyncAction* UTurnInPlaceAsyncAction::RequestTurnInPlace(class AObsidianFoxCharacter* Character, float RequestedAngleDegrees)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TurnInPlaceAsyncAction", "RequestTurnInPlace");

	Params::TurnInPlaceAsyncAction_RequestTurnInPlace Parms{};

	Parms.Character = Character;
	Parms.RequestedAngleDegrees = RequestedAngleDegrees;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.TurnInPlaceAsyncAction.OnTurnInPlaceEnded
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       TurningCharacter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsBlendingOutToWalk                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTurnInPlaceAsyncAction::OnTurnInPlaceEnded(class ACharacter* TurningCharacter, bool bIsBlendingOutToWalk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TurnInPlaceAsyncAction", "OnTurnInPlaceEnded");

	Params::TurnInPlaceAsyncAction_OnTurnInPlaceEnded Parms{};

	Parms.TurningCharacter = TurningCharacter;
	Parms.bIsBlendingOutToWalk = bIsBlendingOutToWalk;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.TurnInPlaceAsyncAction.OnTurnInPlaceFailedAngleTooSmall
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       TurningCharacter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTurnInPlaceAsyncAction::OnTurnInPlaceFailedAngleTooSmall(class ACharacter* TurningCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TurnInPlaceAsyncAction", "OnTurnInPlaceFailedAngleTooSmall");

	Params::TurnInPlaceAsyncAction_OnTurnInPlaceFailedAngleTooSmall Parms{};

	Parms.TurningCharacter = TurningCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.TurnInPlaceAsyncAction.TurnInPlaceTaskEnd__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UTurnInPlaceAsyncAction::TurnInPlaceTaskEnd__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TurnInPlaceAsyncAction", "TurnInPlaceTaskEnd__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.OFCharacterMovementComponent.DisableRootMotion
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    RootMotionDisabled                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCharacterMovementComponent::DisableRootMotion(bool RootMotionDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "DisableRootMotion");

	Params::OFCharacterMovementComponent_DisableRootMotion Parms{};

	Parms.RootMotionDisabled = RootMotionDisabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.DisableTurnRadius
// (Final, Native, Public, BlueprintCallable)

void UOFCharacterMovementComponent::DisableTurnRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "DisableTurnRadius");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.DisableVelocityModifyingAnimationCurves
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          LockReference                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCharacterMovementComponent::DisableVelocityModifyingAnimationCurves(const class UObject* LockReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "DisableVelocityModifyingAnimationCurves");

	Params::OFCharacterMovementComponent_DisableVelocityModifyingAnimationCurves Parms{};

	Parms.LockReference = LockReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.EnableTurnRadius
// (Final, Native, Public, BlueprintCallable)

void UOFCharacterMovementComponent::EnableTurnRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "EnableTurnRadius");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.EnableVelocityModifyingAnimationCurves
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          LockReference                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCharacterMovementComponent::EnableVelocityModifyingAnimationCurves(const class UObject* LockReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "EnableVelocityModifyingAnimationCurves");

	Params::OFCharacterMovementComponent_EnableVelocityModifyingAnimationCurves Parms{};

	Parms.LockReference = LockReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.EndTurnInPlace
// (Final, Native, Public, BlueprintCallable)

void UOFCharacterMovementComponent::EndTurnInPlace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "EndTurnInPlace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.IsFocusWalk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFCharacterMovementComponent::IsFocusWalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "IsFocusWalk");

	Params::OFCharacterMovementComponent_IsFocusWalk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFCharacterMovementComponent.K2_EndFastTurn
// (Final, Native, Public, BlueprintCallable)

void UOFCharacterMovementComponent::K2_EndFastTurn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "K2_EndFastTurn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.LockInput
// (Final, Native, Public, BlueprintCallable)

void UOFCharacterMovementComponent::LockInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "LockInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.OFCharacterMovementComponent.OnMovementModeChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// EMovementMode                           PreviousMovementMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           NewMovementMode                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCharacterMovementComponent::OnMovementModeChanged__DelegateSignature(EMovementMode PreviousMovementMode, EMovementMode NewMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "OnMovementModeChanged__DelegateSignature");

	Params::OFCharacterMovementComponent_OnMovementModeChanged__DelegateSignature Parms{};

	Parms.PreviousMovementMode = PreviousMovementMode;
	Parms.NewMovementMode = NewMovementMode;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OFCharacterMovementComponent.OnOwnerAim
// (Final, Native, Protected)
// Parameters:
// bool                                    IsAiming                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCharacterMovementComponent::OnOwnerAim(bool IsAiming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "OnOwnerAim");

	Params::OFCharacterMovementComponent_OnOwnerAim Parms{};

	Parms.IsAiming = IsAiming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.ReleaseLockedInput
// (Final, Native, Public, BlueprintCallable)

void UOFCharacterMovementComponent::ReleaseLockedInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "ReleaseLockedInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.ReleaseRootMotionTranslation
// (Final, Native, Public, BlueprintCallable)

void UOFCharacterMovementComponent::ReleaseRootMotionTranslation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "ReleaseRootMotionTranslation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.RootMotionEnd
// (Final, Native, Public)
// Parameters:
// class UObject*                          LockOwner                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Force                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCharacterMovementComponent::RootMotionEnd(const class UObject* LockOwner, bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "RootMotionEnd");

	Params::OFCharacterMovementComponent_RootMotionEnd Parms{};

	Parms.LockOwner = LockOwner;
	Parms.Force = Force;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.RootMotionStart
// (Final, Native, Public)
// Parameters:
// class UObject*                          LockOwner                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ApplyTranslation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ApplyRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsRotationAbsolute                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFCharacterMovementComponent::RootMotionStart(const class UObject* LockOwner, bool ApplyTranslation, bool ApplyRotation, bool IsRotationAbsolute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "RootMotionStart");

	Params::OFCharacterMovementComponent_RootMotionStart Parms{};

	Parms.LockOwner = LockOwner;
	Parms.ApplyTranslation = ApplyTranslation;
	Parms.ApplyRotation = ApplyRotation;
	Parms.IsRotationAbsolute = IsRotationAbsolute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFCharacterMovementComponent.RootMotionUpdate
// (Final, Native, Protected)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCharacterMovementComponent::RootMotionUpdate(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "RootMotionUpdate");

	Params::OFCharacterMovementComponent_RootMotionUpdate Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.SetBaseMovementSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCharacterMovementComponent::SetBaseMovementSpeed(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "SetBaseMovementSpeed");

	Params::OFCharacterMovementComponent_SetBaseMovementSpeed Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.SetRootMotionData
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// float                                   InRootMotionSpeed                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InRootMotionMoveDir                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         InRootMotionRotation                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UOFCharacterMovementComponent::SetRootMotionData(float InRootMotionSpeed, const struct FVector& InRootMotionMoveDir, const struct FRotator& InRootMotionRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "SetRootMotionData");

	Params::OFCharacterMovementComponent_SetRootMotionData Parms{};

	Parms.InRootMotionSpeed = InRootMotionSpeed;
	Parms.InRootMotionMoveDir = std::move(InRootMotionMoveDir);
	Parms.InRootMotionRotation = std::move(InRootMotionRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.OFCharacterMovementComponent.SprintStateChangeSignature__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bIsSprinting_0                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCharacterMovementComponent::SprintStateChangeSignature__DelegateSignature(bool bIsSprinting_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "SprintStateChangeSignature__DelegateSignature");

	Params::OFCharacterMovementComponent_SprintStateChangeSignature__DelegateSignature Parms{};

	Parms.bIsSprinting_0 = bIsSprinting_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OFCharacterMovementComponent.StartSprint
// (Final, Native, Public, BlueprintCallable)

void UOFCharacterMovementComponent::StartSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "StartSprint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.StopSprint
// (Final, Native, Public, BlueprintCallable)

void UOFCharacterMovementComponent::StopSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "StopSprint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.TurnInPlaceBranchToWalkIfAppropriate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          LockOwner                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCharacterMovementComponent::TurnInPlaceBranchToWalkIfAppropriate(const class UObject* LockOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "TurnInPlaceBranchToWalkIfAppropriate");

	Params::OFCharacterMovementComponent_TurnInPlaceBranchToWalkIfAppropriate Parms{};

	Parms.LockOwner = LockOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterMovementComponent.TurnInPlaceCacheInputForEndBranch
// (Final, Native, Public, BlueprintCallable)

void UOFCharacterMovementComponent::TurnInPlaceCacheInputForEndBranch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "TurnInPlaceCacheInputForEndBranch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.OFCharacterMovementComponent.TurnInPlaceEnd__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ACharacter*                       TurningCharacter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsBlendingOutToWalk                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCharacterMovementComponent::TurnInPlaceEnd__DelegateSignature(class ACharacter* TurningCharacter, bool bIsBlendingOutToWalk)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "TurnInPlaceEnd__DelegateSignature");

	Params::OFCharacterMovementComponent_TurnInPlaceEnd__DelegateSignature Parms{};

	Parms.TurningCharacter = TurningCharacter;
	Parms.bIsBlendingOutToWalk = bIsBlendingOutToWalk;

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.OFCharacterMovementComponent.TurnInPlaceFailed__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class ACharacter*                       TurningCharacter                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCharacterMovementComponent::TurnInPlaceFailed__DelegateSignature(class ACharacter* TurningCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "TurnInPlaceFailed__DelegateSignature");

	Params::OFCharacterMovementComponent_TurnInPlaceFailed__DelegateSignature Parms{};

	Parms.TurningCharacter = TurningCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OFCharacterMovementComponent.GetCurrentMoveSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFCharacterMovementComponent::GetCurrentMoveSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "GetCurrentMoveSpeed");

	Params::OFCharacterMovementComponent_GetCurrentMoveSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFCharacterMovementComponent.GetCurrentVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UOFCharacterMovementComponent::GetCurrentVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "GetCurrentVelocity");

	Params::OFCharacterMovementComponent_GetCurrentVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFCharacterMovementComponent.GetLockedRotationAngleDegrees
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFCharacterMovementComponent::GetLockedRotationAngleDegrees() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "GetLockedRotationAngleDegrees");

	Params::OFCharacterMovementComponent_GetLockedRotationAngleDegrees Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFCharacterMovementComponent.GetRequestedTurnAngle
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFCharacterMovementComponent::GetRequestedTurnAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "GetRequestedTurnAngle");

	Params::OFCharacterMovementComponent_GetRequestedTurnAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFCharacterMovementComponent.GetRootMotionState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFCharacterMovementComponent::GetRootMotionState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "GetRootMotionState");

	Params::OFCharacterMovementComponent_GetRootMotionState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFCharacterMovementComponent.IsFastTurn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFCharacterMovementComponent::IsFastTurn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "IsFastTurn");

	Params::OFCharacterMovementComponent_IsFastTurn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFCharacterMovementComponent.IsTurningInPlace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFCharacterMovementComponent::IsTurningInPlace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterMovementComponent", "IsTurningInPlace");

	Params::OFCharacterMovementComponent_IsTurningInPlace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFCharacterNoiseEmitter.FootstepNoise
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          StepLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCharacterNoiseEmitter::FootstepNoise(const struct FVector& StepLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterNoiseEmitter", "FootstepNoise");

	Params::OFCharacterNoiseEmitter_FootstepNoise Parms{};

	Parms.StepLocation = std::move(StepLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterNoiseEmitter.FootstepNoise_Internal
// (Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// struct FVector                          StepLocation                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFootType                               FootStepType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BoneName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCharacterNoiseEmitter::FootstepNoise_Internal(const struct FVector& StepLocation, EFootType FootStepType, const class FName& BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterNoiseEmitter", "FootstepNoise_Internal");

	Params::OFCharacterNoiseEmitter_FootstepNoise_Internal Parms{};

	Parms.StepLocation = std::move(StepLocation);
	Parms.FootStepType = FootStepType;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterNoiseEmitter.FootstepsCanMakeNoise
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFCharacterNoiseEmitter::FootstepsCanMakeNoise() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterNoiseEmitter", "FootstepsCanMakeNoise");

	Params::OFCharacterNoiseEmitter_FootstepsCanMakeNoise Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFCharacterNoiseEmitter.GetFootstepLoudness
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFCharacterNoiseEmitter::GetFootstepLoudness() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterNoiseEmitter", "GetFootstepLoudness");

	Params::OFCharacterNoiseEmitter_GetFootstepLoudness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFCharacterNoiseEmitter.GetFootstepNoiseMaxRange
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFCharacterNoiseEmitter::GetFootstepNoiseMaxRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCharacterNoiseEmitter", "GetFootstepNoiseMaxRange");

	Params::OFCharacterNoiseEmitter_GetFootstepNoiseMaxRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFCheatManager.AddAllPuzzleItems
// (Final, Exec, Native, Private)

void UOFCheatManager::AddAllPuzzleItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "AddAllPuzzleItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.BuildVersion
// (Final, Exec, Native, Private)

void UOFCheatManager::BuildVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "BuildVersion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.CheatDebugCrosshair
// (Final, Exec, Native, Private)

void UOFCheatManager::CheatDebugCrosshair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "CheatDebugCrosshair");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.CheatHelp
// (Final, Exec, Native, Private)

void UOFCheatManager::CheatHelp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "CheatHelp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.CheatImmortal
// (Final, Exec, Native, Private)
// Parameters:
// int32                                   Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::CheatImmortal(int32 Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "CheatImmortal");

	Params::OFCheatManager_CheatImmortal Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.CheatKillAllEnemies
// (Event, Public, BlueprintEvent)

void UOFCheatManager::CheatKillAllEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "CheatKillAllEnemies");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.OFCheatManager.CheatMonsterAIDebugText
// (Final, Exec, Native, Private)
// Parameters:
// int32                                   Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::CheatMonsterAIDebugText(int32 Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "CheatMonsterAIDebugText");

	Params::OFCheatManager_CheatMonsterAIDebugText Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.CheatMonsterHealthbar
// (Final, Exec, Native, Private)
// Parameters:
// int32                                   Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::CheatMonsterHealthbar(int32 Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "CheatMonsterHealthbar");

	Params::OFCheatManager_CheatMonsterHealthbar Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.CheatScreenshot
// (Final, Exec, Native, Private)

void UOFCheatManager::CheatScreenshot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "CheatScreenshot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.CheatSpirit
// (Final, Exec, Native, Private)
// Parameters:
// int32                                   Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::CheatSpirit(int32 Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "CheatSpirit");

	Params::OFCheatManager_CheatSpirit Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.CheatUnlockAllDoors
// (Final, Exec, Native, Private)

void UOFCheatManager::CheatUnlockAllDoors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "CheatUnlockAllDoors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.CheatUnlockAllDoorsNativeEvent
// (Native, Event, Public, BlueprintEvent)

void UOFCheatManager::CheatUnlockAllDoorsNativeEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "CheatUnlockAllDoorsNativeEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.ClearSavedFmodParameters
// (Final, Exec, Native, Private)

void UOFCheatManager::ClearSavedFmodParameters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "ClearSavedFmodParameters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.CompleteAchievement
// (Final, Exec, Native, Private)
// Parameters:
// class FString                           AchievementId                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::CompleteAchievement(const class FString& AchievementId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "CompleteAchievement");

	Params::OFCheatManager_CompleteAchievement Parms{};

	Parms.AchievementId = std::move(AchievementId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.DbgCamera
// (Final, Exec, Native, Private)

void UOFCheatManager::DbgCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "DbgCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.EnvironmentDebugMessages
// (Final, Exec, Native, Private)

void UOFCheatManager::EnvironmentDebugMessages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "EnvironmentDebugMessages");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.FmodSetControllerOutputBusPortIndex
// (Final, Exec, Native, Private)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::FmodSetControllerOutputBusPortIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "FmodSetControllerOutputBusPortIndex");

	Params::OFCheatManager_FmodSetControllerOutputBusPortIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.ForceSpawnDynamicActors
// (Final, Exec, Native, Private)

void UOFCheatManager::ForceSpawnDynamicActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "ForceSpawnDynamicActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.GetAllItemsFromChapter
// (Final, Exec, Native, Private)
// Parameters:
// int32                                   Chapter                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShowPopup                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::GetAllItemsFromChapter(int32 Chapter, bool bShowPopup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "GetAllItemsFromChapter");

	Params::OFCheatManager_GetAllItemsFromChapter Parms{};

	Parms.Chapter = Chapter;
	Parms.bShowPopup = bShowPopup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.HackTeleport
// (Final, Exec, Native, Private)
// Parameters:
// class FString                           InKey                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::HackTeleport(const class FString& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "HackTeleport");

	Params::OFCheatManager_HackTeleport Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.LoadFromSlot
// (Final, Exec, Native, Private)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::LoadFromSlot(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "LoadFromSlot");

	Params::OFCheatManager_LoadFromSlot Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.OFTeleportTo
// (Final, Exec, Native, Private)
// Parameters:
// class FString                           InDest                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::OFTeleportTo(const class FString& InDest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "OFTeleportTo");

	Params::OFCheatManager_OFTeleportTo Parms{};

	Parms.InDest = std::move(InDest);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.OnCheatDebugCrosshair
// (Native, Event, Public, BlueprintEvent)

void UOFCheatManager::OnCheatDebugCrosshair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "OnCheatDebugCrosshair");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.OnCheatHelp
// (Native, Event, Public, BlueprintEvent)

void UOFCheatManager::OnCheatHelp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "OnCheatHelp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.OnPostInitStartSpotHandler
// (Final, Native, Protected)

void UOFCheatManager::OnPostInitStartSpotHandler()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "OnPostInitStartSpotHandler");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.OverrideVODelayTime
// (Final, Exec, Native, Private)
// Parameters:
// float                                   InDelay                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::OverrideVODelayTime(const float InDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "OverrideVODelayTime");

	Params::OFCheatManager_OverrideVODelayTime Parms{};

	Parms.InDelay = InDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.OverrideVOIndex
// (Final, Exec, Native, Private)
// Parameters:
// int32                                   InIndex                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::OverrideVOIndex(const int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "OverrideVOIndex");

	Params::OFCheatManager_OverrideVOIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.PrintCollisionResponseForPlayer
// (Final, Exec, Native, Private)

void UOFCheatManager::PrintCollisionResponseForPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "PrintCollisionResponseForPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.PrintMainState
// (Final, Exec, Native, Private)

void UOFCheatManager::PrintMainState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "PrintMainState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.PrintSavedFmodParameters
// (Final, Exec, Native, Private)

void UOFCheatManager::PrintSavedFmodParameters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "PrintSavedFmodParameters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.QueryDLCStatus
// (Final, Exec, Native, Private)

void UOFCheatManager::QueryDLCStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "QueryDLCStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.QuickLoad
// (Final, Exec, Native, Private)

void UOFCheatManager::QuickLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "QuickLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.QuickSave
// (Final, Exec, Native, Private)

void UOFCheatManager::QuickSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "QuickSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.RefreshPersistenceComponents
// (Final, Exec, Native, Private)

void UOFCheatManager::RefreshPersistenceComponents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "RefreshPersistenceComponents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.ResetAchievements
// (Final, Exec, Native, Private)

void UOFCheatManager::ResetAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "ResetAchievements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SaveToSlot
// (Final, Exec, Native, Private)
// Parameters:
// int32                                   SlotIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SaveToSlot(int32 SlotIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SaveToSlot");

	Params::OFCheatManager_SaveToSlot Parms{};

	Parms.SlotIndex = SlotIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetCamDefaultTargetArmLength
// (Final, Exec, Native, Private)
// Parameters:
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetCamDefaultTargetArmLength(float Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetCamDefaultTargetArmLength");

	Params::OFCheatManager_SetCamDefaultTargetArmLength Parms{};

	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetCamRelativeOffset
// (Final, Exec, Native, Private, HasDefaults)
// Parameters:
// struct FVector                          Vector                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetCamRelativeOffset(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetCamRelativeOffset");

	Params::OFCheatManager_SetCamRelativeOffset Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetCamRelativeOffsetX
// (Final, Exec, Native, Private)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetCamRelativeOffsetX(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetCamRelativeOffsetX");

	Params::OFCheatManager_SetCamRelativeOffsetX Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetCamRelativeOffsetY
// (Final, Exec, Native, Private)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetCamRelativeOffsetY(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetCamRelativeOffsetY");

	Params::OFCheatManager_SetCamRelativeOffsetY Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetCamRelativeOffsetZ
// (Final, Exec, Native, Private)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetCamRelativeOffsetZ(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetCamRelativeOffsetZ");

	Params::OFCheatManager_SetCamRelativeOffsetZ Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetCamSocketOffset
// (Final, Exec, Native, Private, HasDefaults)
// Parameters:
// struct FVector                          Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetCamSocketOffset(const struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetCamSocketOffset");

	Params::OFCheatManager_SetCamSocketOffset Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetCamSocketOffsetX
// (Final, Exec, Native, Private)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetCamSocketOffsetX(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetCamSocketOffsetX");

	Params::OFCheatManager_SetCamSocketOffsetX Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetCamSocketOffsetY
// (Final, Exec, Native, Private)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetCamSocketOffsetY(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetCamSocketOffsetY");

	Params::OFCheatManager_SetCamSocketOffsetY Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetCamSocketOffsetZ
// (Final, Exec, Native, Private)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetCamSocketOffsetZ(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetCamSocketOffsetZ");

	Params::OFCheatManager_SetCamSocketOffsetZ Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetCharacter1982Effect
// (Final, Exec, Native, Private)
// Parameters:
// bool                                    InEnable1982CharacterEffect                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InHDR                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetCharacter1982Effect(bool InEnable1982CharacterEffect, bool InHDR)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetCharacter1982Effect");

	Params::OFCheatManager_SetCharacter1982Effect Parms{};

	Parms.InEnable1982CharacterEffect = InEnable1982CharacterEffect;
	Parms.InHDR = InHDR;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetCollisionResponseToAllChannelsForPlayer
// (Final, Exec, Native, Private)
// Parameters:
// class FString                           InName                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCollisionChannel                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCollisionResponse                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetCollisionResponseToAllChannelsForPlayer(const class FString& InName, const int32 InCollisionChannel, const int32 InCollisionResponse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetCollisionResponseToAllChannelsForPlayer");

	Params::OFCheatManager_SetCollisionResponseToAllChannelsForPlayer Parms{};

	Parms.InName = std::move(InName);
	Parms.InCollisionChannel = InCollisionChannel;
	Parms.InCollisionResponse = InCollisionResponse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetExtraFilter
// (Final, Exec, Native, Private)
// Parameters:
// EPostEffectExtra                        InExtraEffect                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InHDR                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetExtraFilter(EPostEffectExtra InExtraEffect, bool InHDR)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetExtraFilter");

	Params::OFCheatManager_SetExtraFilter Parms{};

	Parms.InExtraEffect = InExtraEffect;
	Parms.InHDR = InHDR;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetFactValue
// (Final, Exec, Native, Private)
// Parameters:
// class FString                           InFactTagStr                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetFactValue(const class FString& InFactTagStr, int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetFactValue");

	Params::OFCheatManager_SetFactValue Parms{};

	Parms.InFactTagStr = std::move(InFactTagStr);
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetLightbarEffect
// (Final, Exec, Native, Private)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   R                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   G                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   B                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   A                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetLightbarEffect(bool bEnabled, uint8 R, uint8 G, uint8 B, uint8 A)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetLightbarEffect");

	Params::OFCheatManager_SetLightbarEffect Parms{};

	Parms.bEnabled = bEnabled;
	Parms.R = R;
	Parms.G = G;
	Parms.B = B;
	Parms.A = A;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetNewGamePlus
// (Final, Exec, Native, Private)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetNewGamePlus(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetNewGamePlus");

	Params::OFCheatManager_SetNewGamePlus Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetPlayerDebugLightCastShadows
// (Final, Exec, Native, Private)
// Parameters:
// bool                                    InCastShadows                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetPlayerDebugLightCastShadows(const bool InCastShadows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetPlayerDebugLightCastShadows");

	Params::OFCheatManager_SetPlayerDebugLightCastShadows Parms{};

	Parms.InCastShadows = InCastShadows;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetPlayerDebugLightIntensity
// (Final, Exec, Native, Private)
// Parameters:
// float                                   InIntensity                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetPlayerDebugLightIntensity(const float InIntensity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetPlayerDebugLightIntensity");

	Params::OFCheatManager_SetPlayerDebugLightIntensity Parms{};

	Parms.InIntensity = InIntensity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetPlayerDebugLightSourceRadius
// (Final, Exec, Native, Private)
// Parameters:
// float                                   InSourceRadius                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetPlayerDebugLightSourceRadius(const float InSourceRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetPlayerDebugLightSourceRadius");

	Params::OFCheatManager_SetPlayerDebugLightSourceRadius Parms{};

	Parms.InSourceRadius = InSourceRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetTriggerFeedbackEffect
// (Final, Exec, Native, Private)
// Parameters:
// bool                                    bRightTrigger                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetTriggerFeedbackEffect(bool bRightTrigger, uint8 Position, uint8 Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetTriggerFeedbackEffect");

	Params::OFCheatManager_SetTriggerFeedbackEffect Parms{};

	Parms.bRightTrigger = bRightTrigger;
	Parms.Position = Position;
	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetTriggerVibrationEffect
// (Final, Exec, Native, Private)
// Parameters:
// bool                                    bRightTrigger                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Frequency                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Amplitude                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetTriggerVibrationEffect(bool bRightTrigger, uint8 Position, uint8 Frequency, uint8 Amplitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetTriggerVibrationEffect");

	Params::OFCheatManager_SetTriggerVibrationEffect Parms{};

	Parms.bRightTrigger = bRightTrigger;
	Parms.Position = Position;
	Parms.Frequency = Frequency;
	Parms.Amplitude = Amplitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SetTriggerWeaponEffect
// (Final, Exec, Native, Private)
// Parameters:
// bool                                    bRightTrigger                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   StartPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   EndPosition                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SetTriggerWeaponEffect(bool bRightTrigger, uint8 StartPosition, uint8 EndPosition, uint8 Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SetTriggerWeaponEffect");

	Params::OFCheatManager_SetTriggerWeaponEffect Parms{};

	Parms.bRightTrigger = bRightTrigger;
	Parms.StartPosition = StartPosition;
	Parms.EndPosition = EndPosition;
	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SimulateDLCOwnership
// (Final, Exec, Native, Private)
// Parameters:
// bool                                    DLCOwned                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SimulateDLCOwnership(bool DLCOwned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SimulateDLCOwnership");

	Params::OFCheatManager_SimulateDLCOwnership Parms{};

	Parms.DLCOwned = DLCOwned;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.SwitchPlayerCharacter
// (Final, Exec, Native, Private)
// Parameters:
// EPlayerCharacterType                    InCharacterType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::SwitchPlayerCharacter(EPlayerCharacterType InCharacterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "SwitchPlayerCharacter");

	Params::OFCheatManager_SwitchPlayerCharacter Parms{};

	Parms.InCharacterType = InCharacterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.TeleportToSequence
// (Final, Exec, Native, Private)
// Parameters:
// class FString                           SubStr                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::TeleportToSequence(const class FString& SubStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "TeleportToSequence");

	Params::OFCheatManager_TeleportToSequence Parms{};

	Parms.SubStr = std::move(SubStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.ToggleAchievementDebugInfo
// (Final, Exec, Native, Private)

void UOFCheatManager::ToggleAchievementDebugInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "ToggleAchievementDebugInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.TryToStartSequence
// (Final, Exec, Native, Private)
// Parameters:
// class FString                           SubStr                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::TryToStartSequence(const class FString& SubStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "TryToStartSequence");

	Params::OFCheatManager_TryToStartSequence Parms{};

	Parms.SubStr = std::move(SubStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.TryToStartSequenceAfterTeleport
// (Final, Exec, Native, Private)

void UOFCheatManager::TryToStartSequenceAfterTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "TryToStartSequenceAfterTeleport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.DumpFacts
// (Final, Exec, Native, Private, Const)
// Parameters:
// bool                                    bAllowOverwriting                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bExportForUnreal                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::DumpFacts(bool bAllowOverwriting, bool bExportForUnreal, const class FString& Filename) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "DumpFacts");

	Params::OFCheatManager_DumpFacts Parms{};

	Parms.bAllowOverwriting = bAllowOverwriting;
	Parms.bExportForUnreal = bExportForUnreal;
	Parms.Filename = std::move(Filename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.ObsessionLock
// (Final, Exec, Native, Private, Const)
// Parameters:
// bool                                    bLock                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::ObsessionLock(bool bLock) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "ObsessionLock");

	Params::OFCheatManager_ObsessionLock Parms{};

	Parms.bLock = bLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.ObsessionOverride
// (Final, Exec, Native, Private, Const)
// Parameters:
// float                                   Obsession                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::ObsessionOverride(float Obsession) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "ObsessionOverride");

	Params::OFCheatManager_ObsessionOverride Parms{};

	Parms.Obsession = Obsession;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.ObsessionPrint
// (Final, Exec, Native, Private, Const)

void UOFCheatManager::ObsessionPrint() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "ObsessionPrint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.VerboseFacts
// (Final, Exec, Native, Private, Const)
// Parameters:
// bool                                    bVerboseFactsEnabled                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::VerboseFacts(const bool bVerboseFactsEnabled) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "VerboseFacts");

	Params::OFCheatManager_VerboseFacts Parms{};

	Parms.bVerboseFactsEnabled = bVerboseFactsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheatManager.VerboseFactsDuration
// (Final, Exec, Native, Private, Const)
// Parameters:
// int32                                   Duration                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCheatManager::VerboseFactsDuration(const int32 Duration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheatManager", "VerboseFactsDuration");

	Params::OFCheatManager_VerboseFactsDuration Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCheckBoxUserWidget.OnCheckBoxPressed
// (Final, Native, Private)

void UOFCheckBoxUserWidget::OnCheckBoxPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCheckBoxUserWidget", "OnCheckBoxPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFChildActorComponent.ActivateChild
// (Final, Native, Private)

void UOFChildActorComponent::ActivateChild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFChildActorComponent", "ActivateChild");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFChildActorComponent.DeactivateChild
// (Final, Native, Private)

void UOFChildActorComponent::DeactivateChild()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFChildActorComponent", "DeactivateChild");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFChunkInstallPopupWidget.SetChunkIndex
// (Final, Native, Public)
// Parameters:
// int32                                   NewChunkIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFChunkInstallPopupWidget::SetChunkIndex(const int32 NewChunkIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFChunkInstallPopupWidget", "SetChunkIndex");

	Params::OFChunkInstallPopupWidget_SetChunkIndex Parms{};

	Parms.NewChunkIndex = NewChunkIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFChunkInstallPopupWidget.SetMessage
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             _strText                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOFChunkInstallPopupWidget::SetMessage(const class FText& _strText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFChunkInstallPopupWidget", "SetMessage");

	Params::OFChunkInstallPopupWidget_SetMessage Parms{};

	Parms._strText = std::move(_strText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OFChunkSubSystem.GetProgressForChunk
// (Final, Native, Public, Const)
// Parameters:
// uint32                                  CheckChunkIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UOFChunkSubSystem::GetProgressForChunk(uint32 CheckChunkIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFChunkSubSystem", "GetProgressForChunk");

	Params::OFChunkSubSystem_GetProgressForChunk Parms{};

	Parms.CheckChunkIndex = CheckChunkIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFChunkSubSystem.IsChunkForIndexLoaded
// (Final, Native, Public, Const)
// Parameters:
// uint32                                  CheckChunkIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFChunkSubSystem::IsChunkForIndexLoaded(uint32 CheckChunkIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFChunkSubSystem", "IsChunkForIndexLoaded");

	Params::OFChunkSubSystem_IsChunkForIndexLoaded Parms{};

	Parms.CheckChunkIndex = CheckChunkIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.OFCreditsTextPanelWidget.Action_OnCreditsTextPanelDone__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UOFCreditsTextPanelWidget*        Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCreditsTextPanelWidget::Action_OnCreditsTextPanelDone__DelegateSignature(class UOFCreditsTextPanelWidget* Panel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCreditsTextPanelWidget", "Action_OnCreditsTextPanelDone__DelegateSignature");

	Params::OFCreditsTextPanelWidget_Action_OnCreditsTextPanelDone__DelegateSignature Parms{};

	Parms.Panel = Panel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OFCreditsTextPanelWidget.ScrollFinished
// (Final, Native, Protected, BlueprintCallable)

void UOFCreditsTextPanelWidget::ScrollFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCreditsTextPanelWidget", "ScrollFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCreditsTextPanelWidget.SetFont
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// struct FSlateFontInfo                   FontInfo                                               (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCreditsTextPanelWidget::SetFont(const struct FSlateFontInfo& FontInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCreditsTextPanelWidget", "SetFont");

	Params::OFCreditsTextPanelWidget_SetFont Parms{};

	Parms.FontInfo = std::move(FontInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCreditsTextPanelWidget.SetText
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Text                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOFCreditsTextPanelWidget::SetText(const class FText& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCreditsTextPanelWidget", "SetText");

	Params::OFCreditsTextPanelWidget_SetText Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCreditsTextPanelWidget.TriggerScrollAnimation
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   PlaybackSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCreditsTextPanelWidget::TriggerScrollAnimation(float PlaybackSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCreditsTextPanelWidget", "TriggerScrollAnimation");

	Params::OFCreditsTextPanelWidget_TriggerScrollAnimation Parms{};

	Parms.PlaybackSpeed = PlaybackSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCreditsWidget.CreateTextPanel
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UOFCreditsTextPanelWidget*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOFCreditsTextPanelWidget* UOFCreditsWidget::CreateTextPanel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCreditsWidget", "CreateTextPanel");

	Params::OFCreditsWidget_CreateTextPanel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFCreditsWidget.HandleTextPanelDone
// (Final, Native, Protected)
// Parameters:
// class UOFCreditsTextPanelWidget*        Panel                                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFCreditsWidget::HandleTextPanelDone(class UOFCreditsTextPanelWidget* Panel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCreditsWidget", "HandleTextPanelDone");

	Params::OFCreditsWidget_HandleTextPanelDone Parms{};

	Parms.Panel = Panel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCreditsWidget.OnLastTextSpawned
// (Event, Protected, BlueprintEvent)

void UOFCreditsWidget::OnLastTextSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCreditsWidget", "OnLastTextSpawned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.OFCreditsWidget.OnRollCredits
// (Event, Protected, BlueprintEvent)

void UOFCreditsWidget::OnRollCredits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFCreditsWidget", "OnRollCredits");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.BFL_OFCustomMovementMode.GetOFCustomMovementMode
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// EOFCustomMovementMode                   InCustomMovementMode                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UBFL_OFCustomMovementMode::GetOFCustomMovementMode(const EOFCustomMovementMode InCustomMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFL_OFCustomMovementMode", "GetOFCustomMovementMode");

	Params::BFL_OFCustomMovementMode_GetOFCustomMovementMode Parms{};

	Parms.InCustomMovementMode = InCustomMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFEnemyAIController.OnPlayStateChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EGameMainState                          OldGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameMainState                          NewGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFEnemyAIController::OnPlayStateChanged(EGameMainState OldGameState, EGameMainState NewGameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFEnemyAIController", "OnPlayStateChanged");

	Params::OFEnemyAIController_OnPlayStateChanged Parms{};

	Parms.OldGameState = OldGameState;
	Parms.NewGameState = NewGameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFEnemyAIController.OnTargetPerceptionUpdated
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAIStimulus                      Stimulus                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AOFEnemyAIController::OnTargetPerceptionUpdated(class AActor* Actor, const struct FAIStimulus& Stimulus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFEnemyAIController", "OnTargetPerceptionUpdated");

	Params::OFEnemyAIController_OnTargetPerceptionUpdated Parms{};

	Parms.Actor = Actor;
	Parms.Stimulus = std::move(Stimulus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFEnemyAIController.SetAggro
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFEnemyAIController::SetAggro(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFEnemyAIController", "SetAggro");

	Params::OFEnemyAIController_SetAggro Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.OFEnemyCharacter.AggroChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFEnemyCharacter::AggroChanged__DelegateSignature(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFEnemyCharacter", "AggroChanged__DelegateSignature");

	Params::OFEnemyCharacter_AggroChanged__DelegateSignature Parms{};

	Parms.bEnabled = bEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OFEnemyCharacter.ForceAggro
// (Final, Native, Public, BlueprintCallable)

void AOFEnemyCharacter::ForceAggro()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFEnemyCharacter", "ForceAggro");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFEnemyCharacter.PlayCharHitSound
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFMODEvent*                       Sound                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFEnemyCharacter::PlayCharHitSound(const struct FHitResult& Hit, float Damage, class UFMODEvent* Sound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFEnemyCharacter", "PlayCharHitSound");

	Params::OFEnemyCharacter_PlayCharHitSound Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Damage = Damage;
	Parms.Sound = Sound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFEnemyCharacter.SetSpawnerActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AEnemySpawner*                    Spawner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFEnemyCharacter::SetSpawnerActor(class AEnemySpawner* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFEnemyCharacter", "SetSpawnerActor");

	Params::OFEnemyCharacter_SetSpawnerActor Parms{};

	Parms.Spawner = Spawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFEnemyCharacter.SpawnCharHitDecal
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance*                DecalMaterial                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFEnemyCharacter::SpawnCharHitDecal(const struct FHitResult& Hit, float Damage, class UMaterialInstance* DecalMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFEnemyCharacter", "SpawnCharHitDecal");

	Params::OFEnemyCharacter_SpawnCharHitDecal Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Damage = Damage;
	Parms.DecalMaterial = DecalMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFEnemyCharacter.SpawnCharHitParticleEffect
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCharHitFX                       HitFX                                                  (Parm, NativeAccessSpecifierPublic)

void AOFEnemyCharacter::SpawnCharHitParticleEffect(const struct FHitResult& Hit, float Damage, const struct FCharHitFX& HitFX)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFEnemyCharacter", "SpawnCharHitParticleEffect");

	Params::OFEnemyCharacter_SpawnCharHitParticleEffect Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Damage = Damage;
	Parms.HitFX = std::move(HitFX);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFEnemyCharacter.UpdateBlackboardHealth
// (Final, Native, Public, HasOutParams)
// Parameters:
// float                                   NewCurrentHealth                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            EventTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AOFEnemyCharacter::UpdateBlackboardHealth(float NewCurrentHealth, float DeltaValue, const struct FGameplayTagContainer& EventTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFEnemyCharacter", "UpdateBlackboardHealth");

	Params::OFEnemyCharacter_UpdateBlackboardHealth Parms{};

	Parms.NewCurrentHealth = NewCurrentHealth;
	Parms.DeltaValue = DeltaValue;
	Parms.EventTags = std::move(EventTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFEnemyCharacter.GetDistToTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AOFEnemyCharacter::GetDistToTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFEnemyCharacter", "GetDistToTarget");

	Params::OFEnemyCharacter_GetDistToTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFEnemyCharacter.IsInCombat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOFEnemyCharacter::IsInCombat() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFEnemyCharacter", "IsInCombat");

	Params::OFEnemyCharacter_IsInCombat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFFMODAmbientSound.PlayFMODEvent
// (Final, Native, Public, BlueprintCallable)

void AOFFMODAmbientSound::PlayFMODEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFFMODAmbientSound", "PlayFMODEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFFMODAmbientSound.PlayFMODEventWithStartle
// (Final, Native, Public, BlueprintCallable)

void AOFFMODAmbientSound::PlayFMODEventWithStartle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFFMODAmbientSound", "PlayFMODEventWithStartle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFGameInstance.CheatsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFGameInstance::CheatsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFGameInstance", "CheatsEnabled");

	Params::OFGameInstance_CheatsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFHUD.GetWidgetOfClass
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftClassPtr<class UClass>             WidgetClass                                            (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInGameUIWidget*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInGameUIWidget* AOFHUD::GetWidgetOfClass(const TSoftClassPtr<class UClass>& WidgetClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFHUD", "GetWidgetOfClass");

	Params::OFHUD_GetWidgetOfClass Parms{};

	Parms.WidgetClass = WidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.UIButton.ButtonOnHovered
// (Final, Native, Public)

void UUIButton::ButtonOnHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIButton", "ButtonOnHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFLoadGameMenuWidget.OnConfirmationDone
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsAccepted                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFLoadGameMenuWidget::OnConfirmationDone(bool bIsAccepted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFLoadGameMenuWidget", "OnConfirmationDone");

	Params::OFLoadGameMenuWidget_OnConfirmationDone Parms{};

	Parms.bIsAccepted = bIsAccepted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFLoadGameMenuWidget.OnDeleteSaveFinished
// (Final, Native, Protected)

void UOFLoadGameMenuWidget::OnDeleteSaveFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFLoadGameMenuWidget", "OnDeleteSaveFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFLoadGameMenuWidget.OnLoadSaveButtonHover
// (Final, Native, Protected)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFLoadGameMenuWidget::OnLoadSaveButtonHover(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFLoadGameMenuWidget", "OnLoadSaveButtonHover");

	Params::OFLoadGameMenuWidget_OnLoadSaveButtonHover Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFLoadGameMenuWidget.OnSaveFinished
// (Final, Native, Protected)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFLoadGameMenuWidget::OnSaveFinished(bool Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFLoadGameMenuWidget", "OnSaveFinished");

	Params::OFLoadGameMenuWidget_OnSaveFinished Parms{};

	Parms.Success = Success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFMenuSpinningItemSelector.InitDesignTime
// (Event, Protected, BlueprintEvent)

void UOFMenuSpinningItemSelector::InitDesignTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFMenuSpinningItemSelector", "InitDesignTime");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.OFMenuSpinningItemSelector.MoveSelection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFMenuSpinningItemSelector::MoveSelection(int32 Direction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFMenuSpinningItemSelector", "MoveSelection");

	Params::OFMenuSpinningItemSelector_MoveSelection Parms{};

	Parms.Direction = Direction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFMenuSpinningItemSelector.OnSelectionSlotPressed
// (Final, Native, Protected)

void UOFMenuSpinningItemSelector::OnSelectionSlotPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFMenuSpinningItemSelector", "OnSelectionSlotPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFMenuSpinningItemSelector.Reset
// (Final, Native, Public, BlueprintCallable)

void UOFMenuSpinningItemSelector::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFMenuSpinningItemSelector", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFMenuSpinningItemSelector.SetItems
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<TSoftObjectPtr<class UItemData>> SoftItems                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

void UOFMenuSpinningItemSelector::SetItems(const TArray<TSoftObjectPtr<class UItemData>>& SoftItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFMenuSpinningItemSelector", "SetItems");

	Params::OFMenuSpinningItemSelector_SetItems Parms{};

	Parms.SoftItems = std::move(SoftItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFMenuSpinningItemSelector.UpdateSelectorState
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFMenuSpinningItemSelector::UpdateSelectorState(float State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFMenuSpinningItemSelector", "UpdateSelectorState");

	Params::OFMenuSpinningItemSelector_UpdateSelectorState Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OFMenuSpinningItemSelector.GetActiveMenuSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMenuInventorySelectionSlot*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMenuInventorySelectionSlot* UOFMenuSpinningItemSelector::GetActiveMenuSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFMenuSpinningItemSelector", "GetActiveMenuSlot");

	Params::OFMenuSpinningItemSelector_GetActiveMenuSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFMenuSpinningItemSelector.GetNumItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOFMenuSpinningItemSelector::GetNumItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFMenuSpinningItemSelector", "GetNumItems");

	Params::OFMenuSpinningItemSelector_GetNumItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFMenuSpinningItemSelector.GetSelectedItemIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOFMenuSpinningItemSelector::GetSelectedItemIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFMenuSpinningItemSelector", "GetSelectedItemIndex");

	Params::OFMenuSpinningItemSelector_GetSelectedItemIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFPerfSampleLevelGauntletController.StartTesting
// (Final, Native, Private)

void UOFPerfSampleLevelGauntletController::StartTesting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPerfSampleLevelGauntletController", "StartTesting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPerfSampleLevelGauntletController.StopProfiling
// (Final, Native, Private)

void UOFPerfSampleLevelGauntletController::StopProfiling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPerfSampleLevelGauntletController", "StopProfiling");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ThreatVisualizerComponent.K2_ConvertWorldToScreenLocation
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UWorld*                           WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EdgePercent                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ScreenPosition                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EdgePositionAlpha                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThreatVisualizerComponent::K2_ConvertWorldToScreenLocation(const class UWorld* WorldContextObject, const struct FVector& WorldLocation, const float& EdgePercent, struct FVector2D* ScreenPosition, float* EdgePositionAlpha)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThreatVisualizerComponent", "K2_ConvertWorldToScreenLocation");

	Params::ThreatVisualizerComponent_K2_ConvertWorldToScreenLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.EdgePercent = EdgePercent;

	UObject::ProcessEvent(Func, &Parms);

	if (ScreenPosition != nullptr)
		*ScreenPosition = std::move(Parms.ScreenPosition);

	if (EdgePositionAlpha != nullptr)
		*EdgePositionAlpha = Parms.EdgePositionAlpha;
}


// Function ObsidianFox.OFPlayerCharacter.BeginCrawl
// (Final, Native, Public, BlueprintCallable)

void AOFPlayerCharacter::BeginCrawl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "BeginCrawl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerCharacter.CheckForLossOfControl
// (Final, Native, Protected)

void AOFPlayerCharacter::CheckForLossOfControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "CheckForLossOfControl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerCharacter.GrantAbilityWithInput
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayAbility>     NewAbility                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAbilityInput                           AbilityInput                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFPlayerCharacter::GrantAbilityWithInput(TSubclassOf<class UGameplayAbility> NewAbility, EAbilityInput AbilityInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "GrantAbilityWithInput");

	Params::OFPlayerCharacter_GrantAbilityWithInput Parms{};

	Parms.NewAbility = NewAbility;
	Parms.AbilityInput = AbilityInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerCharacter.InputTypeChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsGamepadType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFPlayerCharacter::InputTypeChanged(bool bIsGamepadType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "InputTypeChanged");

	Params::OFPlayerCharacter_InputTypeChanged Parms{};

	Parms.bIsGamepadType = bIsGamepadType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerCharacter.Interact
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EInteractionType                        ComponentType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFPlayerCharacter::Interact(EInteractionType ComponentType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "Interact");

	Params::OFPlayerCharacter_Interact Parms{};

	Parms.ComponentType = ComponentType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerCharacter.IsAiming
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AOFPlayerCharacter::IsAiming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "IsAiming");

	Params::OFPlayerCharacter_IsAiming Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFPlayerCharacter.Look
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FInputActionValue                InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AOFPlayerCharacter::Look(const struct FInputActionValue& InputActionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "Look");

	Params::OFPlayerCharacter_Look Parms{};

	Parms.InputActionValue = std::move(InputActionValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.OFPlayerCharacter.LossOfControlDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bGameplayInputIgnored                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLookInputIgnored                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMoveInputIgnored                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFPlayerCharacter::LossOfControlDelegate__DelegateSignature(bool bGameplayInputIgnored, bool bLookInputIgnored, bool bMoveInputIgnored)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "LossOfControlDelegate__DelegateSignature");

	Params::OFPlayerCharacter_LossOfControlDelegate__DelegateSignature Parms{};

	Parms.bGameplayInputIgnored = bGameplayInputIgnored;
	Parms.bLookInputIgnored = bLookInputIgnored;
	Parms.bMoveInputIgnored = bMoveInputIgnored;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.OFPlayerCharacter.Move
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FInputActionValue                InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void AOFPlayerCharacter::Move(const struct FInputActionValue& InputActionValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "Move");

	Params::OFPlayerCharacter_Move Parms{};

	Parms.InputActionValue = std::move(InputActionValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerCharacter.OnEnterGauntlet
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AOFPlayerCharacter::OnEnterGauntlet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "OnEnterGauntlet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerCharacter.OnExitGauntlet
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void AOFPlayerCharacter::OnExitGauntlet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "OnExitGauntlet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerCharacter.OnSettingsChangedHandler
// (Final, Native, Protected)
// Parameters:
// class UOFGameUserSettings*              Settings                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFPlayerCharacter::OnSettingsChangedHandler(class UOFGameUserSettings* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "OnSettingsChangedHandler");

	Params::OFPlayerCharacter_OnSettingsChangedHandler Parms{};

	Parms.Settings = Settings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerCharacter.PrintActivatableAbilities
// (Final, Exec, Native, Protected)

void AOFPlayerCharacter::PrintActivatableAbilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "PrintActivatableAbilities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerCharacter.PrintActiveAbilities
// (Final, Exec, Native, Protected)

void AOFPlayerCharacter::PrintActiveAbilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "PrintActiveAbilities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerCharacter.SetGhostBustingRange
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFPlayerCharacter::SetGhostBustingRange(float Range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "SetGhostBustingRange");

	Params::OFPlayerCharacter_SetGhostBustingRange Parms{};

	Parms.Range = Range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerCharacter.SmoothRotateTo
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEasingFunc                             EasingFunction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFPlayerCharacter::SmoothRotateTo(const struct FRotator& Rotation, float Time, EEasingFunc EasingFunction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "SmoothRotateTo");

	Params::OFPlayerCharacter_SmoothRotateTo Parms{};

	Parms.Rotation = std::move(Rotation);
	Parms.Time = Time;
	Parms.EasingFunction = EasingFunction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerCharacter.StopCrawl
// (Final, Native, Public, BlueprintCallable)

void AOFPlayerCharacter::StopCrawl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "StopCrawl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerCharacter.ToggleGhostBusterMode
// (Final, Exec, Native, Protected)

void AOFPlayerCharacter::ToggleGhostBusterMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "ToggleGhostBusterMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFPlayerCharacter.GetNearestEnemyInVisionCone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   VisionConeDegrees                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AOFEnemyCharacter*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AOFEnemyCharacter* AOFPlayerCharacter::GetNearestEnemyInVisionCone(float VisionConeDegrees) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFPlayerCharacter", "GetNearestEnemyInVisionCone");

	Params::OFPlayerCharacter_GetNearestEnemyInVisionCone Parms{};

	Parms.VisionConeDegrees = VisionConeDegrees;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.WorldSubsystem_CharacterStateDebugger.RefreshCharacterCollection
// (Native, Protected)

void UWorldSubsystem_CharacterStateDebugger::RefreshCharacterCollection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldSubsystem_CharacterStateDebugger", "RefreshCharacterCollection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFCharacterTypeSpecificSettingsUtils.GetPauseMenuClass
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlayerCharacterType                    CharacterType                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UOFCharacterTypeSpecificSettingsUtils::GetPauseMenuClass(const EPlayerCharacterType CharacterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFCharacterTypeSpecificSettingsUtils", "GetPauseMenuClass");

	Params::OFCharacterTypeSpecificSettingsUtils_GetPauseMenuClass Parms{};

	Parms.CharacterType = CharacterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFCharacterTypeSpecificSettingsUtils.IsOpenInGameMenuEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPlayerCharacterType                    CharacterType                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFCharacterTypeSpecificSettingsUtils::IsOpenInGameMenuEnabled(const EPlayerCharacterType CharacterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFCharacterTypeSpecificSettingsUtils", "IsOpenInGameMenuEnabled");

	Params::OFCharacterTypeSpecificSettingsUtils_IsOpenInGameMenuEnabled Parms{};

	Parms.CharacterType = CharacterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.BFLPlayerUtils.GetPlayerCharacterType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerCharacterType                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerCharacterType UBFLPlayerUtils::GetPlayerCharacterType(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFLPlayerUtils", "GetPlayerCharacterType");

	Params::BFLPlayerUtils_GetPlayerCharacterType Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.BFLPlayerUtils.GetPlayerDebugLight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPointLightComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPointLightComponent* UBFLPlayerUtils::GetPlayerDebugLight(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFLPlayerUtils", "GetPlayerDebugLight");

	Params::BFLPlayerUtils_GetPlayerDebugLight Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.BFLPlayerUtils.GetPlayerLight
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPointLightComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPointLightComponent* UBFLPlayerUtils::GetPlayerLight(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BFLPlayerUtils", "GetPlayerLight");

	Params::BFLPlayerUtils_GetPlayerLight Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFProjectile.BeginAttack
// (Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     AttackEvent                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AOFProjectile::BeginAttack(const struct FGameplayTag& AttackEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFProjectile", "BeginAttack");

	Params::OFProjectile_BeginAttack Parms{};

	Parms.AttackEvent = std::move(AttackEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFProjectile.EndAttack
// (Native, Protected, BlueprintCallable)

void AOFProjectile::EndAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFProjectile", "EndAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFProjectile.HandleHit
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)

void AOFProjectile::HandleHit(const struct FGameplayAbilityTargetDataHandle& TargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFProjectile", "HandleHit");

	Params::OFProjectile_HandleHit Parms{};

	Parms.TargetData = std::move(TargetData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.WaterLevelTriggerBoxComponent.OnBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UWaterLevelTriggerBoxComponent::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterLevelTriggerBoxComponent", "OnBeginOverlap");

	Params::WaterLevelTriggerBoxComponent_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WaterLevelTriggerBoxComponent.OnEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWaterLevelTriggerBoxComponent::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WaterLevelTriggerBoxComponent", "OnEndOverlap");

	Params::WaterLevelTriggerBoxComponent_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFSaveGameMenuWidget.OnDeleteFinished
// (Final, Native, Protected)
// Parameters:
// bool                                    bResult                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFSaveGameMenuWidget::OnDeleteFinished(bool bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSaveGameMenuWidget", "OnDeleteFinished");

	Params::OFSaveGameMenuWidget_OnDeleteFinished Parms{};

	Parms.bResult = bResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFSaveGameWidget.OnSaveFinished
// (Final, Native, Protected)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFSaveGameWidget::OnSaveFinished(bool Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSaveGameWidget", "OnSaveFinished");

	Params::OFSaveGameWidget_OnSaveFinished Parms{};

	Parms.Success = Success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFSaveGameWidget.OnSaveStarted
// (Final, Native, Protected)

void UOFSaveGameWidget::OnSaveStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSaveGameWidget", "OnSaveStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFSaveGameWidget.PlayFlashAnimation
// (Event, Protected, BlueprintEvent)

void UOFSaveGameWidget::PlayFlashAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFSaveGameWidget", "PlayFlashAnimation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.WallSplineCharacterPath.GetDirectionToLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          CurrentLocation                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TargetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AWallSplineCharacterPath::GetDirectionToLocation(const struct FVector& CurrentLocation, const struct FVector& TargetLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WallSplineCharacterPath", "GetDirectionToLocation");

	Params::WallSplineCharacterPath_GetDirectionToLocation Parms{};

	Parms.CurrentLocation = std::move(CurrentLocation);
	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.WallSplineCharacterPath.GetNearestPointOnSpline
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWallSplineCharacterPathPoint    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FWallSplineCharacterPathPoint AWallSplineCharacterPath::GetNearestPointOnSpline(const struct FVector& Origin) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WallSplineCharacterPath", "GetNearestPointOnSpline");

	Params::WallSplineCharacterPath_GetNearestPointOnSpline Parms{};

	Parms.Origin = std::move(Origin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.WallSplineCharacterPath.GetRandomPointOnSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FWallSplineCharacterPathPoint    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FWallSplineCharacterPathPoint AWallSplineCharacterPath::GetRandomPointOnSpline() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WallSplineCharacterPath", "GetRandomPointOnSpline");

	Params::WallSplineCharacterPath_GetRandomPointOnSpline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.OFStruckTextWidget.FadeIn
// (Event, Public, BlueprintEvent)

void UOFStruckTextWidget::FadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFStruckTextWidget", "FadeIn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.OFStruckTextWidget.SetStrokeEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFStruckTextWidget::SetStrokeEnabled(bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFStruckTextWidget", "SetStrokeEnabled");

	Params::OFStruckTextWidget_SetStrokeEnabled Parms{};

	Parms.InEnabled = InEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFStruckTextWidget.SetText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOFStruckTextWidget::SetText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFStruckTextWidget", "SetText");

	Params::OFStruckTextWidget_SetText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.OFWidgetInterface.FadeOutAndThenDestroy
// (Event, Public, BlueprintCallable, BlueprintEvent)

void IOFWidgetInterface::FadeOutAndThenDestroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OFWidgetInterface", "FadeOutAndThenDestroy");

	UObject::ProcessEvent(Func, nullptr);
}


// DelegateFunction ObsidianFox.Opportunity.AdditionalAssetsLoaded__DelegateSignature
// (MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// TArray<TSoftObjectPtr<class UObject>>   Assets                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<TSoftClassPtr<class UClass>>     Classes                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

void AOpportunity::AdditionalAssetsLoaded__DelegateSignature(const TArray<TSoftObjectPtr<class UObject>>& Assets, const TArray<TSoftClassPtr<class UClass>>& Classes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Opportunity", "AdditionalAssetsLoaded__DelegateSignature");

	Params::Opportunity_AdditionalAssetsLoaded__DelegateSignature Parms{};

	Parms.Assets = std::move(Assets);
	Parms.Classes = std::move(Classes);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.Opportunity.GetAdditionalRequiredAssets
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<TSoftObjectPtr<class UObject>>   AdditionalAssets                                       (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// TArray<TSoftClassPtr<class UClass>>     AdditionalClasses                                      (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

void AOpportunity::GetAdditionalRequiredAssets(TArray<TSoftObjectPtr<class UObject>>* AdditionalAssets, TArray<TSoftClassPtr<class UClass>>* AdditionalClasses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Opportunity", "GetAdditionalRequiredAssets");

	Params::Opportunity_GetAdditionalRequiredAssets Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AdditionalAssets != nullptr)
		*AdditionalAssets = std::move(Parms.AdditionalAssets);

	if (AdditionalClasses != nullptr)
		*AdditionalClasses = std::move(Parms.AdditionalClasses);
}


// Function ObsidianFox.Opportunity.SetOpportunityEffectContext
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContextHandle                                    (Parm, NativeAccessSpecifierPublic)
// class AActor*                           OpportunityInstigator                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayEffectContextHandle AOpportunity::SetOpportunityEffectContext(const struct FGameplayEffectContextHandle& EffectContextHandle, class AActor* OpportunityInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Opportunity", "SetOpportunityEffectContext");

	Params::Opportunity_SetOpportunityEffectContext Parms{};

	Parms.EffectContextHandle = std::move(EffectContextHandle);
	Parms.OpportunityInstigator = OpportunityInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ParticleBlockerManager.SetNiagaraParameterCollection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNiagaraParameterCollectionInstance*NiagaraPC                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UParticleBlockerManager::SetNiagaraParameterCollection(class UNiagaraParameterCollectionInstance* NiagaraPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ParticleBlockerManager", "SetNiagaraParameterCollection");

	Params::ParticleBlockerManager_SetNiagaraParameterCollection Parms{};

	Parms.NiagaraPC = NiagaraPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseComponent.OnPlayStateChanged
// (Final, Native, Protected)
// Parameters:
// EGameMainState                          OldGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameMainState                          NewGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPauseComponent::OnPlayStateChanged(EGameMainState OldGameState, EGameMainState NewGameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseComponent", "OnPlayStateChanged");

	Params::PauseComponent_OnPlayStateChanged Parms{};

	Parms.OldGameState = OldGameState;
	Parms.NewGameState = NewGameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseMenuPT.ButtonHovered
// (Final, Native, Private)

void UPauseMenuPT::ButtonHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "ButtonHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseMenuPT.ButtonUnHovered
// (Final, Native, Private)

void UPauseMenuPT::ButtonUnHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "ButtonUnHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseMenuPT.CancelButtonPressed
// (Final, Native, Private)

void UPauseMenuPT::CancelButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "CancelButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseMenuPT.DecreaseOption
// (Final, Native, Private)

void UPauseMenuPT::DecreaseOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "DecreaseOption");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseMenuPT.IncreaseOption
// (Final, Native, Private)

void UPauseMenuPT::IncreaseOption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "IncreaseOption");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseMenuPT.InteractButtonPressed
// (Final, Native, Private)

void UPauseMenuPT::InteractButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "InteractButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseMenuPT.LeftStickX
// (Final, Native, Private)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPauseMenuPT::LeftStickX(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "LeftStickX");

	Params::PauseMenuPT_LeftStickX Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseMenuPT.LeftStickY
// (Final, Native, Private)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPauseMenuPT::LeftStickY(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "LeftStickY");

	Params::PauseMenuPT_LeftStickY Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseMenuPT.OnExitSaveDone
// (Final, Native, Private)
// Parameters:
// bool                                    Success                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPauseMenuPT::OnExitSaveDone(bool Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "OnExitSaveDone");

	Params::PauseMenuPT_OnExitSaveDone Parms{};

	Parms.Success = Success;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseMenuPT.OpenLoadGameMenu
// (Event, Protected, BlueprintEvent)

void UPauseMenuPT::OpenLoadGameMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "OpenLoadGameMenu");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.PauseMenuPT.OpenSaveGameMenu
// (Event, Protected, BlueprintEvent)

void UPauseMenuPT::OpenSaveGameMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "OpenSaveGameMenu");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.PauseMenuPT.PlayHoverSound
// (Event, Protected, BlueprintEvent)

void UPauseMenuPT::PlayHoverSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "PlayHoverSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.PauseMenuPT.PlayPressedSound
// (Event, Protected, BlueprintEvent)

void UPauseMenuPT::PlayPressedSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "PlayPressedSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.PauseMenuPT.QuitGame
// (Event, Protected, BlueprintEvent)

void UPauseMenuPT::QuitGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "QuitGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function ObsidianFox.PauseMenuPT.SelectDownPressed
// (Final, Native, Private)

void UPauseMenuPT::SelectDownPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "SelectDownPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseMenuPT.SelectNextPressed
// (Final, Native, Private)

void UPauseMenuPT::SelectNextPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "SelectNextPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseMenuPT.SelectPreviousPressed
// (Final, Native, Private)

void UPauseMenuPT::SelectPreviousPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "SelectPreviousPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseMenuPT.SelectUpPressed
// (Final, Native, Private)

void UPauseMenuPT::SelectUpPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "SelectUpPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseMenuPT.SetCanMoveWithLeftStickXToTrue
// (Final, Native, Private)

void UPauseMenuPT::SetCanMoveWithLeftStickXToTrue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "SetCanMoveWithLeftStickXToTrue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PauseMenuPT.SetCanMoveWithLeftStickYToTrue
// (Final, Native, Private)

void UPauseMenuPT::SetCanMoveWithLeftStickYToTrue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PauseMenuPT", "SetCanMoveWithLeftStickYToTrue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerAnimInstance.GetClosestPickupAnimation
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ItemLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPickupAnimationData             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FPickupAnimationData UPlayerAnimInstance::GetClosestPickupAnimation(const struct FVector& ItemLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerAnimInstance", "GetClosestPickupAnimation");

	Params::PlayerAnimInstance_GetClosestPickupAnimation Parms{};

	Parms.ItemLocation = std::move(ItemLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PlayerAnimInstance.LoadEditorPreviewAnimations
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAnimationDataAssetBase>AssetType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UAnimationDataAssetBase>AnimationDataAsset                                     (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationDataAssetBase*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimationDataAssetBase* UPlayerAnimInstance::LoadEditorPreviewAnimations(TSubclassOf<class UAnimationDataAssetBase> AssetType, TSoftObjectPtr<class UAnimationDataAssetBase> AnimationDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerAnimInstance", "LoadEditorPreviewAnimations");

	Params::PlayerAnimInstance_LoadEditorPreviewAnimations Parms{};

	Parms.AssetType = AssetType;
	Parms.AnimationDataAsset = AnimationDataAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PlayerAnimInstance.PlayPickupAnimation
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ItemLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpToSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpFromSpeed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerAnimInstance::PlayPickupAnimation(const struct FVector& ItemLocation, float InterpToSpeed, float InterpFromSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerAnimInstance", "PlayPickupAnimation");

	Params::PlayerAnimInstance_PlayPickupAnimation Parms{};

	Parms.ItemLocation = std::move(ItemLocation);
	Parms.InterpToSpeed = InterpToSpeed;
	Parms.InterpFromSpeed = InterpFromSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerAnimInstance.VisualizePickupAnimCoverage
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   DrawDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerAnimInstance::VisualizePickupAnimCoverage(float DrawDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerAnimInstance", "VisualizePickupAnimCoverage");

	Params::PlayerAnimInstance_VisualizePickupAnimCoverage Parms{};

	Parms.DrawDuration = DrawDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerCharacterMovementComponent.SprintHoldPressed
// (Final, Native, Public, BlueprintCallable)

void UPlayerCharacterMovementComponent::SprintHoldPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacterMovementComponent", "SprintHoldPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerCharacterMovementComponent.SprintHoldReleased
// (Final, Native, Public, BlueprintCallable)

void UPlayerCharacterMovementComponent::SprintHoldReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacterMovementComponent", "SprintHoldReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerCharacterMovementComponent.SprintPressed
// (Final, Native, Public, BlueprintCallable)

void UPlayerCharacterMovementComponent::SprintPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerCharacterMovementComponent", "SprintPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerHitReactionComponent.OnOwnerPossessed
// (Final, Native, Protected)
// Parameters:
// class AController*                      NewController                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerHitReactionComponent::OnOwnerPossessed(class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHitReactionComponent", "OnOwnerPossessed");

	Params::PlayerHitReactionComponent_OnOwnerPossessed Parms{};

	Parms.NewController = NewController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerInteractionComponent.GetStandardSelectedInteractable
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UInteractionComponentBase*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionComponentBase* UPlayerInteractionComponent::GetStandardSelectedInteractable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionComponent", "GetStandardSelectedInteractable");

	Params::PlayerInteractionComponent_GetStandardSelectedInteractable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PlayerInteractionComponent.InteractWithSelected
// (Final, Native, Public)
// Parameters:
// class AOFPlayerCharacter*               InteractingPlayer                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInteractionComponent::InteractWithSelected(class AOFPlayerCharacter* InteractingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionComponent", "InteractWithSelected");

	Params::PlayerInteractionComponent_InteractWithSelected Parms{};

	Parms.InteractingPlayer = InteractingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PlayerInteractionComponent.InterruptInteraction
// (Final, Native, Public, BlueprintCallable)

void UPlayerInteractionComponent::InterruptInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionComponent", "InterruptInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.PlayerInteractionComponent.NearbyInteractablesChangedSignature__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// TSet<class UInteractionComponentBase*>  NearbyInteractables                                    (ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSet<class UInteractionComponentBase*>  AddedInteractables                                     (ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TSet<class UInteractionComponentBase*>  RemovedInteractables                                   (ConstParm, Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPlayerInteractionComponent::NearbyInteractablesChangedSignature__DelegateSignature(const TSet<class UInteractionComponentBase*>& NearbyInteractables, const TSet<class UInteractionComponentBase*>& AddedInteractables, const TSet<class UInteractionComponentBase*>& RemovedInteractables)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionComponent", "NearbyInteractablesChangedSignature__DelegateSignature");

	Params::PlayerInteractionComponent_NearbyInteractablesChangedSignature__DelegateSignature Parms{};

	Parms.NearbyInteractables = std::move(NearbyInteractables);
	Parms.AddedInteractables = std::move(AddedInteractables);
	Parms.RemovedInteractables = std::move(RemovedInteractables);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction ObsidianFox.PlayerInteractionComponent.SelectionChangedSignature__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class UInteractionComponentBase*        SelectedInteractable_0                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionComponent::SelectionChangedSignature__DelegateSignature(const class UInteractionComponentBase* SelectedInteractable_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionComponent", "SelectionChangedSignature__DelegateSignature");

	Params::PlayerInteractionComponent_SelectionChangedSignature__DelegateSignature Parms{};

	Parms.SelectedInteractable_0 = SelectedInteractable_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.PlayerInteractionComponent.SetUseRoomFilter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bUseFilter                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInteractionComponent::SetUseRoomFilter(bool bUseFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionComponent", "SetUseRoomFilter");

	Params::PlayerInteractionComponent_SetUseRoomFilter Parms{};

	Parms.bUseFilter = bUseFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerInteractionComponent.GetInteractablesNearby
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSet<class UInteractionComponentBase*>  ReturnValue                                            (ExportObject, Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TSet<class UInteractionComponentBase*> UPlayerInteractionComponent::GetInteractablesNearby() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionComponent", "GetInteractablesNearby");

	Params::PlayerInteractionComponent_GetInteractablesNearby Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PlayerInteractionComponent.GetSelectedInteractable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInteractionType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInteractionComponentBase*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionComponentBase* UPlayerInteractionComponent::GetSelectedInteractable(EInteractionType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionComponent", "GetSelectedInteractable");

	Params::PlayerInteractionComponent_GetSelectedInteractable Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PlayerInteractionComponent.HasSelectedInteractable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInteractionType                        Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInteractionComponent::HasSelectedInteractable(EInteractionType Type) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInteractionComponent", "HasSelectedInteractable");

	Params::PlayerInteractionComponent_HasSelectedInteractable Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction ObsidianFox.PlayerLocationTrackingSubsystem.OnLocationUpdated__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// struct FGameplayTagContainer            LocationTags                                           (Parm, NativeAccessSpecifierPublic)

void UPlayerLocationTrackingSubsystem::OnLocationUpdated__DelegateSignature(const struct FGameplayTagContainer& LocationTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLocationTrackingSubsystem", "OnLocationUpdated__DelegateSignature");

	Params::PlayerLocationTrackingSubsystem_OnLocationUpdated__DelegateSignature Parms{};

	Parms.LocationTags = std::move(LocationTags);

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.PlayerLocationTrackingSubsystem.GetCurrentLocationTags
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UPlayerLocationTrackingSubsystem::GetCurrentLocationTags() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLocationTrackingSubsystem", "GetCurrentLocationTags");

	Params::PlayerLocationTrackingSubsystem_GetCurrentLocationTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PlayerLocationTrackingSubsystem.GetDercetoLocationTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UPlayerLocationTrackingSubsystem::GetDercetoLocationTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLocationTrackingSubsystem", "GetDercetoLocationTag");

	Params::PlayerLocationTrackingSubsystem_GetDercetoLocationTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PlayerLocationTrackingSubsystem.PlayerIsInDerceto
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerLocationTrackingSubsystem::PlayerIsInDerceto() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLocationTrackingSubsystem", "PlayerIsInDerceto");

	Params::PlayerLocationTrackingSubsystem_PlayerIsInDerceto Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PlayerLocationTrackingSubsystem.PlayerIsInLocation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     LocationTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerLocationTrackingSubsystem::PlayerIsInLocation(const struct FGameplayTag& LocationTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerLocationTrackingSubsystem", "PlayerIsInLocation");

	Params::PlayerLocationTrackingSubsystem_PlayerIsInLocation Parms{};

	Parms.LocationTag = std::move(LocationTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PlayerStartTransitional.InitTransition
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      SpawnedController                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerStartTransitional::InitTransition(class AController* SpawnedController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStartTransitional", "InitTransition");

	Params::PlayerStartTransitional_InitTransition Parms{};

	Parms.SpawnedController = SpawnedController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerSubsystem_PlayerHUD.MainStateChanged
// (Final, Native, Protected)
// Parameters:
// EGameMainState                          OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameMainState                          NewGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerSubsystem_PlayerHUD::MainStateChanged(EGameMainState OldState, EGameMainState NewGameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerSubsystem_PlayerHUD", "MainStateChanged");

	Params::PlayerSubsystem_PlayerHUD_MainStateChanged Parms{};

	Parms.OldState = OldState;
	Parms.NewGameState = NewGameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerSubsystem_PlayerHUD.PlayerHealthStateChanged
// (Final, Native, Protected)
// Parameters:
// EPlayerHealthState                      NewHealthState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerSubsystem_PlayerHUD::PlayerHealthStateChanged(EPlayerHealthState NewHealthState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerSubsystem_PlayerHUD", "PlayerHealthStateChanged");

	Params::PlayerSubsystem_PlayerHUD_PlayerHealthStateChanged Parms{};

	Parms.NewHealthState = NewHealthState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction ObsidianFox.PlayerSubsystem_PlayerHUD.PlayerHUDVisibilitySignature__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    bNewHUDVisibility                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerSubsystem_PlayerHUD::PlayerHUDVisibilitySignature__DelegateSignature(bool bNewHUDVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerSubsystem_PlayerHUD", "PlayerHUDVisibilitySignature__DelegateSignature");

	Params::PlayerSubsystem_PlayerHUD_PlayerHUDVisibilitySignature__DelegateSignature Parms{};

	Parms.bNewHUDVisibility = bNewHUDVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ObsidianFox.PlayerSubsystem_PlayerHUD.SetAllowedHUDVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInAllowedHUDVisibility                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerSubsystem_PlayerHUD::SetAllowedHUDVisibility(const bool bInAllowedHUDVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerSubsystem_PlayerHUD", "SetAllowedHUDVisibility");

	Params::PlayerSubsystem_PlayerHUD_SetAllowedHUDVisibility Parms{};

	Parms.bInAllowedHUDVisibility = bInAllowedHUDVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerSubsystem_PlayerHUD.SetUpdateHUDFromMainStateChanged
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInAllowedHUDVisibility                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerSubsystem_PlayerHUD::SetUpdateHUDFromMainStateChanged(const bool bInAllowedHUDVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerSubsystem_PlayerHUD", "SetUpdateHUDFromMainStateChanged");

	Params::PlayerSubsystem_PlayerHUD_SetUpdateHUDFromMainStateChanged Parms{};

	Parms.bInAllowedHUDVisibility = bInAllowedHUDVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.PlayerSubsystem_PlayerHUD.GetAllowedHUDVisibility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerSubsystem_PlayerHUD::GetAllowedHUDVisibility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerSubsystem_PlayerHUD", "GetAllowedHUDVisibility");

	Params::PlayerSubsystem_PlayerHUD_GetAllowedHUDVisibility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PlayerSubsystem_PlayerHUD.GetForceShowHealthBar
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerSubsystem_PlayerHUD::GetForceShowHealthBar() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerSubsystem_PlayerHUD", "GetForceShowHealthBar");

	Params::PlayerSubsystem_PlayerHUD_GetForceShowHealthBar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PreloadLevelsGISubsystem.OnPreActorBeginPlay
// (Final, Native, Protected)

void UPreloadLevelsGISubsystem::OnPreActorBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreloadLevelsGISubsystem", "OnPreActorBeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ProgressionSubsystem.FactChangedHandler
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESubscriptionTagChangeType              ChangeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProgressionSubsystem::FactChangedHandler(const struct FGameplayTag& Tag, ESubscriptionTagChangeType ChangeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "FactChangedHandler");

	Params::ProgressionSubsystem_FactChangedHandler Parms{};

	Parms.Tag = std::move(Tag);
	Parms.ChangeType = ChangeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ProgressionSubsystem.GameLoadedHandler
// (Final, Native, Private)
// Parameters:
// EPersistenceLoadResult                  Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGameWorld*                   SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProgressionSubsystem::GameLoadedHandler(EPersistenceLoadResult Result, class USaveGameWorld* SaveGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GameLoadedHandler");

	Params::ProgressionSubsystem_GameLoadedHandler Parms{};

	Parms.Result = Result;
	Parms.SaveGame = SaveGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ProgressionSubsystem.GameSessionEndedHandler
// (Final, Native, Private)
// Parameters:
// class UGameplaySession*                 GameplaySession                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProgressionSubsystem::GameSessionEndedHandler(class UGameplaySession* GameplaySession)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GameSessionEndedHandler");

	Params::ProgressionSubsystem_GameSessionEndedHandler Parms{};

	Parms.GameplaySession = GameplaySession;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ProgressionSubsystem.GameSessionStartedHandler
// (Final, Native, Private)
// Parameters:
// class UGameplaySession*                 GameplaySession                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProgressionSubsystem::GameSessionStartedHandler(class UGameplaySession* GameplaySession)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GameSessionStartedHandler");

	Params::ProgressionSubsystem_GameSessionStartedHandler Parms{};

	Parms.GameplaySession = GameplaySession;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ProgressionSubsystem.SetChapterFactFromTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ChapterTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProgressionSubsystem::SetChapterFactFromTag(const struct FGameplayTag& ChapterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "SetChapterFactFromTag");

	Params::ProgressionSubsystem_SetChapterFactFromTag Parms{};

	Parms.ChapterTag = std::move(ChapterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ProgressionSubsystem.SetFactsFromProgressionTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ProgressionTag                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProgressionSubsystem::SetFactsFromProgressionTag(const struct FGameplayTag& ProgressionTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "SetFactsFromProgressionTag");

	Params::ProgressionSubsystem_SetFactsFromProgressionTag Parms{};

	Parms.ProgressionTag = std::move(ProgressionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ProgressionSubsystem.SetLevelFactFromTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     LevelTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProgressionSubsystem::SetLevelFactFromTag(const struct FGameplayTag& LevelTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "SetLevelFactFromTag");

	Params::ProgressionSubsystem_SetLevelFactFromTag Parms{};

	Parms.LevelTag = std::move(LevelTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.ProgressionSubsystem.GetChapterName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ChapterTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UProgressionSubsystem::GetChapterName(const struct FGameplayTag& ChapterTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GetChapterName");

	Params::ProgressionSubsystem_GetChapterName Parms{};

	Parms.ChapterTag = std::move(ChapterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProgressionSubsystem.GetChapterTagFromProgression
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ProgressionTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UProgressionSubsystem::GetChapterTagFromProgression(const struct FGameplayTag& ProgressionTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GetChapterTagFromProgression");

	Params::ProgressionSubsystem_GetChapterTagFromProgression Parms{};

	Parms.ProgressionTag = std::move(ProgressionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProgressionSubsystem.GetCurrentChapter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UProgressionSubsystem::GetCurrentChapter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GetCurrentChapter");

	Params::ProgressionSubsystem_GetCurrentChapter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProgressionSubsystem.GetCurrentChapterName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UProgressionSubsystem::GetCurrentChapterName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GetCurrentChapterName");

	Params::ProgressionSubsystem_GetCurrentChapterName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProgressionSubsystem.GetCurrentLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UProgressionSubsystem::GetCurrentLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GetCurrentLevel");

	Params::ProgressionSubsystem_GetCurrentLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProgressionSubsystem.GetCurrentLevelName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UProgressionSubsystem::GetCurrentLevelName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GetCurrentLevelName");

	Params::ProgressionSubsystem_GetCurrentLevelName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProgressionSubsystem.GetCurrentMenuImage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> UProgressionSubsystem::GetCurrentMenuImage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GetCurrentMenuImage");

	Params::ProgressionSubsystem_GetCurrentMenuImage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProgressionSubsystem.GetCurrentProgression
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UProgressionSubsystem::GetCurrentProgression() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GetCurrentProgression");

	Params::ProgressionSubsystem_GetCurrentProgression Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProgressionSubsystem.GetCurrentSaveSlotImage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> UProgressionSubsystem::GetCurrentSaveSlotImage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GetCurrentSaveSlotImage");

	Params::ProgressionSubsystem_GetCurrentSaveSlotImage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProgressionSubsystem.GetLevelName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     LevelTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UProgressionSubsystem::GetLevelName(const struct FGameplayTag& LevelTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GetLevelName");

	Params::ProgressionSubsystem_GetLevelName Parms{};

	Parms.LevelTag = std::move(LevelTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProgressionSubsystem.GetLevelTagFromProgression
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ProgressionTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UProgressionSubsystem::GetLevelTagFromProgression(const struct FGameplayTag& ProgressionTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GetLevelTagFromProgression");

	Params::ProgressionSubsystem_GetLevelTagFromProgression Parms{};

	Parms.ProgressionTag = std::move(ProgressionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProgressionSubsystem.GetLoadingScreenImage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ProgressionTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> UProgressionSubsystem::GetLoadingScreenImage(const struct FGameplayTag& ProgressionTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GetLoadingScreenImage");

	Params::ProgressionSubsystem_GetLoadingScreenImage Parms{};

	Parms.ProgressionTag = std::move(ProgressionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProgressionSubsystem.GetMenuImage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ProgressionTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> UProgressionSubsystem::GetMenuImage(const struct FGameplayTag& ProgressionTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GetMenuImage");

	Params::ProgressionSubsystem_GetMenuImage Parms{};

	Parms.ProgressionTag = std::move(ProgressionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProgressionSubsystem.GetProgressionTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ChapterTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     LevelTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UProgressionSubsystem::GetProgressionTag(const struct FGameplayTag& ChapterTag, const struct FGameplayTag& LevelTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GetProgressionTag");

	Params::ProgressionSubsystem_GetProgressionTag Parms{};

	Parms.ChapterTag = std::move(ChapterTag);
	Parms.LevelTag = std::move(LevelTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.ProgressionSubsystem.GetSaveSlotImage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ProgressionTag                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> UProgressionSubsystem::GetSaveSlotImage(const struct FGameplayTag& ProgressionTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionSubsystem", "GetSaveSlotImage");

	Params::ProgressionSubsystem_GetSaveSlotImage Parms{};

	Parms.ProgressionTag = std::move(ProgressionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.PSOCachingEngineSubsystem.OnSettingsChanged
// (Final, Native, Private)

void UPSOCachingEngineSubsystem::OnSettingsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PSOCachingEngineSubsystem", "OnSettingsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SaveBFL.SaveVariableDoOnce
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    SaveVariable                                           (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESaveBFLDoOnceExec                      Branches                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveBFL::SaveVariableDoOnce(bool& SaveVariable, ESaveBFLDoOnceExec* Branches)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SaveBFL", "SaveVariableDoOnce");

	Params::SaveBFL_SaveVariableDoOnce Parms{};

	Parms.SaveVariable = SaveVariable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	SaveVariable = Parms.SaveVariable;

	if (Branches != nullptr)
		*Branches = Parms.Branches;
}


// Function ObsidianFox.SolventSubsystem.ActivateGauntlet
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           SplinePath                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESolventGauntlet                        Action                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolventSubsystem::ActivateGauntlet(class AActor* SplinePath, float MaxTime, ESolventGauntlet* Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolventSubsystem", "ActivateGauntlet");

	Params::SolventSubsystem_ActivateGauntlet Parms{};

	Parms.SplinePath = SplinePath;
	Parms.MaxTime = MaxTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Action != nullptr)
		*Action = Parms.Action;
}


// Function ObsidianFox.SolventSubsystem.EndGauntlet
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ESolventGauntlet                        Action                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolventSubsystem::EndGauntlet(ESolventGauntlet* Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolventSubsystem", "EndGauntlet");

	Params::SolventSubsystem_EndGauntlet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Action != nullptr)
		*Action = Parms.Action;
}


// Function ObsidianFox.SolventSubsystem.GetGauntletEndLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USolventSubsystem::GetGauntletEndLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolventSubsystem", "GetGauntletEndLocation");

	Params::SolventSubsystem_GetGauntletEndLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.SolventSubsystem.GetGauntletEndSplinePoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USolventSubsystem::GetGauntletEndSplinePoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolventSubsystem", "GetGauntletEndSplinePoint");

	Params::SolventSubsystem_GetGauntletEndSplinePoint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.SolventSubsystem.GetGauntletStartLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USolventSubsystem::GetGauntletStartLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolventSubsystem", "GetGauntletStartLocation");

	Params::SolventSubsystem_GetGauntletStartLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.SolventSubsystem.GetGauntletTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USolventSubsystem::GetGauntletTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolventSubsystem", "GetGauntletTimer");

	Params::SolventSubsystem_GetGauntletTimer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.SolventSubsystem.GetMaxTimeInGauntlet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USolventSubsystem::GetMaxTimeInGauntlet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolventSubsystem", "GetMaxTimeInGauntlet");

	Params::SolventSubsystem_GetMaxTimeInGauntlet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.SolventSubsystem.GetPathLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USolventSubsystem::GetPathLocation(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolventSubsystem", "GetPathLocation");

	Params::SolventSubsystem_GetPathLocation Parms{};

	Parms.Distance = Distance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.SolventSubsystem.GetPlayerPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USolventSubsystem::GetPlayerPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolventSubsystem", "GetPlayerPosition");

	Params::SolventSubsystem_GetPlayerPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.SolventSubsystem.GetProgressPercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USolventSubsystem::GetProgressPercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolventSubsystem", "GetProgressPercent");

	Params::SolventSubsystem_GetProgressPercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.SolventSubsystem.GetSplinePosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector USolventSubsystem::GetSplinePosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolventSubsystem", "GetSplinePosition");

	Params::SolventSubsystem_GetSplinePosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.SolventSubsystem.GetTimePercent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USolventSubsystem::GetTimePercent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolventSubsystem", "GetTimePercent");

	Params::SolventSubsystem_GetTimePercent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.SolventSubsystem.IsGauntletActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USolventSubsystem::IsGauntletActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolventSubsystem", "IsGauntletActive");

	Params::SolventSubsystem_IsGauntletActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.SolventSubsystem.IsGauntletReversed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USolventSubsystem::IsGauntletReversed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolventSubsystem", "IsGauntletReversed");

	Params::SolventSubsystem_IsGauntletReversed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.SolventSubsystem.StartGauntlet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SplinePath                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USolventSubsystem::StartGauntlet(class AActor* SplinePath, float MaxTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SolventSubsystem", "StartGauntlet");

	Params::SolventSubsystem_StartGauntlet Parms{};

	Parms.SplinePath = SplinePath;
	Parms.MaxTime = MaxTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SplineMovementComponent.MoveBackward
// (Final, Native, Public, BlueprintCallable)

void USplineMovementComponent::MoveBackward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplineMovementComponent", "MoveBackward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SplineMovementComponent.MoveForward
// (Final, Native, Public, BlueprintCallable)

void USplineMovementComponent::MoveForward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplineMovementComponent", "MoveForward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SplineMovementComponent.StartSplineMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USplineComponent*                 Spline                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMovementComponent::StartSplineMovement(class USplineComponent* Spline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplineMovementComponent", "StartSplineMovement");

	Params::SplineMovementComponent_StartSplineMovement Parms{};

	Parms.Spline = Spline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SplineMovementComponent.StopAutomatedSplineMovement
// (Final, Native, Public, BlueprintCallable)

void USplineMovementComponent::StopAutomatedSplineMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplineMovementComponent", "StopAutomatedSplineMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SplineMovementComponent.StopSplineMovement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMovementMode                           NewMovementMode                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USplineMovementComponent::StopSplineMovement(EMovementMode NewMovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplineMovementComponent", "StopSplineMovement");

	Params::SplineMovementComponent_StopSplineMovement Parms{};

	Parms.NewMovementMode = NewMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.SplineMovementComponent.IsOnSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USplineMovementComponent::IsOnSpline() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SplineMovementComponent", "IsOnSpline");

	Params::SplineMovementComponent_IsOnSpline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.StartleInterface.OnStartle
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FFocusPointData                  StartleComponentData                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void IStartleInterface::OnStartle(const struct FFocusPointData& StartleComponentData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StartleInterface", "OnStartle");

	Params::StartleInterface_OnStartle Parms{};

	Parms.StartleComponentData = std::move(StartleComponentData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.Talisman.CheckCombination
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Combination                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     FlowTag                                                (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATalisman::CheckCombination(int32 Combination, struct FGameplayTag* FlowTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Talisman", "CheckCombination");

	Params::Talisman_CheckCombination Parms{};

	Parms.Combination = Combination;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FlowTag != nullptr)
		*FlowTag = std::move(Parms.FlowTag);

	return Parms.ReturnValue;
}


// Function ObsidianFox.Talisman.CheckCurrentCombination
// (Final, Native, Protected, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     FlowTag                                                (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATalisman::CheckCurrentCombination(struct FGameplayTag* FlowTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Talisman", "CheckCurrentCombination");

	Params::Talisman_CheckCurrentCombination Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FlowTag != nullptr)
		*FlowTag = std::move(Parms.FlowTag);

	return Parms.ReturnValue;
}


// Function ObsidianFox.TimedObjectiveSubsystem.CancelTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     IdentityTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimedObjectiveSubsystem::CancelTimer(const struct FGameplayTag& IdentityTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimedObjectiveSubsystem", "CancelTimer");

	Params::TimedObjectiveSubsystem_CancelTimer Parms{};

	Parms.IdentityTag = std::move(IdentityTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.TimedObjectiveSubsystem.GetRemainingObjectiveTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     IdentityTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTimedObjectiveSubsystem::GetRemainingObjectiveTime(const struct FGameplayTag& IdentityTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimedObjectiveSubsystem", "GetRemainingObjectiveTime");

	Params::TimedObjectiveSubsystem_GetRemainingObjectiveTime Parms{};

	Parms.IdentityTag = std::move(IdentityTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.TimedObjectiveSubsystem.IsObjectPauseSource
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          SourceObject                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTimedObjectiveSubsystem::IsObjectPauseSource(class UObject* SourceObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimedObjectiveSubsystem", "IsObjectPauseSource");

	Params::TimedObjectiveSubsystem_IsObjectPauseSource Parms{};

	Parms.SourceObject = SourceObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.TimedObjectiveSubsystem.OnCustomPauseSourcesValueUpdatedHandler
// (Final, Native, Private)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimedObjectiveSubsystem::OnCustomPauseSourcesValueUpdatedHandler(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimedObjectiveSubsystem", "OnCustomPauseSourcesValueUpdatedHandler");

	Params::TimedObjectiveSubsystem_OnCustomPauseSourcesValueUpdatedHandler Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.TimedObjectiveSubsystem.OnLocationEnterHandler
// (Final, Native, Private)
// Parameters:
// struct FGameplayTagContainer            LocationTags                                           (Parm, NativeAccessSpecifierPublic)

void UTimedObjectiveSubsystem::OnLocationEnterHandler(const struct FGameplayTagContainer& LocationTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimedObjectiveSubsystem", "OnLocationEnterHandler");

	Params::TimedObjectiveSubsystem_OnLocationEnterHandler Parms{};

	Parms.LocationTags = std::move(LocationTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.TimedObjectiveSubsystem.OnLocationExitHandler
// (Final, Native, Private)
// Parameters:
// struct FGameplayTagContainer            LocationTags                                           (Parm, NativeAccessSpecifierPublic)

void UTimedObjectiveSubsystem::OnLocationExitHandler(const struct FGameplayTagContainer& LocationTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimedObjectiveSubsystem", "OnLocationExitHandler");

	Params::TimedObjectiveSubsystem_OnLocationExitHandler Parms{};

	Parms.LocationTags = std::move(LocationTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.TimedObjectiveSubsystem.OnMainGameStateUpdatedHandler
// (Final, Native, Private)
// Parameters:
// EGameMainState                          OldGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGameMainState                          NewGameState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimedObjectiveSubsystem::OnMainGameStateUpdatedHandler(EGameMainState OldGameState, EGameMainState NewGameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimedObjectiveSubsystem", "OnMainGameStateUpdatedHandler");

	Params::TimedObjectiveSubsystem_OnMainGameStateUpdatedHandler Parms{};

	Parms.OldGameState = OldGameState;
	Parms.NewGameState = NewGameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.TimedObjectiveSubsystem.PauseAllTimers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          SourceObject                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimedObjectiveSubsystem::PauseAllTimers(class UObject* SourceObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimedObjectiveSubsystem", "PauseAllTimers");

	Params::TimedObjectiveSubsystem_PauseAllTimers Parms{};

	Parms.SourceObject = SourceObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.TimedObjectiveSubsystem.PauseTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     IdentityTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimedObjectiveSubsystem::PauseTimer(const struct FGameplayTag& IdentityTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimedObjectiveSubsystem", "PauseTimer");

	Params::TimedObjectiveSubsystem_PauseTimer Parms{};

	Parms.IdentityTag = std::move(IdentityTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.TimedObjectiveSubsystem.ResumeAllTimers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          SourceObject                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimedObjectiveSubsystem::ResumeAllTimers(class UObject* SourceObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimedObjectiveSubsystem", "ResumeAllTimers");

	Params::TimedObjectiveSubsystem_ResumeAllTimers Parms{};

	Parms.SourceObject = SourceObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.TimedObjectiveSubsystem.ResumeTimer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     IdentityTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimedObjectiveSubsystem::ResumeTimer(const struct FGameplayTag& IdentityTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimedObjectiveSubsystem", "ResumeTimer");

	Params::TimedObjectiveSubsystem_ResumeTimer Parms{};

	Parms.IdentityTag = std::move(IdentityTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.TimedObjectiveSubsystem.StartMinimumWaitTime
// (Final, Native, Public, BlueprintCallable)

void UTimedObjectiveSubsystem::StartMinimumWaitTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimedObjectiveSubsystem", "StartMinimumWaitTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.TimedObjectiveSubsystem.StartTimedObjective
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObjectivesData*                  ObjectiveData                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EObjectiveParts                         Part                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     IdentityTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     InObjectiveTag                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTimedObjectiveSubsystem::StartTimedObjective(class UObjectivesData* ObjectiveData, EObjectiveParts Part, float Time, const struct FGameplayTag& IdentityTag, const struct FGameplayTag& InObjectiveTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimedObjectiveSubsystem", "StartTimedObjective");

	Params::TimedObjectiveSubsystem_StartTimedObjective Parms{};

	Parms.ObjectiveData = ObjectiveData;
	Parms.Part = Part;
	Parms.Time = Time;
	Parms.IdentityTag = std::move(IdentityTag);
	Parms.InObjectiveTag = std::move(InObjectiveTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponAnimationHandDataAsset.GetAnimationDataForCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AOFPlayerCharacter*               Character                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWeaponAnimationHandData         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FWeaponAnimationHandData UWeaponAnimationHandDataAsset::GetAnimationDataForCharacter(const class AOFPlayerCharacter* Character) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimationHandDataAsset", "GetAnimationDataForCharacter");

	Params::WeaponAnimationHandDataAsset_GetAnimationDataForCharacter Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.WeaponAnimInstance.StateTimeoutReached
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   MachineIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponAnimInstance::StateTimeoutReached(int32 MachineIndex, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimInstance", "StateTimeoutReached");

	Params::WeaponAnimInstance_StateTimeoutReached Parms{};

	Parms.MachineIndex = MachineIndex;
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.WeaponAnimInstance.IsAttachedToSocket
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWeaponAnimInstance::IsAttachedToSocket(class FName SocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponAnimInstance", "IsAttachedToSocket");

	Params::WeaponAnimInstance_IsAttachedToSocket Parms{};

	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.WeaponWidget.OnMonitoredWeaponDestroyed
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponWidget::OnMonitoredWeaponDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponWidget", "OnMonitoredWeaponDestroyed");

	Params::WeaponWidget_OnMonitoredWeaponDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponWidget.OnMonitoredWeaponEquipped
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AOFWeaponActor*                   DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponWidget::OnMonitoredWeaponEquipped(class AOFWeaponActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponWidget", "OnMonitoredWeaponEquipped");

	Params::WeaponWidget_OnMonitoredWeaponEquipped Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WeaponWidget.OnMonitoredWeaponUnequipped
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AOFWeaponActor*                   DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWeaponWidget::OnMonitoredWeaponUnequipped(class AOFWeaponActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WeaponWidget", "OnMonitoredWeaponUnequipped");

	Params::WeaponWidget_OnMonitoredWeaponUnequipped Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WorldSubsystem_EQSPlayerValidPoints.SetNearbyPoints
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>                  Points                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UWorldSubsystem_EQSPlayerValidPoints::SetNearbyPoints(const TArray<struct FVector>& Points)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldSubsystem_EQSPlayerValidPoints", "SetNearbyPoints");

	Params::WorldSubsystem_EQSPlayerValidPoints_SetNearbyPoints Parms{};

	Parms.Points = std::move(Points);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ObsidianFox.WorldSubsystem_EQSPlayerValidPoints.GetNearbyPoints
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FVector>            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FVector> UWorldSubsystem_EQSPlayerValidPoints::GetNearbyPoints() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldSubsystem_EQSPlayerValidPoints", "GetNearbyPoints");

	Params::WorldSubsystem_EQSPlayerValidPoints_GetNearbyPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ObsidianFox.WorldSubsystem_MonsterManager.MonsterDisengaged
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class AObsidianFoxCharacter*            OFCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldSubsystem_MonsterManager::MonsterDisengaged(class AObsidianFoxCharacter* OFCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldSubsystem_MonsterManager", "MonsterDisengaged");

	Params::WorldSubsystem_MonsterManager_MonsterDisengaged Parms{};

	Parms.OFCharacter = OFCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

