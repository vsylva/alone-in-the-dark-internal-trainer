#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FunctionLibrary_Blueprint

#include "Basic.hpp"

#include "FunctionLibrary_Blueprint_classes.hpp"
#include "FunctionLibrary_Blueprint_parameters.hpp"


namespace SDK
{

// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.OF Spawn Force Feedback Attached
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UForceFeedbackEffect*             ForceFeedbackEffect                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class USceneComponent*                  AttachToComponent                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             AttachPointName                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// EAttachLocation                         LocationType                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bStopWhenAttachedToDestroyed                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bLooping                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   IntensityMultiplier                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UForceFeedbackAttenuation*        AttenuationSettings                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bAutoDestroy                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFunctionLibrary_Blueprint_C::OF_Spawn_Force_Feedback_Attached(class UForceFeedbackEffect* ForceFeedbackEffect, class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, const struct FRotator& Rotation, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "OF Spawn Force Feedback Attached");

	Params::FunctionLibrary_Blueprint_C_OF_Spawn_Force_Feedback_Attached Parms{};

	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPointName = AttachPointName;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.LocationType = LocationType;
	Parms.bStopWhenAttachedToDestroyed = bStopWhenAttachedToDestroyed;
	Parms.bLooping = bLooping;
	Parms.IntensityMultiplier = IntensityMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.OF Spawn Force Feedback At Location
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UForceFeedbackEffect*             ForceFeedbackEffect                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bLooping                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   IntensityMultiplier                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   StartTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UForceFeedbackAttenuation*        AttenuationSettings                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bAutoDestroy                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFunctionLibrary_Blueprint_C::OF_Spawn_Force_Feedback_At_Location(class UForceFeedbackEffect* ForceFeedbackEffect, const struct FVector& Location, const struct FRotator& Rotation, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "OF Spawn Force Feedback At Location");

	Params::FunctionLibrary_Blueprint_C_OF_Spawn_Force_Feedback_At_Location Parms{};

	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.bLooping = bLooping;
	Parms.IntensityMultiplier = IntensityMultiplier;
	Parms.StartTime = StartTime;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.bAutoDestroy = bAutoDestroy;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.OF Play Force Feedback
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UForceFeedbackEffect*             ForceFeedbackEffect                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             Tag                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bLooping                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bIgnoreTimeDilation                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bPlayWhilePaused                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFunctionLibrary_Blueprint_C::OF_Play_Force_Feedback(class UForceFeedbackEffect* ForceFeedbackEffect, class FName Tag, bool bLooping, bool bIgnoreTimeDilation, bool bPlayWhilePaused, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "OF Play Force Feedback");

	Params::FunctionLibrary_Blueprint_C_OF_Play_Force_Feedback Parms{};

	Parms.ForceFeedbackEffect = ForceFeedbackEffect;
	Parms.Tag = Tag;
	Parms.bLooping = bLooping;
	Parms.bIgnoreTimeDilation = bIgnoreTimeDilation;
	Parms.bPlayWhilePaused = bPlayWhilePaused;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.SortActorsByDistance
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class AActor*                           SourceActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   SortedArray                                            (Parm, OutParm)

void UFunctionLibrary_Blueprint_C::SortActorsByDistance(TArray<class AActor*>& Array, class AActor* SourceActor, class UObject* __WorldContext, TArray<class AActor*>* SortedArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "SortActorsByDistance");

	Params::FunctionLibrary_Blueprint_C_SortActorsByDistance Parms{};

	Parms.Array = std::move(Array);
	Parms.SourceActor = SourceActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (SortedArray != nullptr)
		*SortedArray = std::move(Parms.SortedArray);
}


// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.GetEnemyThreatWithinRange
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Range                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct EnemyThreatData::FEnemyThreatData>EnemyThreatDataOut                                     (Parm, OutParm)

void UFunctionLibrary_Blueprint_C::GetEnemyThreatWithinRange(float Range, class UObject* __WorldContext, TArray<struct EnemyThreatData::FEnemyThreatData>* EnemyThreatDataOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "GetEnemyThreatWithinRange");

	Params::FunctionLibrary_Blueprint_C_GetEnemyThreatWithinRange Parms{};

	Parms.Range = Range;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (EnemyThreatDataOut != nullptr)
		*EnemyThreatDataOut = std::move(Parms.EnemyThreatDataOut);
}


// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.GetActorsWithinRange
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class AActor>               Class_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
// float                                   Range                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           SourceActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>                   FoundActors                                            (Parm, OutParm)

void UFunctionLibrary_Blueprint_C::GetActorsWithinRange(TSubclassOf<class AActor> Class_0, float Range, class AActor* SourceActor, class UObject* __WorldContext, TArray<class AActor*>* FoundActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "GetActorsWithinRange");

	Params::FunctionLibrary_Blueprint_C_GetActorsWithinRange Parms{};

	Parms.Class_0 = Class_0;
	Parms.Range = Range;
	Parms.SourceActor = SourceActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (FoundActors != nullptr)
		*FoundActors = std::move(Parms.FoundActors);
}


// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.GetClosestActorFromVector
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class AActor>               OfClass                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
// struct FVector                          OriginVector                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   WithinRange                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseWithinRange                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           ClosestActor                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFunctionLibrary_Blueprint_C::GetClosestActorFromVector(TSubclassOf<class AActor> OfClass, const struct FVector& OriginVector, float WithinRange, bool UseWithinRange, class UObject* __WorldContext, class AActor** ClosestActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "GetClosestActorFromVector");

	Params::FunctionLibrary_Blueprint_C_GetClosestActorFromVector Parms{};

	Parms.OfClass = OfClass;
	Parms.OriginVector = std::move(OriginVector);
	Parms.WithinRange = WithinRange;
	Parms.UseWithinRange = UseWithinRange;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ClosestActor != nullptr)
		*ClosestActor = Parms.ClosestActor;
}


// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.Move Camera to Target
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Camera_Rotation_Alpha                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         StartingControlRotation                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFunctionLibrary_Blueprint_C::Move_Camera_to_Target(class AActor* Target, float Camera_Rotation_Alpha, const struct FRotator& StartingControlRotation, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "Move Camera to Target");

	Params::FunctionLibrary_Blueprint_C_Move_Camera_to_Target Parms{};

	Parms.Target = Target;
	Parms.Camera_Rotation_Alpha = Camera_Rotation_Alpha;
	Parms.StartingControlRotation = std::move(StartingControlRotation);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.GetClosestActorFromArray
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   ActorArray                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class AActor*                           OriginActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   WithinRange                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseWithinRange                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           ClosestActor                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFunctionLibrary_Blueprint_C::GetClosestActorFromArray(TArray<class AActor*>& ActorArray, class AActor* OriginActor, float WithinRange, bool UseWithinRange, class UObject* __WorldContext, class AActor** ClosestActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "GetClosestActorFromArray");

	Params::FunctionLibrary_Blueprint_C_GetClosestActorFromArray Parms{};

	Parms.ActorArray = std::move(ActorArray);
	Parms.OriginActor = OriginActor;
	Parms.WithinRange = WithinRange;
	Parms.UseWithinRange = UseWithinRange;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	ActorArray = std::move(Parms.ActorArray);

	if (ClosestActor != nullptr)
		*ClosestActor = Parms.ClosestActor;
}


// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.GetCurrentActWorld
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EActWorlds                              NewParam                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFunctionLibrary_Blueprint_C::GetCurrentActWorld(class UObject* __WorldContext, EActWorlds* NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "GetCurrentActWorld");

	Params::FunctionLibrary_Blueprint_C_GetCurrentActWorld Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = Parms.NewParam;
}


// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.Close Item Picker
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFunctionLibrary_Blueprint_C::Close_Item_Picker(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "Close Item Picker");

	Params::FunctionLibrary_Blueprint_C_Close_Item_Picker Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.Open Item Picker
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          ObjectCaller                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    DeleteItemAfterUse                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UWBP_ItemPicker_C*                ItemPickerWidget                                       (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFunctionLibrary_Blueprint_C::Open_Item_Picker(class UObject* ObjectCaller, bool DeleteItemAfterUse, class UObject* __WorldContext, class UWBP_ItemPicker_C** ItemPickerWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "Open Item Picker");

	Params::FunctionLibrary_Blueprint_C_Open_Item_Picker Parms{};

	Parms.ObjectCaller = ObjectCaller;
	Parms.DeleteItemAfterUse = DeleteItemAfterUse;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ItemPickerWidget != nullptr)
		*ItemPickerWidget = Parms.ItemPickerWidget;
}


// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.playReaction
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Version                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFunctionLibrary_Blueprint_C::PlayReaction(class FName Version, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "playReaction");

	Params::FunctionLibrary_Blueprint_C_PlayReaction Parms{};

	Parms.Version = Version;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.GetClosestActor
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class AActor>               OfClass                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
// class AActor*                           OriginActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   WithinRange                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    UseWithinRange                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           ClosestActor                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFunctionLibrary_Blueprint_C::GetClosestActor(TSubclassOf<class AActor> OfClass, class AActor* OriginActor, float WithinRange, bool UseWithinRange, class UObject* __WorldContext, class AActor** ClosestActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "GetClosestActor");

	Params::FunctionLibrary_Blueprint_C_GetClosestActor Parms{};

	Parms.OfClass = OfClass;
	Parms.OriginActor = OriginActor;
	Parms.WithinRange = WithinRange;
	Parms.UseWithinRange = UseWithinRange;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ClosestActor != nullptr)
		*ClosestActor = Parms.ClosestActor;
}


// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.GetClosestEnemyCharacter
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   WithinRange                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bUeWithinRange                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    NoDead                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           OriginActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTagContainer            DisallowedTags                                         (BlueprintVisible, BlueprintReadOnly, Parm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AObsidianFoxCharacter*            Character                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UFunctionLibrary_Blueprint_C::GetClosestEnemyCharacter(float WithinRange, bool bUeWithinRange, bool NoDead, class AActor* OriginActor, const struct FGameplayTagContainer& DisallowedTags, class UObject* __WorldContext, class AObsidianFoxCharacter** Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "GetClosestEnemyCharacter");

	Params::FunctionLibrary_Blueprint_C_GetClosestEnemyCharacter Parms{};

	Parms.WithinRange = WithinRange;
	Parms.bUeWithinRange = bUeWithinRange;
	Parms.NoDead = NoDead;
	Parms.OriginActor = OriginActor;
	Parms.DisallowedTags = std::move(DisallowedTags);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Character != nullptr)
		*Character = Parms.Character;
}


// Function FunctionLibrary_Blueprint.FunctionLibrary_Blueprint_C.Get In Game Time
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FDateTime                        DateTime                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UFunctionLibrary_Blueprint_C::Get_In_Game_Time(class UObject* __WorldContext, struct FDateTime* DateTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FunctionLibrary_Blueprint_C", "Get In Game Time");

	Params::FunctionLibrary_Blueprint_C_Get_In_Game_Time Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (DateTime != nullptr)
		*DateTime = std::move(Parms.DateTime);
}

}

