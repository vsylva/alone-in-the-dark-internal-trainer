#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PiecesAnimNodes

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "FMODStudio_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameplayAbilities_classes.hpp"
#include "PiecesAnimNodes_structs.hpp"
#include "DeveloperSettings_classes.hpp"


namespace SDK
{

// Class PiecesAnimNodes.AnimationTagComponent
// 0x0050 (0x0108 - 0x00B8)
class UAnimationTagComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTag(const class UObject* Caller, const struct FGameplayTag& Tag);
	void RemoveTag(const class UObject* Caller, const struct FGameplayTag& Tag);

	int32 GetNumReferencersForTag(const struct FGameplayTag& Tag) const;
	bool HasTag(const struct FGameplayTag& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationTagComponent">();
	}
	static class UAnimationTagComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationTagComponent>();
	}
};
static_assert(alignof(UAnimationTagComponent) == 0x000008, "Wrong alignment on UAnimationTagComponent");
static_assert(sizeof(UAnimationTagComponent) == 0x000108, "Wrong size on UAnimationTagComponent");

// Class PiecesAnimNodes.BPAsyncAction_PlayMontageBase
// 0x00E0 (0x0110 - 0x0030)
class UBPAsyncAction_PlayMontageBase : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnCompleted;                                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFullyBlendedOut;                                 // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlendOut;                                        // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInterrupted;                                     // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotifyBegin;                                     // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNotifyEnd;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlendOutAllowedBegin;                            // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlendOutAllowedEnd;                              // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x28];                                      // 0x00B0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ActionMontageToPlay;                               // 0x00D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E0[0x30];                                      // 0x00E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBlendOutAllowedNotifyStateChangedHandler(const class UAnimSequenceBase* Sequence, bool bNotifyBegin);
	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageNotifyBegin(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointPayload);
	void OnMontageNotifyEnd(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointPayload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPAsyncAction_PlayMontageBase">();
	}
	static class UBPAsyncAction_PlayMontageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPAsyncAction_PlayMontageBase>();
	}
};
static_assert(alignof(UBPAsyncAction_PlayMontageBase) == 0x000008, "Wrong alignment on UBPAsyncAction_PlayMontageBase");
static_assert(sizeof(UBPAsyncAction_PlayMontageBase) == 0x000110, "Wrong size on UBPAsyncAction_PlayMontageBase");
static_assert(offsetof(UBPAsyncAction_PlayMontageBase, OnCompleted) == 0x000030, "Member 'UBPAsyncAction_PlayMontageBase::OnCompleted' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_PlayMontageBase, OnFullyBlendedOut) == 0x000040, "Member 'UBPAsyncAction_PlayMontageBase::OnFullyBlendedOut' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_PlayMontageBase, OnBlendOut) == 0x000050, "Member 'UBPAsyncAction_PlayMontageBase::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_PlayMontageBase, OnInterrupted) == 0x000060, "Member 'UBPAsyncAction_PlayMontageBase::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_PlayMontageBase, OnNotifyBegin) == 0x000070, "Member 'UBPAsyncAction_PlayMontageBase::OnNotifyBegin' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_PlayMontageBase, OnNotifyEnd) == 0x000080, "Member 'UBPAsyncAction_PlayMontageBase::OnNotifyEnd' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_PlayMontageBase, OnBlendOutAllowedBegin) == 0x000090, "Member 'UBPAsyncAction_PlayMontageBase::OnBlendOutAllowedBegin' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_PlayMontageBase, OnBlendOutAllowedEnd) == 0x0000A0, "Member 'UBPAsyncAction_PlayMontageBase::OnBlendOutAllowedEnd' has a wrong offset!");
static_assert(offsetof(UBPAsyncAction_PlayMontageBase, ActionMontageToPlay) == 0x0000D8, "Member 'UBPAsyncAction_PlayMontageBase::ActionMontageToPlay' has a wrong offset!");

// Class PiecesAnimNodes.AnimationInputInterface
// 0x0000 (0x0028 - 0x0028)
class IAnimationInputInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationInputInterface">();
	}
	static class IAnimationInputInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimationInputInterface>();
	}
};
static_assert(alignof(IAnimationInputInterface) == 0x000008, "Wrong alignment on IAnimationInputInterface");
static_assert(sizeof(IAnimationInputInterface) == 0x000028, "Wrong size on IAnimationInputInterface");

// Class PiecesAnimNodes.PiecesAnimationStaggeredUpdateManager_WorldSubsystem
// 0x0078 (0x00B8 - 0x0040)
class UPiecesAnimationStaggeredUpdateManager_WorldSubsystem final : public UTickableWorldSubsystem
{
public:
	TArray<class UAnimationStaggerUpdateHandle*>  Handles;                                           // 0x0040(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x68];                                      // 0x0050(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesAnimationStaggeredUpdateManager_WorldSubsystem">();
	}
	static class UPiecesAnimationStaggeredUpdateManager_WorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPiecesAnimationStaggeredUpdateManager_WorldSubsystem>();
	}
};
static_assert(alignof(UPiecesAnimationStaggeredUpdateManager_WorldSubsystem) == 0x000008, "Wrong alignment on UPiecesAnimationStaggeredUpdateManager_WorldSubsystem");
static_assert(sizeof(UPiecesAnimationStaggeredUpdateManager_WorldSubsystem) == 0x0000B8, "Wrong size on UPiecesAnimationStaggeredUpdateManager_WorldSubsystem");
static_assert(offsetof(UPiecesAnimationStaggeredUpdateManager_WorldSubsystem, Handles) == 0x000040, "Member 'UPiecesAnimationStaggeredUpdateManager_WorldSubsystem::Handles' has a wrong offset!");

// Class PiecesAnimNodes.PiecesAnimInstance
// 0x0160 (0x0430 - 0x02D0)
class UPiecesAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_2C8[0x168];                                    // 0x02C8(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintUpdateAnimationStaggered(float DeltaTime);
	bool GetEarlyBlendOutPossible(int32 MachineIndex, int32 TransitionIndex);
	struct FTransform GetRecordedComponentSpaceTransform(const class FName& BoneName, const class FName& SnapshotName);

	bool IsSlotPlayingMontage(const class FName& SlotName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesAnimInstance">();
	}
	static class UPiecesAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPiecesAnimInstance>();
	}
};
static_assert(alignof(UPiecesAnimInstance) == 0x000010, "Wrong alignment on UPiecesAnimInstance");
static_assert(sizeof(UPiecesAnimInstance) == 0x000430, "Wrong size on UPiecesAnimInstance");

// Class PiecesAnimNodes.AbilityTask_PiecesPlayMontageAndWait
// 0x0020 (0x0128 - 0x0108)
class UAbilityTask_PiecesPlayMontageAndWait final : public UAbilityTask_PlayMontageAndWait
{
public:
	FMulticastInlineDelegateProperty_             OnBlendOutAllowedBegin;                            // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnBlendOutAllowedEnd;                              // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UAbilityTask_PiecesPlayMontageAndWait* PiecesPlayMontageAndWait(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* InMontageToPlay, float InRate, class FName InStartSection, bool bInStopWhenAbilityEnds, float InAnimRootMotionTranslationScale, float InStartTimeSeconds);

	void OnBlendOutAllowedNotifyStateChangedHandler(const class UAnimSequenceBase* Sequence, bool bNotifyBegin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_PiecesPlayMontageAndWait">();
	}
	static class UAbilityTask_PiecesPlayMontageAndWait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_PiecesPlayMontageAndWait>();
	}
};
static_assert(alignof(UAbilityTask_PiecesPlayMontageAndWait) == 0x000008, "Wrong alignment on UAbilityTask_PiecesPlayMontageAndWait");
static_assert(sizeof(UAbilityTask_PiecesPlayMontageAndWait) == 0x000128, "Wrong size on UAbilityTask_PiecesPlayMontageAndWait");
static_assert(offsetof(UAbilityTask_PiecesPlayMontageAndWait, OnBlendOutAllowedBegin) == 0x000108, "Member 'UAbilityTask_PiecesPlayMontageAndWait::OnBlendOutAllowedBegin' has a wrong offset!");
static_assert(offsetof(UAbilityTask_PiecesPlayMontageAndWait, OnBlendOutAllowedEnd) == 0x000118, "Member 'UAbilityTask_PiecesPlayMontageAndWait::OnBlendOutAllowedEnd' has a wrong offset!");

// Class PiecesAnimNodes.AnimationBarkMetaData
// 0x0028 (0x0050 - 0x0028)
class UAnimationBarkMetaData final : public UAnimMetaData
{
public:
	class FName                                   BarkBaseName;                                      // 0x0028(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   BarkLine;                                          // 0x0030(0x0018)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   BarkContext;                                       // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationBarkMetaData">();
	}
	static class UAnimationBarkMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationBarkMetaData>();
	}
};
static_assert(alignof(UAnimationBarkMetaData) == 0x000008, "Wrong alignment on UAnimationBarkMetaData");
static_assert(sizeof(UAnimationBarkMetaData) == 0x000050, "Wrong size on UAnimationBarkMetaData");
static_assert(offsetof(UAnimationBarkMetaData, BarkBaseName) == 0x000028, "Member 'UAnimationBarkMetaData::BarkBaseName' has a wrong offset!");
static_assert(offsetof(UAnimationBarkMetaData, BarkLine) == 0x000030, "Member 'UAnimationBarkMetaData::BarkLine' has a wrong offset!");
static_assert(offsetof(UAnimationBarkMetaData, BarkContext) == 0x000048, "Member 'UAnimationBarkMetaData::BarkContext' has a wrong offset!");

// Class PiecesAnimNodes.AnimNotify_PlayMontage
// 0x0068 (0x00A0 - 0x0038)
class UAnimNotify_PlayMontage : public UAnimNotify
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopOtherMontagesInTheSameGroup;                   // 0x0040(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayAsBark;                                       // 0x0041(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBarkCollection                        BarkCollection;                                    // 0x0048(0x0050)(Edit, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EBarkPriority                                 BarkPriority;                                      // 0x0098(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlayMontage">();
	}
	static class UAnimNotify_PlayMontage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlayMontage>();
	}
};
static_assert(alignof(UAnimNotify_PlayMontage) == 0x000008, "Wrong alignment on UAnimNotify_PlayMontage");
static_assert(sizeof(UAnimNotify_PlayMontage) == 0x0000A0, "Wrong size on UAnimNotify_PlayMontage");
static_assert(offsetof(UAnimNotify_PlayMontage, MontageToPlay) == 0x000038, "Member 'UAnimNotify_PlayMontage::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayMontage, StopOtherMontagesInTheSameGroup) == 0x000040, "Member 'UAnimNotify_PlayMontage::StopOtherMontagesInTheSameGroup' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayMontage, bPlayAsBark) == 0x000041, "Member 'UAnimNotify_PlayMontage::bPlayAsBark' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayMontage, BarkCollection) == 0x000048, "Member 'UAnimNotify_PlayMontage::BarkCollection' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlayMontage, BarkPriority) == 0x000098, "Member 'UAnimNotify_PlayMontage::BarkPriority' has a wrong offset!");

// Class PiecesAnimNodes.AnimNotifyBlendOutAllowedInterface
// 0x0000 (0x0028 - 0x0028)
class IAnimNotifyBlendOutAllowedInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyBlendOutAllowedInterface">();
	}
	static class IAnimNotifyBlendOutAllowedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAnimNotifyBlendOutAllowedInterface>();
	}
};
static_assert(alignof(IAnimNotifyBlendOutAllowedInterface) == 0x000008, "Wrong alignment on IAnimNotifyBlendOutAllowedInterface");
static_assert(sizeof(IAnimNotifyBlendOutAllowedInterface) == 0x000028, "Wrong size on IAnimNotifyBlendOutAllowedInterface");

// Class PiecesAnimNodes.AnimNotifyState_AddAnimationTag
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_AddAnimationTag final : public UAnimNotifyState
{
public:
	struct FGameplayTag                           TagToAdd;                                          // 0x0030(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_AddAnimationTag">();
	}
	static class UAnimNotifyState_AddAnimationTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_AddAnimationTag>();
	}
};
static_assert(alignof(UAnimNotifyState_AddAnimationTag) == 0x000008, "Wrong alignment on UAnimNotifyState_AddAnimationTag");
static_assert(sizeof(UAnimNotifyState_AddAnimationTag) == 0x000038, "Wrong size on UAnimNotifyState_AddAnimationTag");
static_assert(offsetof(UAnimNotifyState_AddAnimationTag, TagToAdd) == 0x000030, "Member 'UAnimNotifyState_AddAnimationTag::TagToAdd' has a wrong offset!");

// Class PiecesAnimNodes.AnimNotifyState_AlignToFloor
// 0x0028 (0x0058 - 0x0030)
class UAnimNotifyState_AlignToFloor final : public UAnimNotifyState
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_AlignToFloor">();
	}
	static class UAnimNotifyState_AlignToFloor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_AlignToFloor>();
	}
};
static_assert(alignof(UAnimNotifyState_AlignToFloor) == 0x000008, "Wrong alignment on UAnimNotifyState_AlignToFloor");
static_assert(sizeof(UAnimNotifyState_AlignToFloor) == 0x000058, "Wrong size on UAnimNotifyState_AlignToFloor");

// Class PiecesAnimNodes.AnimNotifyState_BlendOutAllowed
// 0x0090 (0x00C0 - 0x0030)
class UAnimNotifyState_BlendOutAllowed final : public UAnimNotifyState
{
public:
	uint8                                         bBlendOutOnMovementInput : 1;                      // 0x0030(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBlendOutOnNoMovementInput : 1;                    // 0x0030(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bCustomBlendOutTime : 1;                           // 0x0030(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bBlendOutTimeBasedOnNotifyLength : 1;              // 0x0030(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendOutTime;                                      // 0x0034(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPiecesAnimInstance>        AnimationInstance;                                 // 0x0038(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCachedAnimTransitionData              BlendOutTransition;                                // 0x0040(0x0024)(Edit, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x8];                                       // 0x0064(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EarlyBlendOutEnabledMachine;                       // 0x006C(0x0004)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<int32>                                   EarlyBlendOutEnabledStates;                        // 0x0070(0x0050)(BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_BlendOutAllowed">();
	}
	static class UAnimNotifyState_BlendOutAllowed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_BlendOutAllowed>();
	}
};
static_assert(alignof(UAnimNotifyState_BlendOutAllowed) == 0x000008, "Wrong alignment on UAnimNotifyState_BlendOutAllowed");
static_assert(sizeof(UAnimNotifyState_BlendOutAllowed) == 0x0000C0, "Wrong size on UAnimNotifyState_BlendOutAllowed");
static_assert(offsetof(UAnimNotifyState_BlendOutAllowed, BlendOutTime) == 0x000034, "Member 'UAnimNotifyState_BlendOutAllowed::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BlendOutAllowed, AnimationInstance) == 0x000038, "Member 'UAnimNotifyState_BlendOutAllowed::AnimationInstance' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BlendOutAllowed, BlendOutTransition) == 0x000040, "Member 'UAnimNotifyState_BlendOutAllowed::BlendOutTransition' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BlendOutAllowed, EarlyBlendOutEnabledMachine) == 0x00006C, "Member 'UAnimNotifyState_BlendOutAllowed::EarlyBlendOutEnabledMachine' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_BlendOutAllowed, EarlyBlendOutEnabledStates) == 0x000070, "Member 'UAnimNotifyState_BlendOutAllowed::EarlyBlendOutEnabledStates' has a wrong offset!");

// Class PiecesAnimNodes.AnimNotifyState_CameraModifier
// 0x0018 (0x0048 - 0x0030)
class UAnimNotifyState_CameraModifier final : public UAnimNotifyState
{
public:
	TSubclassOf<class UCameraModifier>            ModifierClass;                                     // 0x0030(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AllowStackingModifiers;                            // 0x0038(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          KeepModifierAlive;                                 // 0x0039(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraModifier*                        ModifierInstance;                                  // 0x0040(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_CameraModifier">();
	}
	static class UAnimNotifyState_CameraModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_CameraModifier>();
	}
};
static_assert(alignof(UAnimNotifyState_CameraModifier) == 0x000008, "Wrong alignment on UAnimNotifyState_CameraModifier");
static_assert(sizeof(UAnimNotifyState_CameraModifier) == 0x000048, "Wrong size on UAnimNotifyState_CameraModifier");
static_assert(offsetof(UAnimNotifyState_CameraModifier, ModifierClass) == 0x000030, "Member 'UAnimNotifyState_CameraModifier::ModifierClass' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_CameraModifier, AllowStackingModifiers) == 0x000038, "Member 'UAnimNotifyState_CameraModifier::AllowStackingModifiers' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_CameraModifier, KeepModifierAlive) == 0x000039, "Member 'UAnimNotifyState_CameraModifier::KeepModifierAlive' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_CameraModifier, ModifierInstance) == 0x000040, "Member 'UAnimNotifyState_CameraModifier::ModifierInstance' has a wrong offset!");

// Class PiecesAnimNodes.AnimNotifyState_MotionWarping
// 0x0010 (0x0040 - 0x0030)
class UAnimNotifyState_MotionWarping final : public UAnimNotifyState
{
public:
	struct FGameplayTag                           MotionIdentifier;                                  // 0x0030(0x0008)(Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bApplyTranslation : 1;                             // 0x0038(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreZ : 1;                                      // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bIgnoreXY : 1;                                     // 0x0038(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bApplyRotation : 1;                                // 0x0038(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_MotionWarping">();
	}
	static class UAnimNotifyState_MotionWarping* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_MotionWarping>();
	}
};
static_assert(alignof(UAnimNotifyState_MotionWarping) == 0x000008, "Wrong alignment on UAnimNotifyState_MotionWarping");
static_assert(sizeof(UAnimNotifyState_MotionWarping) == 0x000040, "Wrong size on UAnimNotifyState_MotionWarping");
static_assert(offsetof(UAnimNotifyState_MotionWarping, MotionIdentifier) == 0x000030, "Member 'UAnimNotifyState_MotionWarping::MotionIdentifier' has a wrong offset!");

// Class PiecesAnimNodes.AnimNotifyState_PlaySound
// 0x0090 (0x00C0 - 0x0030)
class alignas(0x10) UAnimNotifyState_PlaySound final : public UAnimNotifyState
{
public:
	class UAnimMontage*                           PlayingMontageRef;                                 // 0x0030(0x0008)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         BitPad_38_0 : 1;                                   // 0x0038(0x0001)(Fixing Bit-Field Size Between Bits [ Dumper-7 ])
	uint8                                         bPlayAfterNotifyEnd : 1;                           // 0x0038(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bPlayAfterInterrupt : 1;                           // 0x0038(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bStopMontageOnAudioFinished : 1;                   // 0x0038(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bFollow : 1;                                       // 0x0038(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bUseRandomizeBarks : 1;                            // 0x0038(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         ShowSubtitle : 1;                                  // 0x0038(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AttachName;                                        // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFMODEvent*                             Event;                                             // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FFMODEventInstance>             EventInstances;                                    // 0x0058(0x0010)(BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UFMODAudioComponent>> EventAudioComponents;                              // 0x0068(0x0010)(ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FText                                   FMODProgrammerSoundKey;                            // 0x0078(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<class FText>                           SequentialFMODProgrammerSoundKeys;                 // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FText>                           RandomizedFMODProgrammerSoundKeys;                 // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_PlaySound">();
	}
	static class UAnimNotifyState_PlaySound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_PlaySound>();
	}
};
static_assert(alignof(UAnimNotifyState_PlaySound) == 0x000010, "Wrong alignment on UAnimNotifyState_PlaySound");
static_assert(sizeof(UAnimNotifyState_PlaySound) == 0x0000C0, "Wrong size on UAnimNotifyState_PlaySound");
static_assert(offsetof(UAnimNotifyState_PlaySound, PlayingMontageRef) == 0x000030, "Member 'UAnimNotifyState_PlaySound::PlayingMontageRef' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_PlaySound, AttachName) == 0x000040, "Member 'UAnimNotifyState_PlaySound::AttachName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_PlaySound, Event) == 0x000050, "Member 'UAnimNotifyState_PlaySound::Event' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_PlaySound, EventInstances) == 0x000058, "Member 'UAnimNotifyState_PlaySound::EventInstances' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_PlaySound, EventAudioComponents) == 0x000068, "Member 'UAnimNotifyState_PlaySound::EventAudioComponents' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_PlaySound, FMODProgrammerSoundKey) == 0x000078, "Member 'UAnimNotifyState_PlaySound::FMODProgrammerSoundKey' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_PlaySound, SequentialFMODProgrammerSoundKeys) == 0x000090, "Member 'UAnimNotifyState_PlaySound::SequentialFMODProgrammerSoundKeys' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_PlaySound, RandomizedFMODProgrammerSoundKeys) == 0x0000B0, "Member 'UAnimNotifyState_PlaySound::RandomizedFMODProgrammerSoundKeys' has a wrong offset!");

// Class PiecesAnimNodes.AnimNotifyState_RootMotion
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_RootMotion final : public UAnimNotifyState
{
public:
	struct FPiecesRootMotionMaskParams            RootMotionMask;                                    // 0x0030(0x0001)(Edit, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_RootMotion">();
	}
	static class UAnimNotifyState_RootMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_RootMotion>();
	}
};
static_assert(alignof(UAnimNotifyState_RootMotion) == 0x000008, "Wrong alignment on UAnimNotifyState_RootMotion");
static_assert(sizeof(UAnimNotifyState_RootMotion) == 0x000038, "Wrong size on UAnimNotifyState_RootMotion");
static_assert(offsetof(UAnimNotifyState_RootMotion, RootMotionMask) == 0x000030, "Member 'UAnimNotifyState_RootMotion::RootMotionMask' has a wrong offset!");

// Class PiecesAnimNodes.AnimNotifyState_SetRootMotionMode
// 0x0008 (0x0038 - 0x0030)
class UAnimNotifyState_SetRootMotionMode final : public UAnimNotifyState
{
public:
	ERootMotionMode                               RootMotionMode;                                    // 0x0030(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERootMotionMode                               PreviousRootMotionMode;                            // 0x0031(0x0001)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SetRootMotionMode">();
	}
	static class UAnimNotifyState_SetRootMotionMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SetRootMotionMode>();
	}
};
static_assert(alignof(UAnimNotifyState_SetRootMotionMode) == 0x000008, "Wrong alignment on UAnimNotifyState_SetRootMotionMode");
static_assert(sizeof(UAnimNotifyState_SetRootMotionMode) == 0x000038, "Wrong size on UAnimNotifyState_SetRootMotionMode");
static_assert(offsetof(UAnimNotifyState_SetRootMotionMode, RootMotionMode) == 0x000030, "Member 'UAnimNotifyState_SetRootMotionMode::RootMotionMode' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SetRootMotionMode, PreviousRootMotionMode) == 0x000031, "Member 'UAnimNotifyState_SetRootMotionMode::PreviousRootMotionMode' has a wrong offset!");

// Class PiecesAnimNodes.AnimNotifyState_SpawnAndAttachActor
// 0x0050 (0x0080 - 0x0030)
class UAnimNotifyState_SpawnAndAttachActor final : public UAnimNotifyState
{
public:
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AttachSocketName;                                  // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             RelativeTransform;                                 // 0x0040(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 SpawnedActor;                                      // 0x0070(0x0008)(BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_SpawnAndAttachActor">();
	}
	static class UAnimNotifyState_SpawnAndAttachActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_SpawnAndAttachActor>();
	}
};
static_assert(alignof(UAnimNotifyState_SpawnAndAttachActor) == 0x000010, "Wrong alignment on UAnimNotifyState_SpawnAndAttachActor");
static_assert(sizeof(UAnimNotifyState_SpawnAndAttachActor) == 0x000080, "Wrong size on UAnimNotifyState_SpawnAndAttachActor");
static_assert(offsetof(UAnimNotifyState_SpawnAndAttachActor, ActorClass) == 0x000030, "Member 'UAnimNotifyState_SpawnAndAttachActor::ActorClass' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnAndAttachActor, AttachSocketName) == 0x000038, "Member 'UAnimNotifyState_SpawnAndAttachActor::AttachSocketName' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnAndAttachActor, RelativeTransform) == 0x000040, "Member 'UAnimNotifyState_SpawnAndAttachActor::RelativeTransform' has a wrong offset!");
static_assert(offsetof(UAnimNotifyState_SpawnAndAttachActor, SpawnedActor) == 0x000070, "Member 'UAnimNotifyState_SpawnAndAttachActor::SpawnedActor' has a wrong offset!");

// Class PiecesAnimNodes.BarkCollectionFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UBarkCollectionFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TSoftObjectPtr<class UAnimMontage> GetBarkMontageFromCollection(const class ACharacter* Character, const struct FBarkCollection& Collection);
	static TSoftObjectPtr<class UAnimMontage> GetBarkMontageFromCollectionForMeshComponent(const class USkeletalMeshComponent* MeshComponent, const struct FBarkCollection& Collection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BarkCollectionFunctionLibrary">();
	}
	static class UBarkCollectionFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBarkCollectionFunctionLibrary>();
	}
};
static_assert(alignof(UBarkCollectionFunctionLibrary) == 0x000008, "Wrong alignment on UBarkCollectionFunctionLibrary");
static_assert(sizeof(UBarkCollectionFunctionLibrary) == 0x000028, "Wrong size on UBarkCollectionFunctionLibrary");

// Class PiecesAnimNodes.BPAsyncAction_PiecesPlayMontage
// 0x0000 (0x0110 - 0x0110)
class UBPAsyncAction_PiecesPlayMontage : public UBPAsyncAction_PlayMontageBase
{
public:
	static class UBPAsyncAction_PiecesPlayMontage* MontagePlay(class USkeletalMeshComponent* InSkeletalMesh, class UAnimMontage* MontageToPlay, float PlayRate, float StartingPosition, const class FName StartingSection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPAsyncAction_PiecesPlayMontage">();
	}
	static class UBPAsyncAction_PiecesPlayMontage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPAsyncAction_PiecesPlayMontage>();
	}
};
static_assert(alignof(UBPAsyncAction_PiecesPlayMontage) == 0x000008, "Wrong alignment on UBPAsyncAction_PiecesPlayMontage");
static_assert(sizeof(UBPAsyncAction_PiecesPlayMontage) == 0x000110, "Wrong size on UBPAsyncAction_PiecesPlayMontage");

// Class PiecesAnimNodes.BPAsyncAction_PiecesPlayBarkCollection
// 0x0060 (0x0170 - 0x0110)
class UBPAsyncAction_PiecesPlayBarkCollection final : public UBPAsyncAction_PiecesPlayMontage
{
public:
	uint8                                         Pad_110[0x60];                                     // 0x0110(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBPAsyncAction_PiecesPlayMontage* PlayBarkCollection(const class ACharacter* Character, const struct FBarkCollection& BarkCollection, EBarkPriority BarkPriority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPAsyncAction_PiecesPlayBarkCollection">();
	}
	static class UBPAsyncAction_PiecesPlayBarkCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPAsyncAction_PiecesPlayBarkCollection>();
	}
};
static_assert(alignof(UBPAsyncAction_PiecesPlayBarkCollection) == 0x000008, "Wrong alignment on UBPAsyncAction_PiecesPlayBarkCollection");
static_assert(sizeof(UBPAsyncAction_PiecesPlayBarkCollection) == 0x000170, "Wrong size on UBPAsyncAction_PiecesPlayBarkCollection");

// Class PiecesAnimNodes.EngineSubsystem_Barks
// 0x0050 (0x0080 - 0x0030)
class UEngineSubsystem_Barks final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearRegisteredBarks();
	void RegisterBarkPlayed(const class FText& BarkIdentifier);

	class FText GetRandomBarkWeighted(const TArray<class FText>& Candidates) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EngineSubsystem_Barks">();
	}
	static class UEngineSubsystem_Barks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEngineSubsystem_Barks>();
	}
};
static_assert(alignof(UEngineSubsystem_Barks) == 0x000008, "Wrong alignment on UEngineSubsystem_Barks");
static_assert(sizeof(UEngineSubsystem_Barks) == 0x000080, "Wrong size on UEngineSubsystem_Barks");

// Class PiecesAnimNodes.MotionWarpingComponent
// 0x00E8 (0x01A0 - 0x00B8)
class UMotionWarpingComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0xE8];                                      // 0x00B8(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RemoveMotionWarpingTarget(const struct FGameplayTag& MotionIdentifier);
	void SetMotionWarpingTarget(const struct FGameplayTag& MotionIdentifier, const struct FTransform& TransformTarget, float DataLifeTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotionWarpingComponent">();
	}
	static class UMotionWarpingComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMotionWarpingComponent>();
	}
};
static_assert(alignof(UMotionWarpingComponent) == 0x000008, "Wrong alignment on UMotionWarpingComponent");
static_assert(sizeof(UMotionWarpingComponent) == 0x0001A0, "Wrong size on UMotionWarpingComponent");

// Class PiecesAnimNodes.MotionWarpingInterface
// 0x0000 (0x0028 - 0x0028)
class IMotionWarpingInterface final : public IInterface
{
public:
	void RemoveMotionWarpingTarget(const struct FGameplayTag& MotionIdentifier);
	void SetMotionWarpingTarget(const struct FGameplayTag& MotionIdentifier, const struct FTransform& TransformTarget, float DataLifeTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotionWarpingInterface">();
	}
	static class IMotionWarpingInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMotionWarpingInterface>();
	}
};
static_assert(alignof(IMotionWarpingInterface) == 0x000008, "Wrong alignment on IMotionWarpingInterface");
static_assert(sizeof(IMotionWarpingInterface) == 0x000028, "Wrong size on IMotionWarpingInterface");

// Class PiecesAnimNodes.PiecesAnimationBarkFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UPiecesAnimationBarkFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UAnimMontage* GetBarkMontageBPNodeHelperFunction(const TArray<TSoftObjectPtr<class UAnimMontage>>& SelectedMontages, const class ACharacter* Character, bool bPlayMontage, EBarkPriority Priority);
	static TSoftObjectPtr<class UAnimMontage> GetBarkMontageBPNodeHelperFunctionLoadAsync(const TArray<TSoftObjectPtr<class UAnimMontage>>& SelectedMontages, const class ACharacter* Character, bool bPlayMontage, EBarkPriority Priority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesAnimationBarkFunctionLibrary">();
	}
	static class UPiecesAnimationBarkFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPiecesAnimationBarkFunctionLibrary>();
	}
};
static_assert(alignof(UPiecesAnimationBarkFunctionLibrary) == 0x000008, "Wrong alignment on UPiecesAnimationBarkFunctionLibrary");
static_assert(sizeof(UPiecesAnimationBarkFunctionLibrary) == 0x000028, "Wrong size on UPiecesAnimationBarkFunctionLibrary");

// Class PiecesAnimNodes.PiecesAnimationBarkInterface
// 0x0000 (0x0028 - 0x0028)
class IPiecesAnimationBarkInterface final : public IInterface
{
public:
	void ClearOverrideFaceBlendWeightForBarks();
	TSoftObjectPtr<class UAnimMontage> GetCurrentPlayingBark();
	void OnBarkFinished(class UAnimMontage* BarkMontage);
	void OverrideFaceBlendWeightForBarks(float OverrideWeight);
	void StopBark(const TSoftObjectPtr<class UAnimMontage>& BarkMontage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesAnimationBarkInterface">();
	}
	static class IPiecesAnimationBarkInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPiecesAnimationBarkInterface>();
	}
};
static_assert(alignof(IPiecesAnimationBarkInterface) == 0x000008, "Wrong alignment on IPiecesAnimationBarkInterface");
static_assert(sizeof(IPiecesAnimationBarkInterface) == 0x000028, "Wrong size on IPiecesAnimationBarkInterface");

// Class PiecesAnimNodes.PiecesAnimationBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UPiecesAnimationBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void PauseDynamics(class UAnimInstance* AnimInstance);
	static void ResumeDynamics(class UAnimInstance* AnimInstance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesAnimationBlueprintFunctionLibrary">();
	}
	static class UPiecesAnimationBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPiecesAnimationBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UPiecesAnimationBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UPiecesAnimationBlueprintFunctionLibrary");
static_assert(sizeof(UPiecesAnimationBlueprintFunctionLibrary) == 0x000028, "Wrong size on UPiecesAnimationBlueprintFunctionLibrary");

// Class PiecesAnimNodes.PiecesAnimationDeveloperSettings
// 0x0028 (0x0060 - 0x0038)
class UPiecesAnimationDeveloperSettings final : public UDeveloperSettings
{
public:
	float                                         BarkTrackingTime;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableAnimationStagger;                            // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AnimationStaggerHighPriorityCount;                 // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimationStaggerMediumPriorityCount;               // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationStaggerCameraDistanceLowPriorityThreshold; // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimationStaggerHighPriorityUpdateFrequency;       // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimationStaggerMediumPriorityUpdateFrequency;     // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimationStaggerLowPriorityUpdateFrequency;        // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnimationStaggerMinimumUpdateFrequency;            // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesAnimationDeveloperSettings">();
	}
	static class UPiecesAnimationDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPiecesAnimationDeveloperSettings>();
	}
};
static_assert(alignof(UPiecesAnimationDeveloperSettings) == 0x000008, "Wrong alignment on UPiecesAnimationDeveloperSettings");
static_assert(sizeof(UPiecesAnimationDeveloperSettings) == 0x000060, "Wrong size on UPiecesAnimationDeveloperSettings");
static_assert(offsetof(UPiecesAnimationDeveloperSettings, BarkTrackingTime) == 0x000038, "Member 'UPiecesAnimationDeveloperSettings::BarkTrackingTime' has a wrong offset!");
static_assert(offsetof(UPiecesAnimationDeveloperSettings, EnableAnimationStagger) == 0x00003C, "Member 'UPiecesAnimationDeveloperSettings::EnableAnimationStagger' has a wrong offset!");
static_assert(offsetof(UPiecesAnimationDeveloperSettings, AnimationStaggerHighPriorityCount) == 0x000040, "Member 'UPiecesAnimationDeveloperSettings::AnimationStaggerHighPriorityCount' has a wrong offset!");
static_assert(offsetof(UPiecesAnimationDeveloperSettings, AnimationStaggerMediumPriorityCount) == 0x000044, "Member 'UPiecesAnimationDeveloperSettings::AnimationStaggerMediumPriorityCount' has a wrong offset!");
static_assert(offsetof(UPiecesAnimationDeveloperSettings, AnimationStaggerCameraDistanceLowPriorityThreshold) == 0x000048, "Member 'UPiecesAnimationDeveloperSettings::AnimationStaggerCameraDistanceLowPriorityThreshold' has a wrong offset!");
static_assert(offsetof(UPiecesAnimationDeveloperSettings, AnimationStaggerHighPriorityUpdateFrequency) == 0x00004C, "Member 'UPiecesAnimationDeveloperSettings::AnimationStaggerHighPriorityUpdateFrequency' has a wrong offset!");
static_assert(offsetof(UPiecesAnimationDeveloperSettings, AnimationStaggerMediumPriorityUpdateFrequency) == 0x000050, "Member 'UPiecesAnimationDeveloperSettings::AnimationStaggerMediumPriorityUpdateFrequency' has a wrong offset!");
static_assert(offsetof(UPiecesAnimationDeveloperSettings, AnimationStaggerLowPriorityUpdateFrequency) == 0x000054, "Member 'UPiecesAnimationDeveloperSettings::AnimationStaggerLowPriorityUpdateFrequency' has a wrong offset!");
static_assert(offsetof(UPiecesAnimationDeveloperSettings, AnimationStaggerMinimumUpdateFrequency) == 0x000058, "Member 'UPiecesAnimationDeveloperSettings::AnimationStaggerMinimumUpdateFrequency' has a wrong offset!");

// Class PiecesAnimNodes.AnimationStaggerUpdateHandle
// 0x0018 (0x0040 - 0x0028)
class UAnimationStaggerUpdateHandle final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimationStaggerUpdateHandle">();
	}
	static class UAnimationStaggerUpdateHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimationStaggerUpdateHandle>();
	}
};
static_assert(alignof(UAnimationStaggerUpdateHandle) == 0x000008, "Wrong alignment on UAnimationStaggerUpdateHandle");
static_assert(sizeof(UAnimationStaggerUpdateHandle) == 0x000040, "Wrong size on UAnimationStaggerUpdateHandle");

// Class PiecesAnimNodes.PiecesAnimInterface
// 0x0000 (0x0028 - 0x0028)
class IPiecesAnimInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesAnimInterface">();
	}
	static class IPiecesAnimInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPiecesAnimInterface>();
	}
};
static_assert(alignof(IPiecesAnimInterface) == 0x000008, "Wrong alignment on IPiecesAnimInterface");
static_assert(sizeof(IPiecesAnimInterface) == 0x000028, "Wrong size on IPiecesAnimInterface");

// Class PiecesAnimNodes.PiecesAnimNotify_BarkEndMarker
// 0x0000 (0x0030 - 0x0030)
class UPiecesAnimNotify_BarkEndMarker final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesAnimNotify_BarkEndMarker">();
	}
	static class UPiecesAnimNotify_BarkEndMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPiecesAnimNotify_BarkEndMarker>();
	}
};
static_assert(alignof(UPiecesAnimNotify_BarkEndMarker) == 0x000008, "Wrong alignment on UPiecesAnimNotify_BarkEndMarker");
static_assert(sizeof(UPiecesAnimNotify_BarkEndMarker) == 0x000030, "Wrong size on UPiecesAnimNotify_BarkEndMarker");

// Class PiecesAnimNodes.PiecesRootMotionAnimInterface
// 0x0000 (0x0028 - 0x0028)
class IPiecesRootMotionAnimInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesRootMotionAnimInterface">();
	}
	static class IPiecesRootMotionAnimInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPiecesRootMotionAnimInterface>();
	}
};
static_assert(alignof(IPiecesRootMotionAnimInterface) == 0x000008, "Wrong alignment on IPiecesRootMotionAnimInterface");
static_assert(sizeof(IPiecesRootMotionAnimInterface) == 0x000028, "Wrong size on IPiecesRootMotionAnimInterface");

// Class PiecesAnimNodes.PiecesSkeletalMeshComponent
// 0x0010 (0x0F00 - 0x0EF0)
class UPiecesSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	bool                                          TickBeforeMovementComponent;                       // 0x0EF0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DisableUpdatingPhysicsOnAnimationFinalize;         // 0x0EF1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EF2[0xE];                                      // 0x0EF2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesSkeletalMeshComponent">();
	}
	static class UPiecesSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPiecesSkeletalMeshComponent>();
	}
};
static_assert(alignof(UPiecesSkeletalMeshComponent) == 0x000010, "Wrong alignment on UPiecesSkeletalMeshComponent");
static_assert(sizeof(UPiecesSkeletalMeshComponent) == 0x000F00, "Wrong size on UPiecesSkeletalMeshComponent");
static_assert(offsetof(UPiecesSkeletalMeshComponent, TickBeforeMovementComponent) == 0x000EF0, "Member 'UPiecesSkeletalMeshComponent::TickBeforeMovementComponent' has a wrong offset!");
static_assert(offsetof(UPiecesSkeletalMeshComponent, DisableUpdatingPhysicsOnAnimationFinalize) == 0x000EF1, "Member 'UPiecesSkeletalMeshComponent::DisableUpdatingPhysicsOnAnimationFinalize' has a wrong offset!");

}

