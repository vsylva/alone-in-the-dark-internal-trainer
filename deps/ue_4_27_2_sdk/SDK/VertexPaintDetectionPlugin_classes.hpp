#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: VertexPaintDetectionPlugin

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "PhysicsCore_structs.hpp"
#include "VertexPaintDetectionPlugin_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DeveloperSettings_classes.hpp"


namespace SDK
{

// Class VertexPaintDetectionPlugin.VertexPaintClothOverlapComponent
// 0x0120 (0x0330 - 0x0210)
class UVertexPaintClothOverlapComponent final : public USceneComponent
{
public:
	bool                                          ClothOverlapTracingEnabled;                        // 0x0208(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209[0x3];                                      // 0x0209(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClothVertexTraceRadius;                            // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClothVertexTraceIntervall;                         // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugClothSphereTraces;                            // 0x0214(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215[0x3];                                      // 0x0215(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 ParentSkeletalMeshComponent;                       // 0x0218(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UClothingAssetBase*>             ParentSkeletalMeshComponentClothingAssets;         // 0x0220(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<EObjectTypeQuery>                      ClothObjectsToSphereTrace;                         // 0x0230(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TMap<class AActor*, struct FVertexPaintClothOverlapComponentsStruct> ClothOverlappingActorsAndComponent;                // 0x0240(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class UClothingAssetBase*, struct FTransform> ClothBoneTransformsInComponentSpaceTemp;           // 0x0290(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class UClothingAssetBase*, struct FQuat> ClothBoneQuaternionsInComponentSpaceTemp;          // 0x02E0(0x0050)(NativeAccessSpecifierPrivate)

public:
	TArray<EObjectTypeQuery> GetClothObjectsToSphereTrace();
	void OnRep_ClothOverlapTracingEnabledRep();
	void SetClothObjectsToSphereTrace(const TArray<EObjectTypeQuery>& Objects);
	void SetClothOverlapTracingEnabled(bool EnableClothTracing);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintClothOverlapComponent">();
	}
	static class UVertexPaintClothOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintClothOverlapComponent>();
	}
};
static_assert(alignof(UVertexPaintClothOverlapComponent) == 0x000010, "Wrong alignment on UVertexPaintClothOverlapComponent");
static_assert(sizeof(UVertexPaintClothOverlapComponent) == 0x000330, "Wrong size on UVertexPaintClothOverlapComponent");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ClothOverlapTracingEnabled) == 0x000208, "Member 'UVertexPaintClothOverlapComponent::ClothOverlapTracingEnabled' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ClothVertexTraceRadius) == 0x00020C, "Member 'UVertexPaintClothOverlapComponent::ClothVertexTraceRadius' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ClothVertexTraceIntervall) == 0x000210, "Member 'UVertexPaintClothOverlapComponent::ClothVertexTraceIntervall' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, DebugClothSphereTraces) == 0x000214, "Member 'UVertexPaintClothOverlapComponent::DebugClothSphereTraces' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ParentSkeletalMeshComponent) == 0x000218, "Member 'UVertexPaintClothOverlapComponent::ParentSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ParentSkeletalMeshComponentClothingAssets) == 0x000220, "Member 'UVertexPaintClothOverlapComponent::ParentSkeletalMeshComponentClothingAssets' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ClothObjectsToSphereTrace) == 0x000230, "Member 'UVertexPaintClothOverlapComponent::ClothObjectsToSphereTrace' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ClothOverlappingActorsAndComponent) == 0x000240, "Member 'UVertexPaintClothOverlapComponent::ClothOverlappingActorsAndComponent' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ClothBoneTransformsInComponentSpaceTemp) == 0x000290, "Member 'UVertexPaintClothOverlapComponent::ClothBoneTransformsInComponentSpaceTemp' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ClothBoneQuaternionsInComponentSpaceTemp) == 0x0002E0, "Member 'UVertexPaintClothOverlapComponent::ClothBoneQuaternionsInComponentSpaceTemp' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintColorSnippetDataAsset
// 0x0050 (0x0080 - 0x0030)
class UVertexPaintColorSnippetDataAsset final : public UDataAsset
{
public:
	TMap<class FString, struct FVertexDetectColorSnippetDataStruct> SnippetColorData;                                  // 0x0030(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintColorSnippetDataAsset">();
	}
	static class UVertexPaintColorSnippetDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintColorSnippetDataAsset>();
	}
};
static_assert(alignof(UVertexPaintColorSnippetDataAsset) == 0x000008, "Wrong alignment on UVertexPaintColorSnippetDataAsset");
static_assert(sizeof(UVertexPaintColorSnippetDataAsset) == 0x000080, "Wrong size on UVertexPaintColorSnippetDataAsset");
static_assert(offsetof(UVertexPaintColorSnippetDataAsset, SnippetColorData) == 0x000030, "Member 'UVertexPaintColorSnippetDataAsset::SnippetColorData' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintColorSnippetRefs
// 0x00C0 (0x00F0 - 0x0030)
class UVertexPaintColorSnippetRefs final : public UDataAsset
{
public:
	TMap<TSoftObjectPtr<class UObject>, struct FVertexDetectColorSnippetReferenceDataStruct> StaticMeshesColorSnippets;                         // 0x0030(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UObject>, struct FVertexDetectColorSnippetReferenceDataStruct> SkeletalMeshesColorSnippets;                       // 0x0080(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AllAvailableColorSnippets;                         // 0x00D0(0x0020)(NativeAccessSpecifierPublic)

public:
	bool ContainsColorSnippet(const class FString& SnippetID);
	TMap<class FString, TSoftObjectPtr<class UVertexPaintColorSnippetDataAsset>> GetAllColorSnippetsAndDataAssetForObject(class UObject* Object);
	TSoftObjectPtr<class UObject> GetObjectFromSnippetID(const class FString& SnippetID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintColorSnippetRefs">();
	}
	static class UVertexPaintColorSnippetRefs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintColorSnippetRefs>();
	}
};
static_assert(alignof(UVertexPaintColorSnippetRefs) == 0x000008, "Wrong alignment on UVertexPaintColorSnippetRefs");
static_assert(sizeof(UVertexPaintColorSnippetRefs) == 0x0000F0, "Wrong size on UVertexPaintColorSnippetRefs");
static_assert(offsetof(UVertexPaintColorSnippetRefs, StaticMeshesColorSnippets) == 0x000030, "Member 'UVertexPaintColorSnippetRefs::StaticMeshesColorSnippets' has a wrong offset!");
static_assert(offsetof(UVertexPaintColorSnippetRefs, SkeletalMeshesColorSnippets) == 0x000080, "Member 'UVertexPaintColorSnippetRefs::SkeletalMeshesColorSnippets' has a wrong offset!");
static_assert(offsetof(UVertexPaintColorSnippetRefs, AllAvailableColorSnippets) == 0x0000D0, "Member 'UVertexPaintColorSnippetRefs::AllAvailableColorSnippets' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintDetectionComponent
// 0x0128 (0x01E0 - 0x00B8)
class UVertexPaintDetectionComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             GetClosestVertexDataDelegate;                      // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             GetAllVertexColorsOnlyDelegate;                    // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             VertexColorsPaintedAtLocationDelegate;             // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             VertexColorsPaintedMeshWithinAreaDelegate;         // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             VertexColorsPaintedEntireMeshDelegate;             // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             VertexColorsPaintColorSnippetDelegate;             // 0x0108(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             VertexColorsSetMeshColorsDelegate;                 // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             VertexColorsSetMeshColorsUsingSerializedStringDelegate; // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class AActor>>          CanOnlyApplyPaintOnTheseActors;                    // 0x0138(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          PrintLogsToScreen;                                 // 0x0148(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrintLogsToScreen_Duration;                        // 0x014C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PrintLogsToOutputLog;                              // 0x0150(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AtGameThread_drawVertexPositionDebugPoint;         // 0x0151(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AtGameThread_drawVertexNormalDebugArrow;           // 0x0152(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AtGameThread_drawVertexPositionDebugPointOnVertexThatGotPaintApplied; // 0x0153(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AtGameThread_drawClothVertexPositionDebugPoint;    // 0x0154(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AtGameThread_DrawVertexPointsDuration;             // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AtGameThread_DrawPaintConditionsDebugSymbols;      // 0x015C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15D[0x3];                                      // 0x015D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AtGameThread_DrawPaintConditionsDebugSymbolsDuration; // 0x0160(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawGetClosestVertexDataDebugSymbols;              // 0x0164(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_165[0x3];                                      // 0x0165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawGetClosestVertexDataDebugSymbolsDuration;      // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawGetEstimatedColorAtHitLocationDebugSymbols;    // 0x016C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawGetEstimatedColorAtHitLocationDebugSymbolsDuration; // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DrawPaintWithinAreaDebugSymbols;                   // 0x0174(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175[0x3];                                      // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawPaintWithinAreaDebugSymbolsDuration;           // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x54];                                     // 0x017C(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	class UVertexPaintDetectionGISubSystem*       VertexPaintGameInstanceSubsystem_Global;           // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D8[0x8];                                      // 0x01D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintDetectionComponent">();
	}
	static class UVertexPaintDetectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintDetectionComponent>();
	}
};
static_assert(alignof(UVertexPaintDetectionComponent) == 0x000008, "Wrong alignment on UVertexPaintDetectionComponent");
static_assert(sizeof(UVertexPaintDetectionComponent) == 0x0001E0, "Wrong size on UVertexPaintDetectionComponent");
static_assert(offsetof(UVertexPaintDetectionComponent, GetClosestVertexDataDelegate) == 0x0000B8, "Member 'UVertexPaintDetectionComponent::GetClosestVertexDataDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, GetAllVertexColorsOnlyDelegate) == 0x0000C8, "Member 'UVertexPaintDetectionComponent::GetAllVertexColorsOnlyDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, VertexColorsPaintedAtLocationDelegate) == 0x0000D8, "Member 'UVertexPaintDetectionComponent::VertexColorsPaintedAtLocationDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, VertexColorsPaintedMeshWithinAreaDelegate) == 0x0000E8, "Member 'UVertexPaintDetectionComponent::VertexColorsPaintedMeshWithinAreaDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, VertexColorsPaintedEntireMeshDelegate) == 0x0000F8, "Member 'UVertexPaintDetectionComponent::VertexColorsPaintedEntireMeshDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, VertexColorsPaintColorSnippetDelegate) == 0x000108, "Member 'UVertexPaintDetectionComponent::VertexColorsPaintColorSnippetDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, VertexColorsSetMeshColorsDelegate) == 0x000118, "Member 'UVertexPaintDetectionComponent::VertexColorsSetMeshColorsDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, VertexColorsSetMeshColorsUsingSerializedStringDelegate) == 0x000128, "Member 'UVertexPaintDetectionComponent::VertexColorsSetMeshColorsUsingSerializedStringDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, CanOnlyApplyPaintOnTheseActors) == 0x000138, "Member 'UVertexPaintDetectionComponent::CanOnlyApplyPaintOnTheseActors' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, PrintLogsToScreen) == 0x000148, "Member 'UVertexPaintDetectionComponent::PrintLogsToScreen' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, PrintLogsToScreen_Duration) == 0x00014C, "Member 'UVertexPaintDetectionComponent::PrintLogsToScreen_Duration' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, PrintLogsToOutputLog) == 0x000150, "Member 'UVertexPaintDetectionComponent::PrintLogsToOutputLog' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, AtGameThread_drawVertexPositionDebugPoint) == 0x000151, "Member 'UVertexPaintDetectionComponent::AtGameThread_drawVertexPositionDebugPoint' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, AtGameThread_drawVertexNormalDebugArrow) == 0x000152, "Member 'UVertexPaintDetectionComponent::AtGameThread_drawVertexNormalDebugArrow' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, AtGameThread_drawVertexPositionDebugPointOnVertexThatGotPaintApplied) == 0x000153, "Member 'UVertexPaintDetectionComponent::AtGameThread_drawVertexPositionDebugPointOnVertexThatGotPaintApplied' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, AtGameThread_drawClothVertexPositionDebugPoint) == 0x000154, "Member 'UVertexPaintDetectionComponent::AtGameThread_drawClothVertexPositionDebugPoint' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, AtGameThread_DrawVertexPointsDuration) == 0x000158, "Member 'UVertexPaintDetectionComponent::AtGameThread_DrawVertexPointsDuration' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, AtGameThread_DrawPaintConditionsDebugSymbols) == 0x00015C, "Member 'UVertexPaintDetectionComponent::AtGameThread_DrawPaintConditionsDebugSymbols' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, AtGameThread_DrawPaintConditionsDebugSymbolsDuration) == 0x000160, "Member 'UVertexPaintDetectionComponent::AtGameThread_DrawPaintConditionsDebugSymbolsDuration' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, DrawGetClosestVertexDataDebugSymbols) == 0x000164, "Member 'UVertexPaintDetectionComponent::DrawGetClosestVertexDataDebugSymbols' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, DrawGetClosestVertexDataDebugSymbolsDuration) == 0x000168, "Member 'UVertexPaintDetectionComponent::DrawGetClosestVertexDataDebugSymbolsDuration' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, DrawGetEstimatedColorAtHitLocationDebugSymbols) == 0x00016C, "Member 'UVertexPaintDetectionComponent::DrawGetEstimatedColorAtHitLocationDebugSymbols' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, DrawGetEstimatedColorAtHitLocationDebugSymbolsDuration) == 0x000170, "Member 'UVertexPaintDetectionComponent::DrawGetEstimatedColorAtHitLocationDebugSymbolsDuration' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, DrawPaintWithinAreaDebugSymbols) == 0x000174, "Member 'UVertexPaintDetectionComponent::DrawPaintWithinAreaDebugSymbols' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, DrawPaintWithinAreaDebugSymbolsDuration) == 0x000178, "Member 'UVertexPaintDetectionComponent::DrawPaintWithinAreaDebugSymbolsDuration' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, VertexPaintGameInstanceSubsystem_Global) == 0x0001D0, "Member 'UVertexPaintDetectionComponent::VertexPaintGameInstanceSubsystem_Global' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintDetectionEngSubsystem
// 0x0000 (0x0030 - 0x0030)
class UVertexPaintDetectionEngSubsystem final : public UEngineSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintDetectionEngSubsystem">();
	}
	static class UVertexPaintDetectionEngSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintDetectionEngSubsystem>();
	}
};
static_assert(alignof(UVertexPaintDetectionEngSubsystem) == 0x000008, "Wrong alignment on UVertexPaintDetectionEngSubsystem");
static_assert(sizeof(UVertexPaintDetectionEngSubsystem) == 0x000030, "Wrong size on UVertexPaintDetectionEngSubsystem");

// Class VertexPaintDetectionPlugin.VertexPaintDetectionGISubSystem
// 0x0188 (0x01B8 - 0x0030)
class UVertexPaintDetectionGISubSystem final : public UGameInstanceSubsystem
{
public:
	TMap<class UPrimitiveComponent*, struct FVertexPaintCalculateColorsQueueArrayStruct> CalculateColorsPaintQueue;                         // 0x0030(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UPrimitiveComponent*, struct FVertexPaintCalculateColorsQueueArrayStruct> CalculateColorsDetectionQueue;                     // 0x0080(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<int32, struct FCalculateColorsInfo>      OnGoingAsyncTasks;                                 // 0x00D0(0x0050)(NativeAccessSpecifierPrivate)
	struct FTimerHandle                           VertexColorPaint_QueueThreadPool_ResetTimer;       // 0x0120(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWorld*                                 VertexColorPaint_QueueThreadPool_ResetTimerWorld;  // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x18];                                     // 0x0130(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTimerHandle>                   CleanupOldVertexColorBufferTimers;                 // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class UPrimitiveComponent*, int32>       MeshesPaintedOnSinceSessionStarted;                // 0x0158(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UPhysicalMaterial*>              CachedPhysicalMaterialAssets;                      // 0x01A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintDetectionGISubSystem">();
	}
	static class UVertexPaintDetectionGISubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintDetectionGISubSystem>();
	}
};
static_assert(alignof(UVertexPaintDetectionGISubSystem) == 0x000008, "Wrong alignment on UVertexPaintDetectionGISubSystem");
static_assert(sizeof(UVertexPaintDetectionGISubSystem) == 0x0001B8, "Wrong size on UVertexPaintDetectionGISubSystem");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, CalculateColorsPaintQueue) == 0x000030, "Member 'UVertexPaintDetectionGISubSystem::CalculateColorsPaintQueue' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, CalculateColorsDetectionQueue) == 0x000080, "Member 'UVertexPaintDetectionGISubSystem::CalculateColorsDetectionQueue' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, OnGoingAsyncTasks) == 0x0000D0, "Member 'UVertexPaintDetectionGISubSystem::OnGoingAsyncTasks' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, VertexColorPaint_QueueThreadPool_ResetTimer) == 0x000120, "Member 'UVertexPaintDetectionGISubSystem::VertexColorPaint_QueueThreadPool_ResetTimer' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, VertexColorPaint_QueueThreadPool_ResetTimerWorld) == 0x000128, "Member 'UVertexPaintDetectionGISubSystem::VertexColorPaint_QueueThreadPool_ResetTimerWorld' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, CleanupOldVertexColorBufferTimers) == 0x000148, "Member 'UVertexPaintDetectionGISubSystem::CleanupOldVertexColorBufferTimers' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, MeshesPaintedOnSinceSessionStarted) == 0x000158, "Member 'UVertexPaintDetectionGISubSystem::MeshesPaintedOnSinceSessionStarted' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, CachedPhysicalMaterialAssets) == 0x0001A8, "Member 'UVertexPaintDetectionGISubSystem::CachedPhysicalMaterialAssets' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintDetectionInterface
// 0x0000 (0x0028 - 0x0028)
class IVertexPaintDetectionInterface final : public IInterface
{
public:
	void ClothBeginOverlappingMesh(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp);
	void ClothEndOverlappingMesh(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp);
	void ColorsAppliedOnActor(const struct FVertexDetectTaskResultInfo& TaskResultInfo, const struct FVertexDetectMeshDataStruct& MeshData, const struct FVertexPaintStruct& PaintedOnActorSettings, const struct FVertexDetectAmountOfPaintedColorsOfEachChannel& AmountOfPaintedColorsOfEachChannel, const struct FVertexDetectVertexColorsOnEachBone& VertexColorsOnEachBone, const struct FVertexDetectAdditionalDataToPassThrough& AdditionalData);
	void GetAllVertexColorsOnlyOnActor(const struct FVertexDetectTaskResultInfo& TaskResultInfo, const struct FVertexDetectMeshDataStruct& MeshData, const struct FVertexDetectGetColorsOnlyStruct& GotAllVertexColorsWithSettings, const struct FVertexDetectAmountOfPaintedColorsOfEachChannel& AmountOfPaintedColorsOfEachChannel, const struct FVertexDetectVertexColorsOnEachBone& VertexColorsOnEachBone, const struct FVertexDetectAdditionalDataToPassThrough& AdditionalData);
	void GetClosestVertexDataOnActor(const struct FVertexDetectTaskResultInfo& TaskResultInfo, const struct FVertexDetectMeshDataStruct& MeshData, const struct FVertexDetectInfoStruct& DetectedMeshWithSettings, const struct FVertexDetectClosestVertexDataResultStruct& ClosestVertexColorResult, const struct FVertexDetectEstimatedColorAtHitLocationResultStruct& EstimatedColorAtHitLocationResult, const struct FVertexDetectAvarageColorInAreaInfo& AvarageColorInAreaInfo, const struct FVertexDetectAmountOfPaintedColorsOfEachChannel& AmountOfPaintedColorsOfEachChannel, const struct FVertexDetectVertexColorsOnEachBone& VertexColorsOnEachBone, const struct FVertexDetectAdditionalDataToPassThrough& AdditionalData);
	TMap<class UClothingAssetBase*, struct FVertexDetectClothSettingsStruct> GetSkeletalMeshClothPhysicsSettings(class USkeletalMeshComponent* SkeletalMeshComponentTryingToGetClothSettingsFor);
	void PaintedOnActor_AtLocation(const struct FVertexDetectTaskResultInfo& TaskResultInfo, const struct FVertexDetectMeshDataStruct& MeshData, const struct FVertexPaintAtLocationStruct& PaintedAtLocationSettings, const struct FVertexDetectClosestVertexDataResultStruct& ClosestVertexColorResult, const struct FVertexDetectEstimatedColorAtHitLocationResultStruct& EstimatedColorAtHitLocationResult, const struct FVertexDetectAvarageColorInAreaInfo& AvarageColorInAreaInfo, const struct FVertexDetectAmountOfPaintedColorsOfEachChannel& AmountOfPaintedColorsOfEachChannel, const struct FVertexDetectVertexColorsOnEachBone& VertexColorsOnEachBone, const struct FVertexDetectAdditionalDataToPassThrough& AdditionalData);
	void PaintedOnActor_EntireMesh(const struct FVertexDetectTaskResultInfo& TaskResultInfo, const struct FVertexDetectMeshDataStruct& MeshData, const struct FVertexPaintOnEntireMeshStruct& PaintedEntireMeshSettings, const struct FVertexDetectAmountOfPaintedColorsOfEachChannel& AmountOfPaintedColorsOfEachChannel, const struct FVertexDetectVertexColorsOnEachBone& VertexColorsOnEachBone, const struct FVertexDetectAdditionalDataToPassThrough& AdditionalData);
	void PaintedOnActor_PaintColorSnippet(const struct FVertexDetectTaskResultInfo& TaskResultInfo, const struct FVertexDetectMeshDataStruct& MeshData, const struct FVertexPaintColorSnippetStruct& PaintedColorSnippetSettings, const struct FVertexDetectAmountOfPaintedColorsOfEachChannel& AmountOfPaintedColorsOfEachChannel, const struct FVertexDetectVertexColorsOnEachBone& VertexColorsOnEachBone, const struct FVertexDetectAdditionalDataToPassThrough& AdditionalData);
	void PaintedOnActor_WithinArea(const struct FVertexDetectTaskResultInfo& TaskResultInfo, const struct FVertexDetectMeshDataStruct& MeshData, const struct FVertexPainthWithinAreaStruct& PaintedWithinAreaSettings, const struct FVertexDetectAmountOfPaintedColorsOfEachChannel& AmountOfPaintedColorsOfEachChannel, const struct FVertexDetectVertexColorsOnEachBone& VertexColorsOnEachBone, const struct FVertexDetectAdditionalDataToPassThrough& AdditionalData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintDetectionInterface">();
	}
	static class IVertexPaintDetectionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVertexPaintDetectionInterface>();
	}
};
static_assert(alignof(IVertexPaintDetectionInterface) == 0x000008, "Wrong alignment on IVertexPaintDetectionInterface");
static_assert(sizeof(IVertexPaintDetectionInterface) == 0x000028, "Wrong size on IVertexPaintDetectionInterface");

// Class VertexPaintDetectionPlugin.VertexPaintDetectionSettings
// 0x0088 (0x00C0 - 0x0038)
class UVertexPaintDetectionSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UVertexPaintOptimizationDataAsset> VertexPaintAndDetectionPlugin_OptimizationDataAssetToUse; // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVertexPaintMaterialDataAsset> VertexPaintAndDetectionPlugin_MaterialsDataAssetToUse; // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVertexPaintColorSnippetRefs> VertexPaintAndDetectionPlugin_ColorSnippetReferencesDataAssetToUse; // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VertexPaintAndDetectionPlugin_EditorWidgetNotificationEnabled; // 0x00B0(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VertexPaintAndDetectionPlugin_EditorWidgetNotificationDuration; // 0x00B4(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VertexPaintAndDetectionPlugin_MaxAmountOfAllowedTasksPerMesh; // 0x00B8(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintDetectionSettings">();
	}
	static class UVertexPaintDetectionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintDetectionSettings>();
	}
};
static_assert(alignof(UVertexPaintDetectionSettings) == 0x000008, "Wrong alignment on UVertexPaintDetectionSettings");
static_assert(sizeof(UVertexPaintDetectionSettings) == 0x0000C0, "Wrong size on UVertexPaintDetectionSettings");
static_assert(offsetof(UVertexPaintDetectionSettings, VertexPaintAndDetectionPlugin_OptimizationDataAssetToUse) == 0x000038, "Member 'UVertexPaintDetectionSettings::VertexPaintAndDetectionPlugin_OptimizationDataAssetToUse' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionSettings, VertexPaintAndDetectionPlugin_MaterialsDataAssetToUse) == 0x000060, "Member 'UVertexPaintDetectionSettings::VertexPaintAndDetectionPlugin_MaterialsDataAssetToUse' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionSettings, VertexPaintAndDetectionPlugin_ColorSnippetReferencesDataAssetToUse) == 0x000088, "Member 'UVertexPaintDetectionSettings::VertexPaintAndDetectionPlugin_ColorSnippetReferencesDataAssetToUse' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionSettings, VertexPaintAndDetectionPlugin_EditorWidgetNotificationEnabled) == 0x0000B0, "Member 'UVertexPaintDetectionSettings::VertexPaintAndDetectionPlugin_EditorWidgetNotificationEnabled' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionSettings, VertexPaintAndDetectionPlugin_EditorWidgetNotificationDuration) == 0x0000B4, "Member 'UVertexPaintDetectionSettings::VertexPaintAndDetectionPlugin_EditorWidgetNotificationDuration' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionSettings, VertexPaintAndDetectionPlugin_MaxAmountOfAllowedTasksPerMesh) == 0x0000B8, "Member 'UVertexPaintDetectionSettings::VertexPaintAndDetectionPlugin_MaxAmountOfAllowedTasksPerMesh' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVertexPaintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClearMeshPaintedSinceSessionStarted_Wrapper(const class UObject* WorldContextObject);
	static EObjectTypeQuery CollisionChannelToObjectType(ECollisionChannel Channel);
	static void DrawPrimitiveComponentBoundsBox(class UPrimitiveComponent* Component, float Lifetime, float Thickness, const struct FLinearColor& ColorToDraw);
	static void GetAllMeshColorSnippetsAsString_Wrapper(class UPrimitiveComponent* MeshComponent, TMap<class FString, TSoftObjectPtr<class UVertexPaintColorSnippetDataAsset>>* AvailableColorSnippetsAndDataAssets);
	static void GetAllMeshColorSnippetsAsTags_Wrapper(class UPrimitiveComponent* MeshComponent, TMap<struct FGameplayTag, TSoftObjectPtr<class UVertexPaintColorSnippetDataAsset>>* AvailableColorSnippetTagsAndDataAssets);
	static void GetAllMeshColorSnippetsTagsUnderTagCategory_Wrapper(class UPrimitiveComponent* MeshComponent, const struct FGameplayTag& TagCategory, TMap<struct FGameplayTag, TSoftObjectPtr<class UVertexPaintColorSnippetDataAsset>>* AvailableColorSnippetTagsAndDataAssetsUnderTagCategory);
	static TArray<EPhysicalSurface> GetAllPhysicsSurfaces();
	static TArray<Enum_SurfaceAtChannel> GetAllVertexColorChannelsPhysicsSurfaceIsRegisteredTo_Wrapper(class UMaterialInterface* Material, EPhysicalSurface PhysicsSurface, bool* Successfull);
	static void GetAllVertexColorsOnly_Wrapper(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, class UPrimitiveComponent* MeshComponent, const struct FVertexDetectGetColorsOnlyStruct& GetAllVertexColorsStruct, const struct FVertexDetectAdditionalDataToPassThrough& AdditionalDataToPassThrough);
	static int32 GetAmountOfLODsToPaintOn(class UPrimitiveComponent* MeshComp, bool OverrideLODToPaintUpOn, int32 OverrideUpToLOD);
	static struct FVertexDetectAmountOfPaintedColorsOfEachChannel GetAmountOfPaintedColorsForEachChannel(const TArray<struct FColor>& VertexColors, float MinColorAmountToBeConsidered);
	static int32 GetAmountOfTasksStartedByComponent(class UVertexPaintDetectionComponent* PaintComponent);
	static TMap<class UPrimitiveComponent*, int32> GetCalculateColorsDetectionTasksAmount_Wrapper(const class UObject* WorldContextObject);
	static TMap<class UPrimitiveComponent*, int32> GetCalculateColorsPaintTasksAmount_Wrapper(const class UObject* WorldContextObject);
	static void GetClosestVertexDataOnMesh_Wrapper(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, class UPrimitiveComponent* MeshComponent, const struct FVertexDetectInfoStruct& GetClosestVertexDataStruct, const struct FVertexDetectAdditionalDataToPassThrough& AdditionalDataToPassThrough);
	static TArray<class UClothingAssetBase*> GetClothAssets(class USkeletalMesh* SkeletalMesh);
	static class UVertexPaintColorSnippetRefs* GetColorSnippetReferenceDataAsset();
	static bool GetColorsToApplyFromPhysicsMaterial_Wrapper(class UMaterialInterface* MaterialToApplyColorsTo, EPhysicalSurface PhysicalSurface, float* RedAmountToApply, float* GreenAmountToApply, float* blueAmountToApply, float* AlphaAmountToApply, float DefaultAmountIfFailOrChannelIsNotRegistered);
	static void GetMeshColorSnippetsTagsInTagCategory_Wrapper(class UPrimitiveComponent* MeshComponent, const struct FGameplayTag& TagCategory, TMap<struct FGameplayTag, TSoftObjectPtr<class UVertexPaintColorSnippetDataAsset>>* AvailableColorSnippetTagsAndDataAssetsUnderTagCategory);
	static struct FVertexDetectMeshDataStruct GetMeshComponentVertexColors_Wrapper(class UPrimitiveComponent* MeshComponent, bool* Success, bool GetColorsForAllLODs, int32 GetColorsUpToLOD);
	static TMap<class UPrimitiveComponent*, int32> GetMeshPaintedSinceSessionStarted_Wrapper(const class UObject* WorldContextObject);
	static class UVertexPaintOptimizationDataAsset* GetOptimizationDataAsset();
	static class UPhysicalMaterial* GetPhysicalMaterialUsingPhysicsSurface_Wrapper(const class UObject* WorldContextObject, TSubclassOf<class UPhysicalMaterial> PhysicalMaterialClass, EPhysicalSurface PhysicsSurface);
	static bool GetTheMostDominantPhysicsSurface_Wrapper(class UMaterialInterface* OptionalMaterialPhysicsSurfaceWasDetectedOn, const TArray<EPhysicalSurface>& PhysicsSurfaces, const TArray<float>& PhysicsSurfaceValues, EPhysicalSurface* MostDominantPhysicsSurfaceFromArray, float* MostDominantPhysicsSurfaceColorValue);
	static class UVertexPaintMaterialDataAsset* GetVertexPaintMaterialDataAsset();
	static bool IsWorldValid(class UWorld* World);
	static TArray<struct FHitResult> MultisphereTraceForPaintAtLocation_Wrapper(const class UObject* WorldContextObject, const struct FVector& Location, const float& AreaOfEffect, const TArray<EObjectTypeQuery>& ObjectTypesToTraceFor, int32* ExpectedCallbacksFromPaintAtLocation);
	static ECollisionChannel ObjectTypeToCollisionChannel(EObjectTypeQuery Object);
	static void PaintColorSnippetOnMesh_Wrappers(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, class UPrimitiveComponent* MeshComponent, const struct FVertexPaintColorSnippetStruct& PaintColorSnippetStruct, const struct FVertexDetectAdditionalDataToPassThrough& AdditionalDataToPassThrough);
	static void PaintOnEntireMesh_Wrapper(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, class UPrimitiveComponent* MeshComponent, const struct FVertexPaintOnEntireMeshStruct& PaintOnEntireMeshStruct, const struct FVertexDetectAdditionalDataToPassThrough& AdditionalDataToPassThrough);
	static void PaintOnMeshAtLocation_Wrapper(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, class UPrimitiveComponent* MeshComponent, const struct FVertexPaintAtLocationStruct& PaintAtLocationStruct, const struct FVertexDetectAdditionalDataToPassThrough& AdditionalDataToPassThrough);
	static void PaintOnMeshWithinArea_Wrapper(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, class UPrimitiveComponent* MeshComponent, const TArray<struct FVertexPainthWithinArea_ComponentToCheckIfIsWithinInfo>& ComponentsToCheckIfIsWithin, const struct FVertexPainthWithinAreaStruct& PaintWithinAreaStruct, const struct FVertexDetectAdditionalDataToPassThrough& AdditionalDataToPassThrough);
	static void SetChaosClothPhysics(class USkeletalMeshComponent* SkeletalMeshComponent, class UClothingAssetBase* ClothingAsset, const struct FVertexDetectChaosClothPhysicsSettings& ClothPhysicsSettings);
	static void SetChaosWheeledVehicleFrictionMultiplier_Wrapper(class UChaosWheeledVehicleMovementComponent* ChaosWheeledVehicleMovementComponent, int32 WheelIndex, float Friction);
	static void SetMeshComponentVertexColors_Wrapper(class UPrimitiveComponent* MeshComponent, const struct FVertexPaintSetMeshComponentVertexColors& SetMeshComponentVertexColorsSettings, const struct FVertexDetectAdditionalDataToPassThrough& AdditionalDataToPassThrough);
	static void SetMeshComponentVertexColorsUsingSerializedString_Wrapper(class UPrimitiveComponent* MeshComponent, const struct FVertexPaintSetMeshComponentVertexColorsUsingSerializedString& SetMeshComponentVertexColorsUsingSerializedStringSettings, const struct FVertexDetectAdditionalDataToPassThrough& AdditionalDataToPassThrough);
	static void UpdateChaosClothPhysicsWithExistingColors(class USkeletalMeshComponent* SkeletalMeshComponent);
	static class USkeletalMesh* VertexPaintDetectionPlugin_GetSkeletalMesh(class USkeletalMeshComponent* SkeletalMeshComp);
	static TArray<struct FColor> VertexPaintDetectionPlugin_GetSkeletalMeshVertexColorsAtLOD(class USkeletalMeshComponent* SkeletalMeshComponent, int32 Lod);
	static TArray<struct FColor> VertexPaintDetectionPlugin_GetStaticMeshVertexColorsAtLOD(class UStaticMeshComponent* StaticMeshComponent, int32 Lod);
	static void VertexPaintDetectionPlugin_SetSkeletalMeshAndReleaseResources(class USkeletalMeshComponent* SkeletalMeshComponent, class USkeletalMesh* NewMesh);
	static void VertexPaintDetectionPlugin_SetStaticMeshAndReleaseOverrideVertexColors(class UStaticMeshComponent* StaticMeshComponent, class UStaticMesh* NewMesh);
	static TMap<int32, class FString> VertexPaintDetectionPlugin_SortAssetsNamesAlphabetically(const TMap<int32, class FString>& AssetIndexAndName);
	static TArray<class FString> VertexPaintDetectionPlugin_SortStringArrayAlphabetically(const TArray<class FString>& Strings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintFunctionLibrary">();
	}
	static class UVertexPaintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintFunctionLibrary>();
	}
};
static_assert(alignof(UVertexPaintFunctionLibrary) == 0x000008, "Wrong alignment on UVertexPaintFunctionLibrary");
static_assert(sizeof(UVertexPaintFunctionLibrary) == 0x000028, "Wrong size on UVertexPaintFunctionLibrary");

// Class VertexPaintDetectionPlugin.VertexPaintMaterialDataAsset
// 0x0050 (0x0080 - 0x0030)
class UVertexPaintMaterialDataAsset final : public UDataAsset
{
public:
	TMap<TSoftObjectPtr<class UMaterialInterface>, struct FVertexPaintMaterialDataAssetStruct> VertexPaintMaterialInterfaces;                     // 0x0030(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)

public:
	void AddToVertexPaintMaterialInterface(TSoftObjectPtr<class UMaterialInterface> Material, const struct FVertexPaintMaterialDataAssetStruct& MaterialDataAssetStruct);
	TMap<TSoftObjectPtr<class UMaterialInterface>, struct FVertexPaintMaterialDataAssetStruct> GetVertexPaintMaterialInterface();
	bool IsMaterialAddedToPaintOnMaterialDataAsset(TSoftObjectPtr<class UMaterialInterface> Material);
	void RemoveFromVertexPaintMaterialInterface(TSoftObjectPtr<class UMaterialInterface> Material);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintMaterialDataAsset">();
	}
	static class UVertexPaintMaterialDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintMaterialDataAsset>();
	}
};
static_assert(alignof(UVertexPaintMaterialDataAsset) == 0x000008, "Wrong alignment on UVertexPaintMaterialDataAsset");
static_assert(sizeof(UVertexPaintMaterialDataAsset) == 0x000080, "Wrong size on UVertexPaintMaterialDataAsset");
static_assert(offsetof(UVertexPaintMaterialDataAsset, VertexPaintMaterialInterfaces) == 0x000030, "Member 'UVertexPaintMaterialDataAsset::VertexPaintMaterialInterfaces' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintOptimizationDataAsset
// 0x00A0 (0x00D0 - 0x0030)
class UVertexPaintOptimizationDataAsset final : public UDataAsset
{
public:
	TMap<class UStaticMesh*, struct FPaintOnLODSettingsStruct> StaticMeshNumOfLODsToPaint;                        // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	TMap<class USkeletalMesh*, struct FPaintOnLODSettingsStruct> SkeletalMeshNumOfLODsToPaint;                      // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintOptimizationDataAsset">();
	}
	static class UVertexPaintOptimizationDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintOptimizationDataAsset>();
	}
};
static_assert(alignof(UVertexPaintOptimizationDataAsset) == 0x000008, "Wrong alignment on UVertexPaintOptimizationDataAsset");
static_assert(sizeof(UVertexPaintOptimizationDataAsset) == 0x0000D0, "Wrong size on UVertexPaintOptimizationDataAsset");
static_assert(offsetof(UVertexPaintOptimizationDataAsset, StaticMeshNumOfLODsToPaint) == 0x000030, "Member 'UVertexPaintOptimizationDataAsset::StaticMeshNumOfLODsToPaint' has a wrong offset!");
static_assert(offsetof(UVertexPaintOptimizationDataAsset, SkeletalMeshNumOfLODsToPaint) == 0x000080, "Member 'UVertexPaintOptimizationDataAsset::SkeletalMeshNumOfLODsToPaint' has a wrong offset!");

}

