#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PiecesGameplayAbilities

#include "Basic.hpp"

#include "GameplayAbilities_classes.hpp"
#include "PiecesGameplayAbilities_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "EnhancedInput_classes.hpp"


namespace SDK
{

// Class PiecesGameplayAbilities.PGameplayTargetActor_Trace
// 0x0030 (0x0380 - 0x0350)
class APGameplayTargetActor_Trace : public AGameplayAbilityTargetActor
{
public:
	float                                         MaxRange;                                          // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCollisionProfileName                  TraceProfile;                                      // 0x034C(0x0008)(Edit, BlueprintVisible, Config, NoDestructor, ExposeOnSpawn, NativeAccessSpecifierPublic)
	uint8                                         bTraceAffectsAimPitch : 1;                         // 0x0354(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bTraceFromPlayerViewPoint : 1;                     // 0x0354(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bContinousTargetConfirmation : 1;                  // 0x0354(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bSnapReticleToTarget : 1;                          // 0x0354(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_355[0x3];                                      // 0x0355(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReticleSocketLocation;                             // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetLerpSpeed;                                   // 0x0360(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseSpread;                                        // 0x0364(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetingSpreadIncrement;                          // 0x0368(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetingSpreadMax;                                // 0x036C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_370[0x10];                                     // 0x0370(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PGameplayTargetActor_Trace">();
	}
	static class APGameplayTargetActor_Trace* GetDefaultObj()
	{
		return GetDefaultObjImpl<APGameplayTargetActor_Trace>();
	}
};
static_assert(alignof(APGameplayTargetActor_Trace) == 0x000010, "Wrong alignment on APGameplayTargetActor_Trace");
static_assert(sizeof(APGameplayTargetActor_Trace) == 0x000380, "Wrong size on APGameplayTargetActor_Trace");
static_assert(offsetof(APGameplayTargetActor_Trace, MaxRange) == 0x000348, "Member 'APGameplayTargetActor_Trace::MaxRange' has a wrong offset!");
static_assert(offsetof(APGameplayTargetActor_Trace, TraceProfile) == 0x00034C, "Member 'APGameplayTargetActor_Trace::TraceProfile' has a wrong offset!");
static_assert(offsetof(APGameplayTargetActor_Trace, ReticleSocketLocation) == 0x000358, "Member 'APGameplayTargetActor_Trace::ReticleSocketLocation' has a wrong offset!");
static_assert(offsetof(APGameplayTargetActor_Trace, TargetLerpSpeed) == 0x000360, "Member 'APGameplayTargetActor_Trace::TargetLerpSpeed' has a wrong offset!");
static_assert(offsetof(APGameplayTargetActor_Trace, BaseSpread) == 0x000364, "Member 'APGameplayTargetActor_Trace::BaseSpread' has a wrong offset!");
static_assert(offsetof(APGameplayTargetActor_Trace, TargetingSpreadIncrement) == 0x000368, "Member 'APGameplayTargetActor_Trace::TargetingSpreadIncrement' has a wrong offset!");
static_assert(offsetof(APGameplayTargetActor_Trace, TargetingSpreadMax) == 0x00036C, "Member 'APGameplayTargetActor_Trace::TargetingSpreadMax' has a wrong offset!");

// Class PiecesGameplayAbilities.PGameplayTargetActor_LineTrace
// 0x0000 (0x0380 - 0x0380)
class APGameplayTargetActor_LineTrace final : public APGameplayTargetActor_Trace
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PGameplayTargetActor_LineTrace">();
	}
	static class APGameplayTargetActor_LineTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<APGameplayTargetActor_LineTrace>();
	}
};
static_assert(alignof(APGameplayTargetActor_LineTrace) == 0x000010, "Wrong alignment on APGameplayTargetActor_LineTrace");
static_assert(sizeof(APGameplayTargetActor_LineTrace) == 0x000380, "Wrong size on APGameplayTargetActor_LineTrace");

// Class PiecesGameplayAbilities.PiecesGameplayAbility
// 0x0008 (0x03B8 - 0x03B0)
class UPiecesGameplayAbility : public UGameplayAbility
{
public:
	EAbilityActivationPolicy                      ActivationPolicy;                                  // 0x03B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGiveAbility_GetAssetsToBeAsyncLoaded(class AActor* OwnerActor, TArray<struct FSoftObjectPath>& AssetsToLoad) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesGameplayAbility">();
	}
	static class UPiecesGameplayAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPiecesGameplayAbility>();
	}
};
static_assert(alignof(UPiecesGameplayAbility) == 0x000008, "Wrong alignment on UPiecesGameplayAbility");
static_assert(sizeof(UPiecesGameplayAbility) == 0x0003B8, "Wrong size on UPiecesGameplayAbility");
static_assert(offsetof(UPiecesGameplayAbility, ActivationPolicy) == 0x0003B0, "Member 'UPiecesGameplayAbility::ActivationPolicy' has a wrong offset!");

// Class PiecesGameplayAbilities.AbilityTask_WaitVelocity
// 0x0020 (0x00A0 - 0x0080)
class UAbilityTask_WaitVelocity : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnVelocityReached;                                 // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UMovementComponent>      CachedMovementComponent;                           // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitVelocity">();
	}
	static class UAbilityTask_WaitVelocity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitVelocity>();
	}
};
static_assert(alignof(UAbilityTask_WaitVelocity) == 0x000008, "Wrong alignment on UAbilityTask_WaitVelocity");
static_assert(sizeof(UAbilityTask_WaitVelocity) == 0x0000A0, "Wrong size on UAbilityTask_WaitVelocity");
static_assert(offsetof(UAbilityTask_WaitVelocity, OnVelocityReached) == 0x000080, "Member 'UAbilityTask_WaitVelocity::OnVelocityReached' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitVelocity, CachedMovementComponent) == 0x000090, "Member 'UAbilityTask_WaitVelocity::CachedMovementComponent' has a wrong offset!");

// Class PiecesGameplayAbilities.AbilityTask_WaitMaxVelocity
// 0x0008 (0x00A8 - 0x00A0)
class UAbilityTask_WaitMaxVelocity final : public UAbilityTask_WaitVelocity
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitMaxVelocity* CreateWaitMaxVelocity(class UGameplayAbility* OwningAbility, float MaximumMagnitude, bool bVelocity2D);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitMaxVelocity">();
	}
	static class UAbilityTask_WaitMaxVelocity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitMaxVelocity>();
	}
};
static_assert(alignof(UAbilityTask_WaitMaxVelocity) == 0x000008, "Wrong alignment on UAbilityTask_WaitMaxVelocity");
static_assert(sizeof(UAbilityTask_WaitMaxVelocity) == 0x0000A8, "Wrong size on UAbilityTask_WaitMaxVelocity");

// Class PiecesGameplayAbilities.AbilityTask_WaitMinVelocity
// 0x0008 (0x00A8 - 0x00A0)
class UAbilityTask_WaitMinVelocity final : public UAbilityTask_WaitVelocity
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitMinVelocity* CreateWaitMinVelocity(class UGameplayAbility* OwningAbility, float MinimumMagnitude, bool bVelocity2D);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitMinVelocity">();
	}
	static class UAbilityTask_WaitMinVelocity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitMinVelocity>();
	}
};
static_assert(alignof(UAbilityTask_WaitMinVelocity) == 0x000008, "Wrong alignment on UAbilityTask_WaitMinVelocity");
static_assert(sizeof(UAbilityTask_WaitMinVelocity) == 0x0000A8, "Wrong size on UAbilityTask_WaitMinVelocity");

// Class PiecesGameplayAbilities.InputConfigDataAsset
// 0x0020 (0x0050 - 0x0030)
class UInputConfigDataAsset final : public UDataAsset
{
public:
	TArray<struct FTaggedInputAction>             NativeInputActions;                                // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FTaggedInputAction>             AbilityInputActions;                               // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputConfigDataAsset">();
	}
	static class UInputConfigDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputConfigDataAsset>();
	}
};
static_assert(alignof(UInputConfigDataAsset) == 0x000008, "Wrong alignment on UInputConfigDataAsset");
static_assert(sizeof(UInputConfigDataAsset) == 0x000050, "Wrong size on UInputConfigDataAsset");
static_assert(offsetof(UInputConfigDataAsset, NativeInputActions) == 0x000030, "Member 'UInputConfigDataAsset::NativeInputActions' has a wrong offset!");
static_assert(offsetof(UInputConfigDataAsset, AbilityInputActions) == 0x000040, "Member 'UInputConfigDataAsset::AbilityInputActions' has a wrong offset!");

// Class PiecesGameplayAbilities.InputEngineSubSystem
// 0x0010 (0x0040 - 0x0030)
class UInputEngineSubSystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputEngineSubSystem">();
	}
	static class UInputEngineSubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputEngineSubSystem>();
	}
};
static_assert(alignof(UInputEngineSubSystem) == 0x000008, "Wrong alignment on UInputEngineSubSystem");
static_assert(sizeof(UInputEngineSubSystem) == 0x000040, "Wrong size on UInputEngineSubSystem");

// Class PiecesGameplayAbilities.PGameplayTargetActor_SphereTrace
// 0x0020 (0x03A0 - 0x0380)
class APGameplayTargetActor_SphereTrace final : public APGameplayTargetActor_Trace
{
public:
	float                                         CollisionRadius;                                   // 0x0380(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_384[0x1C];                                     // 0x0384(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PGameplayTargetActor_SphereTrace">();
	}
	static class APGameplayTargetActor_SphereTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<APGameplayTargetActor_SphereTrace>();
	}
};
static_assert(alignof(APGameplayTargetActor_SphereTrace) == 0x000010, "Wrong alignment on APGameplayTargetActor_SphereTrace");
static_assert(sizeof(APGameplayTargetActor_SphereTrace) == 0x0003A0, "Wrong size on APGameplayTargetActor_SphereTrace");
static_assert(offsetof(APGameplayTargetActor_SphereTrace, CollisionRadius) == 0x000380, "Member 'APGameplayTargetActor_SphereTrace::CollisionRadius' has a wrong offset!");

// Class PiecesGameplayAbilities.PiecesAbilitySystemComponent
// 0x0080 (0x1390 - 0x1310)
class UPiecesAbilitySystemComponent final : public UAbilitySystemComponent
{
public:
	uint8                                         Pad_1310[0x80];                                    // 0x1310(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PauseActiveGameplayEffects(const bool bPaused);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesAbilitySystemComponent">();
	}
	static class UPiecesAbilitySystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPiecesAbilitySystemComponent>();
	}
};
static_assert(alignof(UPiecesAbilitySystemComponent) == 0x000008, "Wrong alignment on UPiecesAbilitySystemComponent");
static_assert(sizeof(UPiecesAbilitySystemComponent) == 0x001390, "Wrong size on UPiecesAbilitySystemComponent");

// Class PiecesGameplayAbilities.PiecesCustomTargetDataFiltersUtils
// 0x0000 (0x0028 - 0x0028)
class UPiecesCustomTargetDataFiltersUtils final : public UBlueprintFunctionLibrary
{
public:
	static struct FGameplayTargetDataFilterHandle MakePiecesGameplayTargetDataFilterHandle(const class UGameplayAbility* Ability, const struct FPiecesGameplayTargetDataFilter& Filter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesCustomTargetDataFiltersUtils">();
	}
	static class UPiecesCustomTargetDataFiltersUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPiecesCustomTargetDataFiltersUtils>();
	}
};
static_assert(alignof(UPiecesCustomTargetDataFiltersUtils) == 0x000008, "Wrong alignment on UPiecesCustomTargetDataFiltersUtils");
static_assert(sizeof(UPiecesCustomTargetDataFiltersUtils) == 0x000028, "Wrong size on UPiecesCustomTargetDataFiltersUtils");

// Class PiecesGameplayAbilities.PiecesEnhancedInputComponent
// 0x0000 (0x0170 - 0x0170)
class UPiecesEnhancedInputComponent final : public UEnhancedInputComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesEnhancedInputComponent">();
	}
	static class UPiecesEnhancedInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPiecesEnhancedInputComponent>();
	}
};
static_assert(alignof(UPiecesEnhancedInputComponent) == 0x000008, "Wrong alignment on UPiecesEnhancedInputComponent");
static_assert(sizeof(UPiecesEnhancedInputComponent) == 0x000170, "Wrong size on UPiecesEnhancedInputComponent");

// Class PiecesGameplayAbilities.PiecesGameplayEffect
// 0x0010 (0x0810 - 0x0800)
class UPiecesGameplayEffect final : public UGameplayEffect
{
public:
	TArray<struct FGameplayTag>                   InputTags;                                         // 0x0800(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiecesGameplayEffect">();
	}
	static class UPiecesGameplayEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPiecesGameplayEffect>();
	}
};
static_assert(alignof(UPiecesGameplayEffect) == 0x000008, "Wrong alignment on UPiecesGameplayEffect");
static_assert(sizeof(UPiecesGameplayEffect) == 0x000810, "Wrong size on UPiecesGameplayEffect");
static_assert(offsetof(UPiecesGameplayEffect, InputTags) == 0x000800, "Member 'UPiecesGameplayEffect::InputTags' has a wrong offset!");

}

