#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: OBJPool

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "OBJPool_structs.hpp"


namespace SDK
{

// Class OBJPool.PooledProjectile
// 0x0098 (0x0150 - 0x00B8)
class UPooledProjectile final : public UActorComponent
{
public:
	class UProjectileMovementComponent*           Movement;                                          // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APooledActor*                           AOwner;                                            // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APooledPawn*                            POwner;                                            // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    Primitive;                                         // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Direction;                                         // 0x00D8(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialSpeed;                                      // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UpdateOnlyIfRendered;                              // 0x00EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         RotationFollowsVelocity : 1;                       // 0x00F0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         InitialVelocityInLocalSpace : 1;                   // 0x00F0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectileGravityScale;                            // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ShouldBounce : 1;                                  // 0x00F8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         BounceAngleAffectsFriction : 1;                    // 0x00F8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Bounciness;                                        // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BounceVelocityStopSimulatingThreshold;             // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ForceSubStepping : 1;                              // 0x0108(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxSimulationIterations;                           // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimulationTimeStep;                             // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         IsHomingProjectile : 1;                            // 0x0114(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnProjectileBounce;                                // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnProjectileStop;                                  // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AActor*                                 HomingTarget;                                      // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class USceneComponent>         HomingTargetComponent;                             // 0x0140(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingAccelerationMagnitude;                       // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14C[0x4];                                      // 0x014C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Break();
	void ProjectileBounce(const struct FHitResult& HitResult, const struct FVector& Velocity);
	void ProjectileStop(const struct FHitResult& HitResult);
	void Shoot();

	class UProjectileMovementComponent* GetMovementComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PooledProjectile">();
	}
	static class UPooledProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPooledProjectile>();
	}
};
static_assert(alignof(UPooledProjectile) == 0x000008, "Wrong alignment on UPooledProjectile");
static_assert(sizeof(UPooledProjectile) == 0x000150, "Wrong size on UPooledProjectile");
static_assert(offsetof(UPooledProjectile, Movement) == 0x0000B8, "Member 'UPooledProjectile::Movement' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, AOwner) == 0x0000C0, "Member 'UPooledProjectile::AOwner' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, POwner) == 0x0000C8, "Member 'UPooledProjectile::POwner' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, Primitive) == 0x0000D0, "Member 'UPooledProjectile::Primitive' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, Direction) == 0x0000D8, "Member 'UPooledProjectile::Direction' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, InitialSpeed) == 0x0000E4, "Member 'UPooledProjectile::InitialSpeed' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, MaxSpeed) == 0x0000E8, "Member 'UPooledProjectile::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, UpdateOnlyIfRendered) == 0x0000EC, "Member 'UPooledProjectile::UpdateOnlyIfRendered' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, ProjectileGravityScale) == 0x0000F4, "Member 'UPooledProjectile::ProjectileGravityScale' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, Bounciness) == 0x0000FC, "Member 'UPooledProjectile::Bounciness' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, Friction) == 0x000100, "Member 'UPooledProjectile::Friction' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, BounceVelocityStopSimulatingThreshold) == 0x000104, "Member 'UPooledProjectile::BounceVelocityStopSimulatingThreshold' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, MaxSimulationIterations) == 0x00010C, "Member 'UPooledProjectile::MaxSimulationIterations' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, MaxSimulationTimeStep) == 0x000110, "Member 'UPooledProjectile::MaxSimulationTimeStep' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, OnProjectileBounce) == 0x000118, "Member 'UPooledProjectile::OnProjectileBounce' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, OnProjectileStop) == 0x000128, "Member 'UPooledProjectile::OnProjectileStop' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, HomingTarget) == 0x000138, "Member 'UPooledProjectile::HomingTarget' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, HomingTargetComponent) == 0x000140, "Member 'UPooledProjectile::HomingTargetComponent' has a wrong offset!");
static_assert(offsetof(UPooledProjectile, HomingAccelerationMagnitude) == 0x000148, "Member 'UPooledProjectile::HomingAccelerationMagnitude' has a wrong offset!");

// Class OBJPool.ObjectPool
// 0x0028 (0x00E0 - 0x00B8)
class UObjectPool final : public UActorComponent
{
public:
	TArray<class APooledActor*>                   Pool;                                              // 0x00B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          ReinitializeInstances;                             // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InstantiateOnDemand;                               // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeverFailDeferredSpawn;                            // 0x00CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KeepOrphanActorsAlive;                             // 0x00CB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APooledActor>               TemplateClass;                                     // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PoolSize;                                          // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoInitialize;                                    // 0x00DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class APooledActor* BeginDeferredSpawnFromPool(const class UObject* WorldContextObject, class UObjectPool* ObjectPool, class UClass* PooledClass, const struct FPoolSpawnOptions& SpawnOptions, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, const bool Reconstruct, bool* SpawnSuccessful);
	static class APooledActor* FinishDeferredSpawnFromPool(class APooledActor* Actor, const bool Reconstruct, const struct FTransform& SpawnTransform);

	void EmptyObjectPool();
	void GetInactiveObjects(TArray<class APooledActor*>* Inactive);
	void GetObjectsFromPool(TArray<class APooledActor*>* Spawned, TArray<class APooledActor*>* Inactive);
	void GetSpawnedObjects(TArray<class APooledActor*>* Spawned);
	void InitializeObjectPool();
	void InitializeObjectPoolWithNewTemplateClass(const TSubclassOf<class APooledActor> Template, const int32 SizeOfPool);
	void ReturnActor(class APooledActor* PooledActor);

	class APooledActor* GetInactiveObject() const;
	TArray<class APooledActor*> GetObjectArray() const;
	class APooledActor* GetSpawnedObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPool">();
	}
	static class UObjectPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPool>();
	}
};
static_assert(alignof(UObjectPool) == 0x000008, "Wrong alignment on UObjectPool");
static_assert(sizeof(UObjectPool) == 0x0000E0, "Wrong size on UObjectPool");
static_assert(offsetof(UObjectPool, Pool) == 0x0000B8, "Member 'UObjectPool::Pool' has a wrong offset!");
static_assert(offsetof(UObjectPool, ReinitializeInstances) == 0x0000C8, "Member 'UObjectPool::ReinitializeInstances' has a wrong offset!");
static_assert(offsetof(UObjectPool, InstantiateOnDemand) == 0x0000C9, "Member 'UObjectPool::InstantiateOnDemand' has a wrong offset!");
static_assert(offsetof(UObjectPool, NeverFailDeferredSpawn) == 0x0000CA, "Member 'UObjectPool::NeverFailDeferredSpawn' has a wrong offset!");
static_assert(offsetof(UObjectPool, KeepOrphanActorsAlive) == 0x0000CB, "Member 'UObjectPool::KeepOrphanActorsAlive' has a wrong offset!");
static_assert(offsetof(UObjectPool, TemplateClass) == 0x0000D0, "Member 'UObjectPool::TemplateClass' has a wrong offset!");
static_assert(offsetof(UObjectPool, PoolSize) == 0x0000D8, "Member 'UObjectPool::PoolSize' has a wrong offset!");
static_assert(offsetof(UObjectPool, AutoInitialize) == 0x0000DC, "Member 'UObjectPool::AutoInitialize' has a wrong offset!");

// Class OBJPool.PawnPool
// 0x0028 (0x00E0 - 0x00B8)
class UPawnPool final : public UActorComponent
{
public:
	TArray<class APooledPawn*>                    Pool;                                              // 0x00B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          ReinitializeInstances;                             // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InstantiateOnDemand;                               // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeverFailDeferredSpawn;                            // 0x00CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KeepOrphanActorsAlive;                             // 0x00CB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APooledPawn>                TemplateClass;                                     // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PoolSize;                                          // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoInitialize;                                    // 0x00DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class APooledPawn* BeginDeferredSpawnFromPool(const class UObject* WorldContextObject, class UPawnPool* ObjectPool, class UClass* PooledClass, const struct FPoolSpawnOptions& SpawnOptions, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, const bool Reconstruct, bool* SpawnSuccessful);
	static class APooledPawn* FinishDeferredSpawnFromPool(class APooledPawn* Pawn, const bool Reconstruct, const struct FTransform& SpawnTransform);

	void EmptyObjectPool();
	void GetInactiveObjects(TArray<class APooledPawn*>* Inactive);
	void GetObjectsFromPool(TArray<class APooledPawn*>* Spawned, TArray<class APooledPawn*>* Inactive);
	void GetSpawnedObjects(TArray<class APooledPawn*>* Spawned);
	void InitializeObjectPool();
	void InitializeObjectPoolWithNewTemplateClass(const TSubclassOf<class APooledPawn> Template, const int32 SizeOfPool);
	void ReturnActor(class APooledPawn* PooledActor);

	class APooledPawn* GetInactiveObject() const;
	TArray<class APooledPawn*> GetObjectArray() const;
	class APooledPawn* GetSpawnedObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PawnPool">();
	}
	static class UPawnPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPawnPool>();
	}
};
static_assert(alignof(UPawnPool) == 0x000008, "Wrong alignment on UPawnPool");
static_assert(sizeof(UPawnPool) == 0x0000E0, "Wrong size on UPawnPool");
static_assert(offsetof(UPawnPool, Pool) == 0x0000B8, "Member 'UPawnPool::Pool' has a wrong offset!");
static_assert(offsetof(UPawnPool, ReinitializeInstances) == 0x0000C8, "Member 'UPawnPool::ReinitializeInstances' has a wrong offset!");
static_assert(offsetof(UPawnPool, InstantiateOnDemand) == 0x0000C9, "Member 'UPawnPool::InstantiateOnDemand' has a wrong offset!");
static_assert(offsetof(UPawnPool, NeverFailDeferredSpawn) == 0x0000CA, "Member 'UPawnPool::NeverFailDeferredSpawn' has a wrong offset!");
static_assert(offsetof(UPawnPool, KeepOrphanActorsAlive) == 0x0000CB, "Member 'UPawnPool::KeepOrphanActorsAlive' has a wrong offset!");
static_assert(offsetof(UPawnPool, TemplateClass) == 0x0000D0, "Member 'UPawnPool::TemplateClass' has a wrong offset!");
static_assert(offsetof(UPawnPool, PoolSize) == 0x0000D8, "Member 'UPawnPool::PoolSize' has a wrong offset!");
static_assert(offsetof(UPawnPool, AutoInitialize) == 0x0000DC, "Member 'UPawnPool::AutoInitialize' has a wrong offset!");

// Class OBJPool.CharacterPool
// 0x0028 (0x00E0 - 0x00B8)
class UCharacterPool final : public UActorComponent
{
public:
	TArray<class APooledCharacter*>               Pool;                                              // 0x00B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          ReinitializeInstances;                             // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InstantiateOnDemand;                               // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeverFailDeferredSpawn;                            // 0x00CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KeepOrphanActorsAlive;                             // 0x00CB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class APooledCharacter>           TemplateClass;                                     // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PoolSize;                                          // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoInitialize;                                    // 0x00DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x3];                                       // 0x00DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class APooledCharacter* BeginDeferredSpawnFromPool(const class UObject* WorldContextObject, class UCharacterPool* ObjectPool, class UClass* PooledClass, const struct FPoolSpawnOptions& SpawnOptions, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, const bool Reconstruct, bool* SpawnSuccessful);
	static class APooledCharacter* FinishDeferredSpawnFromPool(class APooledCharacter* Character, const bool Reconstruct, const struct FTransform& SpawnTransform);

	void EmptyObjectPool();
	void GetInactiveObjects(TArray<class APooledCharacter*>* Inactive);
	void GetObjectsFromPool(TArray<class APooledCharacter*>* Spawned, TArray<class APooledCharacter*>* Inactive);
	void GetSpawnedObjects(TArray<class APooledCharacter*>* Spawned);
	void InitializeObjectPool();
	void InitializeObjectPoolWithNewTemplateClass(const TSubclassOf<class APooledCharacter> Template, const int32 SizeOfPool);
	void ReturnActor(class APooledCharacter* PooledActor);

	class APooledCharacter* GetInactiveObject() const;
	TArray<class APooledCharacter*> GetObjectArray() const;
	class APooledCharacter* GetSpawnedObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterPool">();
	}
	static class UCharacterPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterPool>();
	}
};
static_assert(alignof(UCharacterPool) == 0x000008, "Wrong alignment on UCharacterPool");
static_assert(sizeof(UCharacterPool) == 0x0000E0, "Wrong size on UCharacterPool");
static_assert(offsetof(UCharacterPool, Pool) == 0x0000B8, "Member 'UCharacterPool::Pool' has a wrong offset!");
static_assert(offsetof(UCharacterPool, ReinitializeInstances) == 0x0000C8, "Member 'UCharacterPool::ReinitializeInstances' has a wrong offset!");
static_assert(offsetof(UCharacterPool, InstantiateOnDemand) == 0x0000C9, "Member 'UCharacterPool::InstantiateOnDemand' has a wrong offset!");
static_assert(offsetof(UCharacterPool, NeverFailDeferredSpawn) == 0x0000CA, "Member 'UCharacterPool::NeverFailDeferredSpawn' has a wrong offset!");
static_assert(offsetof(UCharacterPool, KeepOrphanActorsAlive) == 0x0000CB, "Member 'UCharacterPool::KeepOrphanActorsAlive' has a wrong offset!");
static_assert(offsetof(UCharacterPool, TemplateClass) == 0x0000D0, "Member 'UCharacterPool::TemplateClass' has a wrong offset!");
static_assert(offsetof(UCharacterPool, PoolSize) == 0x0000D8, "Member 'UCharacterPool::PoolSize' has a wrong offset!");
static_assert(offsetof(UCharacterPool, AutoInitialize) == 0x0000DC, "Member 'UCharacterPool::AutoInitialize' has a wrong offset!");

// Class OBJPool.SharedObjectPool
// 0x0068 (0x0120 - 0x00B8)
class USharedObjectPool final : public UActorComponent
{
public:
	TArray<class APooledActor*>                   Pool;                                              // 0x00B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          ReinitializeInstances;                             // 0x00C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InstantiateOnDemand;                               // 0x00C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NeverFailDeferredSpawn;                            // 0x00CA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KeepOrphanActorsAlive;                             // 0x00CB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoInitialize;                                    // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class APooledActor>, int32>  TemplateClasses;                                   // 0x00D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class APooledActor* BeginDeferredSpawnFromPool(const class UObject* WorldContextObject, class USharedObjectPool* SharedPool, class UClass* Class_0, const struct FPoolSpawnOptions& SpawnOptions, const struct FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, const bool Reconstruct, bool* SpawnSuccessful);
	static class APooledActor* FinishDeferredSpawnFromPool(class APooledActor* Actor, const bool Reconstruct, const struct FTransform& SpawnTransform);

	void EmptyObjectPool(const class UClass* Class_0);
	void GetInactiveObjects(const class UClass* Class_0, TArray<class APooledActor*>* Inactive);
	void GetObjectsFromPool(const class UClass* Class_0, TArray<class APooledActor*>* Spawned, TArray<class APooledActor*>* Inactive);
	void GetSpawnedObjects(const class UClass* Class_0, TArray<class APooledActor*>* Spawned);
	void InitializeObjectPool();
	void ReturnActor(class APooledActor* PooledActor);

	class APooledActor* GetInactiveObject(const class UClass* Class_0) const;
	TArray<class APooledActor*> GetObjectArray() const;
	class APooledActor* GetSpawnedObject(const class UClass* Class_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SharedObjectPool">();
	}
	static class USharedObjectPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<USharedObjectPool>();
	}
};
static_assert(alignof(USharedObjectPool) == 0x000008, "Wrong alignment on USharedObjectPool");
static_assert(sizeof(USharedObjectPool) == 0x000120, "Wrong size on USharedObjectPool");
static_assert(offsetof(USharedObjectPool, Pool) == 0x0000B8, "Member 'USharedObjectPool::Pool' has a wrong offset!");
static_assert(offsetof(USharedObjectPool, ReinitializeInstances) == 0x0000C8, "Member 'USharedObjectPool::ReinitializeInstances' has a wrong offset!");
static_assert(offsetof(USharedObjectPool, InstantiateOnDemand) == 0x0000C9, "Member 'USharedObjectPool::InstantiateOnDemand' has a wrong offset!");
static_assert(offsetof(USharedObjectPool, NeverFailDeferredSpawn) == 0x0000CA, "Member 'USharedObjectPool::NeverFailDeferredSpawn' has a wrong offset!");
static_assert(offsetof(USharedObjectPool, KeepOrphanActorsAlive) == 0x0000CB, "Member 'USharedObjectPool::KeepOrphanActorsAlive' has a wrong offset!");
static_assert(offsetof(USharedObjectPool, AutoInitialize) == 0x0000CC, "Member 'USharedObjectPool::AutoInitialize' has a wrong offset!");
static_assert(offsetof(USharedObjectPool, TemplateClasses) == 0x0000D0, "Member 'USharedObjectPool::TemplateClasses' has a wrong offset!");

// Class OBJPool.PooledActor
// 0x0048 (0x0280 - 0x0238)
class APooledActor final : public AActor
{
public:
	bool                                          Spawned;                                           // 0x0238(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectPool*                            OwningPool;                                        // 0x0240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USharedObjectPool*                      SharedPool;                                        // 0x0248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           LifeSpanHandle;                                    // 0x0250(0x0008)(NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifeSpanPool;                                      // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPoolBeginPlay;                                   // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPoolEndPlay;                                     // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void EVENT_OnPoolBeginPlay();
	void EVENT_OnPoolEndPlay();
	void ReturnToPool();
	void SetLifeSpanPool(float InLifespan);
	void SpawnFromPool(const bool Reconstruct, const struct FPoolSpawnOptions& SpawnOptions, const struct FTransform& SpawnTransform);

	float GetLifeSpanPool() const;
	class UObjectPool* GetOwningPool() const;
	class USharedObjectPool* GetSharedPool() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PooledActor">();
	}
	static class APooledActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APooledActor>();
	}
};
static_assert(alignof(APooledActor) == 0x000008, "Wrong alignment on APooledActor");
static_assert(sizeof(APooledActor) == 0x000280, "Wrong size on APooledActor");
static_assert(offsetof(APooledActor, Spawned) == 0x000238, "Member 'APooledActor::Spawned' has a wrong offset!");
static_assert(offsetof(APooledActor, OwningPool) == 0x000240, "Member 'APooledActor::OwningPool' has a wrong offset!");
static_assert(offsetof(APooledActor, SharedPool) == 0x000248, "Member 'APooledActor::SharedPool' has a wrong offset!");
static_assert(offsetof(APooledActor, LifeSpanHandle) == 0x000250, "Member 'APooledActor::LifeSpanHandle' has a wrong offset!");
static_assert(offsetof(APooledActor, LifeSpanPool) == 0x000258, "Member 'APooledActor::LifeSpanPool' has a wrong offset!");
static_assert(offsetof(APooledActor, OnPoolBeginPlay) == 0x000260, "Member 'APooledActor::OnPoolBeginPlay' has a wrong offset!");
static_assert(offsetof(APooledActor, OnPoolEndPlay) == 0x000270, "Member 'APooledActor::OnPoolEndPlay' has a wrong offset!");

// Class OBJPool.PooledCharacter
// 0x0090 (0x0560 - 0x04D0)
class APooledCharacter : public ACharacter
{
public:
	class UCharacterPool*                         OwningPool;                                        // 0x04C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Spawned;                                           // 0x04D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D1[0x7];                                      // 0x04D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           LifeSpanHandle;                                    // 0x04D8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LifeSpanPool;                                      // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E4[0x4];                                      // 0x04E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPoolBeginPlay;                                   // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPoolEndPlay;                                     // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<uint32, struct FComponentPrePooledSettings> UniqueIdToPrePooledSettings;                       // 0x0508(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_558[0x8];                                      // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EVENT_OnPoolBeginPlay();
	void EVENT_OnPoolEndPlay();
	void ReturnToPool();
	void SetLifeSpanPool(float InLifespan);
	void SpawnFromPool(const bool Reconstruct, const struct FPoolSpawnOptions& SpawnOptions, const struct FTransform& SpawnTransform);

	float GetLifeSpanPool() const;
	class UCharacterPool* GetOwningPool() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PooledCharacter">();
	}
	static class APooledCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<APooledCharacter>();
	}
};
static_assert(alignof(APooledCharacter) == 0x000010, "Wrong alignment on APooledCharacter");
static_assert(sizeof(APooledCharacter) == 0x000560, "Wrong size on APooledCharacter");
static_assert(offsetof(APooledCharacter, OwningPool) == 0x0004C8, "Member 'APooledCharacter::OwningPool' has a wrong offset!");
static_assert(offsetof(APooledCharacter, Spawned) == 0x0004D0, "Member 'APooledCharacter::Spawned' has a wrong offset!");
static_assert(offsetof(APooledCharacter, LifeSpanHandle) == 0x0004D8, "Member 'APooledCharacter::LifeSpanHandle' has a wrong offset!");
static_assert(offsetof(APooledCharacter, LifeSpanPool) == 0x0004E0, "Member 'APooledCharacter::LifeSpanPool' has a wrong offset!");
static_assert(offsetof(APooledCharacter, OnPoolBeginPlay) == 0x0004E8, "Member 'APooledCharacter::OnPoolBeginPlay' has a wrong offset!");
static_assert(offsetof(APooledCharacter, OnPoolEndPlay) == 0x0004F8, "Member 'APooledCharacter::OnPoolEndPlay' has a wrong offset!");
static_assert(offsetof(APooledCharacter, UniqueIdToPrePooledSettings) == 0x000508, "Member 'APooledCharacter::UniqueIdToPrePooledSettings' has a wrong offset!");

// Class OBJPool.PooledPawn
// 0x0040 (0x02D8 - 0x0298)
class APooledPawn final : public APawn
{
public:
	class UPawnPool*                              OwningPool;                                        // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          Spawned;                                           // 0x02A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           LifeSpanHandle;                                    // 0x02A8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LifeSpanPool;                                      // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPoolBeginPlay;                                   // 0x02B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPoolEndPlay;                                     // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void EVENT_OnPoolBeginPlay();
	void EVENT_OnPoolEndPlay();
	void ReturnToPool();
	void SetLifeSpanPool(float InLifespan);
	void SpawnFromPool(const bool Reconstruct, const struct FPoolSpawnOptions& SpawnOptions, const struct FTransform& SpawnTransform);

	float GetLifeSpanPool() const;
	class UPawnPool* GetOwningPool() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PooledPawn">();
	}
	static class APooledPawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<APooledPawn>();
	}
};
static_assert(alignof(APooledPawn) == 0x000008, "Wrong alignment on APooledPawn");
static_assert(sizeof(APooledPawn) == 0x0002D8, "Wrong size on APooledPawn");
static_assert(offsetof(APooledPawn, OwningPool) == 0x000298, "Member 'APooledPawn::OwningPool' has a wrong offset!");
static_assert(offsetof(APooledPawn, Spawned) == 0x0002A0, "Member 'APooledPawn::Spawned' has a wrong offset!");
static_assert(offsetof(APooledPawn, LifeSpanHandle) == 0x0002A8, "Member 'APooledPawn::LifeSpanHandle' has a wrong offset!");
static_assert(offsetof(APooledPawn, LifeSpanPool) == 0x0002B0, "Member 'APooledPawn::LifeSpanPool' has a wrong offset!");
static_assert(offsetof(APooledPawn, OnPoolBeginPlay) == 0x0002B8, "Member 'APooledPawn::OnPoolBeginPlay' has a wrong offset!");
static_assert(offsetof(APooledPawn, OnPoolEndPlay) == 0x0002C8, "Member 'APooledPawn::OnPoolEndPlay' has a wrong offset!");

// Class OBJPool.PooledSplineProjectile
// 0x00F0 (0x01A8 - 0x00B8)
class UPooledSplineProjectile final : public UActorComponent
{
public:
	uint8                                         Pad_B8[0x90];                                      // 0x00B8(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	class APooledPawn*                            POwner;                                            // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APooledActor*                           AOwner;                                            // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPrimitiveComponent*                    Primitive;                                         // 0x0158(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       SplineComponent;                                   // 0x0160(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PathWidth;                                         // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      PathCollisionQueryTypes;                           // 0x0170(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoredActorsOnCollisionQuery;                     // 0x0180(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               CollisionQueryDebugMode;                           // 0x0190(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnProjectileHit;                                   // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Break();
	void SetSplineComponent(class USplineComponent* Target);
	void Shoot();

	class USplineComponent* GetSplineComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PooledSplineProjectile">();
	}
	static class UPooledSplineProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPooledSplineProjectile>();
	}
};
static_assert(alignof(UPooledSplineProjectile) == 0x000008, "Wrong alignment on UPooledSplineProjectile");
static_assert(sizeof(UPooledSplineProjectile) == 0x0001A8, "Wrong size on UPooledSplineProjectile");
static_assert(offsetof(UPooledSplineProjectile, POwner) == 0x000148, "Member 'UPooledSplineProjectile::POwner' has a wrong offset!");
static_assert(offsetof(UPooledSplineProjectile, AOwner) == 0x000150, "Member 'UPooledSplineProjectile::AOwner' has a wrong offset!");
static_assert(offsetof(UPooledSplineProjectile, Primitive) == 0x000158, "Member 'UPooledSplineProjectile::Primitive' has a wrong offset!");
static_assert(offsetof(UPooledSplineProjectile, SplineComponent) == 0x000160, "Member 'UPooledSplineProjectile::SplineComponent' has a wrong offset!");
static_assert(offsetof(UPooledSplineProjectile, PathWidth) == 0x000168, "Member 'UPooledSplineProjectile::PathWidth' has a wrong offset!");
static_assert(offsetof(UPooledSplineProjectile, Speed) == 0x00016C, "Member 'UPooledSplineProjectile::Speed' has a wrong offset!");
static_assert(offsetof(UPooledSplineProjectile, PathCollisionQueryTypes) == 0x000170, "Member 'UPooledSplineProjectile::PathCollisionQueryTypes' has a wrong offset!");
static_assert(offsetof(UPooledSplineProjectile, IgnoredActorsOnCollisionQuery) == 0x000180, "Member 'UPooledSplineProjectile::IgnoredActorsOnCollisionQuery' has a wrong offset!");
static_assert(offsetof(UPooledSplineProjectile, CollisionQueryDebugMode) == 0x000190, "Member 'UPooledSplineProjectile::CollisionQueryDebugMode' has a wrong offset!");
static_assert(offsetof(UPooledSplineProjectile, OnProjectileHit) == 0x000198, "Member 'UPooledSplineProjectile::OnProjectileHit' has a wrong offset!");

}

