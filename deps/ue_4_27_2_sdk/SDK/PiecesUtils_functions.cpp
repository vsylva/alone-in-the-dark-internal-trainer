#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PiecesUtils

#include "Basic.hpp"

#include "PiecesUtils_classes.hpp"
#include "PiecesUtils_parameters.hpp"


namespace SDK
{

// Function PiecesUtils.AssetUtils.GetReferencersOfAsset
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAssetData                       AssetData                                              (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           InRefrencersClass                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   InSubStringsToIgnore                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReferenceDepthToLookBeforeWeGiveUp                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAssetData>               OutRefrencers                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAssetUtils::GetReferencersOfAsset(const class UObject* WorldContextObject, const struct FAssetData& AssetData, const class UClass* InRefrencersClass, const TArray<class FString>& InSubStringsToIgnore, const int32 ReferenceDepthToLookBeforeWeGiveUp, TArray<struct FAssetData>* OutRefrencers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AssetUtils", "GetReferencersOfAsset");

	Params::AssetUtils_GetReferencersOfAsset Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AssetData = std::move(AssetData);
	Parms.InRefrencersClass = InRefrencersClass;
	Parms.InSubStringsToIgnore = std::move(InSubStringsToIgnore);
	Parms.ReferenceDepthToLookBeforeWeGiveUp = ReferenceDepthToLookBeforeWeGiveUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRefrencers != nullptr)
		*OutRefrencers = std::move(Parms.OutRefrencers);
}


// Function PiecesUtils.BuildInfoUtils_BFL.GetConfig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EConfigEnum                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EConfigEnum UBuildInfoUtils_BFL::GetConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BuildInfoUtils_BFL", "GetConfig");

	Params::BuildInfoUtils_BFL_GetConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PiecesUtils.OFMultiBoolFunctionLibrary.GetMultiBoolValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FMultiBool                       MultiBool                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOFMultiBoolFunctionLibrary::GetMultiBoolValue(const struct FMultiBool& MultiBool)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFMultiBoolFunctionLibrary", "GetMultiBoolValue");

	Params::OFMultiBoolFunctionLibrary_GetMultiBoolValue Parms{};

	Parms.MultiBool = std::move(MultiBool);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PiecesUtils.OFMultiBoolFunctionLibrary.SetMultiBoolFalse
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMultiBool                       MultiBool                                              (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UObject*                          AssignmentSourceReference                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFMultiBoolFunctionLibrary::SetMultiBoolFalse(struct FMultiBool& MultiBool, const class UObject* AssignmentSourceReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFMultiBoolFunctionLibrary", "SetMultiBoolFalse");

	Params::OFMultiBoolFunctionLibrary_SetMultiBoolFalse Parms{};

	Parms.MultiBool = std::move(MultiBool);
	Parms.AssignmentSourceReference = AssignmentSourceReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MultiBool = std::move(Parms.MultiBool);
}


// Function PiecesUtils.OFMultiBoolFunctionLibrary.SetMultiBoolTrue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMultiBool                       MultiBool                                              (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UObject*                          AssignmentSouceReference                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOFMultiBoolFunctionLibrary::SetMultiBoolTrue(struct FMultiBool& MultiBool, const class UObject* AssignmentSouceReference)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OFMultiBoolFunctionLibrary", "SetMultiBoolTrue");

	Params::OFMultiBoolFunctionLibrary_SetMultiBoolTrue Parms{};

	Parms.MultiBool = std::move(MultiBool);
	Parms.AssignmentSouceReference = AssignmentSouceReference;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	MultiBool = std::move(Parms.MultiBool);
}


// Function PiecesUtils.PiecesAsyncAction_RotateToActorComponent.StopRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    CallCompleteDelegate                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPiecesAsyncAction_RotateToActorComponent::StopRotation(bool CallCompleteDelegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesAsyncAction_RotateToActorComponent", "StopRotation");

	Params::PiecesAsyncAction_RotateToActorComponent_StopRotation Parms{};

	Parms.CallCompleteDelegate = CallCompleteDelegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PiecesUtils.PiecesAsyncAction_RotateTo.RotateActorTo
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Target                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPiecesAsyncAction_RotateTo*      OutRotatorProxy                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPiecesAsyncAction_RotateTo*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPiecesAsyncAction_RotateTo* UPiecesAsyncAction_RotateTo::RotateActorTo(class AActor* Actor, const struct FRotator& Target, float Speed, class UPiecesAsyncAction_RotateTo** OutRotatorProxy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PiecesAsyncAction_RotateTo", "RotateActorTo");

	Params::PiecesAsyncAction_RotateTo_RotateActorTo Parms{};

	Parms.Actor = Actor;
	Parms.Target = std::move(Target);
	Parms.Speed = Speed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRotatorProxy != nullptr)
		*OutRotatorProxy = Parms.OutRotatorProxy;

	return Parms.ReturnValue;
}


// Function PiecesUtils.PiecesAsyncAction_RotateTo.GetRotatorComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPiecesAsyncAction_RotateToActorComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPiecesAsyncAction_RotateToActorComponent* UPiecesAsyncAction_RotateTo::GetRotatorComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesAsyncAction_RotateTo", "GetRotatorComponent");

	Params::PiecesAsyncAction_RotateTo_GetRotatorComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PiecesUtils.PiecesAbilityTask_RotateTo.RotateActorTo
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Target                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPiecesAbilityTask_RotateTo*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPiecesAbilityTask_RotateTo* UPiecesAbilityTask_RotateTo::RotateActorTo(class UGameplayAbility* OwningAbility, class AActor* Actor, const struct FRotator& Target, float Speed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PiecesAbilityTask_RotateTo", "RotateActorTo");

	Params::PiecesAbilityTask_RotateTo_RotateActorTo Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Actor = Actor;
	Parms.Target = std::move(Target);
	Parms.Speed = Speed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PiecesUtils.PiecesAbilityTask_RotateTo.GetRotatorComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPiecesAsyncAction_RotateToActorComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPiecesAsyncAction_RotateToActorComponent* UPiecesAbilityTask_RotateTo::GetRotatorComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PiecesAbilityTask_RotateTo", "GetRotatorComponent");

	Params::PiecesAbilityTask_RotateTo_GetRotatorComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PiecesUtils.PiecesUtilsFunctionLibrary.GetClosestToValue
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>                     Names                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   TargetValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UPiecesUtilsFunctionLibrary::GetClosestToValue(const TArray<class FName>& Names, float TargetValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PiecesUtilsFunctionLibrary", "GetClosestToValue");

	Params::PiecesUtilsFunctionLibrary_GetClosestToValue Parms{};

	Parms.Names = std::move(Names);
	Parms.TargetValue = TargetValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PiecesUtils.PiecesUtilsFunctionLibrary.GetGameInstanceSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameInstanceSubsystem>Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameInstanceSubsystem*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGameInstanceSubsystem* UPiecesUtilsFunctionLibrary::GetGameInstanceSubsystem(class UObject* WorldContextObject, TSubclassOf<class UGameInstanceSubsystem> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PiecesUtilsFunctionLibrary", "GetGameInstanceSubsystem");

	Params::PiecesUtilsFunctionLibrary_GetGameInstanceSubsystem Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PiecesUtils.PiecesUtilsFunctionLibrary.GetTimeDilationPauseThreshold
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPiecesUtilsFunctionLibrary::GetTimeDilationPauseThreshold()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PiecesUtilsFunctionLibrary", "GetTimeDilationPauseThreshold");

	Params::PiecesUtilsFunctionLibrary_GetTimeDilationPauseThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PiecesUtils.PiecesUtilsFunctionLibrary.GetWorldSubsystem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UWorldSubsystem>      Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorldSubsystem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWorldSubsystem* UPiecesUtilsFunctionLibrary::GetWorldSubsystem(class UObject* WorldContextObject, TSubclassOf<class UWorldSubsystem> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PiecesUtilsFunctionLibrary", "GetWorldSubsystem");

	Params::PiecesUtilsFunctionLibrary_GetWorldSubsystem Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function PiecesUtils.PiecesUtilsFunctionLibrary.IsPausedByTimeDilation
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPiecesUtilsFunctionLibrary::IsPausedByTimeDilation(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PiecesUtilsFunctionLibrary", "IsPausedByTimeDilation");

	Params::PiecesUtilsFunctionLibrary_IsPausedByTimeDilation Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

