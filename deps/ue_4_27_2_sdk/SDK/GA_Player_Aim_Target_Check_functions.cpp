#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GA_Player_Aim_Target_Check

#include "Basic.hpp"

#include "GA_Player_Aim_Target_Check_classes.hpp"
#include "GA_Player_Aim_Target_Check_parameters.hpp"


namespace SDK
{

// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.ExecuteUbergraph_GA_Player_Aim_Target_Check
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::ExecuteUbergraph_GA_Player_Aim_Target_Check(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "ExecuteUbergraph_GA_Player_Aim_Target_Check");

	Params::GA_Player_Aim_Target_Check_C_ExecuteUbergraph_GA_Player_Aim_Target_Check Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.MeleeAttack
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Player_Aim_Target_Check_C::MeleeAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "MeleeAttack");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.Start Aim Assist
// (BlueprintCallable, BlueprintEvent)

void UGA_Player_Aim_Target_Check_C::Start_Aim_Assist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "Start Aim Assist");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.K2_ActivateAbility
// (Event, Protected, BlueprintEvent)

void UGA_Player_Aim_Target_Check_C::K2_ActivateAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "K2_ActivateAbility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.updateBossHealthData
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   CurrentHealthPercentage                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::UpdateBossHealthData(float CurrentHealthPercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "updateBossHealthData");

	Params::GA_Player_Aim_Target_Check_C_UpdateBossHealthData Parms{};

	Parms.CurrentHealthPercentage = CurrentHealthPercentage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.SetMostSuitableMeleeSection
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EAnimationMontageIdentifier             Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::SetMostSuitableMeleeSection(EAnimationMontageIdentifier Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "SetMostSuitableMeleeSection");

	Params::GA_Player_Aim_Target_Check_C_SetMostSuitableMeleeSection Parms{};

	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.MoveToGrappleLocatio
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Grapple_Location                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::MoveToGrappleLocatio(const struct FVector& Grapple_Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "MoveToGrappleLocatio");

	Params::GA_Player_Aim_Target_Check_C_MoveToGrappleLocatio Parms{};

	Parms.Grapple_Location = std::move(Grapple_Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.ControlRotationFocus
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           FocusTarget                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::ControlRotationFocus(class AActor* FocusTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "ControlRotationFocus");

	Params::GA_Player_Aim_Target_Check_C_ControlRotationFocus Parms{};

	Parms.FocusTarget = FocusTarget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.MeleeAttackTranslate
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          StartVector                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          EndVector                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::MeleeAttackTranslate(const struct FVector& StartVector, const struct FVector& EndVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "MeleeAttackTranslate");

	Params::GA_Player_Aim_Target_Check_C_MeleeAttackTranslate Parms{};

	Parms.StartVector = std::move(StartVector);
	Parms.EndVector = std::move(EndVector);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.LaserHit
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Player_Aim_Target_Check_C::LaserHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "LaserHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.QuicktimeInput
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   CurrentProgress                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaxProgress                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::QuicktimeInput(float CurrentProgress, float MaxProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "QuicktimeInput");

	Params::GA_Player_Aim_Target_Check_C_QuicktimeInput Parms{};

	Parms.CurrentProgress = CurrentProgress;
	Parms.MaxProgress = MaxProgress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.QuicktimeSuccess
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Player_Aim_Target_Check_C::QuicktimeSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "QuicktimeSuccess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.SetCemeteryCreatureType
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECemeteryCreatureType                   CreatureType                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::SetCemeteryCreatureType(ECemeteryCreatureType CreatureType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "SetCemeteryCreatureType");

	Params::GA_Player_Aim_Target_Check_C_SetCemeteryCreatureType Parms{};

	Parms.CreatureType = CreatureType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.Triggered_006A72AB49E9C46267C83583A97E6534
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector2D                        Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ElapsedTime                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TriggeredSeconds                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::Triggered_006A72AB49E9C46267C83583A97E6534(const struct FVector2D& Value, float ElapsedTime, float TriggeredSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "Triggered_006A72AB49E9C46267C83583A97E6534");

	Params::GA_Player_Aim_Target_Check_C_Triggered_006A72AB49E9C46267C83583A97E6534 Parms{};

	Parms.Value = std::move(Value);
	Parms.ElapsedTime = ElapsedTime;
	Parms.TriggeredSeconds = TriggeredSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.ValidData_E0F84E8A4305C51ADA12A6BAD8CDA469
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle Data                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UGA_Player_Aim_Target_Check_C::ValidData_E0F84E8A4305C51ADA12A6BAD8CDA469(const struct FGameplayAbilityTargetDataHandle& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "ValidData_E0F84E8A4305C51ADA12A6BAD8CDA469");

	Params::GA_Player_Aim_Target_Check_C_ValidData_E0F84E8A4305C51ADA12A6BAD8CDA469 Parms{};

	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.Cancelled_E0F84E8A4305C51ADA12A6BAD8CDA469
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle Data                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UGA_Player_Aim_Target_Check_C::Cancelled_E0F84E8A4305C51ADA12A6BAD8CDA469(const struct FGameplayAbilityTargetDataHandle& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "Cancelled_E0F84E8A4305C51ADA12A6BAD8CDA469");

	Params::GA_Player_Aim_Target_Check_C_Cancelled_E0F84E8A4305C51ADA12A6BAD8CDA469 Parms{};

	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.ValidData_84311F3F44DD37131F18D89ACE2BDDA7
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle Data                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UGA_Player_Aim_Target_Check_C::ValidData_84311F3F44DD37131F18D89ACE2BDDA7(const struct FGameplayAbilityTargetDataHandle& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "ValidData_84311F3F44DD37131F18D89ACE2BDDA7");

	Params::GA_Player_Aim_Target_Check_C_ValidData_84311F3F44DD37131F18D89ACE2BDDA7 Parms{};

	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.Cancelled_84311F3F44DD37131F18D89ACE2BDDA7
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle Data                                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UGA_Player_Aim_Target_Check_C::Cancelled_84311F3F44DD37131F18D89ACE2BDDA7(const struct FGameplayAbilityTargetDataHandle& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "Cancelled_84311F3F44DD37131F18D89ACE2BDDA7");

	Params::GA_Player_Aim_Target_Check_C_Cancelled_84311F3F44DD37131F18D89ACE2BDDA7 Parms{};

	Parms.Data = std::move(Data);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.TryApplyingAimBlockerForCloseObjects
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle HitResult                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UGA_Player_Aim_Target_Check_C::TryApplyingAimBlockerForCloseObjects(const struct FGameplayAbilityTargetDataHandle& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "TryApplyingAimBlockerForCloseObjects");

	Params::GA_Player_Aim_Target_Check_C_TryApplyingAimBlockerForCloseObjects Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.Send Aim At GameplayEvent
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle InputPin                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void UGA_Player_Aim_Target_Check_C::Send_Aim_At_GameplayEvent(const struct FGameplayAbilityTargetDataHandle& InputPin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "Send Aim At GameplayEvent");

	Params::GA_Player_Aim_Target_Check_C_Send_Aim_At_GameplayEvent Parms{};

	Parms.InputPin = std::move(InputPin);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.Run Aim Assist On Target Data
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayAbilityTargetDataHandle Target_Data                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    Target_Met                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGA_Player_Aim_Target_Check_C::Run_Aim_Assist_On_Target_Data(const struct FGameplayAbilityTargetDataHandle& Target_Data, bool* Target_Met)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "Run Aim Assist On Target Data");

	Params::GA_Player_Aim_Target_Check_C_Run_Aim_Assist_On_Target_Data Parms{};

	Parms.Target_Data = std::move(Target_Data);

	UObject::ProcessEvent(Func, &Parms);

	if (Target_Met != nullptr)
		*Target_Met = Parms.Target_Met;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.Stop Aim Assist
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Player_Aim_Target_Check_C::Stop_Aim_Assist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "Stop Aim Assist");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.Handle Aim Assist Blockage Timer
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bSocket_Is_Visible                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGA_Player_Aim_Target_Check_C::Handle_Aim_Assist_Blockage_Timer(bool bSocket_Is_Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "Handle Aim Assist Blockage Timer");

	Params::GA_Player_Aim_Target_Check_C_Handle_Aim_Assist_Blockage_Timer Parms{};

	Parms.bSocket_Is_Visible = bSocket_Is_Visible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.AimedAt
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGA_Player_Aim_Target_Check_C::AimedAt(bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "AimedAt");

	Params::GA_Player_Aim_Target_Check_C_AimedAt Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.GetUpgradeComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UWeaponUpgradeComponent_C*        UpgradeComponent                                       (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::GetUpgradeComponent(class UWeaponUpgradeComponent_C** UpgradeComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "GetUpgradeComponent");

	Params::GA_Player_Aim_Target_Check_C_GetUpgradeComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (UpgradeComponent != nullptr)
		*UpgradeComponent = Parms.UpgradeComponent;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.FlashlightHit
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Distance                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGA_Player_Aim_Target_Check_C::FlashlightHit(float Distance, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "FlashlightHit");

	Params::GA_Player_Aim_Target_Check_C_FlashlightHit Parms{};

	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.setStartOnWall
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    StartOnWall                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGA_Player_Aim_Target_Check_C::SetStartOnWall(bool StartOnWall, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "setStartOnWall");

	Params::GA_Player_Aim_Target_Check_C_SetStartOnWall Parms{};

	Parms.StartOnWall = StartOnWall;

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.setCanCirculate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    CanCirculate                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGA_Player_Aim_Target_Check_C::SetCanCirculate(bool CanCirculate, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "setCanCirculate");

	Params::GA_Player_Aim_Target_Check_C_SetCanCirculate Parms{};

	Parms.CanCirculate = CanCirculate;

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.getCemeteryCreatureType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECemeteryCreatureType                   CemeteryCreatureType                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::GetCemeteryCreatureType(ECemeteryCreatureType* CemeteryCreatureType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "getCemeteryCreatureType");

	Params::GA_Player_Aim_Target_Check_C_GetCemeteryCreatureType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CemeteryCreatureType != nullptr)
		*CemeteryCreatureType = Parms.CemeteryCreatureType;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.GetCharacterSize
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECharacterSize                          Size                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::GetCharacterSize(ECharacterSize* Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "GetCharacterSize");

	Params::GA_Player_Aim_Target_Check_C_GetCharacterSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Size != nullptr)
		*Size = Parms.Size;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.IncrementJac3ProneCounter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ProneCounter                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::IncrementJac3ProneCounter(int32* ProneCounter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "IncrementJac3ProneCounter");

	Params::GA_Player_Aim_Target_Check_C_IncrementJac3ProneCounter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ProneCounter != nullptr)
		*ProneCounter = Parms.ProneCounter;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.setNewAggro
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewAggro                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGA_Player_Aim_Target_Check_C::SetNewAggro(bool NewAggro, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "setNewAggro");

	Params::GA_Player_Aim_Target_Check_C_SetNewAggro Parms{};

	Parms.NewAggro = NewAggro;

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.getAggroState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Aggro                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGA_Player_Aim_Target_Check_C::GetAggroState(bool* Aggro)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "getAggroState");

	Params::GA_Player_Aim_Target_Check_C_GetAggroState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Aggro != nullptr)
		*Aggro = Parms.Aggro;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.GetMostSuitableMeleeSection
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EAnimationMontageIdentifier             Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::GetMostSuitableMeleeSection(EAnimationMontageIdentifier* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "GetMostSuitableMeleeSection");

	Params::GA_Player_Aim_Target_Check_C_GetMostSuitableMeleeSection Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.hitscanWeaponFired
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGA_Player_Aim_Target_Check_C::HitscanWeaponFired(bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "hitscanWeaponFired");

	Params::GA_Player_Aim_Target_Check_C_HitscanWeaponFired Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.setOrderTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGA_Player_Aim_Target_Check_C::SetOrderTarget(const struct FVector& Location, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "setOrderTarget");

	Params::GA_Player_Aim_Target_Check_C_SetOrderTarget Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.setStartBurrowed
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    beginBurrowed                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGA_Player_Aim_Target_Check_C::SetStartBurrowed(bool beginBurrowed, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "setStartBurrowed");

	Params::GA_Player_Aim_Target_Check_C_SetStartBurrowed Parms{};

	Parms.beginBurrowed = beginBurrowed;

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.GetCameraLookAtRotationForActor
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           Look_At_Actor                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Aim_Assist_Location                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Look_At_Rotation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          Look_at_Vector                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::GetCameraLookAtRotationForActor(class AActor* Look_At_Actor, const struct FVector& Aim_Assist_Location, struct FRotator* Look_At_Rotation, struct FVector* Look_at_Vector) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "GetCameraLookAtRotationForActor");

	Params::GA_Player_Aim_Target_Check_C_GetCameraLookAtRotationForActor Parms{};

	Parms.Look_At_Actor = Look_At_Actor;
	Parms.Aim_Assist_Location = std::move(Aim_Assist_Location);

	UObject::ProcessEvent(Func, &Parms);

	if (Look_At_Rotation != nullptr)
		*Look_At_Rotation = std::move(Parms.Look_At_Rotation);

	if (Look_at_Vector != nullptr)
		*Look_at_Vector = std::move(Parms.Look_at_Vector);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.GetCamera Angle Dot Product
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FRotator                         InRot                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Dot_Product                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::GetCamera_Angle_Dot_Product(const struct FRotator& InRot, float* Dot_Product) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "GetCamera Angle Dot Product");

	Params::GA_Player_Aim_Target_Check_C_GetCamera_Angle_Dot_Product Parms{};

	Parms.InRot = std::move(InRot);

	UObject::ProcessEvent(Func, &Parms);

	if (Dot_Product != nullptr)
		*Dot_Product = Parms.Dot_Product;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.SelectActorWithClosestDotProduct
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TMap<class AActor*, class FName>        TargetMap                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         Look_At_Rotation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           Selected_Actor                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             Socket_Name                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Look_at_Vector                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float UGA_Player_Aim_Target_Check_C::SelectActorWithClosestDotProduct(const TMap<class AActor*, class FName>& TargetMap, struct FRotator* Look_At_Rotation, class AActor** Selected_Actor, class FName* Socket_Name, struct FVector* Look_at_Vector) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "SelectActorWithClosestDotProduct");

	Params::GA_Player_Aim_Target_Check_C_SelectActorWithClosestDotProduct Parms{};

	Parms.TargetMap = std::move(TargetMap);

	UObject::ProcessEvent(Func, &Parms);

	if (Look_At_Rotation != nullptr)
		*Look_At_Rotation = std::move(Parms.Look_At_Rotation);

	if (Selected_Actor != nullptr)
		*Selected_Actor = Parms.Selected_Actor;

	if (Socket_Name != nullptr)
		*Socket_Name = Parms.Socket_Name;

	if (Look_at_Vector != nullptr)
		*Look_at_Vector = std::move(Parms.Look_at_Vector);

	return Parms.ReturnValue;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.TargetDataHasAnyActor
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetData                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UGA_Player_Aim_Target_Check_C::TargetDataHasAnyActor(const struct FGameplayAbilityTargetDataHandle& TargetData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "TargetDataHasAnyActor");

	Params::GA_Player_Aim_Target_Check_C_TargetDataHasAnyActor Parms{};

	Parms.TargetData = std::move(TargetData);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.Parse Visible Targets
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// struct FGameplayAbilityTargetDataHandle TargetData                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TMap<class AActor*, class FName>        ActorsWithVisibleSockets                               (Parm, OutParm)

void UGA_Player_Aim_Target_Check_C::Parse_Visible_Targets(const struct FGameplayAbilityTargetDataHandle& TargetData, TMap<class AActor*, class FName>* ActorsWithVisibleSockets) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "Parse Visible Targets");

	Params::GA_Player_Aim_Target_Check_C_Parse_Visible_Targets Parms{};

	Parms.TargetData = std::move(TargetData);

	UObject::ProcessEvent(Func, &Parms);

	if (ActorsWithVisibleSockets != nullptr)
		*ActorsWithVisibleSockets = std::move(Parms.ActorsWithVisibleSockets);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.GetActorsVisibleAimSocket
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// class AActor*                           TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bHasVisisbleSocket                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FName                             VisibleSocketName                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::GetActorsVisibleAimSocket(class AActor* TargetActor, bool* bHasVisisbleSocket, class FName* VisibleSocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "GetActorsVisibleAimSocket");

	Params::GA_Player_Aim_Target_Check_C_GetActorsVisibleAimSocket Parms{};

	Parms.TargetActor = TargetActor;

	UObject::ProcessEvent(Func, &Parms);

	if (bHasVisisbleSocket != nullptr)
		*bHasVisisbleSocket = Parms.bHasVisisbleSocket;

	if (VisibleSocketName != nullptr)
		*VisibleSocketName = Parms.VisibleSocketName;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.Is Character Socket Visible
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// class AActor*                           Target_Actor                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             SocketName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    SocketIsVisible                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          SocketWorldLocation                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Player_Aim_Target_Check_C::Is_Character_Socket_Visible(class AActor* Target_Actor, class FName SocketName, bool* SocketIsVisible, struct FVector* SocketWorldLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "Is Character Socket Visible");

	Params::GA_Player_Aim_Target_Check_C_Is_Character_Socket_Visible Parms{};

	Parms.Target_Actor = Target_Actor;
	Parms.SocketName = SocketName;

	UObject::ProcessEvent(Func, &Parms);

	if (SocketIsVisible != nullptr)
		*SocketIsVisible = Parms.SocketIsVisible;

	if (SocketWorldLocation != nullptr)
		*SocketWorldLocation = std::move(Parms.SocketWorldLocation);
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.IsGamepadLastInputUsed
// (Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UGA_Player_Aim_Target_Check_C::IsGamepadLastInputUsed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "IsGamepadLastInputUsed");

	Params::GA_Player_Aim_Target_Check_C_IsGamepadLastInputUsed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_Player_Aim_Target_Check.GA_Player_Aim_Target_Check_C.GetEasedAimRotation
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FRotator                         Control_Rot                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor)
// struct FVector                          Look_at_Vector                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         New_Control_Rotation                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGA_Player_Aim_Target_Check_C::GetEasedAimRotation(struct FRotator& Control_Rot, struct FVector& Look_at_Vector, struct FRotator* New_Control_Rotation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Player_Aim_Target_Check_C", "GetEasedAimRotation");

	Params::GA_Player_Aim_Target_Check_C_GetEasedAimRotation Parms{};

	Parms.Control_Rot = std::move(Control_Rot);
	Parms.Look_at_Vector = std::move(Look_at_Vector);

	UObject::ProcessEvent(Func, &Parms);

	Control_Rot = std::move(Parms.Control_Rot);
	Look_at_Vector = std::move(Parms.Look_at_Vector);

	if (New_Control_Rotation != nullptr)
		*New_Control_Rotation = std::move(Parms.New_Control_Rotation);
}

}

